<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5f42026480c0ce3ed074eda63bff9ebe668be71e" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78828904" /></Metadata><TypeSignature Language="C#" Value="public class AppDomain : MarshalByRefObject" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit AppDomain extends System.MarshalByRefObject" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public Class AppDomain&#xA;Inherits MarshalByRefObject" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain : MarshalByRefObject" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject" FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject" FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject" FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject" FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" FrameworkAlternate="xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="8f325-101">アプリケーション ドメインを表します。アプリケーション ドメインとは、アプリケーションが実行される分離された環境です。</span><span class="sxs-lookup"><span data-stu-id="8f325-101">Represents an application domain, which is an isolated environment where applications execute.</span></span> <span data-ttu-id="8f325-102">このクラスは継承できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-103"><xref:System.AppDomain> オブジェクトによって表されるアプリケーションドメインは、マネージコードを実行するための分離、アンロード、およびセキュリティ境界を提供するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="8f325-103">Application domains, which are represented by <xref:System.AppDomain> objects, help provide isolation, unloading, and security boundaries for executing managed code.</span></span>  
  
-   <span data-ttu-id="8f325-104">プロセスをダウンさせる可能性のあるタスクを分離するには、アプリケーションドメインを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-104">Use application domains to isolate tasks that might bring down a process.</span></span> <span data-ttu-id="8f325-105">タスクを実行している <xref:System.AppDomain> の状態が不安定になった場合、<xref:System.AppDomain> はプロセスに影響を与えずにアンロードできます。</span><span class="sxs-lookup"><span data-stu-id="8f325-105">If the state of the <xref:System.AppDomain> that's executing a task becomes unstable, the <xref:System.AppDomain> can be unloaded without affecting the process.</span></span> <span data-ttu-id="8f325-106">これは、プロセスを再起動せずに長期間実行する必要がある場合に重要です。</span><span class="sxs-lookup"><span data-stu-id="8f325-106">This is important when a process must run for long periods without restarting.</span></span> <span data-ttu-id="8f325-107">また、アプリケーションドメインを使用して、データを共有しないタスクを分離することもできます。</span><span class="sxs-lookup"><span data-stu-id="8f325-107">You can also use application domains to isolate tasks that should not share data.</span></span>  
  
-   <span data-ttu-id="8f325-108">アセンブリが既定のアプリケーションドメインに読み込まれた場合、プロセスの実行中にメモリからアンロードすることはできません。</span><span class="sxs-lookup"><span data-stu-id="8f325-108">If an assembly is loaded into the default application domain, it cannot be unloaded from memory while the process is running.</span></span> <span data-ttu-id="8f325-109">ただし、アセンブリを読み込んで実行するために2番目のアプリケーションドメインを開いた場合、そのアプリケーションドメインがアンロードされると、アセンブリはアンロードされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-109">However, if you open a second application domain to load and execute the assembly, the assembly is unloaded when that application domain is unloaded.</span></span> <span data-ttu-id="8f325-110">この手法を使用すると、大規模な Dll を頻繁に使用する実行時間の長いプロセスのワーキングセットを最小限に抑えることができます。</span><span class="sxs-lookup"><span data-stu-id="8f325-110">Use this technique to minimize the working set of long-running processes that occasionally use large DLLs.</span></span>  
  
 > [!NOTE]
 >  <span data-ttu-id="8f325-111">.NET Core では、<xref:System.AppDomain> の実装は設計によって制限され、分離、アンロード、セキュリティの境界は提供されません。</span><span class="sxs-lookup"><span data-stu-id="8f325-111">On .NET Core, the <xref:System.AppDomain> implementation is limited by design and does not provide isolation, unloading, or security boundaries.</span></span> <span data-ttu-id="8f325-112">.NET Core の場合、<xref:System.AppDomain>は1つだけです。</span><span class="sxs-lookup"><span data-stu-id="8f325-112">For .NET Core, there is exactly one <xref:System.AppDomain>.</span></span> <span data-ttu-id="8f325-113">分離とアンロードは <xref:System.Runtime.Loader.AssemblyLoadContext>を通じて提供されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-113">Isolation and unloading are provided through <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span> <span data-ttu-id="8f325-114">セキュリティ境界は、プロセスの境界と適切なリモート処理手法によって提供される必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-114">Security boundaries should be provided by process boundaries and appropriate remoting techniques.</span></span>
 
 <span data-ttu-id="8f325-115">複数のアプリケーションドメインを1つのプロセスで実行できます。ただし、アプリケーションドメインとスレッドの間には1対1の相関関係はありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-115">Multiple application domains can run in a single process; however, there is not a one-to-one correlation between application domains and threads.</span></span> <span data-ttu-id="8f325-116">複数のスレッドを1つのアプリケーションドメインに所属させることができ、特定のスレッドが1つのアプリケーションドメインに限定されることはありませんが、スレッドは1つのアプリケーションドメインで実行されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-116">Several threads can belong to a single application domain, and while a given thread is not confined to a single application domain, at any given time, a thread executes in a single application domain.</span></span>  
  
 <span data-ttu-id="8f325-117">アプリケーションドメインは、<xref:System.AppDomain.CreateDomain%2A> メソッドを使用して作成されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-117">Application domains are created using the <xref:System.AppDomain.CreateDomain%2A> method.</span></span> <span data-ttu-id="8f325-118"><xref:System.AppDomain> インスタンスは、アセンブリの読み込みと実行 (<xref:System.Reflection.Assembly>) に使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-118"><xref:System.AppDomain> instances are used to load and execute assemblies (<xref:System.Reflection.Assembly>).</span></span> <span data-ttu-id="8f325-119"><xref:System.AppDomain> が使用されなくなった場合は、アンロードできます。</span><span class="sxs-lookup"><span data-stu-id="8f325-119">When an <xref:System.AppDomain> is no longer in use, it can be unloaded.</span></span>  
  
 <span data-ttu-id="8f325-120"><xref:System.AppDomain> クラスは、アセンブリが読み込まれたとき、アプリケーションドメインがアンロードされるとき、またはハンドルされない例外がスローされたときに、アプリケーションが応答できるようにする一連のイベントを実装します。</span><span class="sxs-lookup"><span data-stu-id="8f325-120">The <xref:System.AppDomain> class implements a set of events that enable applications to respond when an assembly is loaded, when an application domain will be unloaded, or when an unhandled exception is thrown.</span></span>  
  
 <span data-ttu-id="8f325-121">アプリケーションドメインの使用方法の詳細については、「[アプリケーションドメイン](~/docs/framework/app-domains/application-domains.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-121">For more information on using application domains, see [Application Domains](~/docs/framework/app-domains/application-domains.md).</span></span>  
  
 <span data-ttu-id="8f325-122">このクラスは、<xref:System.MarshalByRefObject>、<xref:System._AppDomain>、および <xref:System.Security.IEvidenceFactory> インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="8f325-122">This class implements the <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, and <xref:System.Security.IEvidenceFactory> interfaces.</span></span>  
  
 <span data-ttu-id="8f325-123"><xref:System.AppDomain> オブジェクトに対してリモート処理可能なラッパーを作成しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="8f325-123">You should never create a remotable wrapper for an <xref:System.AppDomain> object.</span></span> <span data-ttu-id="8f325-124">これを行うと、その <xref:System.AppDomain>へのリモート参照を発行して、<xref:System.AppDomain.CreateInstance%2A> などのメソッドをリモートアクセスに公開し、その <xref:System.AppDomain>のコードアクセスセキュリティを効果的に破棄することができます。</span><span class="sxs-lookup"><span data-stu-id="8f325-124">Doing so could publish a remote reference to that <xref:System.AppDomain>, exposing methods such as <xref:System.AppDomain.CreateInstance%2A> to remote access and effectively destroying code access security for that <xref:System.AppDomain>.</span></span> <span data-ttu-id="8f325-125">リモート <xref:System.AppDomain> に接続している悪意のあるクライアントは、<xref:System.AppDomain> 自身がアクセスできる任意のリソースにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="8f325-125">Malicious clients connecting to the remoted <xref:System.AppDomain> could obtain access to any resource the <xref:System.AppDomain> itself has access to.</span></span> <span data-ttu-id="8f325-126"><xref:System.MarshalByRefObject> を拡張し、悪意のあるクライアントがセキュリティシステムをバイパスするために使用できるメソッドを実装するすべての型に対して、リモート処理可能なラッパーを作成しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-126">Do not create remotable wrappers for any type that extends <xref:System.MarshalByRefObject> and that implements methods that could be used by malicious clients to bypass the security system.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8f325-127"><xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> プロパティの既定値は `false`です。</span><span class="sxs-lookup"><span data-stu-id="8f325-127">The default value for the <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> property is `false`.</span></span> <span data-ttu-id="8f325-128">この設定は、サービスでは安全ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-128">This setting is unsafe for services.</span></span> <span data-ttu-id="8f325-129">サービスが部分的に信頼されているコードをダウンロードできないようにするには、このプロパティを `true`に設定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-129">To prevent services from downloading partially trusted code, set this property to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-130">この例では、新しい <xref:System.AppDomain>を作成し、その新しい <xref:System.AppDomain>内の型をインスタンス化し、その型のオブジェクトと通信する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-130">This example shows how to create a new <xref:System.AppDomain>, instantiate a type in that new <xref:System.AppDomain>, and communicate with that type's object.</span></span> <span data-ttu-id="8f325-131">また、この例では、オブジェクトがガベージコレクションされる原因となった <xref:System.AppDomain> をアンロードする方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-131">In addition, this example shows how to unload the <xref:System.AppDomain> causing the object to be garbage collected.</span></span>  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482"><span data-ttu-id="8f325-132">方法: アプリケーションドメインを構成する</span><span class="sxs-lookup"><span data-stu-id="8f325-132">How To: Configure an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/ba1fa43e-49f5-47d9-bd7f-3024af16f4ba"><span data-ttu-id="8f325-133">方法: アプリケーションドメインを作成する</span><span class="sxs-lookup"><span data-stu-id="8f325-133">How To: Create an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/1432aa2d-bd83-4346-bf3b-a1b7920e2aa9"><span data-ttu-id="8f325-134">方法 : アプリケーション ドメインにアセンブリを読み込む</span><span class="sxs-lookup"><span data-stu-id="8f325-134">How to: Load Assemblies into an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/f356116d-e415-4f7c-a332-6e6a60227192"><span data-ttu-id="8f325-135">方法: アプリケーション ドメインをアンロードする</span><span class="sxs-lookup"><span data-stu-id="8f325-135">How to: Unload an Application Domain</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-136">現在のアプリケーション ドメインのアクティベーション コンテキストを取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-136">Gets the activation context for the current application domain.</span></span></summary>
        <value><span data-ttu-id="8f325-137">現在のアプリケーション ドメインのアクティベーション コンテキストを表すオブジェクト。ドメインにアクティベーション コンテキストが存在しない場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-137">An object that represents the activation context for the current application domain, or <see langword="null" /> if the domain has no activation context.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendPrivatePath(string path) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendPrivatePath(System::String ^ path);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f325-138">プライベート パスに追加するディレクトリ名。</span><span class="sxs-lookup"><span data-stu-id="8f325-138">The name of the directory to be appended to the private path.</span></span></param>
        <summary><span data-ttu-id="8f325-139">指定されたディレクトリ名をプライベート パス リストに追加します。</span><span class="sxs-lookup"><span data-stu-id="8f325-139">Appends the specified directory name to the private path list.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-140">このプロパティの使用は推奨されません。これは、アセンブリが既に読み込まれた後、アセンブリのプローブパスが変更される可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="8f325-140">The use of this property is not recommended, because it might change the probing path for assemblies after they have already been loaded.</span></span> <span data-ttu-id="8f325-141">代わりに <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-141">Use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property instead.</span></span>  
  
 <span data-ttu-id="8f325-142">プライベートパス、または相対検索パスは、アセンブリリゾルバーがプライベートアセンブリを検査するベースディレクトリを基準とした相対パスです。</span><span class="sxs-lookup"><span data-stu-id="8f325-142">The private path, or relative search path, is the path relative to the base directory where the assembly resolver probes for private assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-143">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-143">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-144">アプリケーション ドメイン内のアプリケーションの ID を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-144">Gets the identity of the application in the application domain.</span></span></summary>
        <value><span data-ttu-id="8f325-145">アプリケーション ドメイン内のアプリケーションを識別するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-145">An object that identifies the application in the application domain.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-146">アプリケーションに付与されているアクセス許可の情報を取得し、実行に必要な信頼レベルがそのアプリケーションにあるかどうかを調べます。</span><span class="sxs-lookup"><span data-stu-id="8f325-146">Gets information describing permissions granted to an application and whether the application has a trust level that allows it to run.</span></span></summary>
        <value><span data-ttu-id="8f325-147">アプリケーション ドメインにおけるアプリケーションのアクセス許可および信頼情報をカプセル化するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-147">An object that encapsulates permission and trust information for the application in the application domain.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-148">アセンブリの表示名。<see cref="P:System.Reflection.Assembly.FullName" /> プロパティによって返される表示名と同じ形式で指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-148">The assembly display name, in the form provided by the <see cref="P:System.Reflection.Assembly.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="8f325-149">ポリシーが適用された後のアセンブリの表示名を返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-149">Returns the assembly display name after policy has been applied.</span></span></summary>
        <returns><span data-ttu-id="8f325-150">ポリシーが適用された後のアセンブリの表示名を保持する文字列。</span><span class="sxs-lookup"><span data-stu-id="8f325-150">A string containing the assembly display name after policy has been applied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-151"><xref:System.AppDomain.ApplyPolicy%2A> メソッドは、アセンブリの表示名を受け取り、ポリシー後の表示名を返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-151">The <xref:System.AppDomain.ApplyPolicy%2A> method takes an assembly display name and returns the post-policy display name.</span></span> <span data-ttu-id="8f325-152">これは、ポリシーを使用してアセンブリを読み込む必要がある場合に便利です。リフレクションのみのコンテキストではポリシーが適用されないためです。</span><span class="sxs-lookup"><span data-stu-id="8f325-152">This is useful if you need to load an assembly using policy, because the reflection-only context does not apply policy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event AssemblyLoadEventHandler ^ AssemblyLoad;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Event AssemblyLoad As AssemblyLoadEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-153">アセンブリが読み込まれたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-153">Occurs when an assembly is loaded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-154">このイベントの <xref:System.AssemblyLoadEventHandler> デリゲートは、どのアセンブリが読み込まれたかを示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-154">The <xref:System.AssemblyLoadEventHandler> delegate for this event indicates what assembly was loaded.</span></span>  
  
 <span data-ttu-id="8f325-155">このイベントのイベントハンドラーを登録するには、必要なアクセス許可が必要です。または、<xref:System.Security.SecurityException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-155">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="8f325-156">イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-156">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-157"><xref:System.AppDomain.AssemblyLoad> イベントの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-157">The following sample demonstrates the <xref:System.AppDomain.AssemblyLoad> event.</span></span>  
  
 <span data-ttu-id="8f325-158">このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-158">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="8f325-159">完全修飾アセンブリ名を取得する方法については、「[アセンブリ名](~/docs/standard/assembly/names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-159">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ AssemblyResolve;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-160">アセンブリの解決が失敗したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-160">Occurs when the resolution of an assembly fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-161">このイベントが <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> プロパティによって指定されたアセンブリを返すか、またはアセンブリが認識されない場合は null を返す必要 <xref:System.ResolveEventHandler> があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-161">It is the responsibility of the <xref:System.ResolveEventHandler> for this event to return the assembly that is specified by the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property, or to return null if the assembly is not recognized.</span></span> <span data-ttu-id="8f325-162">アセンブリは、実行コンテキストに読み込む必要があります。リフレクションのみのコンテキストに読み込まれた場合、このイベントの原因となった読み込みは失敗します。</span><span class="sxs-lookup"><span data-stu-id="8f325-162">The assembly must be loaded into an execution context; if it is loaded into the reflection-only context, the load that caused this event to be raised fails.</span></span>  
  
 <span data-ttu-id="8f325-163">このイベントの使用に関するガイダンスについては、「[アセンブリの読み込みの解決](~/docs/standard/assembly/resolve-loads.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-163">For guidance on the use of this event, see [Resolving Assembly Loads](~/docs/standard/assembly/resolve-loads.md).</span></span>  
  
 <span data-ttu-id="8f325-164">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> プロパティは、解決できなかったアセンブリの読み込みを要求したアセンブリを返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-164">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property returns the assembly that requested the assembly load that could not be resolved.</span></span> <span data-ttu-id="8f325-165">たとえば、要求元のアセンブリとその依存関係がプローブパスにないため、ローダーは要求元のアセンブリの依存関係を読み込むことができない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-165">For example, the loader might be unable to load a dependency of the requesting assembly because the requesting assembly and its dependency are not in the probing path.</span></span> <span data-ttu-id="8f325-166">要求元アセンブリの id を知っておくと、依存関係を特定するときや、依存関係のバージョンが複数ある場合に正しいバージョンを特定する際に役立つことがあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-166">Knowing the identity of the requesting assembly might be useful in locating the dependency or in identifying the correct version, if more than one version of the dependency is available.</span></span> <span data-ttu-id="8f325-167">詳細については、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-167">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8f325-168">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降では、リソースアセンブリを含むすべてのアセンブリに対して <xref:System.ResolveEventHandler> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-168">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the <xref:System.ResolveEventHandler> event is raised for all assemblies, including resource assemblies.</span></span> <span data-ttu-id="8f325-169">以前のバージョンでは、リソースアセンブリに対してイベントが発生していませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-169">In earlier versions, the event was not raised for resource assemblies.</span></span> <span data-ttu-id="8f325-170">オペレーティングシステムがローカライズされている場合は、ハンドラーが複数回呼び出される可能性があります。フォールバックチェーンのカルチャごとに1回です。</span><span class="sxs-lookup"><span data-stu-id="8f325-170">If the operating system is localized, the handler might be called multiple times: once for each culture in the fallback chain.</span></span>  
  
 <span data-ttu-id="8f325-171">このイベントの場合、<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> プロパティは、ポリシーが適用される前にアセンブリ名を返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-171">For this event, the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property returns the assembly name before policy is applied.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8f325-172">このイベントに複数のイベントハンドラーが登録されている場合は、イベントハンドラーが `null`ない値を返すまで、イベントハンドラーが順番に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-172">If more than one event handler is registered for this event, the event handlers are called in order until an event handler returns a value that isn't `null`.</span></span> <span data-ttu-id="8f325-173">後続のイベントハンドラーは無視されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-173">Subsequent event handlers are ignored.</span></span>
  
 <span data-ttu-id="8f325-174">イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-174">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-175"><xref:System.AppDomain.AssemblyResolve> イベントの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-175">The following sample demonstrates the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="8f325-176">このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-176">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="8f325-177">完全修飾アセンブリ名を取得する方法については、「[アセンブリ名](~/docs/standard/assembly/names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-177">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
        <related type="Article" href="https://msdn.microsoft.com/library/5099e549-f4fd-49fb-a290-549edd456c6a"><span data-ttu-id="8f325-178">解決 (アセンブリ読み込みを)</span><span class="sxs-lookup"><span data-stu-id="8f325-178">Resolving Assembly Loads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-179">アセンブリを探すためにアセンブリ リゾルバーが使用したベース ディレクトリを取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-179">Gets the base directory that the assembly resolver uses to probe for assemblies.</span></span></summary>
        <value><span data-ttu-id="8f325-180">アセンブリを探すためにアセンブリ リゾルバーが使用するベース ディレクトリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-180">The base directory that the assembly resolver uses to probe for assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-181">このプロパティは、<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> プロパティに対応しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-181">This property corresponds to the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8f325-182">また、文字列 "APPBASE" を使用して <xref:System.AppDomain.GetData%2A> メソッドを使用して取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="8f325-182">It can also be retrieved using the <xref:System.AppDomain.GetData%2A> method with the string "APPBASE".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-183">次のコード例では、ドメインに読み込むアセンブリを検索するときに使用するベースディレクトリを指定して、新しいアプリケーションドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-183">The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain.</span></span> <span data-ttu-id="8f325-184">この例では、<xref:System.AppDomain.BaseDirectory%2A> プロパティを使用して、コンソールに表示するベースディレクトリパスを取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-184">The example then uses the <xref:System.AppDomain.BaseDirectory%2A> property to obtain the base directory path, for display to the console.</span></span>  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-185">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-185">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearPrivatePath() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearPrivatePath();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f325-186">プライベート アセンブリの場所を指定するパスを空の文字列 ("") にリセットします。</span><span class="sxs-lookup"><span data-stu-id="8f325-186">Resets the path that specifies the location of private assemblies to the empty string ("").</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-187">プライベートパスは、共通言語ランタイムがプライベートアセンブリを検索するために検索するベースディレクトリを基準とした相対パスです。</span><span class="sxs-lookup"><span data-stu-id="8f325-187">The private path is a path relative to the base directory that the common language runtime searches to locate private assemblies.</span></span>  
  
 <span data-ttu-id="8f325-188">詳細については、<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-188">For more information, see <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-189">次のコード例は、<xref:System.AppDomain.ClearPrivatePath%2A> メソッドを使用して、アセンブリが読み込まれるときに検索するプライベートパスのリストからすべてのエントリを削除する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-189">The following code example demonstrates how to use the <xref:System.AppDomain.ClearPrivatePath%2A> method to remove all entries from the list of private paths to search when assemblies are loaded.</span></span>  
  
 <span data-ttu-id="8f325-190">このメソッドは互換性のために残されています。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-190">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-191">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-191">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearShadowCopyPath() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearShadowCopyPath();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f325-192">シャドウ コピーされたアセンブリが含まれているディレクトリのリストを空の文字列 ("") にリセットします。</span><span class="sxs-lookup"><span data-stu-id="8f325-192">Resets the list of directories containing shadow copied assemblies to the empty string ("").</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-193">シャドウコピーパスは、シャドウコピーされたアセンブリが格納されているディレクトリの一覧です。</span><span class="sxs-lookup"><span data-stu-id="8f325-193">The shadow copy path is a list of directories where shadow copied assemblies are stored.</span></span>  
  
 <span data-ttu-id="8f325-194">詳細については、「アセンブリの <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> と[シャドウコピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-194">For more information, see <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-195">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-195">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="F:System.String.Empty" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="8f325-196">アセンブリのシャドウ コピー</span><span class="sxs-lookup"><span data-stu-id="8f325-196">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8f325-197">指定した COM 型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-197">Creates a new instance of a specified COM type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-198">要求された型を定義するアセンブリが格納されているファイルの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-198">The name of a file containing an assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-199">要求された型の名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-199">The name of the requested type.</span></span></param>
        <summary><span data-ttu-id="8f325-200">指定した COM 型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-200">Creates a new instance of a specified COM type.</span></span> <span data-ttu-id="8f325-201">型を含んでいるアセンブリのファイルの名前と、型の名前をパラメーターで指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-201">Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="8f325-202"><paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-202">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="8f325-203">実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-203">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-204">このメソッドは、型をローカルに読み込まずにオブジェクトをリモートで作成するために使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-204">Use this method to create objects remotely without having to load the type locally.</span></span>  
  
 <span data-ttu-id="8f325-205">実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-205">The return value must to be unwrapped to access the real object.</span></span>  
  
 <span data-ttu-id="8f325-206">値が `true` の <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> 属性は、明示的に、または既定でこのメソッドの COM 型に適用して、その型のインスタンスを作成する必要があります。それ以外の場合、<xref:System.TypeLoadException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-206">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribute with a value of `true` must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <xref:System.TypeLoadException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-207">次の例では、</span><span class="sxs-lookup"><span data-stu-id="8f325-207">The following sample demonstrates</span></span>  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-208"><paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-208"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-209">型を読み込めません。</span><span class="sxs-lookup"><span data-stu-id="8f325-209">The type cannot be loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-210">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-210">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-211">パラメーターなしのパブリック コンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-211">No public parameterless constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-212"><paramref name="assemblyName" /> が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-212"><paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="8f325-213"><paramref name="typeName" /> は抽象クラスです。</span><span class="sxs-lookup"><span data-stu-id="8f325-213"><paramref name="typeName" /> is an abstract class.</span></span>  
  
<span data-ttu-id="8f325-214">または</span><span class="sxs-lookup"><span data-stu-id="8f325-214">-or-</span></span> 
<span data-ttu-id="8f325-215">このメンバーは、遅延バインディング メカニズムで呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="8f325-215">This member was invoked with a late-binding mechanism.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-216">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> から継承しないオブジェクトのアクティベーション属性を提供できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-216">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-217"><paramref name="assemblyName" /> が空の文字列 ("") です。</span><span class="sxs-lookup"><span data-stu-id="8f325-217"><paramref name="assemblyName" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-218"><paramref name="assemblyName" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-218"><paramref name="assemblyName" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-219">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-219">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="8f325-220">参照されている COM オブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-220">The COM object that is being referred to is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="8f325-221">要求された型を定義するアセンブリが格納されているファイルの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-221">The name of a file containing an assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-222">要求された型の名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-222">The name of the requested type.</span></span></param>
        <param name="hashValue"><span data-ttu-id="8f325-223">計算されたハッシュ コードの値を表します。</span><span class="sxs-lookup"><span data-stu-id="8f325-223">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="8f325-224">アセンブリ マニフェストが使用するハッシュ アルゴリズムを表します。</span><span class="sxs-lookup"><span data-stu-id="8f325-224">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="8f325-225">指定した COM 型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-225">Creates a new instance of a specified COM type.</span></span> <span data-ttu-id="8f325-226">型を含んでいるアセンブリのファイルの名前と、型の名前をパラメーターで指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-226">Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="8f325-227"><paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-227">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="8f325-228">実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-228">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-229">このメソッドは、型をローカルに読み込まずにオブジェクトをリモートで作成するために使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-229">Use this method to create objects remotely without having to load the type locally.</span></span>  
  
 <span data-ttu-id="8f325-230">実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-230">The return value must to be unwrapped to access the real object.</span></span>  
  
 <span data-ttu-id="8f325-231">値が `true` の <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> 属性は、明示的に、または既定でこのメソッドの COM 型に適用して、その型のインスタンスを作成する必要があります。それ以外の場合、<xref:System.TypeLoadException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-231">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribute with a value of `true` must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <xref:System.TypeLoadException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-232"><paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-232"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-233">型を読み込めません。</span><span class="sxs-lookup"><span data-stu-id="8f325-233">The type cannot be loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-234">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-234">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-235">パラメーターなしのパブリック コンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-235">No public parameterless constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-236"><paramref name="assemblyFile" /> が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-236"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="8f325-237"><paramref name="typeName" /> は抽象クラスです。</span><span class="sxs-lookup"><span data-stu-id="8f325-237"><paramref name="typeName" /> is an abstract class.</span></span>  
  
<span data-ttu-id="8f325-238">または</span><span class="sxs-lookup"><span data-stu-id="8f325-238">-or-</span></span> 
<span data-ttu-id="8f325-239">このメンバーは、遅延バインディング メカニズムで呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="8f325-239">This member was invoked with a late-binding mechanism.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-240">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> から継承しないオブジェクトのアクティベーション属性を提供できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-240">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-241"><paramref name="assemblyFile" /> が空の文字列 ("") です。</span><span class="sxs-lookup"><span data-stu-id="8f325-241"><paramref name="assemblyFile" /> is the empty string ("").</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-242"><paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-242"><paramref name="assemblyFile" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-243">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-243">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="8f325-244">参照されている COM オブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-244">The COM object that is being referred to is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8f325-245">新しいアプリケーション ドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-245">Creates a new application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="8f325-246">ドメインの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-246">The friendly name of the domain.</span></span></param>
        <summary><span data-ttu-id="8f325-247">名前を指定して新しいアプリケーション ドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-247">Creates a new application domain with the specified name.</span></span></summary>
        <returns><span data-ttu-id="8f325-248">新しく作成されたアプリケーション ドメイン。</span><span class="sxs-lookup"><span data-stu-id="8f325-248">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-249">`friendlyName` パラメーターは、ドメインを人間にとって意味のある方法で識別することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="8f325-249">The `friendlyName` parameter is intended to identify the domain in a manner that is meaningful to humans.</span></span> <span data-ttu-id="8f325-250">この文字列は、ユーザーインターフェイスでの表示に適している必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-250">This string should be suitable for display in user interfaces.</span></span>  
  
 <span data-ttu-id="8f325-251">このメソッドオーバーロードは、既定のアプリケーションドメインからの <xref:System.AppDomainSetup> 情報を使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-251">This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-252">次のサンプルでは、一般的に、<xref:System.AppDomain.CreateDomain%2A> のオーバーロードのいずれかを使用してドメインを作成する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-252">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-253"><paramref name="friendlyName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-253"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="8f325-254">.NET Core でサポートされていないメソッド。</span><span class="sxs-lookup"><span data-stu-id="8f325-254">Method not supported on .NET Core.</span></span></exception>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="8f325-255">ドメインの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-255">The friendly name of the domain.</span></span> <span data-ttu-id="8f325-256">この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-256">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="8f325-257">詳細については、<see cref="P:System.AppDomain.FriendlyName" /> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-257">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="8f325-258">アプリケーション ドメインで実行されるコードの ID を確立する証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-258">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="8f325-259">現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</span><span class="sxs-lookup"><span data-stu-id="8f325-259">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <summary><span data-ttu-id="8f325-260">名前および証拠を指定して新しいアプリケーション ドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-260">Creates a new application domain with the given name using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="8f325-261">新しく作成されたアプリケーション ドメイン。</span><span class="sxs-lookup"><span data-stu-id="8f325-261">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-262">このメソッドオーバーロードは、既定のアプリケーションドメインからの <xref:System.AppDomainSetup> 情報を使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-262">This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
 <span data-ttu-id="8f325-263">`securityInfo` が指定されていない場合は、現在のアプリケーションドメインの証拠が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-263">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8f325-264">サンドボックス化されたアプリケーションドメインを作成する場合は、このメソッドオーバーロードを使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-264">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="8f325-265">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降、`securityInfo` に提供された証拠は、アプリケーションドメインの許可セットには影響を与えなくなりました。</span><span class="sxs-lookup"><span data-stu-id="8f325-265">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="8f325-266"><xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> メソッドオーバーロードを使用して、サンドボックス化されたアプリケーションドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-266">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-267">次のサンプルでは、一般的に、<xref:System.AppDomain.CreateDomain%2A> のオーバーロードのいずれかを使用してドメインを作成する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-267">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-268"><paramref name="friendlyName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-268"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="info" Type="System.AppDomainSetup" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="8f325-269">ドメインの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-269">The friendly name of the domain.</span></span> <span data-ttu-id="8f325-270">この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-270">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="8f325-271">詳細については、<see cref="P:System.AppDomain.FriendlyName" /> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-271">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="8f325-272">アプリケーション ドメインで実行されるコードの ID を確立する証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-272">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="8f325-273">現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</span><span class="sxs-lookup"><span data-stu-id="8f325-273">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="info"><span data-ttu-id="8f325-274">アプリケーション ドメインの初期化情報を格納しているオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-274">An object that contains application domain initialization information.</span></span></param>
        <summary><span data-ttu-id="8f325-275">名前、証拠、およびアプリケーション ドメイン設定情報を指定して、新しいアプリケーション ドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-275">Creates a new application domain using the specified name, evidence, and application domain setup information.</span></span></summary>
        <returns><span data-ttu-id="8f325-276">新しく作成されたアプリケーション ドメイン。</span><span class="sxs-lookup"><span data-stu-id="8f325-276">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-277">`info` が指定されていない場合、このメソッドオーバーロードは、既定のアプリケーションドメインからの <xref:System.AppDomainSetup> 情報を使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-277">If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
 <span data-ttu-id="8f325-278">`securityInfo` が指定されていない場合は、現在のアプリケーションドメインの証拠が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-278">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8f325-279">サンドボックス化されたアプリケーションドメインを作成する場合は、このメソッドオーバーロードを使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-279">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="8f325-280">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降、`securityInfo` に提供された証拠は、アプリケーションドメインの許可セットには影響を与えなくなりました。</span><span class="sxs-lookup"><span data-stu-id="8f325-280">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="8f325-281"><xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> メソッドオーバーロードを使用して、サンドボックス化されたアプリケーションドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-281">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-282">次のサンプルでは、一般的に、<xref:System.AppDomain.CreateDomain%2A> のオーバーロードのいずれかを使用してドメインを作成する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-282">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-283"><paramref name="friendlyName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-283"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="info" Type="System.AppDomainSetup" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="8f325-284">ドメインの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-284">The friendly name of the domain.</span></span> <span data-ttu-id="8f325-285">この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-285">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="8f325-286">詳細については、<see cref="P:System.AppDomain.FriendlyName" /> の説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-286">For more information, see the description of <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="8f325-287">アプリケーション ドメインで実行されるコードの ID を確立する証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-287">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="8f325-288">現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</span><span class="sxs-lookup"><span data-stu-id="8f325-288">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="info"><span data-ttu-id="8f325-289">アプリケーション ドメインの初期化情報を格納しているオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-289">An object that contains application domain initialization information.</span></span></param>
        <param name="grantSet"><span data-ttu-id="8f325-290">新しいアプリケーション ドメインに読み込まれた、特定のアクセス許可を持たないすべてのアセンブリに付与される既定のアクセス許可セット。</span><span class="sxs-lookup"><span data-stu-id="8f325-290">A default permission set that is granted to all assemblies loaded into the new application domain that do not have specific grants.</span></span></param>
        <param name="fullTrustAssemblies"><span data-ttu-id="8f325-291">新しいアプリケーション ドメインで、完全に信頼されていると見なされるアセンブリを表す厳密名の配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-291">An array of strong names representing assemblies to be considered fully trusted in the new application domain.</span></span></param>
        <summary><span data-ttu-id="8f325-292">指定された名前、証拠、アプリケーション ドメインの設定情報、既定のアクセス許可セット、および完全信頼されたアセンブリの配列を使用して、新しいアプリケーション ドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-292">Creates a new application domain using the specified name, evidence, application domain setup information, default permission set, and array of fully trusted assemblies.</span></span></summary>
        <returns><span data-ttu-id="8f325-293">新しく作成されたアプリケーション ドメイン。</span><span class="sxs-lookup"><span data-stu-id="8f325-293">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-294">`info`に指定する <xref:System.AppDomainSetup> オブジェクトの <xref:System.AppDomainSetup.ApplicationBase%2A> プロパティを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-294">You must set the <xref:System.AppDomainSetup.ApplicationBase%2A> property of the <xref:System.AppDomainSetup> object that you supply for `info`.</span></span> <span data-ttu-id="8f325-295">それ以外の場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-295">Otherwise, an exception is thrown.</span></span>  
  
 <span data-ttu-id="8f325-296">`securityInfo` が指定されていない場合は、現在のアプリケーションドメインの証拠が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-296">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="8f325-297">`grantSet` と `fullTrustAssemblies` に対して指定された情報は、新しいアプリケーションドメインの <xref:System.Security.Policy.ApplicationTrust> オブジェクトを作成するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-297">The information provided for `grantSet` and `fullTrustAssemblies` is used to create an <xref:System.Security.Policy.ApplicationTrust> object for the new application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-298"><paramref name="friendlyName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-298"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8f325-299">アプリケーション ドメインが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-299">The application domain is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-300">または</span><span class="sxs-lookup"><span data-stu-id="8f325-300">-or-</span></span> 
<span data-ttu-id="8f325-301"><see cref="P:System.AppDomainSetup.ApplicationBase" /> プロパティは、<see cref="T:System.AppDomainSetup" /> 用に提供される <paramref name="info" /> オブジェクトでは設定されません。</span><span class="sxs-lookup"><span data-stu-id="8f325-301">The <see cref="P:System.AppDomainSetup.ApplicationBase" /> property is not set on the <see cref="T:System.AppDomainSetup" /> object that is supplied for <paramref name="info" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appBasePath" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="8f325-302">ドメインの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-302">The friendly name of the domain.</span></span> <span data-ttu-id="8f325-303">この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-303">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="8f325-304">詳細については、<see cref="P:System.AppDomain.FriendlyName" /> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-304">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="8f325-305">アプリケーション ドメインで実行されるコードの ID を確立する証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-305">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="8f325-306">現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</span><span class="sxs-lookup"><span data-stu-id="8f325-306">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="appBasePath"><span data-ttu-id="8f325-307">アセンブリを探すためにアセンブリ リゾルバーが使用するベース ディレクトリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-307">The base directory that the assembly resolver uses to probe for assemblies.</span></span> <span data-ttu-id="8f325-308">詳細については、<see cref="P:System.AppDomain.BaseDirectory" /> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-308">For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</span></span></param>
        <param name="appRelativeSearchPath"><span data-ttu-id="8f325-309">アセンブリ リゾルバーがプライベート アセンブリを調べる場所を示す、ベース ディレクトリを基準とした相対パス。</span><span class="sxs-lookup"><span data-stu-id="8f325-309">The path relative to the base directory where the assembly resolver should probe for private assemblies.</span></span> <span data-ttu-id="8f325-310">詳細については、<see cref="P:System.AppDomain.RelativeSearchPath" /> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-310">For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</span></span></param>
        <param name="shadowCopyFiles"><span data-ttu-id="8f325-311"><see langword="true" /> の場合、アセンブリのシャドウ コピーはこのアプリケーション ドメインに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-311">If <see langword="true" />, a shadow copy of an assembly is loaded into this application domain.</span></span></param>
        <summary><span data-ttu-id="8f325-312">名前、証拠、アプリケーション ベース パス、相対検索パス、およびアセンブリのシャドウ コピーをアプリケーション ドメインに読み込むかどうかを示すパラメーターを指定して、新しいアプリケーション ドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-312">Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</span></span></summary>
        <returns><span data-ttu-id="8f325-313">新しく作成されたアプリケーション ドメイン。</span><span class="sxs-lookup"><span data-stu-id="8f325-313">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-314">`securityInfo` が指定されていない場合は、現在のアプリケーションドメインの証拠が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-314">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="8f325-315">シャドウコピーの詳細については、「アセンブリの <xref:System.AppDomain.ShadowCopyFiles%2A> と[シャドウコピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-315">For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8f325-316">サンドボックス化されたアプリケーションドメインを作成する場合は、このメソッドオーバーロードを使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-316">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="8f325-317">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降、`securityInfo` に提供された証拠は、アプリケーションドメインの許可セットには影響を与えなくなりました。</span><span class="sxs-lookup"><span data-stu-id="8f325-317">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="8f325-318"><xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> メソッドオーバーロードを使用して、サンドボックス化されたアプリケーションドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-318">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-319">次のサンプルでは、一般的に、<xref:System.AppDomain.CreateDomain%2A> のオーバーロードのいずれかを使用してドメインを作成する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-319">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-320"><paramref name="friendlyName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-320"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appBasePath" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="adInitArgs" Type="System.String[]" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="8f325-321">ドメインの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-321">The friendly name of the domain.</span></span> <span data-ttu-id="8f325-322">この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-322">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="8f325-323">詳細については、<see cref="P:System.AppDomain.FriendlyName" /> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-323">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="8f325-324">アプリケーション ドメインで実行されるコードの ID を確立する証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-324">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="8f325-325">現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</span><span class="sxs-lookup"><span data-stu-id="8f325-325">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="appBasePath"><span data-ttu-id="8f325-326">アセンブリを探すためにアセンブリ リゾルバーが使用するベース ディレクトリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-326">The base directory that the assembly resolver uses to probe for assemblies.</span></span> <span data-ttu-id="8f325-327">詳細については、<see cref="P:System.AppDomain.BaseDirectory" /> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-327">For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</span></span></param>
        <param name="appRelativeSearchPath"><span data-ttu-id="8f325-328">アセンブリ リゾルバーがプライベート アセンブリを調べる場所を示す、ベース ディレクトリを基準とした相対パス。</span><span class="sxs-lookup"><span data-stu-id="8f325-328">The path relative to the base directory where the assembly resolver should probe for private assemblies.</span></span> <span data-ttu-id="8f325-329">詳細については、<see cref="P:System.AppDomain.RelativeSearchPath" /> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-329">For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</span></span></param>
        <param name="shadowCopyFiles"><span data-ttu-id="8f325-330">アプリケーション ドメインにアセンブリのシャドウ コピーを読み込む場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-330"><see langword="true" /> to load a shadow copy of an assembly into the application domain.</span></span></param>
        <param name="adInit"><span data-ttu-id="8f325-331">新しい <see cref="T:System.AppDomainInitializer" /> オブジェクトの初期化時に呼び出されるコールバック メソッドを表す <see cref="T:System.AppDomain" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="8f325-331">An <see cref="T:System.AppDomainInitializer" /> delegate that represents a callback method to invoke when the new <see cref="T:System.AppDomain" /> object is initialized.</span></span></param>
        <param name="adInitArgs"><span data-ttu-id="8f325-332">新しい <paramref name="adInit" /> オブジェクトの初期化時に <see cref="T:System.AppDomain" /> によって表されるコールバックに渡される文字列型引数の配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-332">An array of string arguments to be passed to the callback represented by <paramref name="adInit" />, when the new <see cref="T:System.AppDomain" /> object is initialized.</span></span></param>
        <summary><span data-ttu-id="8f325-333">名前、証拠、アプリケーション ベース パス、相対検索パス、およびアセンブリのシャドウ コピーをアプリケーション ドメインに読み込むかどうかを示すパラメーターを指定して、新しいアプリケーション ドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-333">Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</span></span> <span data-ttu-id="8f325-334">アプリケーション ドメインを初期化したときに呼び出されるコールバック メソッドと、そのコールバック メソッドに渡す文字列型引数の配列を指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-334">Specifies a callback method that is invoked when the application domain is initialized, and an array of string arguments to pass the callback method.</span></span></summary>
        <returns><span data-ttu-id="8f325-335">新しく作成されたアプリケーション ドメイン。</span><span class="sxs-lookup"><span data-stu-id="8f325-335">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-336">`adInit` によって表されるメソッドは、新しく作成されたアプリケーションドメインのコンテキストで実行されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-336">The method represented by `adInit` is executed in the context of the newly created application domain.</span></span>  
  
 <span data-ttu-id="8f325-337">`securityInfo` が指定されていない場合は、現在のアプリケーションドメインの証拠が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-337">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="8f325-338">シャドウコピーの詳細については、「アセンブリの <xref:System.AppDomain.ShadowCopyFiles%2A> と[シャドウコピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-338">For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8f325-339">サンドボックス化されたアプリケーションドメインを作成する場合は、このメソッドオーバーロードを使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-339">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="8f325-340">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降、`securityInfo` に提供された証拠は、アプリケーションドメインの許可セットには影響を与えなくなりました。</span><span class="sxs-lookup"><span data-stu-id="8f325-340">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="8f325-341"><xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> メソッドオーバーロードを使用して、サンドボックス化されたアプリケーションドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-341">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-342"><paramref name="friendlyName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-342"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8f325-343">指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-343">Creates a new instance of a specified type defined in a specified assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-344">アセンブリの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-344">The display name of the assembly.</span></span> <span data-ttu-id="8f325-345">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Reflection.Assembly.FullName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-345">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-346">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-346">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="8f325-347">指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-347">Creates a new instance of the specified type defined in the specified assembly.</span></span></summary>
        <returns><span data-ttu-id="8f325-348"><paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-348">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="8f325-349">実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-349">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-350">このメソッドは、`typeName`のパラメーターなしのコンストラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8f325-350">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="8f325-351">`assemblyName`の形式については、「<xref:System.Reflection.AssemblyName>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-351">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="8f325-352">現在のアプリケーションドメインではないターゲットアプリケーションドメインで <xref:System.AppDomain.CreateInstance%2A> を呼び出そうとすると、ターゲットアプリケーションドメインにアセンブリが正常に読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-352">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="8f325-353"><xref:System.Reflection.Assembly> が <xref:System.MarshalByRefObject>されていないため、このメソッドは、読み込まれたアセンブリの <xref:System.Reflection.Assembly> を現在のアプリケーションドメインに返そうとします。共通言語ランタイムは、現在のアプリケーションドメインにアセンブリを読み込もうとして、読み込みが失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-353">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="8f325-354">現在のアプリケーションドメインに読み込まれるアセンブリは、2つのアプリケーションドメインのパス設定が異なる場合、最初に読み込まれたアセンブリとは異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-354">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-355">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-355">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-356"><paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-356"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-357"><paramref name="assemblyName" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-357"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-358">または</span><span class="sxs-lookup"><span data-stu-id="8f325-358">-or-</span></span> 
<span data-ttu-id="8f325-359">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-359">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-360">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-360">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-361"><paramref name="assemblyName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-361"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-362">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-362">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-363">一致するパブリック コンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-363">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-364"><paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-364"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="8f325-365">このインスタンスは <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-365">This instance is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-366">アセンブリの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-366">The display name of the assembly.</span></span> <span data-ttu-id="8f325-367">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Reflection.Assembly.FullName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-367">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-368">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-368">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="8f325-369">アクティブ化に参加できる 1 つ以上の属性の配列です。</span><span class="sxs-lookup"><span data-stu-id="8f325-369">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="8f325-370">通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-370">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="8f325-371">このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-371">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="8f325-372">分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-372">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="8f325-373">指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-373">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="8f325-374">アクティベーション属性の配列をパラメーターで指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-374">A parameter specifies an array of activation attributes.</span></span></summary>
        <returns><span data-ttu-id="8f325-375"><paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-375">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="8f325-376">実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-376">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-377">このメソッドは、`typeName`のパラメーターなしのコンストラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8f325-377">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="8f325-378">`assemblyName`の形式については、「<xref:System.Reflection.AssemblyName>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-378">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="8f325-379">現在のアプリケーションドメインではないターゲットアプリケーションドメインで <xref:System.AppDomain.CreateInstance%2A> を呼び出そうとすると、ターゲットアプリケーションドメインにアセンブリが正常に読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-379">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="8f325-380"><xref:System.Reflection.Assembly> が <xref:System.MarshalByRefObject>されていないため、このメソッドは、読み込まれたアセンブリの <xref:System.Reflection.Assembly> を現在のアプリケーションドメインに返そうとします。共通言語ランタイムは、現在のアプリケーションドメインにアセンブリを読み込もうとして、読み込みが失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-380">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="8f325-381">現在のアプリケーションドメインに読み込まれるアセンブリは、2つのアプリケーションドメインのパス設定が異なる場合、最初に読み込まれたアセンブリとは異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-381">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-382">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-382">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-383"><paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-383"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-384"><paramref name="assemblyName" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-384"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-385">または</span><span class="sxs-lookup"><span data-stu-id="8f325-385">-or-</span></span> 
<span data-ttu-id="8f325-386">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-386">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-387">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-387">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-388"><paramref name="assemblyName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-388"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-389">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-389">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-390">一致するパブリック コンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-390">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-391">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> から継承しないオブジェクトのアクティベーション属性を提供できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-391">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-392"><paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-392"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="8f325-393">このインスタンスは <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-393">This instance is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, ignoreCase As Boolean, bindingAttr As BindingFlags, binder As Binder, args As Object(), culture As CultureInfo, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-394">アセンブリの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-394">The display name of the assembly.</span></span> <span data-ttu-id="8f325-395">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Reflection.Assembly.FullName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-395">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-396">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-396">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8f325-397">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</span><span class="sxs-lookup"><span data-stu-id="8f325-397">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="8f325-398"><paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="8f325-398">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="8f325-399"><paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</span><span class="sxs-lookup"><span data-stu-id="8f325-399">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="8f325-400">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-400">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="8f325-401"><paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-401">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-402">コンストラクターに渡される引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-402">The arguments to pass to the constructor.</span></span> <span data-ttu-id="8f325-403">この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-403">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="8f325-404">パラメーターなしのコンストラクターを使用する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-404">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="8f325-405"><paramref name="args" /> から <paramref name="typeName" /> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。</span><span class="sxs-lookup"><span data-stu-id="8f325-405">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="8f325-406"><paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-406">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="8f325-407">アクティブ化に参加できる 1 つ以上の属性の配列です。</span><span class="sxs-lookup"><span data-stu-id="8f325-407">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="8f325-408">通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-408">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="8f325-409">このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-409">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="8f325-410">クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-410">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="8f325-411">分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-411">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="8f325-412">指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-412">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="8f325-413">バインダー、バインディング フラグ、コンストラクター引数、引数を解釈するために使用するカルチャ固有の情報、および省略可能なアクティベーション属性をパラメーターで指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-413">Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, and optional activation attributes.</span></span></summary>
        <returns><span data-ttu-id="8f325-414"><paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-414">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="8f325-415">実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-415">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-416">`assemblyName`の形式については、「<xref:System.Reflection.AssemblyName>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-416">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="8f325-417">現在のアプリケーションドメインではないターゲットアプリケーションドメインで <xref:System.AppDomain.CreateInstance%2A> を呼び出そうとすると、ターゲットアプリケーションドメインにアセンブリが正常に読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-417">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="8f325-418"><xref:System.Reflection.Assembly> が <xref:System.MarshalByRefObject>されていないため、このメソッドは、読み込まれたアセンブリの <xref:System.Reflection.Assembly> を現在のアプリケーションドメインに返そうとします。共通言語ランタイムは、現在のアプリケーションドメインにアセンブリを読み込もうとして、読み込みが失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-418">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="8f325-419">現在のアプリケーションドメインに読み込まれるアセンブリは、2つのアプリケーションドメインのパス設定が異なる場合、最初に読み込まれたアセンブリとは異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-419">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-420">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-420">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-421"><paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-421"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-422"><paramref name="assemblyName" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-422"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-423">または</span><span class="sxs-lookup"><span data-stu-id="8f325-423">-or-</span></span> 
 <span data-ttu-id="8f325-424">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyName" /> がコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="8f325-424"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-425">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-425">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-426"><paramref name="assemblyName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-426"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-427">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-427">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-428">一致するコンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-428">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-429">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> から継承しないオブジェクトのアクティベーション属性を提供できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-429">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-430"><paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-430"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="8f325-431">このインスタンスは <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-431">This instance is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, ignoreCase As Boolean, bindingAttr As BindingFlags, binder As Binder, args As Object(), culture As CultureInfo, activationAttributes As Object(), securityAttributes As Evidence) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-432">アセンブリの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-432">The display name of the assembly.</span></span> <span data-ttu-id="8f325-433">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Reflection.Assembly.FullName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-433">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-434">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-434">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8f325-435">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</span><span class="sxs-lookup"><span data-stu-id="8f325-435">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="8f325-436"><paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="8f325-436">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="8f325-437"><paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</span><span class="sxs-lookup"><span data-stu-id="8f325-437">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="8f325-438">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-438">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="8f325-439"><paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-439">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-440">コンストラクターに渡される引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-440">The arguments to pass to the constructor.</span></span> <span data-ttu-id="8f325-441">この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-441">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="8f325-442">パラメーターなしのコンストラクターを使用する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-442">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="8f325-443"><paramref name="args" /> から <paramref name="typeName" /> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。</span><span class="sxs-lookup"><span data-stu-id="8f325-443">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="8f325-444"><paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-444">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="8f325-445">アクティブ化に参加できる 1 つ以上の属性の配列です。</span><span class="sxs-lookup"><span data-stu-id="8f325-445">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="8f325-446">通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-446">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="8f325-447">このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-447">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="8f325-448">分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-448">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="8f325-449"><paramref name="typeName" /> の作成を承認するために使用される情報。</span><span class="sxs-lookup"><span data-stu-id="8f325-449">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="8f325-450">指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-450">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="8f325-451">バインダー、バインディング フラグ、コンストラクター引数、引数を解釈するために使用するカルチャ固有の情報、アクティベーション属性、型を作成するために必要な承認情報をパラメーターで指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-451">Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, activation attributes, and authorization to create the type.</span></span></summary>
        <returns><span data-ttu-id="8f325-452"><paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-452">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="8f325-453">実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-453">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-454">`assemblyName`の形式については、「<xref:System.Reflection.AssemblyName>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-454">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="8f325-455">現在のアプリケーションドメインではないターゲットアプリケーションドメインで <xref:System.AppDomain.CreateInstance%2A> を呼び出そうとすると、ターゲットアプリケーションドメインにアセンブリが正常に読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-455">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="8f325-456"><xref:System.Reflection.Assembly> が <xref:System.MarshalByRefObject>されていないため、このメソッドは、読み込まれたアセンブリの <xref:System.Reflection.Assembly> を現在のアプリケーションドメインに返そうとします。共通言語ランタイムは、現在のアプリケーションドメインにアセンブリを読み込もうとして、読み込みが失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-456">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="8f325-457">現在のアプリケーションドメインに読み込まれるアセンブリは、2つのアプリケーションドメインのパス設定が異なる場合、最初に読み込まれたアセンブリとは異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-457">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-458">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-458">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-459"><paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-459"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-460"><paramref name="assemblyName" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-460"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-461">または</span><span class="sxs-lookup"><span data-stu-id="8f325-461">-or-</span></span> 
<span data-ttu-id="8f325-462">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-462">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-463">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-463">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-464"><paramref name="assemblyName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-464"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-465">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-465">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-466">一致するコンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-466">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-467">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> から継承しないオブジェクトのアクティベーション属性を提供できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-467">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span>  
  
<span data-ttu-id="8f325-468">または</span><span class="sxs-lookup"><span data-stu-id="8f325-468">-or-</span></span> 
 <span data-ttu-id="8f325-469"><paramref name="securityAttributes" /> が <see langword="null" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-469"><paramref name="securityAttributes" /> is not <see langword="null" />.</span></span> <span data-ttu-id="8f325-470">レガシ CAS ポリシーが有効でない場合は、 <paramref name="securityAttributes" /> を <see langword="null." /></span><span class="sxs-lookup"><span data-stu-id="8f325-470">When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null." /></span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-471"><paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-471"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="8f325-472">このインスタンスは <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-472">This instance is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8f325-473">指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-473">Creates a new instance of a specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-474">アセンブリの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-474">The display name of the assembly.</span></span> <span data-ttu-id="8f325-475">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Reflection.Assembly.FullName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-475">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-476">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-476">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="8f325-477">指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-477">Creates a new instance of the specified type.</span></span> <span data-ttu-id="8f325-478">型が定義されているアセンブリの名前と、型の名前をパラメーターで指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-478">Parameters specify the assembly where the type is defined, and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="8f325-479"><paramref name="typeName" /> で指定したオブジェクトのインスタンス。</span><span class="sxs-lookup"><span data-stu-id="8f325-479">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-480">これは、<xref:System.AppDomain.CreateInstance%2A> と <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>を組み合わせた便利な方法です。</span><span class="sxs-lookup"><span data-stu-id="8f325-480">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8f325-481">このメソッドは、`typeName`のパラメーターなしのコンストラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8f325-481">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="8f325-482">`assemblyName`の形式については、「<xref:System.Reflection.AssemblyName>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-482">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="8f325-483">`typeName`の形式については、<xref:System.Type.FullName%2A?displayProperty=nameWithType> プロパティを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-483">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-484"><xref:System.AppDomain.CreateInstanceAndUnwrap%2A>によって返された `T1` 型のオブジェクトのメソッド `M` に事前バインディングされた呼び出しを行う場合、そのメソッドは、現在のアセンブリまたは `C` を含むアセンブリ以外のアセンブリ `T1`内の `T2` 型のオブジェクトの事前バインディング呼び出しを行うと、現在のアプリケーションドメインにアセンブリ `C` が読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-484">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="8f325-485">この読み込みは、`T1.M()` の事前バインディングされた呼び出しが <xref:System.Reflection.Emit.DynamicMethod>の本体、または動的に生成された他のコードで行われた場合でも発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-485">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="8f325-486">現在のドメインが既定のドメインである場合、プロセスが終了するまでアセンブリ `C` をアンロードすることはできません。</span><span class="sxs-lookup"><span data-stu-id="8f325-486">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="8f325-487">現在のドメインが後でアセンブリ `C`を読み込もうとすると、読み込みが失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-487">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-488">次のコード例は、別のアプリケーションドメインでコードを実行する最も簡単な方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-488">The following code example shows the simplest way to execute code in another application domain.</span></span> <span data-ttu-id="8f325-489">この例では、<xref:System.MarshalByRefObject>から継承する `Worker` という名前のクラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-489">The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="8f325-490">`Worker` クラスは、実行されているアプリケーションドメインの名前を表示するメソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-490">The `Worker` class defines a method that displays the name of the application domain in which it is executing.</span></span> <span data-ttu-id="8f325-491">この例では、既定のアプリケーションドメインと新しいアプリケーションドメインに `Worker` のインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-491">The example creates instances of `Worker` in the default application domain and in a new application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-492">`Worker` を含むアセンブリを両方のアプリケーションドメインに読み込む必要がありますが、新しいアプリケーションドメインにのみ存在する他のアセンブリを読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="8f325-492">The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.</span></span>  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-493"><paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-493"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-494">一致するパブリック コンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-494">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-495"><paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-495"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-496"><paramref name="assemblyName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-496"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-497">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-497">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-498">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-498">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-499"><paramref name="assemblyName" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-499"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-500">または</span><span class="sxs-lookup"><span data-stu-id="8f325-500">-or-</span></span> 
<span data-ttu-id="8f325-501">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-501">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-502">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-502">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-503">アセンブリの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-503">The display name of the assembly.</span></span> <span data-ttu-id="8f325-504">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Reflection.Assembly.FullName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-504">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-505">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-505">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="8f325-506">アクティブ化に参加できる 1 つ以上の属性の配列です。</span><span class="sxs-lookup"><span data-stu-id="8f325-506">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="8f325-507">通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-507">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="8f325-508">このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-508">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="8f325-509">分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-509">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="8f325-510">指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-510">Creates a new instance of the specified type.</span></span> <span data-ttu-id="8f325-511">型が定義されているアセンブリの名前、型の名前、およびアクティベーション属性の配列をパラメーターで指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-511">Parameters specify the assembly where the type is defined, the name of the type, and an array of activation attributes.</span></span></summary>
        <returns><span data-ttu-id="8f325-512"><paramref name="typeName" /> で指定したオブジェクトのインスタンス。</span><span class="sxs-lookup"><span data-stu-id="8f325-512">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-513">これは、<xref:System.AppDomain.CreateInstance%2A> と <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>を組み合わせた便利な方法です。</span><span class="sxs-lookup"><span data-stu-id="8f325-513">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8f325-514">このメソッドは、`typeName`のパラメーターなしのコンストラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8f325-514">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="8f325-515">`assemblyName`の形式については、「<xref:System.Reflection.AssemblyName>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-515">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="8f325-516">`typeName`の形式については、<xref:System.Type.FullName%2A?displayProperty=nameWithType> プロパティを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-516">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-517"><xref:System.AppDomain.CreateInstanceAndUnwrap%2A>によって返された `T1` 型のオブジェクトのメソッド `M` に事前バインディングされた呼び出しを行う場合、そのメソッドは、現在のアセンブリまたは `C` を含むアセンブリ以外のアセンブリ `T1`内の `T2` 型のオブジェクトの事前バインディング呼び出しを行うと、現在のアプリケーションドメインにアセンブリ `C` が読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-517">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="8f325-518">この読み込みは、`T1.M()` の事前バインディングされた呼び出しが <xref:System.Reflection.Emit.DynamicMethod>の本体、または動的に生成された他のコードで行われた場合でも発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-518">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="8f325-519">現在のドメインが既定のドメインである場合、プロセスが終了するまでアセンブリ `C` をアンロードすることはできません。</span><span class="sxs-lookup"><span data-stu-id="8f325-519">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="8f325-520">現在のドメインが後でアセンブリ `C`を読み込もうとすると、読み込みが失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-520">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-521"><paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-521"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-522">一致するパブリック コンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-522">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-523"><paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-523"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-524"><paramref name="assemblyName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-524"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-525">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-525">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-526">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> から継承しないオブジェクトのアクティベーション属性を提供できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-526">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-527">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-527">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-528"><paramref name="assemblyName" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-528"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-529">または</span><span class="sxs-lookup"><span data-stu-id="8f325-529">-or-</span></span> 
<span data-ttu-id="8f325-530">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-530">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-531">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-531">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, ignoreCase As Boolean, bindingAttr As BindingFlags, binder As Binder, args As Object(), culture As CultureInfo, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-532">アセンブリの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-532">The display name of the assembly.</span></span> <span data-ttu-id="8f325-533">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Reflection.Assembly.FullName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-533">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-534">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-534">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8f325-535">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</span><span class="sxs-lookup"><span data-stu-id="8f325-535">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="8f325-536"><paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="8f325-536">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="8f325-537"><paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</span><span class="sxs-lookup"><span data-stu-id="8f325-537">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="8f325-538">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-538">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="8f325-539"><paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-539">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-540">コンストラクターに渡される引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-540">The arguments to pass to the constructor.</span></span> <span data-ttu-id="8f325-541">この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-541">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="8f325-542">パラメーターなしのコンストラクターを使用する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-542">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="8f325-543">型の強制変換を制御するために使用するカルチャ固有のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-543">A culture-specific object used to govern the coercion of types.</span></span> <span data-ttu-id="8f325-544"><paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see langword="CultureInfo" /> が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-544">If <paramref name="culture" /> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="8f325-545">アクティブ化に参加できる 1 つ以上の属性の配列です。</span><span class="sxs-lookup"><span data-stu-id="8f325-545">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="8f325-546">一般的に、1 つの配列に 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトが含まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-546">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object.</span></span> <span data-ttu-id="8f325-547">リモート オブジェクトのアクティブ化に必要な URL を指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-547">that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="8f325-548">このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-548">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="8f325-549">クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-549">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="8f325-550">分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-550">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="8f325-551">指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。型名の大文字と小文字の区別を無視するかどうか、作成する型を選択するために使用されるバインディング属性とバインダー、コンストラクターの引数、カルチャ、およびアクティベーション属性を指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-551">Creates a new instance of the specified type defined in the specified assembly, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</span></span></summary>
        <returns><span data-ttu-id="8f325-552"><paramref name="typeName" /> で指定したオブジェクトのインスタンス。</span><span class="sxs-lookup"><span data-stu-id="8f325-552">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-553">これは、<xref:System.AppDomain.CreateInstance%2A> と <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>を組み合わせた便利な方法です。</span><span class="sxs-lookup"><span data-stu-id="8f325-553">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="8f325-554">`assemblyName`の形式については、「<xref:System.Reflection.AssemblyName>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-554">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="8f325-555">`typeName`の形式については、<xref:System.Type.FullName%2A?displayProperty=nameWithType> プロパティを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-555">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-556"><xref:System.AppDomain.CreateInstanceAndUnwrap%2A>によって返された `T1` 型のオブジェクトのメソッド `M` に事前バインディングされた呼び出しを行う場合、そのメソッドは、現在のアセンブリまたは `C` を含むアセンブリ以外のアセンブリ `T1`内の `T2` 型のオブジェクトの事前バインディング呼び出しを行うと、現在のアプリケーションドメインにアセンブリ `C` が読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-556">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="8f325-557">この読み込みは、`T1.M()` の事前バインディングされた呼び出しが <xref:System.Reflection.Emit.DynamicMethod>の本体、または動的に生成された他のコードで行われた場合でも発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-557">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="8f325-558">現在のドメインが既定のドメインである場合、プロセスが終了するまでアセンブリ `C` をアンロードすることはできません。</span><span class="sxs-lookup"><span data-stu-id="8f325-558">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="8f325-559">現在のドメインが後でアセンブリ `C`を読み込もうとすると、読み込みが失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-559">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-560">次の例では、`ignoreCase` パラメーターの使用方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-560">The following sample demonstrates the use of the `ignoreCase` parameter.</span></span>  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-561"><paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-561"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-562">一致するコンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-562">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-563"><paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-563"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-564"><paramref name="assemblyName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-564"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-565">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-565">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-566">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> から継承しないオブジェクトのアクティベーション属性を提供できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-566">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-567">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-567">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-568"><paramref name="assemblyName" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-568"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-569">または</span><span class="sxs-lookup"><span data-stu-id="8f325-569">-or-</span></span> 
 <span data-ttu-id="8f325-570">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyName" /> がコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="8f325-570"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-571">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-571">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, ignoreCase As Boolean, bindingAttr As BindingFlags, binder As Binder, args As Object(), culture As CultureInfo, activationAttributes As Object(), securityAttributes As Evidence) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-572">アセンブリの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-572">The display name of the assembly.</span></span> <span data-ttu-id="8f325-573">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Reflection.Assembly.FullName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-573">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-574">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-574">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8f325-575">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</span><span class="sxs-lookup"><span data-stu-id="8f325-575">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="8f325-576"><paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="8f325-576">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="8f325-577"><paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</span><span class="sxs-lookup"><span data-stu-id="8f325-577">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="8f325-578">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-578">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="8f325-579"><paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-579">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-580">コンストラクターに渡される引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-580">The arguments to pass to the constructor.</span></span> <span data-ttu-id="8f325-581">この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-581">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="8f325-582">パラメーターなしのコンストラクターを使用する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-582">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="8f325-583">型の強制変換を制御するために使用するカルチャ固有のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-583">A culture-specific object used to govern the coercion of types.</span></span> <span data-ttu-id="8f325-584"><paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see langword="CultureInfo" /> が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-584">If <paramref name="culture" /> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="8f325-585">アクティブ化に参加できる 1 つ以上の属性の配列です。</span><span class="sxs-lookup"><span data-stu-id="8f325-585">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="8f325-586">通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-586">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="8f325-587">このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-587">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="8f325-588">クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-588">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="8f325-589">分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-589">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="8f325-590"><paramref name="typeName" /> の作成を承認するために使用される情報。</span><span class="sxs-lookup"><span data-stu-id="8f325-590">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="8f325-591">指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-591">Creates a new instance of the specified type.</span></span> <span data-ttu-id="8f325-592">型の名前、およびその検索方法と作成方法をパラメーターで指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-592">Parameters specify the name of the type, and how it is found and created.</span></span></summary>
        <returns><span data-ttu-id="8f325-593"><paramref name="typeName" /> で指定したオブジェクトのインスタンス。</span><span class="sxs-lookup"><span data-stu-id="8f325-593">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-594">これは、<xref:System.AppDomain.CreateInstance%2A> と <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>を組み合わせた便利な方法です。</span><span class="sxs-lookup"><span data-stu-id="8f325-594">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="8f325-595">`assemblyName`の形式については、「<xref:System.Reflection.AssemblyName>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-595">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="8f325-596">`typeName`の形式については、<xref:System.Type.FullName%2A?displayProperty=nameWithType> プロパティを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-596">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-597"><xref:System.AppDomain.CreateInstanceAndUnwrap%2A>によって返された `T1` 型のオブジェクトのメソッド `M` に事前バインディングされた呼び出しを行う場合、そのメソッドは、現在のアセンブリまたは `C` を含むアセンブリ以外のアセンブリ `T1`内の `T2` 型のオブジェクトの事前バインディング呼び出しを行うと、現在のアプリケーションドメインにアセンブリ `C` が読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-597">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="8f325-598">この読み込みは、`T1.M()` の事前バインディングされた呼び出しが <xref:System.Reflection.Emit.DynamicMethod>の本体、または動的に生成された他のコードで行われた場合でも発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-598">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="8f325-599">現在のドメインが既定のドメインである場合、プロセスが終了するまでアセンブリ `C` をアンロードすることはできません。</span><span class="sxs-lookup"><span data-stu-id="8f325-599">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="8f325-600">現在のドメインが後でアセンブリ `C`を読み込もうとすると、読み込みが失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-600">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-601">次の例では、`ignoreCase` パラメーターの使用方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-601">The following sample demonstrates the use of the `ignoreCase` parameter.</span></span>  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-602"><paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-602"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-603">一致するコンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-603">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-604"><paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-604"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-605"><paramref name="assemblyName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-605"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-606">呼び出し元には、このコンストラクターを呼び出すアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-606">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-607">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> から継承しないオブジェクトのアクティベーション属性を提供できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-607">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-608">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-608">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-609"><paramref name="assemblyName" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-609"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-610">または</span><span class="sxs-lookup"><span data-stu-id="8f325-610">-or-</span></span> 
<span data-ttu-id="8f325-611">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-611">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-612">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-612">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8f325-613">指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-613">Creates a new instance of a specified type defined in the specified assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="8f325-614">要求する型を定義しているアセンブリが格納されているファイルの名前 (パスを含む)。</span><span class="sxs-lookup"><span data-stu-id="8f325-614">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="8f325-615">アセンブリは <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> メソッドを使用して読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-615">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-616">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-616">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="8f325-617">指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-617">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="8f325-618">新しいインスタンスのラッパーであるオブジェクト。<see langword="null" /> が見つからない場合は <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-618">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="8f325-619">実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-619">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-620">`typeName` のパラメーターなしのコンストラクターが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-620">The parameterless constructor for `typeName` is invoked.</span></span>  
  
 <span data-ttu-id="8f325-621">詳細については、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> メソッドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-621">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8f325-622"><xref:System.AppDomain.CreateInstanceFrom%2A> メソッドを使用して、呼び出し元のアプリケーションドメイン以外のターゲットアプリケーションドメインにインスタンスを作成すると、アセンブリはターゲットアプリケーションドメインに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-622">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="8f325-623">ただし、呼び出し元のアプリケーションドメインでインスタンスがラップ解除されている場合は、ラップされていないインスタンスを特定の方法で使用すると、アセンブリが呼び出し元のアプリケーションドメインに読み込まれる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-623">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="8f325-624">たとえば、インスタンスがラップ解除された後に、遅延バインディングされたメソッドを呼び出すために、その型情報が要求される場合があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-624">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="8f325-625">アセンブリが呼び出し元のアプリケーションドメインに読み込まれると、例外が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-625">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="8f325-626">同じアセンブリの別のバージョンが以前に呼び出し元のアプリケーションドメインに読み込まれていた場合、または呼び出し元のアプリケーションドメインの読み込みパスがターゲットアプリケーションドメインのものと異なる場合は、<xref:System.MissingMethodException> などの例外が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-626">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="8f325-627">呼び出し元のアプリケーションドメインがインスタンス型への事前バインディング呼び出しを行う場合、インスタンスをキャストしようとしたときに <xref:System.InvalidCastException> がスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-627">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-628">次の例は、<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> メソッドオーバーロードを使用して、ターゲットアプリケーションドメインにオブジェクトのインスタンスを作成し、そのメソッドを呼び出す方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-628">The following example shows how to use the <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> method overload to create an instance of an object in a target application domain and call its methods.</span></span>  
  
 <span data-ttu-id="8f325-629">この例では `MarshalableExample` クラスを定義しています。これは、アプリケーションドメインの境界を越えてマーシャリングできます。</span><span class="sxs-lookup"><span data-stu-id="8f325-629">The example defines the `MarshalableExample` class, which can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="8f325-630">この例では、現在実行中のアセンブリへのパスを構築し、ターゲットアプリケーションドメインを作成し、<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> メソッドオーバーロードを使用して、ターゲットアプリケーションドメインにサンプルアセンブリを読み込み、`MarshalableExample`のインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-630">The example builds a path to the currently executing assembly, creates a target application domain, and uses the <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> method overload to load the example assembly into the target application domain and create an instance of `MarshalableExample`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-631">この例ではパスは absolute ですが、<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> メソッドを使用してアセンブリを読み込むため、相対パスも機能します。</span><span class="sxs-lookup"><span data-stu-id="8f325-631">The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method is used to load the assembly.</span></span>  
  
 <span data-ttu-id="8f325-632">オブジェクトハンドルのラップを解除した後の例では、ターゲットアプリケーションドメインでオブジェクトを使用する3つの方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-632">After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:</span></span>  
  
-   <span data-ttu-id="8f325-633">リフレクションを使用した遅延バインディングを使用したメソッドの呼び出し。</span><span class="sxs-lookup"><span data-stu-id="8f325-633">Invoking a method with late binding, using reflection.</span></span> <span data-ttu-id="8f325-634">これには型情報が必要です。これにより、アセンブリが呼び出し元のアプリケーションドメインに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-634">This requires type information, which causes the assembly to be loaded into the application domain of the caller.</span></span> <span data-ttu-id="8f325-635">(この例では、既に読み込まれています)。</span><span class="sxs-lookup"><span data-stu-id="8f325-635">(In this example, it is already loaded.)</span></span>  
  
-   <span data-ttu-id="8f325-636">呼び出し元と呼び出し先の両方に認識されるインターフェイスにオブジェクトをキャストします。</span><span class="sxs-lookup"><span data-stu-id="8f325-636">Casting the object to an interface known to both the caller and the callee.</span></span> <span data-ttu-id="8f325-637">インターフェイスが呼び出し元のアセンブリまたは呼び出し元と呼び出し先の両方によって参照される3番目のアセンブリで定義されている場合、呼び出されたアセンブリは呼び出し元のアプリケーションドメインに読み込まれません。</span><span class="sxs-lookup"><span data-stu-id="8f325-637">If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.</span></span>  
  
-   <span data-ttu-id="8f325-638">オブジェクトの型が呼び出し元に認識されている場合に、オブジェクトを直接使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-638">Using the object directly when its type is known to the caller.</span></span> <span data-ttu-id="8f325-639">アセンブリは、呼び出し元のアプリケーションドメインに読み込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-639">The assembly must be loaded into the application domain of the caller.</span></span>  
  
 <span data-ttu-id="8f325-640">呼び出されたアセンブリが呼び出し元のアプリケーションドメインに読み込まれないようにするもう1つの方法は、呼び出し元が <xref:System.MarshalByRefObject> クラスから派生し、ターゲットアプリケーションドメインで実行できるメソッドを定義することです。</span><span class="sxs-lookup"><span data-stu-id="8f325-640">Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain.</span></span> <span data-ttu-id="8f325-641">ターゲットアセンブリはターゲットアプリケーションドメインに既に読み込まれているため、このメソッドはリフレクションを使用してターゲットアセンブリを調べることができます。</span><span class="sxs-lookup"><span data-stu-id="8f325-641">That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain.</span></span> <span data-ttu-id="8f325-642"><xref:System.AppDomain.DynamicDirectory%2A> プロパティの例を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-642">See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.</span></span>  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-643"><paramref name="assemblyFile" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-643"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-644">または</span><span class="sxs-lookup"><span data-stu-id="8f325-644">-or-</span></span> 
 <span data-ttu-id="8f325-645"><paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-645"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-646"><paramref name="assemblyFile" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-646"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-647"><paramref name="typeName" /> が <paramref name="assemblyFile" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-647"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-648">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-648">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-649">パラメーターなしのパブリック コンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-649">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-650">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-650">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-651"><paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-651"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-652">または</span><span class="sxs-lookup"><span data-stu-id="8f325-652">-or-</span></span> 
<span data-ttu-id="8f325-653">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-653">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-654">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-654">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="8f325-655">このインスタンスは <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-655">This instance is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" FrameworkAlternate="netcore-3.0;netcore-3.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="8f325-656">要求する型を定義しているアセンブリが格納されているファイルの名前 (パスを含む)。</span><span class="sxs-lookup"><span data-stu-id="8f325-656">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="8f325-657">アセンブリは <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> メソッドを使用して読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-657">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-658">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-658">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="8f325-659">アクティブ化に参加できる 1 つ以上の属性の配列です。</span><span class="sxs-lookup"><span data-stu-id="8f325-659">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="8f325-660">通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-660">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="8f325-661">このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-661">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="8f325-662">分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-662">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="8f325-663">指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-663">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="8f325-664">新しいインスタンスのラッパーであるオブジェクト。<see langword="null" /> が見つからない場合は <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-664">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="8f325-665">実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-665">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-666">`typeName` のパラメーターなしのコンストラクターが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-666">The parameterless constructor for `typeName` is invoked.</span></span>  
  
 <span data-ttu-id="8f325-667">このメソッドの詳細については、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> メソッドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-667">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8f325-668"><xref:System.AppDomain.CreateInstanceFrom%2A> メソッドを使用して、呼び出し元のアプリケーションドメイン以外のターゲットアプリケーションドメインにインスタンスを作成すると、アセンブリはターゲットアプリケーションドメインに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-668">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="8f325-669">ただし、呼び出し元のアプリケーションドメインでインスタンスがラップ解除されている場合は、ラップされていないインスタンスを特定の方法で使用すると、アセンブリが呼び出し元のアプリケーションドメインに読み込まれる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-669">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="8f325-670">たとえば、インスタンスがラップ解除された後に、遅延バインディングされたメソッドを呼び出すために、その型情報が要求される場合があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-670">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="8f325-671">アセンブリが呼び出し元のアプリケーションドメインに読み込まれると、例外が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-671">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="8f325-672">同じアセンブリの別のバージョンが以前に呼び出し元のアプリケーションドメインに読み込まれていた場合、または呼び出し元のアプリケーションドメインの読み込みパスがターゲットアプリケーションドメインのものと異なる場合は、<xref:System.MissingMethodException> などの例外が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-672">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="8f325-673">呼び出し元のアプリケーションドメインがインスタンス型への事前バインディング呼び出しを行う場合、インスタンスをキャストしようとしたときに <xref:System.InvalidCastException> がスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-673">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-674"><paramref name="assemblyFile" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-674"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-675"><paramref name="assemblyFile" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-675"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-676"><paramref name="typeName" /> が <paramref name="assemblyFile" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-676"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-677">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-677">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-678">一致するパブリック コンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-678">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-679">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> から継承しないオブジェクトのアクティベーション属性を提供できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-679">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-680">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-680">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-681"><paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-681"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-682">または</span><span class="sxs-lookup"><span data-stu-id="8f325-682">-or-</span></span> 
<span data-ttu-id="8f325-683">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-683">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-684">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-684">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="8f325-685">このインスタンスは <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-685">This instance is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, ignoreCase As Boolean, bindingAttr As BindingFlags, binder As Binder, args As Object(), culture As CultureInfo, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="8f325-686">要求する型を定義しているアセンブリが格納されているファイルの名前 (パスを含む)。</span><span class="sxs-lookup"><span data-stu-id="8f325-686">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="8f325-687">アセンブリは <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> メソッドを使用して読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-687">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-688">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-688">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8f325-689">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</span><span class="sxs-lookup"><span data-stu-id="8f325-689">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="8f325-690"><paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="8f325-690">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="8f325-691"><paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</span><span class="sxs-lookup"><span data-stu-id="8f325-691">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="8f325-692">バインディング、引数型の強制変換、メンバーの呼び出し、およびリフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-692">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="8f325-693"><paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-693">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-694">コンストラクターに渡される引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-694">The arguments to pass to the constructor.</span></span> <span data-ttu-id="8f325-695">この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-695">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="8f325-696">パラメーターなしのコンストラクターを使用する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-696">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="8f325-697"><paramref name="args" /> から <paramref name="typeName" /> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。</span><span class="sxs-lookup"><span data-stu-id="8f325-697">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="8f325-698"><paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-698">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="8f325-699">アクティブ化に参加できる 1 つ以上の属性の配列です。</span><span class="sxs-lookup"><span data-stu-id="8f325-699">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="8f325-700">通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-700">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="8f325-701">このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-701">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="8f325-702">クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-702">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="8f325-703">分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-703">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="8f325-704">指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-704">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="8f325-705">新しいインスタンスのラッパーであるオブジェクト。<see langword="null" /> が見つからない場合は <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-705">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="8f325-706">実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-706">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-707">詳細については、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> メソッドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-707">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8f325-708"><xref:System.AppDomain.CreateInstanceFrom%2A> メソッドを使用して、呼び出し元のアプリケーションドメイン以外のターゲットアプリケーションドメインにインスタンスを作成すると、アセンブリはターゲットアプリケーションドメインに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-708">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="8f325-709">ただし、呼び出し元のアプリケーションドメインでインスタンスがラップ解除されている場合は、ラップされていないインスタンスを特定の方法で使用すると、アセンブリが呼び出し元のアプリケーションドメインに読み込まれる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-709">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="8f325-710">たとえば、インスタンスがラップ解除された後に、遅延バインディングされたメソッドを呼び出すために、その型情報が要求される場合があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-710">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="8f325-711">アセンブリが呼び出し元のアプリケーションドメインに読み込まれると、例外が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-711">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="8f325-712">同じアセンブリの別のバージョンが以前に呼び出し元のアプリケーションドメインに読み込まれていた場合、または呼び出し元のアプリケーションドメインの読み込みパスがターゲットアプリケーションドメインのものと異なる場合は、<xref:System.MissingMethodException> などの例外が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-712">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="8f325-713">呼び出し元のアプリケーションドメインがインスタンス型への事前バインディング呼び出しを行う場合、インスタンスをキャストしようとしたときに <xref:System.InvalidCastException> がスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-713">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-714"><paramref name="assemblyFile" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-714"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-715">または</span><span class="sxs-lookup"><span data-stu-id="8f325-715">-or-</span></span> 
 <span data-ttu-id="8f325-716"><paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-716"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-717">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> から継承しないオブジェクトのアクティベーション属性を提供できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-717">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-718">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-718">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-719"><paramref name="assemblyFile" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-719"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-720"><paramref name="typeName" /> が <paramref name="assemblyFile" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-720"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-721">一致するパブリック コンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-721">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-722">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-722">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-723"><paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-723"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-724">または</span><span class="sxs-lookup"><span data-stu-id="8f325-724">-or-</span></span> 
 <span data-ttu-id="8f325-725">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyFile" /> がコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="8f325-725"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-726">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-726">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="8f325-727">このインスタンスは <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-727">This instance is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, ignoreCase As Boolean, bindingAttr As BindingFlags, binder As Binder, args As Object(), culture As CultureInfo, activationAttributes As Object(), securityAttributes As Evidence) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="8f325-728">要求する型を定義しているアセンブリが格納されているファイルの名前 (パスを含む)。</span><span class="sxs-lookup"><span data-stu-id="8f325-728">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="8f325-729">アセンブリは <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> メソッドを使用して読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-729">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-730">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-730">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8f325-731">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</span><span class="sxs-lookup"><span data-stu-id="8f325-731">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="8f325-732"><paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="8f325-732">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="8f325-733"><paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</span><span class="sxs-lookup"><span data-stu-id="8f325-733">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="8f325-734">バインディング、引数型の強制変換、メンバーの呼び出し、およびリフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-734">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="8f325-735"><paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-735">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-736">コンストラクターに渡される引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-736">The arguments to pass to the constructor.</span></span> <span data-ttu-id="8f325-737">この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-737">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="8f325-738">パラメーターなしのコンストラクターを使用する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-738">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="8f325-739"><paramref name="args" /> から <paramref name="typeName" /> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。</span><span class="sxs-lookup"><span data-stu-id="8f325-739">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="8f325-740"><paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-740">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="8f325-741">アクティブ化に参加できる 1 つ以上の属性の配列です。</span><span class="sxs-lookup"><span data-stu-id="8f325-741">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="8f325-742">通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-742">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="8f325-743">このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-743">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="8f325-744">クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-744">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="8f325-745">分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-745">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="8f325-746"><paramref name="typeName" /> の作成を承認するために使用される情報。</span><span class="sxs-lookup"><span data-stu-id="8f325-746">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="8f325-747">指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-747">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="8f325-748">新しいインスタンスのラッパーであるオブジェクト。<see langword="null" /> が見つからない場合は <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-748">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="8f325-749">実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-749">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-750">このメソッドの詳細については、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> メソッドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-750">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8f325-751"><xref:System.AppDomain.CreateInstanceFrom%2A> メソッドを使用して、呼び出し元のアプリケーションドメイン以外のターゲットアプリケーションドメインにインスタンスを作成すると、アセンブリはターゲットアプリケーションドメインに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-751">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="8f325-752">ただし、呼び出し元のアプリケーションドメインでインスタンスがラップ解除されている場合は、ラップされていないインスタンスを特定の方法で使用すると、アセンブリが呼び出し元のアプリケーションドメインに読み込まれる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-752">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="8f325-753">たとえば、インスタンスがラップ解除された後に、遅延バインディングされたメソッドを呼び出すために、その型情報が要求される場合があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-753">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="8f325-754">アセンブリが呼び出し元のアプリケーションドメインに読み込まれると、例外が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-754">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="8f325-755">同じアセンブリの別のバージョンが以前に呼び出し元のアプリケーションドメインに読み込まれていた場合、または呼び出し元のアプリケーションドメインの読み込みパスがターゲットアプリケーションドメインのものと異なる場合は、<xref:System.MissingMethodException> などの例外が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-755">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="8f325-756">呼び出し元のアプリケーションドメインがインスタンス型への事前バインディング呼び出しを行う場合、インスタンスをキャストしようとしたときに <xref:System.InvalidCastException> がスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-756">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-757"><paramref name="assemblyFile" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-757"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-758">または</span><span class="sxs-lookup"><span data-stu-id="8f325-758">-or-</span></span> 
 <span data-ttu-id="8f325-759"><paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-759"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-760">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> から継承しないオブジェクトのアクティベーション属性を提供できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-760">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span>  
  
<span data-ttu-id="8f325-761">または</span><span class="sxs-lookup"><span data-stu-id="8f325-761">-or-</span></span> 
 <span data-ttu-id="8f325-762"><paramref name="securityAttributes" /> が <see langword="null" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-762"><paramref name="securityAttributes" /> is not <see langword="null" />.</span></span> <span data-ttu-id="8f325-763">レガシ CAS ポリシーが有効でない場合は、<paramref name="securityAttributes" /> を <see langword="null" /> にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-763">When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-764">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-764">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-765"><paramref name="assemblyFile" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-765"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-766"><paramref name="typeName" /> が <paramref name="assemblyFile" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-766"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-767">一致するパブリック コンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-767">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-768">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-768">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-769"><paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-769"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-770">または</span><span class="sxs-lookup"><span data-stu-id="8f325-770">-or-</span></span> 
<span data-ttu-id="8f325-771">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-771">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-772">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-772">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="8f325-773">このインスタンスは <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-773">This instance is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8f325-774">指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-774">Creates a new instance of a specified type defined in the specified assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyFile As String, typeName As String) As Object" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName)" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-775">要求された型を定義するアセンブリのファイル名とパス。</span><span class="sxs-lookup"><span data-stu-id="8f325-775">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="assemblyFile">To be added.</param>
        <param name="typeName"><span data-ttu-id="8f325-776">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-776">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="8f325-777">指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-777">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="8f325-778">要求されたオブジェクト。<see langword="null" /> が見つからなかった場合は <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-778">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-779">これは、<xref:System.AppDomain.CreateInstanceFrom%2A> と <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>を組み合わせた便利な方法です。</span><span class="sxs-lookup"><span data-stu-id="8f325-779">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8f325-780">このメソッドは、`typeName`のパラメーターなしのコンストラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8f325-780">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="8f325-781">詳細については、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> メソッドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-781">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-782"><paramref name="assemblyName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-782"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-783">または</span><span class="sxs-lookup"><span data-stu-id="8f325-783">-or-</span></span> 
 <span data-ttu-id="8f325-784"><paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-784"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-785">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-785">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-786"><paramref name="assemblyName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-786"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-787"><paramref name="typeName" /> が <paramref name="assemblyName" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-787"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-788">パラメーターなしのパブリック コンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-788">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-789">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-789">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-790"><paramref name="assemblyName" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-790"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-791">または</span><span class="sxs-lookup"><span data-stu-id="8f325-791">-or-</span></span> 
<span data-ttu-id="8f325-792">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-792">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-793">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-793">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, object[] activationAttributes);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyFile As String, typeName As String, activationAttributes As Object()) As Object" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, activationAttributes)" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-794">要求された型を定義するアセンブリのファイル名とパス。</span><span class="sxs-lookup"><span data-stu-id="8f325-794">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="assemblyFile">To be added.</param>
        <param name="typeName"><span data-ttu-id="8f325-795">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します (<see cref="P:System.Type.FullName" /> プロパティを参照)。</span><span class="sxs-lookup"><span data-stu-id="8f325-795">The fully qualified name of the requested type, including the namespace but not the assembly (see the <see cref="P:System.Type.FullName" /> property).</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="8f325-796">アクティブ化に参加できる 1 つ以上の属性の配列です。</span><span class="sxs-lookup"><span data-stu-id="8f325-796">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="8f325-797">通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-797">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="8f325-798">このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-798">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="8f325-799">分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-799">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="8f325-800">指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-800">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="8f325-801">要求されたオブジェクト。<see langword="null" /> が見つからなかった場合は <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-801">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-802">これは、<xref:System.AppDomain.CreateInstanceFrom%2A> と <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>を組み合わせた便利な方法です。</span><span class="sxs-lookup"><span data-stu-id="8f325-802">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8f325-803">このメソッドは、`typeName`のパラメーターなしのコンストラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8f325-803">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="8f325-804">このメソッドの詳細については、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> メソッドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-804">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-805"><paramref name="assemblyName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-805"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-806">または</span><span class="sxs-lookup"><span data-stu-id="8f325-806">-or-</span></span> 
 <span data-ttu-id="8f325-807"><paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-807"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-808">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> から継承しないオブジェクトのアクティベーション属性を提供できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-808">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-809">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-809">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-810"><paramref name="assemblyName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-810"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-811"><paramref name="typeName" /> が <paramref name="assemblyName" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-811"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-812">パラメーターなしのパブリック コンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-812">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-813">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-813">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-814"><paramref name="assemblyName" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-814"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-815">または</span><span class="sxs-lookup"><span data-stu-id="8f325-815">-or-</span></span> 
<span data-ttu-id="8f325-816">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-816">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-817">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-817">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyFile As String, typeName As String, ignoreCase As Boolean, bindingAttr As BindingFlags, binder As Binder, args As Object(), culture As CultureInfo, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="8f325-818">要求された型を定義するアセンブリのファイル名とパス。</span><span class="sxs-lookup"><span data-stu-id="8f325-818">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-819">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-819">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8f325-820">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</span><span class="sxs-lookup"><span data-stu-id="8f325-820">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="8f325-821"><paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="8f325-821">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="8f325-822"><paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</span><span class="sxs-lookup"><span data-stu-id="8f325-822">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="8f325-823">バインディング、引数型の強制変換、メンバーの呼び出し、およびリフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-823">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="8f325-824"><paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-824">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-825">コンストラクターに渡される引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-825">The arguments to pass to the constructor.</span></span> <span data-ttu-id="8f325-826">この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-826">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="8f325-827">パラメーターなしのコンストラクターを使用する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-827">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="8f325-828"><paramref name="args" /> から <paramref name="typeName" /> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。</span><span class="sxs-lookup"><span data-stu-id="8f325-828">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="8f325-829"><paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-829">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="8f325-830">アクティブ化に参加できる 1 つ以上の属性の配列です。</span><span class="sxs-lookup"><span data-stu-id="8f325-830">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="8f325-831">通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-831">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="8f325-832">このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-832">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="8f325-833">クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-833">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="8f325-834">分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-834">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="8f325-835">指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。型名の大文字と小文字の区別を無視するかどうか、作成する型を選択するために使用されるバインディング属性とバインダー、コンストラクターの引数、カルチャ、およびアクティベーション属性を指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-835">Creates a new instance of the specified type defined in the specified assembly file, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</span></span></summary>
        <returns><span data-ttu-id="8f325-836">要求されたオブジェクト。<see langword="null" /> が見つからなかった場合は <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-836">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-837">これは、<xref:System.AppDomain.CreateInstanceFrom%2A> と <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>を組み合わせた便利な方法です。</span><span class="sxs-lookup"><span data-stu-id="8f325-837">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="8f325-838">このメソッドの詳細については、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> メソッドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-838">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-839"><paramref name="assemblyName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-839"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-840">または</span><span class="sxs-lookup"><span data-stu-id="8f325-840">-or-</span></span> 
 <span data-ttu-id="8f325-841"><paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-841"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-842">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> から継承しないオブジェクトのアクティベーション属性を提供できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-842">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-843">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-843">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-844"><paramref name="assemblyName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-844"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-845"><paramref name="typeName" /> が <paramref name="assemblyName" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-845"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-846">一致するパブリック コンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-846">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-847">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-847">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-848"><paramref name="assemblyName" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-848"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-849">または</span><span class="sxs-lookup"><span data-stu-id="8f325-849">-or-</span></span> 
 <span data-ttu-id="8f325-850">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyName" /> がコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="8f325-850"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime that the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-851">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-851">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, ignoreCase As Boolean, bindingAttr As BindingFlags, binder As Binder, args As Object(), culture As CultureInfo, activationAttributes As Object(), securityAttributes As Evidence) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-852">要求された型を定義するアセンブリのファイル名とパス。</span><span class="sxs-lookup"><span data-stu-id="8f325-852">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="8f325-853">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-853">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="8f325-854">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</span><span class="sxs-lookup"><span data-stu-id="8f325-854">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="8f325-855"><paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="8f325-855">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="8f325-856"><paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</span><span class="sxs-lookup"><span data-stu-id="8f325-856">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="8f325-857">バインディング、引数型の強制変換、メンバーの呼び出し、およびリフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-857">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="8f325-858"><paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-858">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-859">コンストラクターに渡される引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-859">The arguments to pass to the constructor.</span></span> <span data-ttu-id="8f325-860">この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-860">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="8f325-861">パラメーターなしのコンストラクターを使用する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-861">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="8f325-862"><paramref name="args" /> から <paramref name="typeName" /> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。</span><span class="sxs-lookup"><span data-stu-id="8f325-862">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="8f325-863"><paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-863">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="8f325-864">アクティブ化に参加できる 1 つ以上の属性の配列です。</span><span class="sxs-lookup"><span data-stu-id="8f325-864">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="8f325-865">通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-865">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="8f325-866">このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-866">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="8f325-867">クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-867">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="8f325-868">分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-868">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="8f325-869"><paramref name="typeName" /> の作成を承認するために使用される情報。</span><span class="sxs-lookup"><span data-stu-id="8f325-869">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="8f325-870">指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-870">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="8f325-871">要求されたオブジェクト。<see langword="null" /> が見つからなかった場合は <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-871">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-872">これは、<xref:System.AppDomain.CreateInstanceFrom%2A> と <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>を組み合わせた便利な方法です。</span><span class="sxs-lookup"><span data-stu-id="8f325-872">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="8f325-873">このメソッドの詳細については、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> メソッドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-873">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-874"><paramref name="assemblyName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-874"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-875">または</span><span class="sxs-lookup"><span data-stu-id="8f325-875">-or-</span></span> 
 <span data-ttu-id="8f325-876"><paramref name="typeName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-876"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-877">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> から継承しないオブジェクトのアクティベーション属性を提供できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-877">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-878">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-878">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-879"><paramref name="assemblyName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-879"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="8f325-880"><paramref name="typeName" /> が <paramref name="assemblyName" /> に見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-880"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-881">一致するパブリック コンストラクターが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-881">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="8f325-882">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-882">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-883"><paramref name="assemblyName" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-883"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-884">または</span><span class="sxs-lookup"><span data-stu-id="8f325-884">-or-</span></span> 
<span data-ttu-id="8f325-885">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-885">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-886">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-886">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-887">現在の <see cref="T:System.Threading.Thread" /> に対する現在のアプリケーション ドメインを取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-887">Gets the current application domain for the current <see cref="T:System.Threading.Thread" />.</span></span></summary>
        <value><span data-ttu-id="8f325-888">現在のアプリケーション ドメイン。</span><span class="sxs-lookup"><span data-stu-id="8f325-888">The current application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8f325-889">次のコード例では、新しいアプリケーションドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-889">The following code example creates a new application domain.</span></span> <span data-ttu-id="8f325-890"><xref:System.AppDomain.CurrentDomain%2A> プロパティは、現在のアプリケーションドメインを表す <xref:System.AppDomain> オブジェクトを取得するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-890">The <xref:System.AppDomain.CurrentDomain%2A> property is used to obtain an <xref:System.AppDomain> object that represents the current application domain.</span></span> <span data-ttu-id="8f325-891"><xref:System.AppDomain.FriendlyName%2A> プロパティは、現在のアプリケーションドメインの名前を指定します。これがコマンドラインに表示されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-891">The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8f325-892">現在のアプリケーション ドメインで動的アセンブリを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-892">Defines a dynamic assembly in the current application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-893">動的アセンブリの一意の ID。</span><span class="sxs-lookup"><span data-stu-id="8f325-893">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="8f325-894">動的アセンブリのアクセス モード。</span><span class="sxs-lookup"><span data-stu-id="8f325-894">The access mode for the dynamic assembly.</span></span></param>
        <summary><span data-ttu-id="8f325-895">名前とアクセス モードを指定して、動的アセンブリを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-895">Defines a dynamic assembly with the specified name and access mode.</span></span></summary>
        <returns><span data-ttu-id="8f325-896">名前とアクセス モードが指定された動的アセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-896">A dynamic assembly with the specified name and access mode.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-897">このメソッドは、現在のアプリケーションドメインで動的アセンブリを定義する場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-897">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="8f325-898">詳細については、「<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロード」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-898">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-899">動的アセンブリを出力するコードの開発時には、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドのオーバーロードを使用して、証拠とアクセス許可を指定し、動的アセンブリに必要な証拠を提供し、`refusedPermissions`に <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> を含めることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8f325-899">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="8f325-900">`refusedPermissions` パラメーターに <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> を含めると、MSIL が確実に検証されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-900">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="8f325-901">この手法の制限として、完全信頼を要求するコードと共に使用すると <xref:System.Security.SecurityException> がスローされることもあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-901">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-902">次の例は、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドと <xref:System.AppDomain.AssemblyResolve> イベントを示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-902">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="8f325-903">このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-903">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="8f325-904">完全修飾アセンブリ名を取得する方法については、「[アセンブリ名](~/docs/standard/assembly/names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-904">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-905"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-905"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-906"><see langword="Name" /> の <paramref name="name" /> プロパティが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-906">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-907">または</span><span class="sxs-lookup"><span data-stu-id="8f325-907">-or-</span></span> 
<span data-ttu-id="8f325-908"><see langword="Name" /> の <paramref name="name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</span><span class="sxs-lookup"><span data-stu-id="8f325-908">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-909">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-909">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-910">動的アセンブリの一意の ID。</span><span class="sxs-lookup"><span data-stu-id="8f325-910">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="8f325-911">動的アセンブリのアクセス モード。</span><span class="sxs-lookup"><span data-stu-id="8f325-911">The access mode for the dynamic assembly.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="8f325-912">アセンブリに適用される属性を列挙した一覧。属性がない場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-912">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="8f325-913">名前、アクセス モード、およびカスタム属性を指定して、動的アセンブリを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-913">Defines a dynamic assembly with the specified name, access mode, and custom attributes.</span></span></summary>
        <returns><span data-ttu-id="8f325-914">名前と機能が指定された動的アセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-914">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-915">動的アセンブリの作成時に適用されない場合、正しく機能しない属性を指定するには、このメソッドオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-915">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="8f325-916">たとえば、動的アセンブリの作成後に追加された場合、<xref:System.Security.SecurityTransparentAttribute> や <xref:System.Security.SecurityCriticalAttribute> などのセキュリティ属性は正しく機能しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-916">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="8f325-917">このメソッドは、現在のアプリケーションドメインで動的アセンブリを定義する場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-917">This method should be used only to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="8f325-918">この制限の詳細については、「<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロード」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-918">For more information about this restriction, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 <span data-ttu-id="8f325-919">このメソッドオーバーロードは、[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]で導入されました。</span><span class="sxs-lookup"><span data-stu-id="8f325-919">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-920">次のコードサンプルは、<xref:System.Security.SecurityTransparentAttribute>を持つ動的アセンブリを作成する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-920">The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>.</span></span> <span data-ttu-id="8f325-921">属性は <xref:System.Reflection.Emit.CustomAttributeBuilder> オブジェクトの配列の要素として指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-921">The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.</span></span>  
  
 <span data-ttu-id="8f325-922"><xref:System.Reflection.Emit.CustomAttributeBuilder> を作成するための最初の手順は、属性のコンストラクターを取得することです。</span><span class="sxs-lookup"><span data-stu-id="8f325-922">The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute.</span></span> <span data-ttu-id="8f325-923">コンストラクターにはパラメーターがないため、パラメーターの型を表す <xref:System.Type> オブジェクトの空の配列を使用して <xref:System.Type.GetConstructor%2A> メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-923">The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters.</span></span> <span data-ttu-id="8f325-924">2番目の手順では、結果の <xref:System.Reflection.ConstructorInfo> オブジェクトを <xref:System.Reflection.Emit.CustomAttributeBuilder> クラスのコンストラクターに渡し、<xref:System.Object> 型の空の配列と共に引数を表します。</span><span class="sxs-lookup"><span data-stu-id="8f325-924">The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.</span></span>  
  
 <span data-ttu-id="8f325-925">結果として得られる <xref:System.Reflection.Emit.CustomAttributeBuilder> は、配列の唯一の要素として <xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドに渡されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-925">The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the <xref:System.AppDomain.DefineDynamicAssembly%2A> method as the only element of an array.</span></span>  
  
 <span data-ttu-id="8f325-926">このコード例では、新しい動的アセンブリにモジュールと型を定義し、アセンブリの属性を表示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-926">The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.</span></span>  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-927"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-927"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-928"><see langword="Name" /> の <paramref name="name" /> プロパティが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-928">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-929">または</span><span class="sxs-lookup"><span data-stu-id="8f325-929">-or-</span></span> 
<span data-ttu-id="8f325-930"><see langword="Name" /> の <paramref name="name" /> プロパティが空白で始まっているか、スラッシュまたは円記号が含まれています。</span><span class="sxs-lookup"><span data-stu-id="8f325-930">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-931">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-931">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, evidence As Evidence) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-932">動的アセンブリの一意の ID。</span><span class="sxs-lookup"><span data-stu-id="8f325-932">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="8f325-933">動的アセンブリにアクセスするときのモード。</span><span class="sxs-lookup"><span data-stu-id="8f325-933">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="evidence"><span data-ttu-id="8f325-934">動的アセンブリに指定する証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-934">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="8f325-935">証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-935">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <summary><span data-ttu-id="8f325-936">名前、アクセス モード、および証拠を指定して、動的アセンブリを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-936">Defines a dynamic assembly using the specified name, access mode, and evidence.</span></span></summary>
        <returns><span data-ttu-id="8f325-937">名前と機能が指定された動的アセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-937">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-938">動的 <xref:System.Reflection.Assembly>を定義するときに、完全に信頼されている呼び出し元だけが `evidence` を提供できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-938">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="8f325-939">ランタイムは、セキュリティポリシーを使用して <xref:System.Security.Policy.Evidence> をマップし、付与されたアクセス許可を決定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-939">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="8f325-940">部分的に信頼された呼び出し元は、null `evidence`を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-940">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="8f325-941">`evidence` が `null`場合、ランタイムは、呼び出し元の <xref:System.Reflection.Assembly> から定義されている動的 <xref:System.Reflection.Assembly> にアクセス許可セット (現在の許可セットと拒否セット) をコピーし、ポリシーを解決済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="8f325-941">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="8f325-942">動的 <xref:System.Reflection.Assembly> がディスクに保存される場合、その後の読み込みは、<xref:System.Reflection.Assembly> が保存された場所に関連付けられたポリシーに基づいて付与されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-942">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="8f325-943">このメソッドは、現在のアプリケーションドメインで動的アセンブリを定義する場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-943">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="8f325-944">詳細については、「<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロード」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-944">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-945">動的アセンブリを出力するコードの開発時には、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドのオーバーロードを使用して、証拠とアクセス許可を指定し、動的アセンブリに必要な証拠を提供し、`refusedPermissions`に <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> を含めることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8f325-945">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="8f325-946">`refusedPermissions` パラメーターに <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> を含めると、MSIL が確実に検証されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-946">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="8f325-947">この手法の制限として、完全信頼を要求するコードと共に使用すると <xref:System.Security.SecurityException> がスローされることもあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-947">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-948">次の例は、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドと <xref:System.AppDomain.AssemblyResolve> イベントを示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-948">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="8f325-949">まず、コード例では、無効なアセンブリ名を使用して <xref:System.AppDomain.CreateInstance%2A> メソッドを呼び出し、結果の例外をキャッチすることによって、`MyDynamicType` のインスタンスを作成しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-949">First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.</span></span>  
  
 <span data-ttu-id="8f325-950">次に、このコード例では、<xref:System.AppDomain.AssemblyResolve> イベントのイベントハンドラーを追加し、もう一度`MyDynamicType`のインスタンスを作成しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-950">The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`.</span></span> <span data-ttu-id="8f325-951"><xref:System.AppDomain.CreateInstance%2A>の呼び出し中に、無効なアセンブリに対して <xref:System.AppDomain.AssemblyResolve> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-951">During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly.</span></span> <span data-ttu-id="8f325-952">イベントハンドラーは、`MyDynamicType`という名前の型を含む動的アセンブリを作成し、型にパラメーターなしのコンストラクターを与え、新しい動的アセンブリを返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-952">The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly.</span></span> <span data-ttu-id="8f325-953"><xref:System.AppDomain.CreateInstance%2A> の呼び出しが正常に完了し、`MyDynamicType` のコンストラクターによってメッセージがコンソールに表示されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-953">The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-954"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-954"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-955"><see langword="Name" /> の <paramref name="name" /> プロパティが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-955">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-956">または</span><span class="sxs-lookup"><span data-stu-id="8f325-956">-or-</span></span> 
<span data-ttu-id="8f325-957"><see langword="Name" /> の <paramref name="name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</span><span class="sxs-lookup"><span data-stu-id="8f325-957">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-958">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-958">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-959">動的アセンブリの一意の ID。</span><span class="sxs-lookup"><span data-stu-id="8f325-959">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="8f325-960">動的アセンブリにアクセスするときのモード。</span><span class="sxs-lookup"><span data-stu-id="8f325-960">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="8f325-961">アセンブリを保存するディレクトリの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-961">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="8f325-962"><paramref name="dir" /> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-962">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <summary><span data-ttu-id="8f325-963">名前、アクセス モード、およびストレージ ディレクトリを指定して、動的アセンブリを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-963">Defines a dynamic assembly using the specified name, access mode, and storage directory.</span></span></summary>
        <returns><span data-ttu-id="8f325-964">名前と機能が指定された動的アセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-964">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-965">このメソッドは、現在のアプリケーションドメインで動的アセンブリを定義する場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-965">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="8f325-966">詳細については、「<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロード」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-966">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-967">動的アセンブリを出力するコードの開発時には、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドのオーバーロードを使用して、証拠とアクセス許可を指定し、動的アセンブリに必要な証拠を提供し、`refusedPermissions`に <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> を含めることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8f325-967">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="8f325-968">`refusedPermissions` パラメーターに <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> を含めると、MSIL が確実に検証されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-968">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="8f325-969">この手法の制限として、完全信頼を要求するコードと共に使用すると <xref:System.Security.SecurityException> がスローされることもあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-969">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-970">次の例は、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドと <xref:System.AppDomain.AssemblyResolve> イベントを示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-970">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="8f325-971">このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-971">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="8f325-972">完全修飾アセンブリ名を取得する方法については、「[アセンブリ名](~/docs/standard/assembly/names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-972">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-973"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-973"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-974"><see langword="Name" /> の <paramref name="name" /> プロパティが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-974">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-975">または</span><span class="sxs-lookup"><span data-stu-id="8f325-975">-or-</span></span> 
<span data-ttu-id="8f325-976"><see langword="Name" /> の <paramref name="name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</span><span class="sxs-lookup"><span data-stu-id="8f325-976">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-977">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-977">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder), securityContextSource As SecurityContextSource) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-978">動的アセンブリの一意の ID。</span><span class="sxs-lookup"><span data-stu-id="8f325-978">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="8f325-979">動的アセンブリのアクセス モード。</span><span class="sxs-lookup"><span data-stu-id="8f325-979">The access mode for the dynamic assembly.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="8f325-980">アセンブリに適用される属性を列挙した一覧。属性がない場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-980">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <param name="securityContextSource"><span data-ttu-id="8f325-981">セキュリティ コンテキストのソース。</span><span class="sxs-lookup"><span data-stu-id="8f325-981">The source of the security context.</span></span></param>
        <summary><span data-ttu-id="8f325-982">名前、アクセス モード、カスタム属性、およびセキュリティ コンテキストのソースを指定して、動的アセンブリを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-982">Defines a dynamic assembly with the specified name, access mode, and custom attributes, and using the specified source for its security context.</span></span></summary>
        <returns><span data-ttu-id="8f325-983">名前と機能が指定された動的アセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-983">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-984">動的アセンブリの作成時に適用されない場合、正しく機能しない属性を指定するには、このメソッドオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-984">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="8f325-985">たとえば、動的アセンブリの作成後に追加された場合、<xref:System.Security.SecurityTransparentAttribute> や <xref:System.Security.SecurityCriticalAttribute> などのセキュリティ属性は正しく機能しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-985">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="8f325-986">このメソッドは、現在のアプリケーションドメインで動的アセンブリを定義する場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-986">This method should be used only to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="8f325-987">この制限の詳細については、「<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロード」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-987">For more information about this restriction, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-988"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-988"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-989"><see langword="Name" /> の <paramref name="name" /> プロパティが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-989">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-990">または</span><span class="sxs-lookup"><span data-stu-id="8f325-990">-or-</span></span> 
<span data-ttu-id="8f325-991"><see langword="Name" /> の <paramref name="name" /> プロパティが空白で始まっているか、スラッシュまたは円記号が含まれています。</span><span class="sxs-lookup"><span data-stu-id="8f325-991">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-992">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-992">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8f325-993"><paramref name="securityContextSource" /> の値が列挙値ではありませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-993">The value of <paramref name="securityContextSource" /> was not one of the enumeration values.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, evidence As Evidence) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-994">動的アセンブリの一意の ID。</span><span class="sxs-lookup"><span data-stu-id="8f325-994">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="8f325-995">動的アセンブリにアクセスするときのモード。</span><span class="sxs-lookup"><span data-stu-id="8f325-995">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="8f325-996">アセンブリを保存するディレクトリの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-996">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="8f325-997"><paramref name="dir" /> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-997">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="8f325-998">動的アセンブリに指定する証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-998">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="8f325-999">証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-999">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <summary><span data-ttu-id="8f325-1000">名前、アクセス モード、ストレージ ディレクトリ、および証拠を指定して、動的アセンブリを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1000">Defines a dynamic assembly using the specified name, access mode, storage directory, and evidence.</span></span></summary>
        <returns><span data-ttu-id="8f325-1001">名前と機能が指定された動的アセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1001">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1002">動的 <xref:System.Reflection.Assembly>を定義するときに、完全に信頼されている呼び出し元だけが `evidence` を提供できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1002">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="8f325-1003">ランタイムは、セキュリティポリシーを使用して <xref:System.Security.Policy.Evidence> をマップし、付与されたアクセス許可を決定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1003">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="8f325-1004">部分的に信頼された呼び出し元は、null `evidence`を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1004">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="8f325-1005">`evidence` が `null`場合、ランタイムは、呼び出し元の <xref:System.Reflection.Assembly> から定義されている動的 <xref:System.Reflection.Assembly> にアクセス許可セット (現在の許可セットと拒否セット) をコピーし、ポリシーを解決済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1005">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="8f325-1006">動的 <xref:System.Reflection.Assembly> がディスクに保存される場合、その後の読み込みは、<xref:System.Reflection.Assembly> が保存された場所に関連付けられたポリシーに基づいて付与されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1006">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="8f325-1007">このメソッドは、現在のアプリケーションドメインで動的アセンブリを定義する場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1007">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="8f325-1008">詳細については、「<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロード」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1008">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1009">動的アセンブリを出力するコードの開発時には、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドのオーバーロードを使用して、証拠とアクセス許可を指定し、動的アセンブリに必要な証拠を提供し、`refusedPermissions`に <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> を含めることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1009">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="8f325-1010">`refusedPermissions` パラメーターに <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> を含めると、MSIL が確実に検証されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1010">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="8f325-1011">この手法の制限として、完全信頼を要求するコードと共に使用すると <xref:System.Security.SecurityException> がスローされることもあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1011">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1012">次の例は、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドと <xref:System.AppDomain.AssemblyResolve> イベントを示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1012">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="8f325-1013">このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1013">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="8f325-1014">完全修飾アセンブリ名を取得する方法については、「[アセンブリ名](~/docs/standard/assembly/names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1014">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1015"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1015"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-1016"><see langword="Name" /> の <paramref name="name" /> プロパティが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1016">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-1017">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1017">-or-</span></span> 
<span data-ttu-id="8f325-1018"><see langword="Name" /> の <paramref name="name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1018">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1019">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1019">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-1020">動的アセンブリの一意の ID。</span><span class="sxs-lookup"><span data-stu-id="8f325-1020">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="8f325-1021">動的アセンブリにアクセスするときのモード。</span><span class="sxs-lookup"><span data-stu-id="8f325-1021">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="8f325-1022">必須のアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1022">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="8f325-1023">オプションのアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1023">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="8f325-1024">拒否されたアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1024">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="8f325-1025">名前、アクセス モード、およびアクセス許可要求を指定して、動的アセンブリを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1025">Defines a dynamic assembly using the specified name, access mode, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="8f325-1026">名前と機能が指定された動的アセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1026">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1027">`requiredPermissions`、`optionalPermissions`、および `refusedPermissions` に指定されたアクセス許可要求は、動的アセンブリが保存され、メモリに再読み込みされない限り、使用されません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1027">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are not used unless the dynamic assembly has been saved and reloaded into memory.</span></span> <span data-ttu-id="8f325-1028">ディスクに保存されていない一時アセンブリに対するアクセス許可要求を指定するには、証拠と要求されたアクセス許可を指定する <xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドのオーバーロードを使用し、<xref:System.Security.Policy.Evidence> オブジェクトを指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1028">To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1029">動的アセンブリを出力するコードの開発時には、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドのオーバーロードを使用して、証拠とアクセス許可を指定し、動的アセンブリに必要な証拠を提供し、`refusedPermissions`に <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> を含めることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1029">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="8f325-1030">`refusedPermissions` パラメーターに <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> を含めると、MSIL が確実に検証されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1030">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="8f325-1031">この手法の制限として、完全信頼を要求するコードと共に使用すると <xref:System.Security.SecurityException> がスローされることもあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1031">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="8f325-1032">このメソッドは、現在のアプリケーションドメインで動的アセンブリを定義する場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1032">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="8f325-1033">詳細については、「<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロード」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1033">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1034">次の例は、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドと <xref:System.AppDomain.AssemblyResolve> イベントを示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1034">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="8f325-1035">このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1035">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="8f325-1036">完全修飾アセンブリ名を取得する方法については、「[アセンブリ名](~/docs/standard/assembly/names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1036">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1037"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1037"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-1038"><see langword="Name" /> の <paramref name="name" /> プロパティが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1038">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-1039">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1039">-or-</span></span> 
<span data-ttu-id="8f325-1040"><see langword="Name" /> の <paramref name="name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1040">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1041">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1041">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-1042">動的アセンブリの一意の ID。</span><span class="sxs-lookup"><span data-stu-id="8f325-1042">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="8f325-1043">動的アセンブリにアクセスするときのモード。</span><span class="sxs-lookup"><span data-stu-id="8f325-1043">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="8f325-1044">動的アセンブリを保存するディレクトリの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-1044">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="8f325-1045"><paramref name="dir" /> が <see langword="null" /> の場合、現在のディレクトリが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1045">If <paramref name="dir" /> is <see langword="null" />, the current directory is used.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="8f325-1046">動的アセンブリ内のモジュール、型、およびメンバーの作成を同期する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-1046"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="8f325-1047">アセンブリに適用される属性を列挙した一覧。属性がない場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-1047">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="8f325-1048">名前、アクセス モード、ストレージ ディレクトリ、および同期オプションを指定して、動的アセンブリを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1048">Defines a dynamic assembly using the specified name, access mode, storage directory, and synchronization option.</span></span></summary>
        <returns><span data-ttu-id="8f325-1049">名前と機能が指定された動的アセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1049">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1050">動的アセンブリの作成時に適用されない場合、正しく機能しない属性を指定するには、このメソッドオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1050">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="8f325-1051">たとえば、動的アセンブリの作成後に追加された場合、<xref:System.Security.SecurityTransparentAttribute> や <xref:System.Security.SecurityCriticalAttribute> などのセキュリティ属性は正しく機能しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1051">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="8f325-1052">`isSynchronized` が `true`場合、結果として得られる <xref:System.Reflection.Emit.AssemblyBuilder> の次のメソッドが同期されます (<xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>)。</span><span class="sxs-lookup"><span data-stu-id="8f325-1052">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="8f325-1053">これらの2つのメソッドが異なるスレッドで呼び出された場合は、もう一方のスレッドが完了するまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1053">If two of these methods are called on different threads, one will block until the other is completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1054"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1054"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-1055"><see langword="Name" /> の <paramref name="name" /> プロパティが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1055">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-1056">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1056">-or-</span></span> 
<span data-ttu-id="8f325-1057"><see langword="Name" /> の <paramref name="name" /> プロパティが空白で始まっているか、スラッシュまたは円記号が含まれています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1057">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1058">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1058">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, evidence As Evidence, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-1059">動的アセンブリの一意の ID。</span><span class="sxs-lookup"><span data-stu-id="8f325-1059">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="8f325-1060">動的アセンブリにアクセスするときのモード。</span><span class="sxs-lookup"><span data-stu-id="8f325-1060">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="evidence"><span data-ttu-id="8f325-1061">動的アセンブリに指定する証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-1061">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="8f325-1062">証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1062">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="8f325-1063">必須のアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1063">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="8f325-1064">オプションのアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1064">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="8f325-1065">拒否されたアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1065">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="8f325-1066">名前、アクセス モード、証拠、およびアクセス許可要求を指定して、動的アセンブリを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1066">Defines a dynamic assembly using the specified name, access mode, evidence, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="8f325-1067">名前と機能が指定された動的アセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1067">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1068">`requiredPermissions`、`optionalPermissions`、および `refusedPermissions` に指定されたアクセス許可要求は、`evidence` も指定されている場合、または動的アセンブリが保存されてメモリに再読み込みされる場合にのみ使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1068">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1069">動的アセンブリを出力するコードの開発中は、`refusedPermissions`に <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> を含めることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1069">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="8f325-1070">`refusedPermissions` パラメーターに <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> を含めると、MSIL が確実に検証されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1070">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="8f325-1071">この手法の制限として、完全信頼を要求するコードと共に使用すると <xref:System.Security.SecurityException> がスローされることもあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1071">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="8f325-1072">動的 <xref:System.Reflection.Assembly>を定義するときに、完全に信頼されている呼び出し元だけが `evidence` を提供できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1072">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="8f325-1073">ランタイムは、セキュリティポリシーを使用して <xref:System.Security.Policy.Evidence> をマップし、付与されたアクセス許可を決定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1073">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="8f325-1074">部分的に信頼された呼び出し元は、null `evidence`を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1074">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="8f325-1075">`evidence` が `null`場合、ランタイムは、呼び出し元の <xref:System.Reflection.Assembly> から定義されている動的 <xref:System.Reflection.Assembly> にアクセス許可セット (現在の許可セットと拒否セット) をコピーし、ポリシーを解決済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1075">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="8f325-1076">動的 <xref:System.Reflection.Assembly> がディスクに保存される場合、その後の読み込みは、<xref:System.Reflection.Assembly> が保存された場所に関連付けられたポリシーに基づいて付与されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1076">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="8f325-1077">このメソッドは、現在のアプリケーションドメインで動的アセンブリを定義する場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1077">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="8f325-1078">詳細については、「<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロード」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1078">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1079">次の例は、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドと <xref:System.AppDomain.AssemblyResolve> イベントを示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1079">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="8f325-1080">このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1080">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="8f325-1081">完全修飾アセンブリ名を取得する方法については、「[アセンブリ名](~/docs/standard/assembly/names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1081">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1082"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1082"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-1083"><see langword="Name" /> の <paramref name="name" /> プロパティが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1083">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-1084">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1084">-or-</span></span> 
<span data-ttu-id="8f325-1085"><see langword="Name" /> の <paramref name="name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1085">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1086">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1086">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-1087">動的アセンブリの一意の ID。</span><span class="sxs-lookup"><span data-stu-id="8f325-1087">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="8f325-1088">動的アセンブリにアクセスするときのモード。</span><span class="sxs-lookup"><span data-stu-id="8f325-1088">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="8f325-1089">アセンブリを保存するディレクトリの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-1089">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="8f325-1090"><paramref name="dir" /> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1090">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="8f325-1091">必須のアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1091">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="8f325-1092">オプションのアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1092">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="8f325-1093">拒否されたアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1093">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="8f325-1094">名前、アクセス モード、ストレージ ディレクトリ、およびアクセス許可要求を指定して、動的アセンブリを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1094">Defines a dynamic assembly using the specified name, access mode, storage directory, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="8f325-1095">名前と機能が指定された動的アセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1095">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1096">`requiredPermissions`、`optionalPermissions`、および `refusedPermissions` に指定されたアクセス許可要求は、動的アセンブリが保存され、メモリに再読み込みされない限り、使用されません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1096">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are not used unless the dynamic assembly has been saved and reloaded into memory.</span></span> <span data-ttu-id="8f325-1097">ディスクに保存されていない一時アセンブリに対するアクセス許可要求を指定するには、証拠と要求されたアクセス許可を指定する <xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドのオーバーロードを使用し、<xref:System.Security.Policy.Evidence> オブジェクトを指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1097">To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1098">動的アセンブリを出力するコードの開発時には、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドのオーバーロードを使用して、証拠とアクセス許可を指定し、動的アセンブリに必要な証拠を提供し、`refusedPermissions`に <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> を含めることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1098">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="8f325-1099">`refusedPermissions` パラメーターに <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> を含めると、MSIL が確実に検証されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1099">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="8f325-1100">この手法の制限として、完全信頼を要求するコードと共に使用すると <xref:System.Security.SecurityException> がスローされることもあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1100">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="8f325-1101">このメソッドは、現在のアプリケーションドメインで動的アセンブリを定義する場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1101">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="8f325-1102">詳細については、「<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロード」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1102">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1103">次の例は、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドと <xref:System.AppDomain.AssemblyResolve> イベントを示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1103">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="8f325-1104">このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1104">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="8f325-1105">完全修飾アセンブリ名を取得する方法については、「[アセンブリ名](~/docs/standard/assembly/names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1105">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1106"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1106"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-1107"><see langword="Name" /> の <paramref name="name" /> プロパティが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1107">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-1108">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1108">-or-</span></span> 
<span data-ttu-id="8f325-1109"><see langword="Name" /> の <paramref name="name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1109">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1110">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1110">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, evidence As Evidence, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-1111">動的アセンブリの一意の ID。</span><span class="sxs-lookup"><span data-stu-id="8f325-1111">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="8f325-1112">動的アセンブリにアクセスするときのモード。</span><span class="sxs-lookup"><span data-stu-id="8f325-1112">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="8f325-1113">アセンブリを保存するディレクトリの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-1113">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="8f325-1114"><paramref name="dir" /> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1114">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="8f325-1115">動的アセンブリに指定する証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-1115">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="8f325-1116">証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1116">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="8f325-1117">必須のアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1117">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="8f325-1118">オプションのアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1118">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="8f325-1119">拒否されたアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1119">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="8f325-1120">名前、アクセス モード、ストレージ ディレクトリ、証拠、およびアクセス許可要求を指定して、動的アセンブリを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1120">Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="8f325-1121">名前と機能が指定された動的アセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1121">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1122">`requiredPermissions`、`optionalPermissions`、および `refusedPermissions` に指定されたアクセス許可要求は、`evidence` も指定されている場合、または動的アセンブリが保存されてメモリに再読み込みされる場合にのみ使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1122">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1123">動的アセンブリを出力するコードの開発中は、`refusedPermissions`に <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> を含めることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1123">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="8f325-1124">`refusedPermissions` パラメーターに <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> を含めると、MSIL が確実に検証されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1124">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="8f325-1125">この手法の制限として、完全信頼を要求するコードと共に使用すると <xref:System.Security.SecurityException> がスローされることもあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1125">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="8f325-1126">動的 <xref:System.Reflection.Assembly>を定義するときに、完全に信頼されている呼び出し元だけが `evidence` を提供できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1126">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="8f325-1127">ランタイムは、セキュリティポリシーを使用して <xref:System.Security.Policy.Evidence> をマップし、付与されたアクセス許可を決定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1127">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="8f325-1128">部分的に信頼された呼び出し元は、null `evidence`を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1128">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="8f325-1129">`evidence` が `null`場合、ランタイムは、呼び出し元の <xref:System.Reflection.Assembly> から定義されている動的 <xref:System.Reflection.Assembly> にアクセス許可セット (現在の許可セットと拒否セット) をコピーし、ポリシーを解決済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1129">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="8f325-1130">動的 <xref:System.Reflection.Assembly> がディスクに保存される場合、その後の読み込みは、<xref:System.Reflection.Assembly> が保存された場所に関連付けられたポリシーに基づいて付与されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1130">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="8f325-1131">このメソッドは、現在のアプリケーションドメインで動的アセンブリを定義する場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1131">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="8f325-1132">詳細については、「<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロード」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1132">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1133">次の例は、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドと <xref:System.AppDomain.AssemblyResolve> イベントを示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1133">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="8f325-1134">このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1134">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="8f325-1135">完全修飾アセンブリ名を取得する方法については、「[アセンブリ名](~/docs/standard/assembly/names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1135">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1136"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1136"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-1137"><see langword="Name" /> の <paramref name="name" /> プロパティが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1137">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-1138">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1138">-or-</span></span> 
<span data-ttu-id="8f325-1139"><see langword="Name" /> の <paramref name="name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1139">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1140">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1140">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, evidence As Evidence, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet, isSynchronized As Boolean) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" FrameworkAlternate="xamarinandroid-7.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-1141">動的アセンブリの一意の ID。</span><span class="sxs-lookup"><span data-stu-id="8f325-1141">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="8f325-1142">動的アセンブリにアクセスするときのモード。</span><span class="sxs-lookup"><span data-stu-id="8f325-1142">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="8f325-1143">動的アセンブリを保存するディレクトリの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-1143">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="8f325-1144"><paramref name="dir" /> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1144">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="8f325-1145">動的アセンブリに指定する証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-1145">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="8f325-1146">証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1146">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="8f325-1147">必須のアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1147">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="8f325-1148">オプションのアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1148">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="8f325-1149">拒否されたアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1149">The refused permissions request.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="8f325-1150">動的アセンブリ内のモジュール、型、およびメンバーの作成を同期する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-1150"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="8f325-1151">名前、アクセス モード、ストレージ ディレクトリ、証拠、アクセス許可要求、および同期オプションを指定して、動的アセンブリを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1151">Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, permission requests, and synchronization option.</span></span></summary>
        <returns><span data-ttu-id="8f325-1152">名前と機能が指定された動的アセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1152">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1153">`requiredPermissions`、`optionalPermissions`、および `refusedPermissions` に指定されたアクセス許可要求は、`evidence` も指定されている場合、または動的アセンブリが保存されてメモリに再読み込みされる場合にのみ使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1153">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1154">動的アセンブリを出力するコードの開発中は、`refusedPermissions`に <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> を含めることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1154">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="8f325-1155">`refusedPermissions` パラメーターに <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> を含めると、MSIL が確実に検証されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1155">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="8f325-1156">この手法の制限として、完全信頼を要求するコードと共に使用すると <xref:System.Security.SecurityException> がスローされることもあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1156">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="8f325-1157">動的 <xref:System.Reflection.Assembly>を定義するときに証拠を提供できるのは、完全に信頼された呼び出し元だけです。</span><span class="sxs-lookup"><span data-stu-id="8f325-1157">Only fully trusted callers can supply their evidence when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="8f325-1158">ランタイムは、セキュリティポリシーを使用して <xref:System.Security.Policy.Evidence> をマップし、付与されたアクセス許可を決定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1158">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="8f325-1159">部分的に信頼された呼び出し元は、`evidence` パラメーターに `null` を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1159">Partially trusted callers must supply `null` for the `evidence` parameter.</span></span> <span data-ttu-id="8f325-1160">`evidence` が `null`場合、ランタイムは、呼び出し元の <xref:System.Reflection.Assembly> から定義されている動的 <xref:System.Reflection.Assembly> にアクセス許可セット (現在の許可セットと拒否セット) をコピーし、ポリシーを解決済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1160">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="8f325-1161">動的 <xref:System.Reflection.Assembly> がディスクに保存される場合、その後の読み込みは、<xref:System.Reflection.Assembly> が保存された場所に関連付けられたポリシーに基づいて付与されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1161">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="8f325-1162">`isSynchronized` が `true`場合、結果として得られる <xref:System.Reflection.Emit.AssemblyBuilder> の次のメソッドが同期されます (<xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>)。</span><span class="sxs-lookup"><span data-stu-id="8f325-1162">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="8f325-1163">これらの2つのメソッドが異なるスレッドで呼び出されると、他のスレッドが完了するまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1163">If two of these methods are called on different threads, one will block until the other completes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1164">次の例は、<xref:System.AppDomain.DefineDynamicAssembly%2A> メソッドと <xref:System.AppDomain.AssemblyResolve> イベントを示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1164">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="8f325-1165">このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1165">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="8f325-1166">完全修飾アセンブリ名を取得する方法については、「[アセンブリ名](~/docs/standard/assembly/names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1166">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1167"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1167"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-1168"><see langword="Name" /> の <paramref name="name" /> プロパティが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1168">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-1169">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1169">-or-</span></span> 
<span data-ttu-id="8f325-1170"><see langword="Name" /> の <paramref name="name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1170">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1171">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1171">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, evidence As Evidence, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="7" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="8" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-1172">動的アセンブリの一意の ID。</span><span class="sxs-lookup"><span data-stu-id="8f325-1172">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="8f325-1173">動的アセンブリにアクセスするときのモード。</span><span class="sxs-lookup"><span data-stu-id="8f325-1173">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="8f325-1174">動的アセンブリを保存するディレクトリの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-1174">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="8f325-1175"><paramref name="dir" /> が <see langword="null" /> の場合、現在のディレクトリが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1175">If <paramref name="dir" /> is <see langword="null" />, the current directory is used.</span></span></param>
        <param name="evidence"><span data-ttu-id="8f325-1176">動的アセンブリに指定する証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-1176">The evidence that is supplied for the dynamic assembly.</span></span> <span data-ttu-id="8f325-1177">証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1177">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="8f325-1178">必須のアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1178">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="8f325-1179">オプションのアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1179">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="8f325-1180">拒否されたアクセス許可要求。</span><span class="sxs-lookup"><span data-stu-id="8f325-1180">The refused permissions request.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="8f325-1181">動的アセンブリ内のモジュール、型、およびメンバーの作成を同期する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-1181"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="8f325-1182">アセンブリに適用される属性を列挙した一覧。属性がない場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-1182">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="8f325-1183">名前、アクセス モード、ストレージ ディレクトリ、証拠、アクセス許可要求、同期オプション、およびカスタム属性を指定して、動的アセンブリを定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1183">Defines a dynamic assembly with the specified name, access mode, storage directory, evidence, permission requests, synchronization option, and custom attributes.</span></span></summary>
        <returns><span data-ttu-id="8f325-1184">名前と機能が指定された動的アセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1184">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1185">動的アセンブリの作成時に適用されない場合、正しく機能しない属性を指定するには、このメソッドオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1185">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="8f325-1186">たとえば、動的アセンブリの作成後に追加された場合、<xref:System.Security.SecurityTransparentAttribute> や <xref:System.Security.SecurityCriticalAttribute> などのセキュリティ属性は正しく機能しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1186">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="8f325-1187">`requiredPermissions`、`optionalPermissions`、および `refusedPermissions` パラメーターに指定されたアクセス許可要求は、`evidence` パラメーターも指定されている場合、または動的アセンブリが保存されてメモリに再読み込みされる場合にのみ使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1187">The permission requests specified for the `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` parameters are used only if the `evidence` parameter is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1188">動的アセンブリを出力するコードを開発する場合は、`refusedPermissions` パラメーターに <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> フラグを含めることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1188">When you develop code that emits dynamic assemblies, we recommend that you include the <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> flag in the `refusedPermissions` parameter.</span></span> <span data-ttu-id="8f325-1189">このフラグを含めると、Microsoft 中間言語 (MSIL) が確実に検証されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1189">The inclusion of this flag ensures that the Microsoft intermediate language (MSIL) will be verified.</span></span> <span data-ttu-id="8f325-1190">この手法では、検証不可能なコードの意図しない生成が検出され、それ以外の場合は検出が非常に困難になります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1190">This technique will detect the unintentional generation of unverifiable code, which otherwise is very difficult to detect.</span></span> <span data-ttu-id="8f325-1191">この手法の制限は、完全な信頼を要求するコードと共に使用する場合にも <xref:System.Security.SecurityException> がスローされることです。</span><span class="sxs-lookup"><span data-stu-id="8f325-1191">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when it is used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="8f325-1192">動的 <xref:System.Reflection.Assembly>を定義するときに証拠を提供できるのは、完全に信頼された呼び出し元だけです。</span><span class="sxs-lookup"><span data-stu-id="8f325-1192">Only fully trusted callers can supply evidence when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="8f325-1193">ランタイムは、セキュリティポリシーを使用して <xref:System.Security.Policy.Evidence> をマップし、付与されたアクセス許可を決定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1193">The runtime maps the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="8f325-1194">部分的に信頼された呼び出し元は、`evidence` パラメーターに `null` を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1194">Partially trusted callers must supply `null` for the `evidence` parameter.</span></span> <span data-ttu-id="8f325-1195">`evidence` が `null`場合、ランタイムは、呼び出し元のアセンブリから定義されている動的アセンブリにアクセス許可セット (つまり、現在の許可および拒否セット) をコピーし、ポリシーを解決済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1195">If `evidence` is `null`, the runtime copies the permission sets (that is, the current grant and deny sets) from the caller's assembly to the dynamic assembly that is being defined, and marks the policy as resolved.</span></span>  
  
 <span data-ttu-id="8f325-1196">動的アセンブリがディスクに保存される場合、その後の読み込みは、動的アセンブリが保存された場所に関連付けられているポリシーに基づいて付与されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1196">If the dynamic assembly is saved to disk, subsequent loads will get grants based on policies that are associated with the location where the dynamic assembly was saved.</span></span>  
  
 <span data-ttu-id="8f325-1197">`isSynchronized` が `true`場合、結果として得られる <xref:System.Reflection.Emit.AssemblyBuilder> の次のメソッドが同期されます (<xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>、<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>)。</span><span class="sxs-lookup"><span data-stu-id="8f325-1197">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="8f325-1198">これらの2つのメソッドが異なるスレッドで呼び出された場合は、もう一方のスレッドが完了するまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1198">If two of these methods are called on different threads, one will block until the other is completed.</span></span>  
  
 <span data-ttu-id="8f325-1199">このメソッドオーバーロードは、[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]で導入されました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1199">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1200"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1200"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-1201"><see langword="Name" /> の <paramref name="name" /> プロパティが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1201">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="8f325-1202">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1202">-or-</span></span> 
<span data-ttu-id="8f325-1203"><see langword="Name" /> の <paramref name="name" /> プロパティが空白で始まっているか、スラッシュまたは円記号が含まれています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1203">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1204">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1204">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate"><span data-ttu-id="8f325-1205">呼び出すメソッドを指定するデリゲート。</span><span class="sxs-lookup"><span data-stu-id="8f325-1205">A delegate that specifies a method to call.</span></span></param>
        <summary><span data-ttu-id="8f325-1206">指定したデリゲートで識別される、別のアプリケーション ドメイン内のコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1206">Executes the code in another application domain that is identified by the specified delegate.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1207">`callBackDelegate` では、値渡し、<xref:System.MarshalByRefObject>、または <xref:System.ContextBoundObject>を指定できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1207">`callBackDelegate` can specify a marshal-by-value, <xref:System.MarshalByRefObject>, or <xref:System.ContextBoundObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1208">次の例では、静的な <xref:System.AppDomain.DoCallBack%2A> メソッドを使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1208">The following sample demonstrates using a static <xref:System.AppDomain.DoCallBack%2A> method.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 <span data-ttu-id="8f325-1209">次の例では、<xref:System.AppDomain.DoCallBack%2A> メソッドを値で使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1209">The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by value.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 <span data-ttu-id="8f325-1210">次の例では、<xref:System.AppDomain.DoCallBack%2A> メソッドを参照渡しで使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1210">The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by reference.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1211"><paramref name="callBackDelegate" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1211"><paramref name="callBackDelegate" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1212">アプリケーション ドメインの初期化時にホストから提供されたドメイン マネージャーを取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1212">Gets the domain manager that was provided by the host when the application domain was initialized.</span></span></summary>
        <value><span data-ttu-id="8f325-1213">アプリケーション ドメインの初期化時にホストから提供されたドメイン マネージャーを表すオブジェクト。ドメイン マネージャーが提供されなかった場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-1213">An object that represents the domain manager provided by the host when the application domain was initialized, or <see langword="null" /> if no domain manager was provided.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1214">共通言語ランタイム (CLR) のアンマネージホストは、ドメインマネージャーを提供できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1214">An unmanaged host of the common language runtime (CLR) can provide a domain manager.</span></span> <span data-ttu-id="8f325-1215">ドメインマネージャーは、新しいアプリケーションドメインの初期化に参加し、アプリケーションドメインの操作に参加する他のマネージャー (<xref:System.Security.HostSecurityManager>など) を提供できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1215">The domain manager can participate in initializing the new application domain and supply other managers, such as a <xref:System.Security.HostSecurityManager>, that participate in the operations of the application domain.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DomainUnload;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1216"><see cref="T:System.AppDomain" /> をアンロードしようとすると発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1216">Occurs when an <see cref="T:System.AppDomain" /> is about to be unloaded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1217">このイベントの <xref:System.EventHandler> デリゲートは、アプリケーションドメインがアンロードされる前に、すべての終了アクティビティを実行できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1217">The <xref:System.EventHandler> delegate for this event can perform any termination activities before the application domain is unloaded.</span></span>  
  
 <span data-ttu-id="8f325-1218">アンロード時に処理を実行する必要がある各アプリケーションドメインは、このイベントのイベントハンドラーを登録する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1218">Each application domain that needs to perform processing when it is unloaded should register an event handler for this event.</span></span> <span data-ttu-id="8f325-1219">共有イベントハンドラーを使用しないでください。 <xref:System.EventHandler> デリゲートは、アンロードされているドメインを識別しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1219">A shared event handler should not be used, because the <xref:System.EventHandler> delegate does not identify the domain that is being unloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1220">既定のアプリケーションドメインでは、このイベントは発生しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1220">This event is never raised in the default application domain.</span></span>  
  
 <span data-ttu-id="8f325-1221">イベントが発生したスレッドについては想定しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1221">Do not make assumptions about the thread the event is raised on.</span></span> <span data-ttu-id="8f325-1222">イベントは、<xref:System.AppDomain.Unload%2A> メソッドを呼び出したスレッドとは異なるスレッドで発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1222">The event can be raised on a different thread than the one that called the <xref:System.AppDomain.Unload%2A> method.</span></span>  
  
 <span data-ttu-id="8f325-1223">イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1223">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1224">動的に作成されたアセンブリを探すためにアセンブリ リゾルバーが使用するディレクトリを取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1224">Gets the directory that the assembly resolver uses to probe for dynamically created assemblies.</span></span></summary>
        <value><span data-ttu-id="8f325-1225">動的に作成されたアセンブリを探すためにアセンブリ リゾルバーが使用するディレクトリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1225">The directory that the assembly resolver uses to probe for dynamically created assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1226">動的ディレクトリを設定するには、新しいアプリケーションドメインの作成に使用される <xref:System.AppDomainSetup> オブジェクトの <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> プロパティに、ベースディレクトリパスを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1226">To set the dynamic directory, assign a base directory path to the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property of the <xref:System.AppDomainSetup> object that will be used to create the new application domain.</span></span> <span data-ttu-id="8f325-1227">プロパティに割り当てる基本ディレクトリのパスは、単純な名前が <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> プロパティに割り当てる文字列のハッシュコードであるサブディレクトリを追加することによって変更されます。したがって、基本ディレクトリの形式は、*ハッシュコード*\\の*元のパス*になります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1227">The base directory path you assign to the property is modified by the addition of a subdirectory whose simple name is the hash code of the string you assign to the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> property, so the format of the base directory is *original path*\\*hash code*.</span></span> <span data-ttu-id="8f325-1228">動的ディレクトリは、このベースディレクトリのサブディレクトリです。</span><span class="sxs-lookup"><span data-stu-id="8f325-1228">The dynamic directory is a subdirectory of this base directory.</span></span> <span data-ttu-id="8f325-1229">単純な名前は <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> プロパティの値であるため、その形式は\\*ハッシュコード*\\*アプリケーション名*の*元のパス*になります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1229">Its simple name is the value of the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> property, so its format is *original path*\\*hash code*\\*application name*.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1230">次の例では、動的アセンブリのディレクトリを使用してアプリケーションドメインを作成し、動的アセンブリを出力して、動的ディレクトリに格納します。その後、アセンブリを新しいアプリケーションドメインに読み込み、それを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1230">The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.</span></span>  
  
 <span data-ttu-id="8f325-1231">この例では、<xref:System.AppDomainSetup> オブジェクトを作成し、その <xref:System.AppDomainSetup.ApplicationName%2A> プロパティを "Example" に設定し、その <xref:System.AppDomainSetup.DynamicBase%2A> プロパティを "C:\ dynamicassemblydir" に設定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1231">The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to "Example" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to "C:\DynamicAssemblyDir".</span></span> <span data-ttu-id="8f325-1232">この例では、<xref:System.AppDomainSetup.DynamicBase%2A> プロパティを表示し、アプリケーション名のハッシュコードが、最初に割り当てられたパスのサブディレクトリとして追加されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1232">The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1233">この例の基本ディレクトリは、サンプルアプリケーションのプローブパスの外部にすることを目的としています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1233">The base directory in this example is intended to be outside the probing path for the example application.</span></span> <span data-ttu-id="8f325-1234">この例は、別の場所でコンパイルしてください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1234">Be sure to compile the example in a different location.</span></span> <span data-ttu-id="8f325-1235">この例を実行するたびに、ベースディレクトリとそのすべてのサブディレクトリが削除されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1235">Delete the base directory and all its subdirectories each time you run the example.</span></span>  
  
 <span data-ttu-id="8f325-1236">この例では、<xref:System.AppDomainSetup> オブジェクトを使用して、新しいアプリケーションドメインを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1236">The example creates a new application domain, using the <xref:System.AppDomainSetup> object.</span></span> <span data-ttu-id="8f325-1237">この例では、<xref:System.AppDomain.DynamicDirectory%2A> プロパティを使用してディレクトリの名前を取得し、ディレクトリを作成できるようにします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1237">The example uses the <xref:System.AppDomain.DynamicDirectory%2A> property to retrieve the name of the directory, so it can create the directory.</span></span> <span data-ttu-id="8f325-1238">(この例では、元のパス、アプリケーション名のハッシュコード、アプリケーション名を連結することで、ディレクトリを事前に簡単に作成できます)。</span><span class="sxs-lookup"><span data-stu-id="8f325-1238">(The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)</span></span>  
  
 <span data-ttu-id="8f325-1239">この例には、`DynamicHelloWorld.dll` という名前のアセンブリを出力し、新しいアプリケーションドメインの動的ディレクトリに格納する `GenerateDynamicAssembly` メソッドがあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1239">The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory.</span></span> <span data-ttu-id="8f325-1240">動的アセンブリには、`HelloWorld`という1つの型が含まれています。この型には `HelloFromAD`という名前の静的メソッド (Visual Basic で`Shared` メソッド) があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1240">The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`.</span></span> <span data-ttu-id="8f325-1241">このメソッドを呼び出すと、アプリケーションドメインの名前が表示されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1241">Calling this method displays the name of the application domain.</span></span>  
  
 <span data-ttu-id="8f325-1242">`Example` クラスは <xref:System.MarshalByRefObject>から派生するため、この例では、新しいアプリケーションドメインにクラスのインスタンスを作成し、その `Test` メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1242">The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method.</span></span> <span data-ttu-id="8f325-1243">`Test` メソッドは、表示名で動的アセンブリを読み込み、静的な `HelloFromAD` メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1243">The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.</span></span>  
  
 <span data-ttu-id="8f325-1244">`DynamicHelloWorld.dll` という名前のアセンブリのコードを記述し、この例と同じディレクトリでコンパイルすることによって、通常のプローブパスの後に動的ディレクトリを検索することを示すことができます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1244">You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example.</span></span> <span data-ttu-id="8f325-1245">アセンブリには、`HelloFromAD`という名前の静的メソッドを持つ `HelloWorld` という名前のクラスが必要です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1245">The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`.</span></span> <span data-ttu-id="8f325-1246">このメソッドの機能は、例のものと同じである必要はありません。単にコンソールに文字列を表示できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1246">This method does not have to have the same functionality as the one in the example; it can simply display a string to the console.</span></span> <span data-ttu-id="8f325-1247">アセンブリには、そのバージョンを1.0.0.0 に設定する <xref:System.Reflection.AssemblyVersionAttribute> 属性も必要です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1247">The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0.</span></span> <span data-ttu-id="8f325-1248">この例を実行すると、現在のディレクトリでコンパイルしたアセンブリが検索されてから、動的ディレクトリが検索されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1248">When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1249">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1249">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1250">このアプリケーション ドメインに関連付けられている <see cref="T:System.Security.Policy.Evidence" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1250">Gets the <see cref="T:System.Security.Policy.Evidence" /> associated with this application domain.</span></span></summary>
        <value><span data-ttu-id="8f325-1251">このアプリケーション ドメインに関連付けられた証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-1251">The evidence associated with this application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1252">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1252">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8f325-1253">指定したファイルに格納されているアセンブリを実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1253">Executes the assembly contained in the specified file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="8f325-1254">実行するアセンブリが格納されているファイルの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-1254">The name of the file that contains the assembly to execute.</span></span></param>
        <summary><span data-ttu-id="8f325-1255">指定したファイルに格納されているアセンブリを実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1255">Executes the assembly contained in the specified file.</span></span></summary>
        <returns><span data-ttu-id="8f325-1256">アセンブリのエントリ ポイントが返す値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1256">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1257">アセンブリは、.NET Framework ヘッダーで指定されたエントリポイントで実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1257">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="8f325-1258">このメソッドは、新しいプロセスまたはアプリケーションドメインを作成するのではなく、新しいスレッドでエントリポイントメソッドを実行しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1258">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="8f325-1259">このメソッドは、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1259">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="8f325-1260">また、<xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用してアセンブリを実行することもできます。このメソッドは、<xref:System.Reflection.Assembly.Load%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1260">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="8f325-1261">読み込みと実行の <xref:System.AppDomain> を作成するには、<xref:System.AppDomain.CreateDomain%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1261">To create the <xref:System.AppDomain> to load and execute, use the <xref:System.AppDomain.CreateDomain%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1262">次の例では、2つの異なるドメイン上の <xref:System.AppDomain.ExecuteAssembly%2A> のいずれかのオーバーロードを使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1262">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1263"><paramref name="assemblyFile" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1263"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1264"><paramref name="assemblyFile" /> が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1264"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1265"><paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1265"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1266">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1266">-or-</span></span> 
<span data-ttu-id="8f325-1267">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1267">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1268">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1268">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1269">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1269">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-1270">指定したアセンブリには、エントリ ポイントがありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1270">The specified assembly has no entry point.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="8f325-1271">実行するアセンブリが格納されているファイルの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-1271">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="8f325-1272">アセンブリを読み込むために必要な証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-1272">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="8f325-1273">指定したファイルに格納されているアセンブリを、指定した証拠を使用して実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1273">Executes the assembly contained in the specified file, using the specified evidence.</span></span></summary>
        <returns><span data-ttu-id="8f325-1274">アセンブリのエントリ ポイントが返す値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1274">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1275">アセンブリは、.NET Framework ヘッダーで指定されたエントリポイントで実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1275">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="8f325-1276"><xref:System.AppDomain.ExecuteAssembly%2A> メソッドでは、新しいプロセスまたはアプリケーションドメインは作成されず、新しいスレッドでエントリポイントメソッドは実行されません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1276">The <xref:System.AppDomain.ExecuteAssembly%2A> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="8f325-1277">このメソッドは、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1277">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="8f325-1278">また、<xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用してアセンブリを実行することもできます。このメソッドは、<xref:System.Reflection.Assembly.Load%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1278">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1279">次の例では、2つの異なるドメイン上の <xref:System.AppDomain.ExecuteAssembly%2A> のいずれかのオーバーロードを使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1279">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1280"><paramref name="assemblyFile" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1280"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1281"><paramref name="assemblyFile" /> が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1281"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1282"><paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1282"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1283">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1283">-or-</span></span> 
<span data-ttu-id="8f325-1284">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1284">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1285">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1285">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1286">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1286">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-1287">指定したアセンブリには、エントリ ポイントがありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1287">The specified assembly has no entry point.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="8f325-1288">実行するアセンブリが格納されているファイルの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-1288">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-1289">アセンブリのエントリ ポイントに渡す引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-1289">The arguments to the entry point of the assembly.</span></span></param>
        <summary><span data-ttu-id="8f325-1290">指定したファイルに格納されているアセンブリを、指定した引数を使用して実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1290">Executes the assembly contained in the specified file, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="8f325-1291">アセンブリのエントリ ポイントから返された値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1291">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1292">アセンブリは、.NET Framework ヘッダーで指定されたエントリポイントで実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1292">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="8f325-1293">このメソッドは、新しいプロセスまたはアプリケーションドメインを作成するのではなく、新しいスレッドでエントリポイントメソッドを実行しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1293">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="8f325-1294">このメソッドは、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1294">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="8f325-1295">また、<xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用してアセンブリを実行することもできます。このメソッドは、<xref:System.Reflection.Assembly.Load%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1295">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1296">次の例では、2つの異なるドメイン上の <xref:System.AppDomain.ExecuteAssembly%2A> のいずれかのオーバーロードを使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1296">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1297"><paramref name="assemblyFile" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1297"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1298"><paramref name="assemblyFile" /> が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1298"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1299"><paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1299"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1300">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1300">-or-</span></span> 
 <span data-ttu-id="8f325-1301">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyFile" /> がコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1301"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1302">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1302">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1303">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1303">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-1304">指定したアセンブリには、エントリ ポイントがありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1304">The specified assembly has no entry point.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="8f325-1305">実行するアセンブリが格納されているファイルの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-1305">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="8f325-1306">アセンブリに指定する証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-1306">The supplied evidence for the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-1307">アセンブリのエントリ ポイントに渡す引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-1307">The arguments to the entry point of the assembly.</span></span></param>
        <summary><span data-ttu-id="8f325-1308">指定したファイルに格納されているアセンブリを、指定した証拠と引数を使用して実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1308">Executes the assembly contained in the specified file, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="8f325-1309">アセンブリのエントリ ポイントが返す値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1309">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1310">アセンブリは、.NET Framework ヘッダーで指定されたエントリポイントで実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1310">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="8f325-1311">このメソッドは、新しいプロセスまたはアプリケーションドメインを作成するのではなく、新しいスレッドでエントリポイントメソッドを実行しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1311">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="8f325-1312">このメソッドは、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1312">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="8f325-1313">また、<xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用してアセンブリを実行することもできます。このメソッドは、<xref:System.Reflection.Assembly.Load%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1313">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1314">次の例では、2つの異なるドメイン上の <xref:System.AppDomain.ExecuteAssembly%2A> のいずれかのオーバーロードを使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1314">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1315"><paramref name="assemblyFile" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1315"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1316"><paramref name="assemblyFile" /> が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1316"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1317"><paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1317"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1318">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1318">-or-</span></span> 
<span data-ttu-id="8f325-1319">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1319">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1320">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1320">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1321">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1321">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-1322"><paramref name="assemblySecurity" /> が <see langword="null" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1322"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="8f325-1323">レガシ CAS ポリシーが有効でない場合は、<paramref name="assemblySecurity" /> を <see langword="null" /> にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1323">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-1324">指定したアセンブリには、エントリ ポイントがありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1324">The specified assembly has no entry point.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="8f325-1325">実行するアセンブリが格納されているファイルの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-1325">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-1326">アセンブリのエントリ ポイントに渡す引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-1326">The arguments to the entry point of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="8f325-1327">計算されたハッシュ コードの値を表します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1327">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="8f325-1328">アセンブリ マニフェストが使用するハッシュ アルゴリズムを表します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1328">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="8f325-1329">指定したファイルに格納されているアセンブリを、指定した引数、ハッシュ値、およびハッシュ アルゴリズムを使用して実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1329">Executes the assembly contained in the specified file, using the specified arguments, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="8f325-1330">アセンブリのエントリ ポイントから返された値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1330">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1331">アセンブリは、.NET Framework ヘッダーで指定されたエントリポイントで実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1331">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="8f325-1332">このメソッドは、新しいプロセスまたはアプリケーションドメインを作成するのではなく、新しいスレッドでエントリポイントメソッドを実行しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1332">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="8f325-1333">このメソッドは、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1333">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="8f325-1334">また、<xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用してアセンブリを実行することもできます。このメソッドは、<xref:System.Reflection.Assembly.Load%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1334">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1335">次の例では、2つの異なるドメイン上の <xref:System.AppDomain.ExecuteAssembly%2A> のいずれかのオーバーロードを使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1335">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1336"><paramref name="assemblyFile" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1336"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1337"><paramref name="assemblyFile" /> が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1337"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1338"><paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1338"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1339">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1339">-or-</span></span> 
 <span data-ttu-id="8f325-1340">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyFile" /> がコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1340"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1341">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1341">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1342">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1342">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-1343">指定したアセンブリには、エントリ ポイントがありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1343">The specified assembly has no entry point.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="8f325-1344">実行するアセンブリが格納されているファイルの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-1344">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="8f325-1345">アセンブリに指定する証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-1345">The supplied evidence for the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-1346">アセンブリのエントリ ポイントに渡す引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-1346">The arguments to the entry point of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="8f325-1347">計算されたハッシュ コードの値を表します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1347">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="8f325-1348">アセンブリ マニフェストが使用するハッシュ アルゴリズムを表します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1348">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="8f325-1349">指定したファイルに格納されているアセンブリを、指定した証拠、引数、ハッシュ値、およびハッシュ アルゴリズムを使用して実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1349">Executes the assembly contained in the specified file, using the specified evidence, arguments, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="8f325-1350">アセンブリのエントリ ポイントが返す値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1350">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1351">アセンブリは、.NET Framework ヘッダーで指定されたエントリポイントで実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1351">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="8f325-1352">このメソッドは、新しいプロセスまたはアプリケーションドメインを作成するのではなく、新しいスレッドでエントリポイントメソッドを実行しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1352">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="8f325-1353">このメソッドは、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1353">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="8f325-1354">また、<xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用してアセンブリを実行することもできます。このメソッドは、<xref:System.Reflection.Assembly.Load%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1354">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1355">次の例では、2つの異なるドメイン上の <xref:System.AppDomain.ExecuteAssembly%2A> のいずれかのオーバーロードを使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1355">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1356"><paramref name="assemblyFile" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1356"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1357"><paramref name="assemblyFile" /> が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1357"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1358"><paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1358"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1359">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1359">-or-</span></span> 
<span data-ttu-id="8f325-1360">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1360">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1361">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1361">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1362">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1362">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-1363"><paramref name="assemblySecurity" /> が <see langword="null" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1363"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="8f325-1364">レガシ CAS ポリシーが有効でない場合は、<paramref name="assemblySecurity" /> を <see langword="null" /> にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1364">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-1365">指定したアセンブリには、エントリ ポイントがありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1365">The specified assembly has no entry point.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8f325-1366">アセンブリを実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1366">Executes an assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-1367">アセンブリの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-1367">The display name of the assembly.</span></span> <span data-ttu-id="8f325-1368">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Reflection.Assembly.FullName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1368">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <summary><span data-ttu-id="8f325-1369">表示名を指定してアセンブリを実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1369">Executes an assembly given its display name.</span></span></summary>
        <returns><span data-ttu-id="8f325-1370">アセンブリのエントリ ポイントが返す値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1370">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1371"><xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドは、<xref:System.AppDomain.ExecuteAssembly%2A> メソッドと同様の機能を提供しますが、アセンブリをファイルの場所ではなく表示名または <xref:System.Reflection.AssemblyName> で指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1371">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="8f325-1372">そのため、<xref:System.AppDomain.ExecuteAssemblyByName%2A> は、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドではなく、<xref:System.Reflection.Assembly.Load%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1372">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="8f325-1373">アセンブリは、.NET Framework ヘッダーで指定されたエントリポイントで実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1373">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="8f325-1374">このメソッドは、新しいプロセスまたはアプリケーションドメインを作成するのではなく、新しいスレッドでエントリポイントメソッドを実行しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1374">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="8f325-1375">読み込みと実行の <xref:System.AppDomain> を作成するには、<xref:System.AppDomain.CreateDomain%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1375">To create the <xref:System.AppDomain> to load and execute, use the <xref:System.AppDomain.CreateDomain%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1376"><paramref name="assemblyName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1376"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1377"><paramref name="assemblyName" /> によって指定したアセンブリが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1377">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1378"><paramref name="assemblyName" /> によって指定したアセンブリは、有効なアセンブリではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1378">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1379">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1379">-or-</span></span> 
<span data-ttu-id="8f325-1380">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1380">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1381">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1381">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1382"><paramref name="assemblyName" /> によって指定したアセンブリが検出されましたが、読み込むことができません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1382">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-1383">指定したアセンブリには、エントリ ポイントがありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1383">The specified assembly has no entry point.</span></span></exception>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As AssemblyName, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-1384">アセンブリの名前を表す <see cref="T:System.Reflection.AssemblyName" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-1384">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-1385">プロセスを起動するときに渡すコマンド ライン引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-1385">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="8f325-1386"><see cref="T:System.Reflection.AssemblyName" /> を指定し、指定された引数を使用してアセンブリを実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1386">Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="8f325-1387">アセンブリのエントリ ポイントから返された値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1387">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1388"><xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドは、<xref:System.AppDomain.ExecuteAssembly%2A> メソッドと同様の機能を提供しますが、アセンブリをファイルの場所ではなく表示名または <xref:System.Reflection.AssemblyName> で指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1388">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="8f325-1389">そのため、<xref:System.AppDomain.ExecuteAssemblyByName%2A> は、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドではなく、<xref:System.Reflection.Assembly.Load%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1389">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="8f325-1390">アセンブリは、.NET Framework ヘッダーで指定されたエントリポイントで実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1390">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="8f325-1391">このメソッドは、新しいプロセスまたはアプリケーションドメインを作成するのではなく、新しいスレッドでエントリポイントメソッドを実行しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1391">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1392"><paramref name="assemblyName" /> によって指定したアセンブリが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1392">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1393"><paramref name="assemblyName" /> によって指定したアセンブリが検出されましたが、読み込むことができません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1393">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1394"><paramref name="assemblyName" /> によって指定したアセンブリは、有効なアセンブリではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1394">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1395">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1395">-or-</span></span> 
 <span data-ttu-id="8f325-1396">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyName" /> がコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1396"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1397">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1397">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-1398">指定したアセンブリには、エントリ ポイントがありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1398">The specified assembly has no entry point.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-1399">アセンブリの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-1399">The display name of the assembly.</span></span> <span data-ttu-id="8f325-1400">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Reflection.Assembly.FullName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1400">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="8f325-1401">アセンブリを読み込むために必要な証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-1401">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="8f325-1402">表示名を指定し、指定された証拠を使用してアセンブリを実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1402">Executes an assembly given its display name, using the specified evidence.</span></span></summary>
        <returns><span data-ttu-id="8f325-1403">アセンブリのエントリ ポイントが返す値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1403">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1404"><xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドは、<xref:System.AppDomain.ExecuteAssembly%2A> メソッドと同様の機能を提供しますが、アセンブリをファイルの場所ではなく表示名または <xref:System.Reflection.AssemblyName> で指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1404">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="8f325-1405">そのため、<xref:System.AppDomain.ExecuteAssemblyByName%2A> は、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドではなく、<xref:System.Reflection.Assembly.Load%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1405">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="8f325-1406">アセンブリは、.NET Framework ヘッダーで指定されたエントリポイントで実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1406">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="8f325-1407"><xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドでは、新しいプロセスまたはアプリケーションドメインは作成されず、新しいスレッドでエントリポイントメソッドは実行されません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1407">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1408"><xref:System.Security.Policy.Evidence> パラメーターを指定して <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用すると、証拠の一部がマージされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1408">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="8f325-1409"><xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドの引数として指定された証拠の部分は、ローダーによって提供される証拠の部分を置き換えます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1409">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1410"><paramref name="assemblyName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1410"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1411"><paramref name="assemblyName" /> によって指定したアセンブリが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1411">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1412"><paramref name="assemblyName" /> によって指定したアセンブリが検出されましたが、読み込むことができません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1412">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1413"><paramref name="assemblyName" /> によって指定したアセンブリは、有効なアセンブリではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1413">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1414">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1414">-or-</span></span> 
<span data-ttu-id="8f325-1415">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1415">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1416">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1416">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-1417">指定したアセンブリには、エントリ ポイントがありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1417">The specified assembly has no entry point.</span></span></exception>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-1418">アセンブリの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-1418">The display name of the assembly.</span></span> <span data-ttu-id="8f325-1419">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Reflection.Assembly.FullName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1419">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-1420">プロセスを起動するときに渡すコマンド ライン引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-1420">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="8f325-1421">表示名を指定し、指定された引数を使用してアセンブリを実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1421">Executes the assembly given its display name, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="8f325-1422">アセンブリのエントリ ポイントから返された値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1422">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1423"><xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドは、<xref:System.AppDomain.ExecuteAssembly%2A> メソッドと同様の機能を提供しますが、アセンブリをファイルの場所ではなく表示名または <xref:System.Reflection.AssemblyName> で指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1423">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="8f325-1424">そのため、<xref:System.AppDomain.ExecuteAssemblyByName%2A> は、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドではなく、<xref:System.Reflection.Assembly.Load%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1424">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="8f325-1425">アセンブリは、.NET Framework ヘッダーで指定されたエントリポイントで実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1425">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="8f325-1426">このメソッドは、新しいプロセスまたはアプリケーションドメインを作成するのではなく、新しいスレッドでエントリポイントメソッドを実行しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1426">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1427"><paramref name="assemblyName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1427"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1428"><paramref name="assemblyName" /> によって指定したアセンブリが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1428">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1429"><paramref name="assemblyName" /> によって指定したアセンブリが検出されましたが、読み込むことができません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1429">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1430"><paramref name="assemblyName" /> によって指定したアセンブリは、有効なアセンブリではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1430">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1431">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1431">-or-</span></span> 
 <span data-ttu-id="8f325-1432">現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyName" /> がコンパイルされました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1432"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1433">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1433">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-1434">指定したアセンブリには、エントリ ポイントがありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1434">The specified assembly has no entry point.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As AssemblyName, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-1435">アセンブリの名前を表す <see cref="T:System.Reflection.AssemblyName" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-1435">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="8f325-1436">アセンブリを読み込むために必要な証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-1436">Evidence for loading the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-1437">プロセスを起動するときに渡すコマンド ライン引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-1437">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="8f325-1438"><see cref="T:System.Reflection.AssemblyName" /> を指定し、指定された証拠および引数を使用してアセンブリを実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1438">Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="8f325-1439">アセンブリのエントリ ポイントが返す値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1439">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1440"><xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドは、<xref:System.AppDomain.ExecuteAssembly%2A> メソッドと同様の機能を提供しますが、アセンブリをファイルの場所ではなく表示名または <xref:System.Reflection.AssemblyName> で指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1440">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="8f325-1441">そのため、<xref:System.AppDomain.ExecuteAssemblyByName%2A> は、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドではなく、<xref:System.Reflection.Assembly.Load%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1441">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="8f325-1442">アセンブリは、.NET Framework ヘッダーで指定されたエントリポイントで実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1442">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="8f325-1443">このメソッドは、新しいプロセスまたはアプリケーションドメインを作成するのではなく、新しいスレッドでエントリポイントメソッドを実行しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1443">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1444"><xref:System.Security.Policy.Evidence> パラメーターを指定して <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用すると、証拠の一部がマージされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1444">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="8f325-1445"><xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドの引数として指定された証拠の部分は、ローダーによって提供される証拠の部分を置き換えます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1445">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1446"><paramref name="assemblyName" /> によって指定したアセンブリが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1446">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1447"><paramref name="assemblyName" /> によって指定したアセンブリが検出されましたが、読み込むことができません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1447">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1448"><paramref name="assemblyName" /> によって指定したアセンブリは、有効なアセンブリではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1448">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1449">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1449">-or-</span></span> 
<span data-ttu-id="8f325-1450">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1450">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1451">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1451">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-1452"><paramref name="assemblySecurity" /> が <see langword="null" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1452"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="8f325-1453">レガシ CAS ポリシーが有効でない場合は、<paramref name="assemblySecurity" /> を <see langword="null" /> にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1453">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-1454">指定したアセンブリには、エントリ ポイントがありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1454">The specified assembly has no entry point.</span></span></exception>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="8f325-1455">アセンブリの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-1455">The display name of the assembly.</span></span> <span data-ttu-id="8f325-1456">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Reflection.Assembly.FullName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1456">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="8f325-1457">アセンブリを読み込むために必要な証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-1457">Evidence for loading the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="8f325-1458">プロセスを起動するときに渡すコマンド ライン引数。</span><span class="sxs-lookup"><span data-stu-id="8f325-1458">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="8f325-1459">表示名を指定し、指定された証拠および引数を使用してアセンブリを実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1459">Executes the assembly given its display name, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="8f325-1460">アセンブリのエントリ ポイントが返す値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1460">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1461"><xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドは、<xref:System.AppDomain.ExecuteAssembly%2A> メソッドと同様の機能を提供しますが、アセンブリをファイルの場所ではなく表示名または <xref:System.Reflection.AssemblyName> で指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1461">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="8f325-1462">そのため、<xref:System.AppDomain.ExecuteAssemblyByName%2A> は、<xref:System.Reflection.Assembly.LoadFile%2A> メソッドではなく、<xref:System.Reflection.Assembly.Load%2A> メソッドを使用してアセンブリを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1462">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="8f325-1463">アセンブリは、.NET Framework ヘッダーで指定されたエントリポイントで実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1463">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="8f325-1464">このメソッドは、新しいプロセスまたはアプリケーションドメインを作成するのではなく、新しいスレッドでエントリポイントメソッドを実行しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1464">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1465"><xref:System.Security.Policy.Evidence> パラメーターを指定して <xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドを使用すると、証拠の一部がマージされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1465">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="8f325-1466"><xref:System.AppDomain.ExecuteAssemblyByName%2A> メソッドの引数として指定された証拠の部分は、ローダーによって提供される証拠の部分を置き換えます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1466">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1467"><paramref name="assemblyName" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1467"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1468"><paramref name="assemblyName" /> によって指定したアセンブリが見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1468">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1469"><paramref name="assemblyName" /> によって指定したアセンブリが検出されましたが、読み込むことができません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1469">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1470"><paramref name="assemblyName" /> によって指定したアセンブリは、有効なアセンブリではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1470">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1471">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1471">-or-</span></span> 
<span data-ttu-id="8f325-1472">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyName" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1472">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1473">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1473">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-1474"><paramref name="assemblySecurity" /> が <see langword="null" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1474"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="8f325-1475">レガシ CAS ポリシーが有効でない場合は、<paramref name="assemblySecurity" /> を <see langword="null" /> にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1475">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="8f325-1476">指定したアセンブリには、エントリ ポイントがありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1476">The specified assembly has no entry point.</span></span></exception>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1477">アプリケーション ドメイン内の例外ハンドラーに対する呼び出し履歴をランタイムが検索する前に、マネージド コード内で例外がスローされた場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1477">Occurs when an exception is thrown in managed code, before the runtime searches the call stack for an exception handler in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1478">このイベントは単なる通知です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1478">This event is only a notification.</span></span> <span data-ttu-id="8f325-1479">このイベントを処理しても、例外は処理されず、それ以降の例外処理にも影響しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1479">Handling this event does not handle the exception or affect subsequent exception handling in any way.</span></span> <span data-ttu-id="8f325-1480">イベントが発生し、イベントハンドラーが呼び出されると、共通言語ランタイム (CLR) は例外のハンドラーの検索を開始します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1480">After the event has been raised and event handlers have been invoked, the common language runtime (CLR) begins to search for a handler for the exception.</span></span> <span data-ttu-id="8f325-1481"><xref:System.AppDomain.FirstChanceException> は、アプリケーションドメインにマネージ例外を最初に確認する機会を提供します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1481"><xref:System.AppDomain.FirstChanceException> provides the application domain with a first chance to examine any managed exception.</span></span>  
  
 <span data-ttu-id="8f325-1482">イベントは、アプリケーションドメインごとに処理できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1482">The event can be handled per application domain.</span></span> <span data-ttu-id="8f325-1483">呼び出しの実行中にスレッドが複数のアプリケーションドメインを通過する場合、イベントは、イベントハンドラーを登録した各アプリケーションドメインで発生し、CLR がそのアプリケーションドメインで一致する例外ハンドラーの検索を開始します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1483">If a thread passes through multiple application domains while executing a call, the event is raised in each application domain that has registered an event handler, before the CLR begins searching for a matching exception handler in that application domain.</span></span> <span data-ttu-id="8f325-1484">イベントが処理された後、そのアプリケーションドメイン内の一致する例外ハンドラーに対して検索が実行されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1484">After the event has been handled, a search is made for a matching exception handler in that application domain.</span></span> <span data-ttu-id="8f325-1485">見つからない場合は、次のアプリケーションドメインでイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1485">If none is found, the event is raised in the next application domain.</span></span>  
  
 <span data-ttu-id="8f325-1486"><xref:System.AppDomain.FirstChanceException> イベントのイベントハンドラーで発生したすべての例外を処理する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1486">You must handle all exceptions that occur in the event handler for the <xref:System.AppDomain.FirstChanceException> event.</span></span> <span data-ttu-id="8f325-1487">それ以外の場合、<xref:System.AppDomain.FirstChanceException> は再帰的に発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1487">Otherwise, <xref:System.AppDomain.FirstChanceException> is raised recursively.</span></span> <span data-ttu-id="8f325-1488">これにより、スタックオーバーフローとアプリケーションの終了が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1488">This could result in a stack overflow and termination of the application.</span></span> <span data-ttu-id="8f325-1489">このイベントのイベントハンドラーは、制約された実行領域 (Cer) として実装することをお勧めします。例外通知が発生している間に、メモリ不足やスタックオーバーフローなどのインフラストラクチャ関連の例外が仮想マシンに影響を与えるのを防ぐためです。処理中です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1489">We recommend that you implement event handlers for this event as constrained execution regions (CERs), to keep infrastructure-related exceptions such as out-of-memory or stack overflow from affecting the virtual machine while the exception notification is being processed.</span></span>  
  
 <span data-ttu-id="8f325-1490">このイベントは、イベントハンドラーがセキュリティクリティカルで、<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> 属性を持っている場合を除き、アクセス違反などのプロセス状態の破損を示す例外に対しては発生しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1490">This event is not raised for exceptions that indicate corruption of process state, such as access violations, unless the event handler is security-critical and has the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute.</span></span>  
  
 <span data-ttu-id="8f325-1491">共通言語ランタイムは、この通知イベントが処理されている間、スレッドの中止を中断します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1491">The common language runtime suspends thread aborts while this notification event is being handled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1492">次の例では、`AD3`を通じて `AD0` という名前の一連のアプリケーションドメインを作成し、各アプリケーションドメインに `Worker` オブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1492">The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain.</span></span> <span data-ttu-id="8f325-1493">各 `Worker` オブジェクトには、最後のアプリケーションドメインの `Worker` を除き、次のアプリケーションドメインの `Worker` オブジェクトへの参照があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1493">Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain.</span></span> <span data-ttu-id="8f325-1494"><xref:System.AppDomain.FirstChanceException> イベントは、`AD1`を除くすべてのアプリケーションドメインで処理されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1494">The <xref:System.AppDomain.FirstChanceException> event is handled in all application domains except `AD1`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1495">この例では、複数のアプリケーションドメインでの初回例外通知を示していますが、単純なユースケースについては、 [「方法: 初回例外通知を受け取る](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1495">In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).</span></span>  
  
 <span data-ttu-id="8f325-1496">アプリケーションドメインが作成されると、既定のアプリケーションドメインは、最初のアプリケーションドメインの `TestException` メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1496">When the application domains have been created, the default application domain calls the `TestException` method for the first application domain.</span></span> <span data-ttu-id="8f325-1497">各 `Worker` オブジェクトは、最後の `Worker` が処理または処理されない例外をスローするまで、次のアプリケーションドメインの `TestException` メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1497">Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled.</span></span> <span data-ttu-id="8f325-1498">したがって、現在のスレッドはすべてのアプリケーションドメインを通過し、`TestException` が各アプリケーションドメインのスタックに追加されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1498">Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.</span></span>  
  
 <span data-ttu-id="8f325-1499">最後の `Worker` オブジェクトが例外を処理するとき、<xref:System.AppDomain.FirstChanceException> イベントは最後のアプリケーションドメインでのみ発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1499">When the last `Worker` object handles the exception, the <xref:System.AppDomain.FirstChanceException> event is raised only in the last application domain.</span></span> <span data-ttu-id="8f325-1500">他のアプリケーションドメインは例外を処理する機会を得られないため、イベントは発生しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1500">The other application domains never get a chance to handle the exception, so the event is not raised.</span></span>  
  
 <span data-ttu-id="8f325-1501">最後の `Worker` オブジェクトが例外を処理しない場合、イベントハンドラーを持つ各アプリケーションドメインで <xref:System.AppDomain.FirstChanceException> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1501">When the last `Worker` object does not handle the exception, the <xref:System.AppDomain.FirstChanceException> event is raised in each application domain that has an event handler.</span></span> <span data-ttu-id="8f325-1502">各イベントハンドラーが完了すると、既定のアプリケーションドメインによって例外がキャッチされるまで、スタックは引き続きアンワインドされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1502">After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1503">イベントが発生したときにスタックの表示がどのように拡大し、既定のアプリケーションドメインの近くにあるかを確認するには、`e.Exception.Message` を `FirstChanceHandler` イベントハンドラーの `e.Exception` に変更します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1503">To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers.</span></span> <span data-ttu-id="8f325-1504">`TestException` がアプリケーションドメインの境界を越えて呼び出されると、2回表示されることに注意してください。1回はプロキシ用、もう1回はスタブ用です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1504">Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.</span></span>  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
        <related type="Article" href="https://msdn.microsoft.com/library/66f002b8-a97d-4a6e-a503-2cec01689113"><span data-ttu-id="8f325-1505">方法: 初回例外通知を受け取る</span><span class="sxs-lookup"><span data-stu-id="8f325-1505">How to: Receive First-Chance Exception Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1506">アプリケーション ドメインの表示名を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1506">Gets the friendly name of this application domain.</span></span></summary>
        <value><span data-ttu-id="8f325-1507">アプリケーション ドメインの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-1507">The friendly name of this application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1508">既定のアプリケーションドメインのフレンドリ名は、プロセスの実行可能ファイルの名前です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1508">The friendly name of the default application domain is the file name of the process executable.</span></span> <span data-ttu-id="8f325-1509">たとえば、プロセスの開始に使用した実行可能ファイルが `"c:\MyAppDirectory\MyAssembly.exe"`場合、既定のアプリケーションドメインの表示名は `"MyAssembly.exe"`ます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1509">For example, if the executable used to start the process is `"c:\MyAppDirectory\MyAssembly.exe"`, the friendly name of the default application domain is `"MyAssembly.exe"`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1510">次のコード例では、<xref:System.AppDomain.FriendlyName%2A> プロパティを使用して、現在のアプリケーションドメインのフレンドリ名を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1510">The following code example uses the <xref:System.AppDomain.FriendlyName%2A> property to get the friendly name of the current application domain.</span></span> <span data-ttu-id="8f325-1511">既定のアプリケーションドメインでは、フレンドリ名はアプリケーションの実行可能ファイルの名前です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1511">For the default application domain, the friendly name is the name of the application's executable file.</span></span> <span data-ttu-id="8f325-1512">このコード例では、アプリケーションドメインに関する追加情報も表示されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1512">The code example also displays additional information about the application domain.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1513">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1513">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] GetAssemblies() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f325-1514">アプリケーション ドメインの実行コンテキストに読み込まれているアセンブリを取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1514">Gets the assemblies that have been loaded into the execution context of this application domain.</span></span></summary>
        <returns><span data-ttu-id="8f325-1515">アプリケーション ドメイン内のアセンブリの配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-1515">An array of assemblies in this application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8f325-1516">次のコード例では、<xref:System.AppDomain.GetAssemblies%2A> メソッドを使用して、アプリケーションドメインに読み込まれているすべてのアセンブリの一覧を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1516">The following code example uses the <xref:System.AppDomain.GetAssemblies%2A> method to get a list of all assemblies that have been loaded into the application domain.</span></span> <span data-ttu-id="8f325-1517">次に、アセンブリがコンソールに表示されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1517">The assemblies are then displayed to the console.</span></span>  
  
 <span data-ttu-id="8f325-1518">このコード例を実行するには、`CustomLibrary.dll`という名前のアセンブリを作成するか、<xref:System.AppDomain.GetAssemblies%2A> メソッドに渡されるアセンブリ名を変更する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1518">To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the <xref:System.AppDomain.GetAssemblies%2A> method.</span></span>  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1519">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1519">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig pinvokeimpl (&quot;kernel32.dll&quot; as &quot;GetCurrentThreadId&quot; winapi)int32 GetCurrentThreadId() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f325-1520">現在のスレッドの識別子を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1520">Gets the current thread identifier.</span></span></summary>
        <returns><span data-ttu-id="8f325-1521">現在のスレッドの識別子を表す 32 ビット符号付き整数。</span><span class="sxs-lookup"><span data-stu-id="8f325-1521">A 32-bit signed integer that is the identifier of the current thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1522"><xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> プロパティを使用します。これは、.NET Framework がファイバー (つまり、軽量スレッド) をサポートする環境でホストされている場合でも安定しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1522">Use the <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property, which is stable even when the .NET Framework is hosted by an environment that supports fibers (that is, lightweight threads).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetData(string name) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetData(System::String ^ name);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.GetData : string -&gt; obj" Usage="appDomain.GetData name" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-1523">あらかじめ定義されたアプリケーション ドメイン プロパティの名前、または独自に定義したアプリケーション ドメイン プロパティの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-1523">The name of a predefined application domain property, or the name of an application domain property you have defined.</span></span></param>
        <summary><span data-ttu-id="8f325-1524">現在のアプリケーション ドメイン内に格納されている、指定した名前の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1524">Gets the value stored in the current application domain for the specified name.</span></span></summary>
        <returns><span data-ttu-id="8f325-1525"><paramref name="name" /> プロパティの値。プロパティが存在しない場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-1525">The value of the <paramref name="name" /> property, or <see langword="null" /> if the property does not exist.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1526">このメソッドを使用して、<xref:System.AppDomain>のこのインスタンスのプロパティを記述する、名前とデータのペアの内部キャッシュにあるエントリの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1526">Use this method to retrieve the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <xref:System.AppDomain>.</span></span> <span data-ttu-id="8f325-1527">キーと値のペアの名前と `name` の比較では、大文字と小文字が区別されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1527">Note that the comparison of `name` with the name of key-value pairs is case-sensitive.</span></span>  
  
 <span data-ttu-id="8f325-1528">キャッシュには、アプリケーションドメインの作成時に挿入される定義済みのシステムエントリが自動的に含まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1528">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="8f325-1529"><xref:System.AppDomain.GetData%2A> メソッド、または同等の <xref:System.AppDomainSetup> プロパティを使用して、値を調べることができます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1529">You can inspect their values with the <xref:System.AppDomain.GetData%2A> method, or the equivalent <xref:System.AppDomainSetup> properties.</span></span>  
  
 <span data-ttu-id="8f325-1530"><xref:System.AppDomain.SetData%2A> メソッドを使用して、独自のユーザー定義の名前とデータのペアを挿入または変更し、<xref:System.AppDomain.GetData%2A> メソッドを使用してその値を調べることができます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1530">You can insert or modify your own user defined name-data pairs with the <xref:System.AppDomain.SetData%2A> method and inspect their values with the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
 <span data-ttu-id="8f325-1531">次の表では、定義済みの各システムエントリとそれに対応する <xref:System.AppDomainSetup> プロパティの `name` について説明します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1531">The following table describes the `name` of each predefined system entry and its corresponding <xref:System.AppDomainSetup> property.</span></span>  
  
|<span data-ttu-id="8f325-1532">' Name ' の値</span><span class="sxs-lookup"><span data-stu-id="8f325-1532">Value of 'name'</span></span>|<span data-ttu-id="8f325-1533">プロパティ</span><span class="sxs-lookup"><span data-stu-id="8f325-1533">Property</span></span>|  
|---------------------|--------------|  
|<span data-ttu-id="8f325-1534">APPBASE</span><span class="sxs-lookup"><span data-stu-id="8f325-1534">"APPBASE"</span></span>|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="8f325-1535">"APP_CONFIG_FILE"</span><span class="sxs-lookup"><span data-stu-id="8f325-1535">"APP_CONFIG_FILE"</span></span>|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="8f325-1536">"APP_LAUNCH_URL"</span><span class="sxs-lookup"><span data-stu-id="8f325-1536">"APP_LAUNCH_URL"</span></span>|<span data-ttu-id="8f325-1537">(プロパティなし)</span><span class="sxs-lookup"><span data-stu-id="8f325-1537">(no property)</span></span><br /><br /> <span data-ttu-id="8f325-1538">"APP_LAUNCH_URL" は、ユーザーがリダイレクトの前に最初に要求した URL を表します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1538">"APP_LAUNCH_URL" represents the URL originally requested by the user, before any redirection.</span></span> <span data-ttu-id="8f325-1539">これは、Internet Explorer などのブラウザーを使用してアプリケーションが起動された場合にのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1539">It is available only when the application has been launched with a browser such as Internet Explorer.</span></span> <span data-ttu-id="8f325-1540">すべてのブラウザーがこの値を提供するわけではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1540">Not all browsers provide this value.</span></span>|  
|<span data-ttu-id="8f325-1541">"APP_NAME"</span><span class="sxs-lookup"><span data-stu-id="8f325-1541">"APP_NAME"</span></span>|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="8f325-1542">"BINPATH_PROBE_ONLY"</span><span class="sxs-lookup"><span data-stu-id="8f325-1542">"BINPATH_PROBE_ONLY"</span></span>|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="8f325-1543">"CACHE_BASE"</span><span class="sxs-lookup"><span data-stu-id="8f325-1543">"CACHE_BASE"</span></span>|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="8f325-1544">"CODE_DOWNLOAD_DISABLED"</span><span class="sxs-lookup"><span data-stu-id="8f325-1544">"CODE_DOWNLOAD_DISABLED"</span></span>|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="8f325-1545">"DEV_PATH"</span><span class="sxs-lookup"><span data-stu-id="8f325-1545">"DEV_PATH"</span></span>|<span data-ttu-id="8f325-1546">(プロパティなし)</span><span class="sxs-lookup"><span data-stu-id="8f325-1546">(no property)</span></span>|  
|<span data-ttu-id="8f325-1547">"DISALLOW_APP"</span><span class="sxs-lookup"><span data-stu-id="8f325-1547">"DISALLOW_APP"</span></span>|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="8f325-1548">"DISALLOW_APP_BASE_PROBING"</span><span class="sxs-lookup"><span data-stu-id="8f325-1548">"DISALLOW_APP_BASE_PROBING"</span></span>|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="8f325-1549">"DISALLOW_APP_REDIRECTS"</span><span class="sxs-lookup"><span data-stu-id="8f325-1549">"DISALLOW_APP_REDIRECTS"</span></span>|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="8f325-1550">"DYNAMIC_BASE"</span><span class="sxs-lookup"><span data-stu-id="8f325-1550">"DYNAMIC_BASE"</span></span>|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="8f325-1551">"FORCE_CACHE_INSTALL"</span><span class="sxs-lookup"><span data-stu-id="8f325-1551">"FORCE_CACHE_INSTALL"</span></span>|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="8f325-1552">"LICENSE_FILE"、またはアプリケーション固有の文字列</span><span class="sxs-lookup"><span data-stu-id="8f325-1552">"LICENSE_FILE", or an application-specific string</span></span>|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="8f325-1553">"LOADER_OPTIMIZATION"</span><span class="sxs-lookup"><span data-stu-id="8f325-1553">"LOADER_OPTIMIZATION"</span></span>|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="8f325-1554">"LOCATION_URI"</span><span class="sxs-lookup"><span data-stu-id="8f325-1554">"LOCATION_URI"</span></span>|<span data-ttu-id="8f325-1555">(プロパティなし)</span><span class="sxs-lookup"><span data-stu-id="8f325-1555">(no property)</span></span>|  
|<span data-ttu-id="8f325-1556">"PRIVATE_BINPATH"</span><span class="sxs-lookup"><span data-stu-id="8f325-1556">"PRIVATE_BINPATH"</span></span>|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="8f325-1557">"REGEX_DEFAULT_MATCH_TIMEOUT"</span><span class="sxs-lookup"><span data-stu-id="8f325-1557">"REGEX_DEFAULT_MATCH_TIMEOUT"</span></span>|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> <span data-ttu-id="8f325-1558">"REGEX_DEFAULT_MATCH_TIMEOUT" はシステムエントリではなく、<xref:System.AppDomain.SetData%2A> メソッドを呼び出すことによって値を設定できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1558">"REGEX_DEFAULT_MATCH_TIMEOUT" is not a system entry, and its value can be set by calling the <xref:System.AppDomain.SetData%2A> method.</span></span>|  
|<span data-ttu-id="8f325-1559">"SHADOW_COPY_DIRS"</span><span class="sxs-lookup"><span data-stu-id="8f325-1559">"SHADOW_COPY_DIRS"</span></span>|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1560">次の例では、新しいアプリケーションドメインを作成し、ドメインにシステム指定の値を設定して、ドメインの新しい値のペアを追加します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1560">The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain.</span></span> <span data-ttu-id="8f325-1561">この例では、<xref:System.AppDomain.GetData%2A> メソッドを使用して、これらの値のペアからデータを取得し、コンソールに表示する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1561">The example then demonstrates how to use the <xref:System.AppDomain.GetData%2A> method to retrieve the data from these value pairs and display them to the console.</span></span>  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1562"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1562"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1563">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1563">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" FrameworkAlternate="netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" FrameworkAlternate="netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f325-1564">現在のインスタンスの型を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1564">Gets the type of the current instance.</span></span></summary>
        <returns><span data-ttu-id="8f325-1565">現在のインスタンスの型。</span><span class="sxs-lookup"><span data-stu-id="8f325-1565">The type of the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1566">プロセス内のアプリケーション ドメインを一意に識別する整数を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1566">Gets an integer that uniquely identifies the application domain within the process.</span></span></summary>
        <value><span data-ttu-id="8f325-1567">アプリケーション ドメインを識別する整数。</span><span class="sxs-lookup"><span data-stu-id="8f325-1567">An integer that identifies the application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8f325-1568">次のコード例では、2つ目のアプリケーションドメインを作成し、既定のドメインと新しいドメインに関する情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1568">The following code example creates a second application domain and displays information about the default domain and the new domain.</span></span>  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f325-1569">リースが作成されないようにすることで、<see cref="T:System.AppDomain" /> に無期限の有効期間を指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1569">Gives the <see cref="T:System.AppDomain" /> an infinite lifetime by preventing a lease from being created.</span></span></summary>
        <returns><span data-ttu-id="8f325-1570">常に <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1570">Always <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1571">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1571">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public bool? IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="8f325-1572">テストする互換性スイッチ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1572">The compatibility switch to test.</span></span></param>
        <summary><span data-ttu-id="8f325-1573">いずれかの互換性スイッチが設定されているかどうか、設定されている場合は指定の互換性スイッチが設定されているかどうかを示す、null 許容のブール値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1573">Gets a nullable Boolean value that indicates whether any compatibility switches are set, and if so, whether the specified compatibility switch is set.</span></span></summary>
        <returns><span data-ttu-id="8f325-1574">互換性スイッチが設定されていない場合は null 参照 (Visual Basic では <see langword="Nothing" />)。それ以外の場合は、<paramref name="value" /> で指定された互換性スイッチが設定されているかどうかを示すブール値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1574">A null reference (<see langword="Nothing" /> in Visual Basic) if no compatibility switches are set; otherwise, a Boolean value that indicates whether the compatibility switch that is specified by <paramref name="value" /> is set.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1575">このメソッドは、指定した互換性スイッチが現在のアプリケーションドメインに対して設定されているかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1575">This method tests whether the specified compatibility switch has been set for the current application domain.</span></span> <span data-ttu-id="8f325-1576">互換性スイッチは通常、.NET Framework のバージョン間で変更された動作 (文字列の並べ替え方法など) を復元します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1576">Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.</span></span>  <span data-ttu-id="8f325-1577">これらは、アプリケーションドメインを作成する前に <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> メソッドを呼び出すことによって設定されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1577">They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> method before creating an application domain.</span></span>  
  
 <span data-ttu-id="8f325-1578">次の表に、以前のバージョンの .NET Framework の動作を復元するために設定できる互換性スイッチの例を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1578">The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.</span></span>  
  
|<span data-ttu-id="8f325-1579">Switch</span><span class="sxs-lookup"><span data-stu-id="8f325-1579">Switch</span></span>|<span data-ttu-id="8f325-1580">意味</span><span class="sxs-lookup"><span data-stu-id="8f325-1580">Meaning</span></span>|  
|------------|-------------|  
|<span data-ttu-id="8f325-1581">"NetFx40_LegacySecurityPolicy"</span><span class="sxs-lookup"><span data-stu-id="8f325-1581">"NetFx40_LegacySecurityPolicy"</span></span>|<span data-ttu-id="8f325-1582">このアプリケーションドメインでは、[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] のコードアクセスセキュリティ (CAS) が有効になっています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1582">Code access security (CAS) for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span> <span data-ttu-id="8f325-1583">「 [&lt;NetFx40_LegacySecurityPolicy&gt; 要素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1583">See [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</span></span>|  
|<span data-ttu-id="8f325-1584">"NetFx40_Legacy20SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="8f325-1584">"NetFx40_Legacy20SortingBehavior"</span></span>|<span data-ttu-id="8f325-1585">このアプリケーションドメインで有効になっている [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] の文字列並べ替えの既定値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1585">String sorting defaults for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] are enabled in this application domain.</span></span> <span data-ttu-id="8f325-1586">成功した場合は、sort00001000.dll がインストールされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1586">Its success requires sort00001000.dll to be installed.</span></span> <span data-ttu-id="8f325-1587">「 [&lt;CompatSortNLSVersion&gt; 要素](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1587">See [&lt;CompatSortNLSVersion&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).</span></span>|  
|<span data-ttu-id="8f325-1588">"NetFx40_Legacy40SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="8f325-1588">"NetFx40_Legacy40SortingBehavior"</span></span>|<span data-ttu-id="8f325-1589">このアプリケーションドメインでは、[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]の文字列の並べ替えの既定値と Unicode 5.0 が有効になっています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1589">String sorting defaults for the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain.</span></span> <span data-ttu-id="8f325-1590">成功した場合は、sort00060101 がインストールされている必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1590">Its success requires sort00060101.dll to be installed.</span></span>|  
|<span data-ttu-id="8f325-1591">"NetFx40_TimeSpanLegacyFormatMode"</span><span class="sxs-lookup"><span data-stu-id="8f325-1591">"NetFx40_TimeSpanLegacyFormatMode"</span></span>|<span data-ttu-id="8f325-1592">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] の <xref:System.TimeSpan> の書式設定動作は、このアプリケーションドメインで有効になっています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1592"><xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span>  <span data-ttu-id="8f325-1593"><xref:System.TimeSpan> トピックの「 [&lt;TimeSpan_LegacyFormatMode&gt; 要素](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)」と「従来の TimeSpan 書式設定の復元」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1593">See [&lt;TimeSpan_LegacyFormatMode&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) and the "Restoring Legacy TimeSpan Formatting" section of the <xref:System.TimeSpan> topic.</span></span>|  
|<span data-ttu-id="8f325-1594">"UseRandomizedStringHashAlgorithm"</span><span class="sxs-lookup"><span data-stu-id="8f325-1594">"UseRandomizedStringHashAlgorithm"</span></span>|<span data-ttu-id="8f325-1595">ランタイムは、アプリケーションドメイン間で一貫性のあるハッシュコードを生成する単一のハッシュアルゴリズムを使用するのではなく、アプリケーションドメインごとに文字列のハッシュコードを計算します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1595">The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains.</span></span> <span data-ttu-id="8f325-1596">「 [&lt;UseRandomizedStringHashAlgorithm&gt; 要素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1596">See [&lt;UseRandomizedStringHashAlgorithm&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f325-1597">アプリケーション ドメインが、プロセスの既定のアプリケーション ドメインであるかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1597">Returns a value that indicates whether the application domain is the default application domain for the process.</span></span></summary>
        <returns><span data-ttu-id="8f325-1598">現在の <see langword="true" /> オブジェクトがプロセスの既定のアプリケーション ドメインを表す場合は <see cref="T:System.AppDomain" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-1598"><see langword="true" /> if the current <see cref="T:System.AppDomain" /> object represents the default application domain for the process; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1599">すべてのマネージプロセスには、既定のアプリケーションドメインがあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1599">Every managed process has a default application domain.</span></span> <span data-ttu-id="8f325-1600">既定のドメインで実行が開始されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1600">Execution begins in the default domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1601">次のコード例では、2つ目のアプリケーションドメインを作成し、既定のドメインと新しいドメインに関する情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1601">The following code example creates a second application domain and displays information about the default domain and the new domain.</span></span>  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f325-1602">このアプリケーション ドメインがアンロード中で、これに含まれるオブジェクトが共通言語ランタイムによって終了処理されているかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1602">Indicates whether this application domain is unloading, and the objects it contains are being finalized by the common language runtime.</span></span></summary>
        <returns><span data-ttu-id="8f325-1603">アプリケーション ドメインがアンロード中で、共通言語ランタイムがファイナライザーの呼び出しを既に開始している場合は <see langword="true" />。これ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-1603"><see langword="true" /> if this application domain is unloading and the common language runtime has started invoking finalizers; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1604">オブジェクトの終了メソッドを使用すると、オブジェクトがガベージコレクションされる前に必要なクリーンアップ操作を実行できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1604">The finalization method for an object provides you an opportunity to perform any necessary cleanup operations before the object is garbage collected.</span></span> <span data-ttu-id="8f325-1605">終了後、オブジェクトにはアクセスできますが、無効な状態のため、使用できません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1605">After finalization, the object is accessible but in an invalid state and therefore unusable.</span></span> <span data-ttu-id="8f325-1606">最終的には、ガベージコレクションが完了し、オブジェクトが解放されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1606">Eventually, garbage collection completes and reclaims the object.</span></span>  
  
 <span data-ttu-id="8f325-1607">オブジェクトの終了メソッドは、ガベージコレクション中、共通言語ランタイムがシャットダウンしているとき、またはオブジェクトを含むアプリケーションドメインがアンロードされたときに、次のいずれかの状況で呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1607">An object's finalization method is called in one of the following situations: during garbage collection, when the common language runtime is shutting down, or when the application domain that contains the object is unloaded.</span></span> <span data-ttu-id="8f325-1608"><xref:System.AppDomain.IsFinalizingForUnload%2A> メソッドは、最後の場合にのみ `true` を返します。ファイナライザーがルーチンのガベージコレクションまたは CLR のシャットダウンからの結果を返す場合、`true` は返しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1608">The <xref:System.AppDomain.IsFinalizingForUnload%2A> method returns `true` only in the last case; it does not return `true` if finalization results from routine garbage collection or from CLR shutdown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1609">ファイナライザーが CLR シャットダウンの原因であるかどうかを確認するには、<xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1609">To determine whether finalization is due to CLR shutdown, use the <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8f325-1610">アプリケーションドメインがアンロードされているか、または CLR がシャットダウンしていることがファイナライズの原因である場合は、`true` を返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1610">It returns `true` if finalization is due to an application domain being unloaded or to the CLR shutting down.</span></span>  
  
 <span data-ttu-id="8f325-1611">ドメインのアンロード中に終了メソッドでを実行しているときに、静的フィールドによって参照され、終了メソッドを持つ別のオブジェクトにアクセスすることが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1611">While executing in your finalization method during domain unloading, you might want to access another object that is referenced by a static field and has a finalization method.</span></span> <span data-ttu-id="8f325-1612">ただし、アクセスされたオブジェクトは既に完了している可能性があるため、確実にこれを行うことはできません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1612">However, you cannot reliably do so because the accessed object might already have been finalized.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1613">この規則の例外は <xref:System.Console> クラスです。このクラスには、ストリームオブジェクトを参照する静的フィールドが含まれていますが、ドメインのアンロードまたはシステムのシャットダウン中でも、常にシステムコンソールに書き込むことができるように特別に実装されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1613">An exception to this rule is the <xref:System.Console> class, which contains static fields that reference stream objects, but is implemented specially so you can always write to the system console, even during domain unloading or system shutdown.</span></span>  
  
 <span data-ttu-id="8f325-1614">オブジェクトの終了メソッドでこのメソッドを使用して、オブジェクトを含むアプリケーションドメインがアンロードされているかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1614">Use this method in an object's finalization method to determine whether the application domain that contains the object is unloading.</span></span> <span data-ttu-id="8f325-1615">その場合、終了メソッドを持ち、静的フィールドによって参照されているオブジェクトに確実にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1615">If that is the case, you cannot reliably access any object that has a finalization method and is referenced by a static field.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1616">現在のアプリケーション ドメインに読み込まれたアセンブリが、完全に信頼された状態で実行されるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1616">Gets a value that indicates whether assemblies that are loaded into the current application domain execute with full trust.</span></span></summary>
        <value><span data-ttu-id="8f325-1617">現在のアプリケーション ドメインに読み込まれたアセンブリが、完全に信頼された状態で実行される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-1617"><see langword="true" /> if assemblies that are loaded into the current application domain execute with full trust; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1618">このメソッドは、常に、デスクトップで実行されるアプリケーションの既定のアプリケーションドメインの `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1618">This method always returns `true` for the default application domain of an application that runs on the desktop.</span></span> <span data-ttu-id="8f325-1619">このメソッドは、アプリケーションドメインに付与されたアクセス許可が完全信頼と同等でない限り、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> メソッドオーバーロードを使用して作成されたサンドボックスアプリケーションドメインの `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1619">It returns `false` for a sandboxed application domain that was created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload, unless the permissions that are granted to the application domain are equivalent to full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1620">次の例は、<xref:System.AppDomain.IsFullyTrusted%2A> プロパティと、完全に信頼され、部分的に信頼されたアプリケーションドメインを持つ <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> プロパティを示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1620">The following example demonstrates the <xref:System.AppDomain.IsFullyTrusted%2A> property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> property with fully trusted and partially trusted application domains.</span></span> <span data-ttu-id="8f325-1621">完全に信頼されたアプリケーションドメインは、アプリケーションの既定のアプリケーションドメインです。</span><span class="sxs-lookup"><span data-stu-id="8f325-1621">The fully trusted application domain is the default application domain for the application.</span></span> <span data-ttu-id="8f325-1622">部分的に信頼されたアプリケーションドメインは、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> メソッドのオーバーロードを使用して作成されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1622">The partially trusted application domain is created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload.</span></span>  
  
 <span data-ttu-id="8f325-1623">この例では、<xref:System.MarshalByRefObject>から派生した `Worker` クラスを使用して、アプリケーションドメインの境界を越えてマーシャリングすることができます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1623">The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="8f325-1624">この例では、既定のアプリケーションドメインに `Worker` オブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1624">The example creates a `Worker` object in the default application domain.</span></span> <span data-ttu-id="8f325-1625">次に、`TestIsFullyTrusted` メソッドを呼び出して、アプリケーションドメインのプロパティ値と、アプリケーションドメインに読み込まれる2つのアセンブリ (.NET Framework の一部である mscorlib と、アセンブリの例) を表示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1625">It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly.</span></span> <span data-ttu-id="8f325-1626">アプリケーションドメインは完全に信頼されているため、両方のアセンブリが完全に信頼されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1626">The application domain is fully trusted, so both assemblies are fully trusted.</span></span>  
  
 <span data-ttu-id="8f325-1627">この例では、サンドボックス化されたアプリケーションドメインに別の `Worker` オブジェクトを作成し、もう一度 `TestIsFullyTrusted` メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1627">The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method.</span></span> <span data-ttu-id="8f325-1628">Mscorlib は、部分的に信頼されたアプリケーションドメインであっても、常に信頼されていますが、この例のアセンブリは部分的に信頼されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1628">Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.</span></span>  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1629">アプリケーション ドメインに読み込まれたすべてのアセンブリに付与されるアクセス許可セットが、現在のアプリケーション ドメインに存在するかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1629">Gets a value that indicates whether the current application domain has a set of permissions that is granted to all assemblies that are loaded into the application domain.</span></span></summary>
        <value><span data-ttu-id="8f325-1630">一貫して付与されるアクセス許可セットが現在のアプリケーション ドメインに存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-1630"><see langword="true" /> if the current application domain has a homogenous set of permissions; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1631">このプロパティは、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> メソッドオーバーロードを使用して作成されたサンドボックスアプリケーションドメインの `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1631">This property returns `true` for sandboxed application domains that were created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="8f325-1632">サンドボックス化されるアプリケーションドメインには、同種のアクセス許可セットがあります。つまり、アプリケーションドメインに読み込まれる部分的に信頼されているすべてのアセンブリに対して、同じアクセス許可のセットが付与されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1632">Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</span></span> <span data-ttu-id="8f325-1633">サンドボックス化されたアプリケーションドメインには、このアクセス許可セットから除外される厳密な名前付きアセンブリの一覧があり、代わりに完全信頼で実行されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1633">A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</span></span>  
  
 <span data-ttu-id="8f325-1634">完全に信頼されたコードでは、<xref:System.AppDomain.PermissionSet%2A> プロパティを使用して、サンドボックス化されたアプリケーションドメインの同種の許可セットを決定できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1634">Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.</span></span>  
  
 <span data-ttu-id="8f325-1635">このプロパティは、アプリケーションドメインがすべてのアセンブリに対して完全な信頼を付与するため、デスクトップアプリケーションの既定のアプリケーションドメインの `true` も返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1635">This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8f325-1636">現在のアプリケーション ドメインに <see cref="T:System.Reflection.Assembly" /> を読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1636">Loads an <see cref="T:System.Reflection.Assembly" /> into this application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="8f325-1637">生成されたアセンブリを含む COFF ベースのイメージである <see langword="byte" /> 型配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-1637">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="8f325-1638">生成された <see cref="T:System.Reflection.Assembly" /> を含む COFF (Common Object File Format) ベースのイメージを使用して、<see cref="T:System.Reflection.Assembly" /> を読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1638">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span></summary>
        <returns><span data-ttu-id="8f325-1639">読み込まれるアセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1639">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1640">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降、このメソッドを使用して読み込まれるアセンブリの信頼レベルは、アプリケーションドメインの信頼レベルと同じになります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1640">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="8f325-1641">このメソッドは、現在のアプリケーションドメインにアセンブリを読み込む場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1641">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="8f325-1642">このメソッドは、静的 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを呼び出すことができない、相互運用性を持つ呼び出し元の便宜的な手段として提供されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1642">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8f325-1643">アセンブリを他のアプリケーションドメインに読み込むには、<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>などのメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1643">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="8f325-1644">このメソッドのすべてのオーバーロードに共通の情報については、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロードに関する説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1644">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1645">次のサンプルは、未加工のアセンブリの読み込みの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1645">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="8f325-1646">このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1646">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="8f325-1647">完全修飾アセンブリ名を取得する方法については、「[アセンブリ名](~/docs/standard/assembly/names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1647">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1648"><paramref name="rawAssembly" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1648"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1649"><paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1649"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1650">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1650">-or-</span></span> 
<span data-ttu-id="8f325-1651">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="rawAssembly" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1651">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1652">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1652">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1653">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1653">An assembly or module was loaded twice with two different evidences.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="8f325-1654">読み込むアセンブリについて記述しているオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-1654">An object that describes the assembly to load.</span></span></param>
        <summary><span data-ttu-id="8f325-1655"><see cref="T:System.Reflection.Assembly" /> を指定して、<see cref="T:System.Reflection.AssemblyName" /> を読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1655">Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="8f325-1656">読み込まれるアセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1656">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1657">このメソッドは、現在のアプリケーションドメインにアセンブリを読み込む場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1657">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="8f325-1658">このメソッドは、静的 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを呼び出すことができない、相互運用性を持つ呼び出し元の便宜的な手段として提供されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1658">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8f325-1659">アセンブリを他のアプリケーションドメインに読み込むには、<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>などのメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1659">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="8f325-1660">要求されたアセンブリのバージョンが既に読み込まれている場合、このメソッドは、別のバージョンが要求された場合でも、読み込まれたアセンブリを返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1660">If a version of the requested assembly is already loaded, this method returns the loaded assembly, even if a different version is requested.</span></span>  
  
 <span data-ttu-id="8f325-1661">`assemblyRef` の部分的なアセンブリ名を指定することは推奨されません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1661">Supplying a partial assembly name for `assemblyRef` is not recommended.</span></span> <span data-ttu-id="8f325-1662">(部分名は、カルチャ、バージョン、または公開キートークンの1つ以上を省略します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1662">(A partial name omits one or more of culture, version, or public key token.</span></span> <span data-ttu-id="8f325-1663"><xref:System.Reflection.AssemblyName> オブジェクトではなく文字列を受け取るオーバーロードでは、"MyAssembly, Version = 1.0.0.0" という部分名の例として "myassembly, version = 1.0.0.0, Culture = ニュートラル, PublicKeyToken = 18ab344 2da84 b47" が完全名の例です)。名前の一部を使用すると、パフォーマンスに悪影響を及ぼします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1663">For overloads that take a string instead of an <xref:System.Reflection.AssemblyName> object, "MyAssembly, Version=1.0.0.0" is an example of a partial name and "MyAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=18ab3442da84b47" is an example of a full name.) Using partial names has a negative effect on performance.</span></span> <span data-ttu-id="8f325-1664">また、アセンブリの部分的な名前は、アプリケーションのベースディレクトリ (<xref:System.AppDomain.BaseDirectory%2A> または <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>) にアセンブリの正確なコピーが存在する場合にのみ、グローバルアセンブリキャッシュからアセンブリを読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1664">In addition, a partial assembly name can load an assembly from the global assembly cache only if there is an exact copy of the assembly in the application base directory (<xref:System.AppDomain.BaseDirectory%2A> or <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).</span></span>  
  
 <span data-ttu-id="8f325-1665">現在の <xref:System.AppDomain> オブジェクトがアプリケーションドメイン `A`を表し、<xref:System.AppDomain.Load%2A> メソッドがアプリケーションドメイン `B`から呼び出された場合、アセンブリは両方のアプリケーションドメインに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1665">If the current <xref:System.AppDomain> object represents application domain `A`, and the <xref:System.AppDomain.Load%2A> method is called from application domain `B`, the assembly is loaded into both application domains.</span></span> <span data-ttu-id="8f325-1666">たとえば、次のコードは、`MyAssembly` を新しいアプリケーションドメイン `ChildDomain` と、コードが実行されるアプリケーションドメインに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1666">For example, the following code loads `MyAssembly` into the new application domain `ChildDomain` and also into the application domain where the code executes:</span></span>  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 <span data-ttu-id="8f325-1667"><xref:System.Reflection.Assembly> は <xref:System.MarshalByRefObject>から派生しないため、アセンブリは両方のドメインに読み込まれます。したがって、<xref:System.AppDomain.Load%2A> メソッドの戻り値をマーシャリングすることはできません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1667">The assembly is loaded into both domains because <xref:System.Reflection.Assembly> does not derive from <xref:System.MarshalByRefObject>, and therefore the return value of the <xref:System.AppDomain.Load%2A> method cannot be marshaled.</span></span> <span data-ttu-id="8f325-1668">代わりに、共通言語ランタイムは、呼び出し元のアプリケーションドメインにアセンブリを読み込もうとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1668">Instead, the common language runtime tries to load the assembly into the calling application domain.</span></span> <span data-ttu-id="8f325-1669">2つのアプリケーションドメインに読み込まれるアセンブリは、2つのアプリケーションドメインのパス設定が異なる場合は異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1669">The assemblies that are loaded into the two application domains might be different if the path settings for the two application domains are different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1670"><xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> プロパティと <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> プロパティの両方が設定されている場合、最初にアセンブリを読み込もうとしたときに、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> プロパティによって返された表示名 (バージョン、カルチャなど) が使用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1670">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="8f325-1671">ファイルが見つからない場合は、<xref:System.Reflection.AssemblyName.CodeBase%2A> プロパティを使用してアセンブリを検索します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1671">If the file is not found, the <xref:System.Reflection.AssemblyName.CodeBase%2A> property is used to search for the assembly.</span></span> <span data-ttu-id="8f325-1672"><xref:System.Reflection.AssemblyName.CodeBase%2A>を使用してアセンブリが見つかった場合、表示名がアセンブリと照合されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1672">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="8f325-1673">一致が失敗した場合は、<xref:System.IO.FileLoadException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1673">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1674"><paramref name="assemblyRef" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1674"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1675"><paramref name="assemblyRef" /> が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1675"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1676"><paramref name="assemblyRef" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1676"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1677">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1677">-or-</span></span> 
<span data-ttu-id="8f325-1678">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyRef" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1678">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1679">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1679">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1680">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1680">An assembly or module was loaded twice with two different evidences.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly Load(string assemblyString) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="8f325-1681">アセンブリの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-1681">The display name of the assembly.</span></span> <span data-ttu-id="8f325-1682">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Reflection.Assembly.FullName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1682">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <summary><span data-ttu-id="8f325-1683">表示名を指定して <see cref="T:System.Reflection.Assembly" /> を読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1683">Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</span></span></summary>
        <returns><span data-ttu-id="8f325-1684">読み込まれるアセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1684">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1685">このメソッドは、現在のアプリケーションドメインにアセンブリを読み込む場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1685">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="8f325-1686">このメソッドは、静的 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを呼び出すことができない、相互運用性を持つ呼び出し元の便宜的な手段として提供されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1686">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8f325-1687">アセンブリを他のアプリケーションドメインに読み込むには、<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>などのメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1687">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="8f325-1688">このメソッドのすべてのオーバーロードに共通の情報については、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロードに関する説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1688">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1689"><paramref name="assemblyString" /> は <see langword="null" /> です</span><span class="sxs-lookup"><span data-stu-id="8f325-1689"><paramref name="assemblyString" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1690"><paramref name="assemblyString" /> が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1690"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1691"><paramref name="assemblyString" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1691"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1692">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1692">-or-</span></span> 
<span data-ttu-id="8f325-1693">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyString" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1693">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1694">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1694">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1695">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1695">An assembly or module was loaded twice with two different evidences.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="8f325-1696">生成されたアセンブリを含む COFF ベースのイメージである <see langword="byte" /> 型配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-1696">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="8f325-1697">アセンブリのシンボルを表す生バイトを格納している <see langword="byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-1697">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="8f325-1698">生成された <see cref="T:System.Reflection.Assembly" /> を含む COFF (Common Object File Format) ベースのイメージを使用して、<see cref="T:System.Reflection.Assembly" /> を読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1698">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span> <span data-ttu-id="8f325-1699"><see cref="T:System.Reflection.Assembly" /> のシンボルを表す生バイトも読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1699">The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</span></span></summary>
        <returns><span data-ttu-id="8f325-1700">読み込まれるアセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1700">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1701">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降、このメソッドを使用して読み込まれるアセンブリの信頼レベルは、アプリケーションドメインの信頼レベルと同じになります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1701">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="8f325-1702">このメソッドは、現在のアプリケーションドメインにアセンブリを読み込む場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1702">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="8f325-1703">このメソッドは、静的 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを呼び出すことができない、相互運用性を持つ呼び出し元の便宜的な手段として提供されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1703">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8f325-1704">アセンブリを他のアプリケーションドメインに読み込むには、<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>などのメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1704">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="8f325-1705">このメソッドのすべてのオーバーロードに共通の情報については、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロードに関する説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1705">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1706">次のサンプルは、未加工のアセンブリの読み込みの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1706">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="8f325-1707">このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1707">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="8f325-1708">完全修飾アセンブリ名を取得する方法については、「[アセンブリ名](~/docs/standard/assembly/names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1708">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1709"><paramref name="rawAssembly" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1709"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1710"><paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1710"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1711">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1711">-or-</span></span> 
<span data-ttu-id="8f325-1712">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="rawAssembly" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1712">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1713">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1713">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1714">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1714">An assembly or module was loaded twice with two different evidences.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="8f325-1715">読み込むアセンブリについて記述しているオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-1715">An object that describes the assembly to load.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="8f325-1716">アセンブリを読み込むために必要な証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-1716">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="8f325-1717"><see cref="T:System.Reflection.Assembly" /> を指定して、<see cref="T:System.Reflection.AssemblyName" /> を読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1717">Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="8f325-1718">読み込まれるアセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1718">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1719">このメソッドは、現在のアプリケーションドメインにアセンブリを読み込む場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1719">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="8f325-1720">このメソッドは、静的 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを呼び出すことができない、相互運用性を持つ呼び出し元の便宜的な手段として提供されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1720">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8f325-1721">アセンブリを他のアプリケーションドメインに読み込むには、<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>などのメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1721">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="8f325-1722">このメソッドのすべてのオーバーロードに共通の情報については、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロードに関する説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1722">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1723"><paramref name="assemblyRef" /> は <see langword="null" /> です</span><span class="sxs-lookup"><span data-stu-id="8f325-1723"><paramref name="assemblyRef" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1724"><paramref name="assemblyRef" /> が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1724"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1725"><paramref name="assemblyRef" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1725"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1726">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1726">-or-</span></span> 
<span data-ttu-id="8f325-1727">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyRef" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1727">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1728">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1728">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1729">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1729">An assembly or module was loaded twice with two different evidences.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="8f325-1730">アセンブリの表示名。</span><span class="sxs-lookup"><span data-stu-id="8f325-1730">The display name of the assembly.</span></span> <span data-ttu-id="8f325-1731">[https://docs.microsoft.com/azure/active-directory/develop/scenario-protected-web-api-overview](<see cref="P:System.Reflection.Assembly.FullName" />) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1731">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="8f325-1732">アセンブリを読み込むために必要な証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-1732">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="8f325-1733">表示名を指定して <see cref="T:System.Reflection.Assembly" /> を読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1733">Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</span></span></summary>
        <returns><span data-ttu-id="8f325-1734">読み込まれるアセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1734">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1735">このメソッドは、現在のアプリケーションドメインにアセンブリを読み込む場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1735">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="8f325-1736">このメソッドは、静的 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを呼び出すことができない、相互運用性を持つ呼び出し元の便宜的な手段として提供されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1736">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8f325-1737">アセンブリを他のアプリケーションドメインに読み込むには、<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>などのメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1737">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="8f325-1738">このメソッドのすべてのオーバーロードに共通の情報については、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロードに関する説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1738">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1739"><paramref name="assemblyString" /> は <see langword="null" /> です</span><span class="sxs-lookup"><span data-stu-id="8f325-1739"><paramref name="assemblyString" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="8f325-1740"><paramref name="assemblyString" /> が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1740"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1741"><paramref name="assemblyString" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1741"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1742">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1742">-or-</span></span> 
<span data-ttu-id="8f325-1743">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyString" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1743">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1744">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1744">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1745">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1745">An assembly or module was loaded twice with two different evidences.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="8f325-1746">生成されたアセンブリを含む COFF ベースのイメージである <see langword="byte" /> 型配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-1746">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="8f325-1747">アセンブリのシンボルを表す生バイトを格納している <see langword="byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-1747">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="8f325-1748">アセンブリを読み込むために必要な証拠。</span><span class="sxs-lookup"><span data-stu-id="8f325-1748">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="8f325-1749">生成された <see cref="T:System.Reflection.Assembly" /> を含む COFF (Common Object File Format) ベースのイメージを使用して、<see cref="T:System.Reflection.Assembly" /> を読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1749">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span> <span data-ttu-id="8f325-1750"><see cref="T:System.Reflection.Assembly" /> のシンボルを表す生バイトも読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1750">The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</span></span></summary>
        <returns><span data-ttu-id="8f325-1751">読み込まれるアセンブリ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1751">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1752">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降、このメソッドを使用して読み込まれるアセンブリの信頼レベルは、アプリケーションドメインの信頼レベルと同じになります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1752">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="8f325-1753">このメソッドは、現在のアプリケーションドメインにアセンブリを読み込む場合にのみ使用してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1753">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="8f325-1754">このメソッドは、静的 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> メソッドを呼び出すことができない、相互運用性を持つ呼び出し元の便宜的な手段として提供されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1754">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8f325-1755">アセンブリを他のアプリケーションドメインに読み込むには、<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>などのメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1755">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="8f325-1756">このメソッドのすべてのオーバーロードに共通の情報については、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> メソッドのオーバーロードに関する説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1756">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1757">次のサンプルは、未加工のアセンブリの読み込みの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1757">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="8f325-1758">このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1758">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="8f325-1759">完全修飾アセンブリ名を取得する方法については、「[アセンブリ名](~/docs/standard/assembly/names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1759">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1760"><paramref name="rawAssembly" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1760"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="8f325-1761"><paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1761"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="8f325-1762">または</span><span class="sxs-lookup"><span data-stu-id="8f325-1762">-or-</span></span> 
<span data-ttu-id="8f325-1763">共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="rawAssembly" /> は、より新しいバージョンでコンパイルされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1763">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1764">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1764">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="8f325-1765">アセンブリまたはモジュールが、2 つの異なる証拠を使用して 2 回読み込まれました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1765">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="8f325-1766"><paramref name="securityEvidence" /> が <see langword="null" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1766"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span> <span data-ttu-id="8f325-1767">レガシ CAS ポリシーが有効でない場合は、<paramref name="securityEvidence" /> を <see langword="null" /> にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1767">When legacy CAS policy is not enabled, <paramref name="securityEvidence" /> should be <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1768">現在のプロセスに対して、アプリケーション ドメインの CPU およびメモリの監視が有効になっているかどうかを示す値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1768">Gets or sets a value that indicates whether CPU and memory monitoring of application domains is enabled for the current process.</span></span> <span data-ttu-id="8f325-1769">プロセスに対して一度有効にした監視を無効にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1769">Once monitoring is enabled for a process, it cannot be disabled.</span></span></summary>
        <value><span data-ttu-id="8f325-1770">監視が有効になっている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-1770"><see langword="true" /> if monitoring is enabled; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1771">この `static` プロパティ (Visual Basic の`Shared` プロパティ) は、プロセス内のすべてのアプリケーションドメインの CPU およびメモリの監視を制御します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1771">This `static` property (`Shared` property in Visual Basic) controls CPU and memory monitoring of all the application domains in the process.</span></span>  
  
 <span data-ttu-id="8f325-1772">このプロパティを `false`に設定しようとすると、プロパティの現在の値が `false`場合でも <xref:System.ArgumentException> 例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1772">If you attempt to set this property to `false`, a <xref:System.ArgumentException> exception is thrown, even if the current value of the property is `false`.</span></span>  
  
 <span data-ttu-id="8f325-1773">監視が有効になったら、<xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>、<xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>、<xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>、および <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> インスタンスの各プロパティを使用して、個々のアプリケーションドメインの CPU とメモリの使用量を監視できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1773">Once monitoring is enabled, you can use the <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, and <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> instance properties to monitor CPU and memory use of individual application domains.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8f325-1774">現在のプロセスがこのプロパティに値 <see langword="false" /> を代入しようとしました。</span><span class="sxs-lookup"><span data-stu-id="8f325-1774">The current process attempted to assign the value <see langword="false" /> to this property.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="8f325-1775">アプリケーション ドメインのリソース監視</span><span class="sxs-lookup"><span data-stu-id="8f325-1775">Application Domain Resource Monitoring</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/02119ab6-1e91-448e-97ad-e7b2e5c4bbbd"><span data-ttu-id="8f325-1776">&lt;appdomainResourceMonitoring&gt; 要素</span><span class="sxs-lookup"><span data-stu-id="8f325-1776">&lt;appdomainResourceMonitoring&gt; Element</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1777">最後のコレクションの実行後に残された、現在のアプリケーション ドメインによって参照されていることが判明しているバイト数を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1777">Gets the number of bytes that survived the last collection and that are known to be referenced by the current application domain.</span></span></summary>
        <value><span data-ttu-id="8f325-1778">残っているバイト数。</span><span class="sxs-lookup"><span data-stu-id="8f325-1778">The number of surviving bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1779">統計は各ガベージコレクションによって更新されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1779">The statistics are updated with each garbage collection.</span></span> <span data-ttu-id="8f325-1780">ただし、完全なブロッキングコレクションの後にのみ正確であることが保証されます。つまり、コレクションの実行中にアプリケーションを停止する、すべてのジェネレーションを含むコレクションです。</span><span class="sxs-lookup"><span data-stu-id="8f325-1780">However, they are guaranteed to be accurate only after a full, blocking collection; that is, a collection that includes all generations and that stops the application while collection occurs.</span></span> <span data-ttu-id="8f325-1781">たとえば、<xref:System.GC.Collect?displayProperty=nameWithType> メソッドのオーバーロードは、完全なブロッキングコレクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1781">For example, the <xref:System.GC.Collect?displayProperty=nameWithType> method overload performs a full, blocking collection.</span></span> <span data-ttu-id="8f325-1782">(同時実行コレクションはバックグラウンドで発生し、アプリケーションをブロックしません)。</span><span class="sxs-lookup"><span data-stu-id="8f325-1782">(Concurrent collection occurs in the background and does not block the application.)</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8f325-1783"><see langword="static" /> (Visual Basic では <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> プロパティが <see langword="false" /> に設定されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1783">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="8f325-1784">アプリケーション ドメインのリソース監視</span><span class="sxs-lookup"><span data-stu-id="8f325-1784">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1785">最後のコレクションの実行後に残された、プロセス内のすべてのアプリケーション ドメインにおける合計バイト数を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1785">Gets the total bytes that survived from the last collection for all application domains in the process.</span></span></summary>
        <value><span data-ttu-id="8f325-1786">プロセスに残っている合計バイト数。</span><span class="sxs-lookup"><span data-stu-id="8f325-1786">The total number of surviving bytes for the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1787">完全なブロッキングコレクションの後、この数は、現在マネージヒープ上にライブで保持されているバイト数を表します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1787">After a full, blocking collection, this number represents the number of bytes currently held live on managed heaps.</span></span> <span data-ttu-id="8f325-1788">この値は、<xref:System.GC.GetTotalMemory%2A> メソッドによって報告された数値に近い必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1788">It should be close to the number reported by the <xref:System.GC.GetTotalMemory%2A> method.</span></span> <span data-ttu-id="8f325-1789">短期コレクションの後、この数値は、短期ジェネレーションで現在保持されているバイト数を表します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1789">After an ephemeral collection, this number represents the number of bytes currently held live in ephemeral generations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8f325-1790"><see langword="static" /> (Visual Basic では <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> プロパティが <see langword="false" /> に設定されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1790">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="8f325-1791">アプリケーション ドメインのリソース監視</span><span class="sxs-lookup"><span data-stu-id="8f325-1791">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1792">アプリケーション ドメインが作成されてから、そのアプリケーション ドメインで実行されたすべてのメモリ割り当ての合計サイズをバイト単位で取得します。収集されたメモリは差し引かれません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1792">Gets the total size, in bytes, of all memory allocations that have been made by the application domain since it was created, without subtracting memory that has been collected.</span></span></summary>
        <value><span data-ttu-id="8f325-1793">すべてのメモリ割り当ての合計サイズ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1793">The total size of all memory allocations.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8f325-1794"><see langword="static" /> (Visual Basic では <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> プロパティが <see langword="false" /> に設定されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1794">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="8f325-1795">アプリケーション ドメインのリソース監視</span><span class="sxs-lookup"><span data-stu-id="8f325-1795">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1796">プロセスが開始されてから、現在のアプリケーション ドメインでの実行中にすべてのスレッドで使用された合計プロセッサ時間を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1796">Gets the total processor time that has been used by all threads while executing in the current application domain, since the process started.</span></span></summary>
        <value><span data-ttu-id="8f325-1797">現在のアプリケーション ドメインの合計プロセッサ時間。</span><span class="sxs-lookup"><span data-stu-id="8f325-1797">Total processor time for the current application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1798">アプリケーションドメインに対して報告される合計時間には、プロセス内の各スレッドがそのアプリケーションドメインで実行に費やした時間が含まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1798">The total time that is reported for an application domain includes the time each thread in the process spent executing in that application domain.</span></span>  
  
 <span data-ttu-id="8f325-1799">アンマネージコードを呼び出すスレッドは引き続きアプリケーションドメインに関連付けられ、呼び出しが行われたアプリケーションドメインに対して、アンマネージコードの実行に費やされたプロセッサ時間が報告されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1799">A thread that calls into unmanaged code is still associated with an application domain, and the processor time spent executing the unmanaged code is reported for the application domain where the call was made.</span></span>  
  
 <span data-ttu-id="8f325-1800">スレッドがブロックまたはスリープ状態になると、プロセッサ時間は消費されません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1800">When a thread is blocked or sleeping, it does not consume processor time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8f325-1801"><see langword="static" /> (Visual Basic では <see langword="Shared" />) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> プロパティが <see langword="false" /> に設定されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1801">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="8f325-1802">アプリケーション ドメインのリソース監視</span><span class="sxs-lookup"><span data-stu-id="8f325-1802">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1803">サンドボックス化されたアプリケーション ドメインのアクセス許可セットを取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1803">Gets the permission set of a sandboxed application domain.</span></span></summary>
        <value><span data-ttu-id="8f325-1804">サンドボックス化されたアプリケーション ドメインのアクセス許可セット。</span><span class="sxs-lookup"><span data-stu-id="8f325-1804">The permission set of the sandboxed application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1805"><xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> メソッドオーバーロードを使用して作成されたサンドボックス化されたアプリケーションドメインには、同種のアクセス許可セットがあります。つまり、アプリケーションドメインに読み込まれる部分的に信頼されているすべてのアセンブリに対して、同じアクセス許可のセットが付与されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1805">Sandboxed application domains that were created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</span></span> <span data-ttu-id="8f325-1806">サンドボックス化されたアプリケーションドメインには、このアクセス許可セットから除外される厳密な名前付きアセンブリの一覧があり、代わりに完全信頼で実行されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1806">A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ProcessExit;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1807">既定のアプリケーション ドメインの親プロセスが終了した場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1807">Occurs when the default application domain's parent process exits.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1808">このイベントの <xref:System.EventHandler> では、プロセスが終了する前に、ファイルのクローズ、ストレージの解放などの終了アクティビティを実行できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1808">The <xref:System.EventHandler> for this event can perform termination activities, such as closing files, releasing storage and so on, before the process ends.</span></span>  
  
 <span data-ttu-id="8f325-1809">.NET Framework バージョン2.0 以降では、イベントハンドラーを登録する各アプリケーションドメインでこのイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1809">Beginning with the .NET Framework version 2.0, this event is raised in each application domain that registers an event handler.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1810">.NET Framework では、すべての <xref:System.AppDomain.ProcessExit> イベントハンドラーの合計実行時間が制限されます。これは、すべてのファイナライザーの実行時間の合計がプロセスのシャットダウン時に制限されるためです。</span><span class="sxs-lookup"><span data-stu-id="8f325-1810">In .NET Framework, the total execution time of all <xref:System.AppDomain.ProcessExit> event handlers is limited, just as the total execution time of all finalizers is limited at process shutdown.</span></span> <span data-ttu-id="8f325-1811">既定値は2秒です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1811">The default is two seconds.</span></span> <span data-ttu-id="8f325-1812">アンマネージホストは、 [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md)列挙値を指定して[ICLRPolicyManager:: SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md)メソッドを呼び出すことによって、この実行時間を変更できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1812">An unmanaged host can change this execution time by calling the [ICLRPolicyManager::SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) method with the [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) enumeration value.</span></span> <span data-ttu-id="8f325-1813">この制限時間は .NET Core には存在しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1813">This time limit does not exist in .NET Core.</span></span>  
  
 <span data-ttu-id="8f325-1814">.NET Framework バージョン1.0 および1.1 では、このイベントは既定のアプリケーションドメインでのみ発生し、イベントハンドラーが既定のアプリケーションドメインに登録されている場合にのみ発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1814">In the .NET Framework versions 1.0 and 1.1, this event is raised only in the default application domain, and only if an event handler is registered in the default application domain.</span></span>  
  
 <span data-ttu-id="8f325-1815">このイベントのイベントハンドラーを登録するには、必要なアクセス許可が必要です。または、<xref:System.Security.SecurityException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1815">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="8f325-1816">イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1816">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1817">リフレクション専用のコンテキストでアセンブリの解決に失敗した場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1817">Occurs when the resolution of an assembly fails in the reflection-only context.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1818">リフレクションのみのコンテキストでは、依存関係は自動的には解決されません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1818">In the reflection-only context, dependencies are not resolved automatically.</span></span> <span data-ttu-id="8f325-1819">これらは、このイベントのハンドラーによってプリロードまたは返される必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1819">They must be preloaded or returned by the handler for this event.</span></span> <span data-ttu-id="8f325-1820">このイベントは、アセンブリにまだリフレクションのみのコンテキストに読み込まれていない依存関係がある場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1820">This event is raised when an assembly has a dependency that is not already loaded into the reflection-only context.</span></span> <span data-ttu-id="8f325-1821">見つからない依存関係は、<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> プロパティによって指定されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1821">The missing dependency is specified by the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8f325-1822">このイベントの <xref:System.ResolveEventHandler> は、依存関係を満たすアセンブリを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1822">The <xref:System.ResolveEventHandler> for this event must return an assembly that satisfies the dependency.</span></span> <span data-ttu-id="8f325-1823">返されるアセンブリは、リフレクションのみのコンテキストに読み込まれる必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1823">The assembly that is returned must be loaded into the reflection-only context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8f325-1824">このイベントは、リフレクションのみのコンテキストに読み込むアセンブリの依存関係が見つからない場合にのみ発生します (たとえば、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> メソッドを使用するなど)。</span><span class="sxs-lookup"><span data-stu-id="8f325-1824">This event is raised only for missing dependencies of the assembly that you are loading into the reflection-only context (for example, by using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method).</span></span> <span data-ttu-id="8f325-1825">読み込み中のアセンブリが見つからない場合には発生しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1825">It is not raised if the assembly that you are loading cannot be found.</span></span>  
  
 <span data-ttu-id="8f325-1826">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> プロパティは、解決できなかったアセンブリの読み込みを要求したアセンブリを返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1826">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property returns the assembly that requested the assembly load that could not be resolved.</span></span> <span data-ttu-id="8f325-1827">要求元アセンブリの id を知っていると、依存関係の正しいバージョンを特定するのに役立つ場合があります (複数のバージョンが使用可能な場合)。</span><span class="sxs-lookup"><span data-stu-id="8f325-1827">Knowing the identity of the requesting assembly might be useful in identifying the correct version of the dependency, if more than one version is available.</span></span> <span data-ttu-id="8f325-1828">詳細については、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1828">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="8f325-1829">このイベントの場合、<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> プロパティは、ポリシーが適用される前にアセンブリ名を返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1829">For this event, the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property returns the assembly name before policy is applied.</span></span>  
  
 <span data-ttu-id="8f325-1830">イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1830">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f325-1831">アプリケーション ドメインのリフレクション専用コンテキストに読み込まれているアセンブリを返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1831">Returns the assemblies that have been loaded into the reflection-only context of the application domain.</span></span></summary>
        <returns><span data-ttu-id="8f325-1832">アプリケーション ドメインのリフレクション専用コンテキストに読み込まれているアセンブリを表す <see cref="T:System.Reflection.Assembly" /> オブジェクトの配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-1832">An array of <see cref="T:System.Reflection.Assembly" /> objects that represent the assemblies loaded into the reflection-only context of the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1833">このメソッドは、リフレクションのみのコンテキストに読み込まれているアセンブリを返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1833">This method returns the assemblies that have been loaded into the reflection-only context.</span></span> <span data-ttu-id="8f325-1834">実行のために読み込まれたアセンブリを取得するには、<xref:System.AppDomain.GetAssemblies%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1834">To get the assemblies that have been loaded for execution, use the <xref:System.AppDomain.GetAssemblies%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1835">次のコード例では、システム .dll アセンブリを実行コンテキストに読み込み、次にリフレクションのみのコンテキストに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1835">The following code example loads the System.dll assembly into the execution context and then into the reflection-only context.</span></span> <span data-ttu-id="8f325-1836">各コンテキストに読み込まれたアセンブリを表示するには、<xref:System.AppDomain.GetAssemblies%2A> メソッドと <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1836">The <xref:System.AppDomain.GetAssemblies%2A> and <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> methods are used to display the assemblies loaded into each context.</span></span>  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1837">アンロードされたアプリケーション ドメインで操作が試行されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1837">An operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1838">アセンブリ リゾルバーがプライベート アセンブリを探す場所を示す、ベース ディレクトリ以下のパスを取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1838">Gets the path under the base directory where the assembly resolver should probe for private assemblies.</span></span></summary>
        <value><span data-ttu-id="8f325-1839">アセンブリ リゾルバーがプライベート アセンブリを探す場所を示す、ベース ディレクトリ以下のパス。</span><span class="sxs-lookup"><span data-stu-id="8f325-1839">The path under the base directory where the assembly resolver should probe for private assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1840">プライベートアセンブリは、アプリケーションと同じディレクトリ構造に配置されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1840">Private assemblies are deployed in the same directory structure as the application.</span></span> <span data-ttu-id="8f325-1841"><xref:System.AppDomain.RelativeSearchPath%2A> プロパティによって指定されたパスが <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>の下にない場合は、無視されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1841">If the path specified by the <xref:System.AppDomain.RelativeSearchPath%2A> property is not under <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, it is ignored.</span></span>  
  
 <span data-ttu-id="8f325-1842">このプロパティは <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>を使用して設定された値を返します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1842">This property returns the value set using <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1843">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1843">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ResourceResolve;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1844">リソースが正しくリンクされていなかったり、アセンブリに埋め込まれているなどの理由からリソースの解決に失敗した場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1844">Occurs when the resolution of a resource fails because the resource is not a valid linked or embedded resource in the assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1845">このイベントの <xref:System.ResolveEventHandler> は、リソースが含まれているアセンブリを特定し、それを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1845">The <xref:System.ResolveEventHandler> for this event can attempt to locate the assembly containing the resource and return it.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8f325-1846">有効なリンクされたリソースのファイルが見つからないために解決が失敗した場合、このイベントは発生しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1846">This event is not raised if resolution fails because no file can be found for a valid linked resource.</span></span> <span data-ttu-id="8f325-1847">このイベントは、マニフェストリソースストリームが見つからない場合に発生しますが、個々のリソースキーが見つからない場合には発生しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1847">It is raised if a manifest resource stream cannot be found, but it is not raised if an individual resource key cannot be found.</span></span>  
  
 <span data-ttu-id="8f325-1848">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> プロパティに、リソースを要求したアセンブリが格納されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1848">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property contains the assembly that requested the resource.</span></span> <span data-ttu-id="8f325-1849">詳細については、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1849">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="8f325-1850">このイベントのイベントハンドラーを登録するには、必要なアクセス許可が必要です。または、<xref:System.Security.SecurityException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1850">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="8f325-1851">イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1851">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit&#xA;override this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domainPolicy"><span data-ttu-id="8f325-1852">セキュリティ ポリシー レベル。</span><span class="sxs-lookup"><span data-stu-id="8f325-1852">The security policy level.</span></span></param>
        <summary><span data-ttu-id="8f325-1853">アプリケーション ドメインのセキュリティ ポリシー レベルを設定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1853">Establishes the security policy level for this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1854">セキュリティポリシーを有効にするために、アセンブリが <xref:System.AppDomain> に読み込まれる前に、このメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1854">Call this method before an assembly is loaded into the <xref:System.AppDomain> in order for the security policy to have effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1855">次の例は、<xref:System.AppDomain.SetAppDomainPolicy%2A> メソッドを使用して、アプリケーションドメインのセキュリティポリシーレベルを設定する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1855">The following example demonstrates how to use the <xref:System.AppDomain.SetAppDomainPolicy%2A> method to set the security policy level of an application domain.</span></span>  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1856"><paramref name="domainPolicy" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1856"><paramref name="domainPolicy" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Policy.PolicyException"><span data-ttu-id="8f325-1857">セキュリティ ポリシー レベルが既に設定されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1857">The security policy level has already been set.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1858">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1858">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCachePath(string path) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCachePath(System::String ^ path);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f325-1859">シャドウ コピー先の絶対パス。</span><span class="sxs-lookup"><span data-stu-id="8f325-1859">The fully qualified path to the shadow copy location.</span></span></param>
        <summary><span data-ttu-id="8f325-1860">指定したディレクトリ パスを、アセンブリのシャドウ コピー先として設定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1860">Establishes the specified directory path as the location where assemblies are shadow copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1861"><xref:System.AppDomainSetup.ApplicationName%2A> プロパティが設定されていない場合、キャッシュパスは無視されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1861">The cache path is ignored if the <xref:System.AppDomainSetup.ApplicationName%2A> property is not set.</span></span> <span data-ttu-id="8f325-1862"><xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> プロパティをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1862">See the <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="8f325-1863">シャドウコピーの詳細については、「[アセンブリのシャドウコピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1863">For more information on shadow copying see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1864">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1864">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="8f325-1865">アセンブリのシャドウ コピー</span><span class="sxs-lookup"><span data-stu-id="8f325-1865">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8f325-1866">アプリケーション ドメイン プロパティに値を代入します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1866">Assigns a value to an application domain property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-1867">作成または変更の対象となるユーザー定義アプリケーション ドメイン プロパティの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-1867">The name of a user-defined application domain property to create or change.</span></span></param>
        <param name="data"><span data-ttu-id="8f325-1868">プロパティの値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1868">The value of the property.</span></span></param>
        <summary><span data-ttu-id="8f325-1869">指定したアプリケーション ドメイン プロパティに、指定した値を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1869">Assigns the specified value to the specified application domain property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1870">このメソッドを使用してエントリを挿入するか、<xref:System.AppDomain>のこのインスタンスのプロパティを記述する名前とデータのペアの内部キャッシュにあるエントリの値を変更します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1870">Use this method to insert an entry, or modify the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <xref:System.AppDomain>.</span></span>  
  
 <span data-ttu-id="8f325-1871">キャッシュには、アプリケーションドメインの作成時に挿入される定義済みのシステムエントリが自動的に含まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1871">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="8f325-1872">このメソッドでシステムエントリを挿入または変更することはできません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1872">You cannot insert or modify system entries with this method.</span></span> <span data-ttu-id="8f325-1873">システムエントリを変更しようとするメソッド呼び出しは効果がありません。メソッドは例外をスローしません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1873">A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</span></span> <span data-ttu-id="8f325-1874">システムエントリの値を調べるには、<xref:System.AppDomain.GetData%2A> メソッドを使用するか、<xref:System.AppDomain.GetData%2A>に記載されている同等の <xref:System.AppDomainSetup> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1874">You can inspect the values of system entries with the <xref:System.AppDomain.GetData%2A> method, or the equivalent <xref:System.AppDomainSetup> properties described in <xref:System.AppDomain.GetData%2A>.</span></span>  
  
 <span data-ttu-id="8f325-1875">このメソッドを呼び出して、正規表現パターンを評価するための既定のタイムアウト間隔の値を設定できます。これを行うには、`name` 引数の値として "REGEX_DEFAULT_MATCH_TIMEOUT" を指定し、`data` 引数の値としてタイムアウト間隔を表す <xref:System.TimeSpan> 値を指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1875">You can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the `name` argument and a <xref:System.TimeSpan> value that represents the timeout interval as the value of the `data` argument.</span></span> <span data-ttu-id="8f325-1876">また、このメソッドを使用してユーザー定義の名前とデータのペアを挿入または変更し、<xref:System.AppDomain.GetData%2A> メソッドを使用してその値を検査することもできます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1876">You can also insert or modify your own user defined name-data pairs with this method and inspect their values with the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1877">次の例では、<xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> メソッドを使用して、新しい値のペアを作成する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1877">The following example demonstrates how to use the <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> method to create a new value pair.</span></span> <span data-ttu-id="8f325-1878">この例では、<xref:System.AppDomain.GetData%2A> メソッドを使用して値を取得し、コンソールに表示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1878">The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.</span></span>  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1879">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1879">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="permission" Type="System.Security.IPermission" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8f325-1880">作成または変更の対象となるユーザー定義アプリケーション ドメイン プロパティの名前。</span><span class="sxs-lookup"><span data-stu-id="8f325-1880">The name of a user-defined application domain property to create or change.</span></span></param>
        <param name="data"><span data-ttu-id="8f325-1881">プロパティの値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1881">The value of the property.</span></span></param>
        <param name="permission"><span data-ttu-id="8f325-1882">プロパティの取得時に呼び出し元に要求するアクセス許可。</span><span class="sxs-lookup"><span data-stu-id="8f325-1882">The permission to demand of the caller when the property is retrieved.</span></span></param>
        <summary><span data-ttu-id="8f325-1883">アプリケーション ドメインの特定のプロパティに対し、指定された値を代入します。プロパティの取得時に呼び出し元に要求するアクセス許可を引数として受け取ります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1883">Assigns the specified value to the specified application domain property, with a specified permission to demand of the caller when the property is retrieved.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1884">このメソッドを使用して、アプリケーションドメインのプロパティを記述する名前/データペアの内部キャッシュに、独自のユーザー定義エントリを挿入または変更します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1884">Use this method to insert or modify your own user-defined entries in an internal cache of name/data pairs that describe properties of the application domain.</span></span> <span data-ttu-id="8f325-1885">エントリを挿入するときに、エントリを取得するときに適用するアクセス許可要求を指定できます。さらに、このメソッドを呼び出して、正規表現パターンを評価するための既定のタイムアウト間隔の値を設定できます。これには、`name` 引数の値として "REGEX_DEFAULT_MATCH_TIMEOUT" を指定し、`data` 引数の値としてタイムアウト間隔を表す <xref:System.TimeSpan> 値を指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1885">When you insert an entry, you can specify a permission demand to enforce when the entry is retrieved.In addition, you can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the `name` argument and a <xref:System.TimeSpan> value that represents the timeout interval as the value of the `data` argument.</span></span>  
  
 <span data-ttu-id="8f325-1886">このメソッドを使用して、システム定義のプロパティ文字列にセキュリティ要求を割り当てることはできません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1886">You cannot use this method to assign a security demand to a system-defined property string.</span></span>  
  
 <span data-ttu-id="8f325-1887">キャッシュには、アプリケーションドメインの作成時に挿入される定義済みのシステムエントリが自動的に含まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1887">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="8f325-1888">このメソッドでシステムエントリを挿入または変更することはできません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1888">You cannot insert or modify system entries with this method.</span></span> <span data-ttu-id="8f325-1889">システムエントリを変更しようとするメソッド呼び出しは効果がありません。メソッドは例外をスローしません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1889">A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</span></span> <span data-ttu-id="8f325-1890">システムエントリの値を調べるには、<xref:System.AppDomain.GetData%2A> メソッドを使用するか、<xref:System.AppDomain.GetData%2A> メソッドの「解説」で説明されている <xref:System.AppDomainSetup> のプロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1890">You can inspect the values of system entries with the <xref:System.AppDomain.GetData%2A> method or the equivalent <xref:System.AppDomainSetup> properties described in the Remarks section for the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1891"><paramref name="name" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1891"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8f325-1892"><paramref name="name" /> にシステム定義のプロパティ文字列が指定されているにもかかわらず、<paramref name="permission" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1892"><paramref name="name" /> specifies a system-defined property string and <paramref name="permission" /> is not <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f325-1893">動的アセンブリの格納先となるサブディレクトリに対するベース ディレクトリを指定する絶対パス。</span><span class="sxs-lookup"><span data-stu-id="8f325-1893">The fully qualified path that is the base directory for subdirectories where dynamic assemblies are stored.</span></span></param>
        <summary><span data-ttu-id="8f325-1894">動的に生成されたファイルの格納先、およびそのファイルへのアクセス先となるサブディレクトリに対するベース ディレクトリとして、ディレクトリ パスを設定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1894">Establishes the specified directory path as the base directory for subdirectories where dynamically generated files are stored and accessed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1895">このメソッドは、このインスタンスに関連付けられている内部 <xref:System.AppDomainSetup> の <xref:System.AppDomainSetup.DynamicBase%2A> プロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1895">This method sets the <xref:System.AppDomainSetup.DynamicBase%2A> property of the internal <xref:System.AppDomainSetup> associated with this instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1896">このメソッドは互換性のために残されています。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1896">This method is now obsolete, and should not be used for new development.</span></span> <span data-ttu-id="8f325-1897">次の例では、廃止されていない代替の <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> プロパティを使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1897">The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8f325-1898">この例の詳細については、<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> プロパティまたは <xref:System.AppDomain.DynamicDirectory%2A> プロパティを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1898">For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1899">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1899">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit&#xA;override this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy"><span data-ttu-id="8f325-1900">スレッドにアタッチするプリンシパル オブジェクトの型を指定する、<see cref="T:System.Security.Principal.PrincipalPolicy" /> のいずれかの値。</span><span class="sxs-lookup"><span data-stu-id="8f325-1900">One of the <see cref="T:System.Security.Principal.PrincipalPolicy" /> values that specifies the type of the principal object to attach to threads.</span></span></param>
        <summary><span data-ttu-id="8f325-1901">アプリケーション ドメインでスレッドを実行中に、スレッドがプリンシパルにバインドしようとした場合に、プリンシパル オブジェクトと ID オブジェクトをそのスレッドに関連付ける方法を指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1901">Specifies how principal and identity objects should be attached to a thread if the thread attempts to bind to a principal while executing in this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1902">この値の設定は、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> プロパティを使用する前に設定した場合にのみ有効になります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1902">Setting this value will only be effective if you set it before using the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8f325-1903">たとえば、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> を特定のプリンシパル (たとえば、汎用プリンシパル) に設定し、<xref:System.AppDomain.SetPrincipalPolicy%2A> メソッドを使用して <xref:System.Security.Principal.PrincipalPolicy> を <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>に設定した場合、現在のプリンシパルは汎用プリンシパルのままになります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1903">For example, if you set <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> to a given principal (for example, a generic principal) and then use the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to set the <xref:System.Security.Principal.PrincipalPolicy> to <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, the current principal will remain the generic principal.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1904">次の例は、<xref:System.AppDomain.SetPrincipalPolicy%2A> メソッドを使用して、アプリケーションドメインのプリンシパルポリシーを変更するスレッドへの影響を示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1904">The following example shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.</span></span> <span data-ttu-id="8f325-1905">また、<xref:System.AppDomain.SetThreadPrincipal%2A> メソッドを使用して、アプリケーションドメインのスレッドにアタッチするために使用できるプリンシパルを変更した場合の影響についても示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1905">It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.</span></span>  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1906">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1906">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f325-1907">シャドウ コピーをオンにします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1907">Turns on shadow copying.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1908">シャドウコピーの詳細については、「[アセンブリのシャドウコピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1908">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1909">このメソッドは互換性のために残されています。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1909">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1910">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1910">The operation is attempted on an unloaded application domain.</span></span></exception>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="8f325-1911">アセンブリのシャドウ コピー</span><span class="sxs-lookup"><span data-stu-id="8f325-1911">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyPath(string path) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyPath(System::String ^ path);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="8f325-1912">ディレクトリ名のリスト。各ディレクトリ名はセミコロンで区切られます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1912">A list of directory names, where each name is separated by a semicolon.</span></span></param>
        <summary><span data-ttu-id="8f325-1913">指定したディレクトリ パスを、シャドウ コピーするアセンブリがある場所として設定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1913">Establishes the specified directory path as the location of assemblies to be shadow copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1914">既定では、シャドウコピーにはプローブによって検出されたすべてのアセンブリが含まれます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1914">By default, a shadow copy includes all assemblies found through probing.</span></span> <span data-ttu-id="8f325-1915"><xref:System.AppDomain.SetShadowCopyPath%2A> メソッドは、`path`によって指定されたディレクトリ内のアセンブリにシャドウコピーを制限します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1915">The <xref:System.AppDomain.SetShadowCopyPath%2A> method restricts the shadow copy to the assemblies in the directories specified by `path`.</span></span>  
  
 <span data-ttu-id="8f325-1916"><xref:System.AppDomain.SetShadowCopyPath%2A> メソッドでは、アセンブリを検索する追加のディレクトリが指定されていません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1916">The <xref:System.AppDomain.SetShadowCopyPath%2A> method does not specify additional directories to be searched for assemblies.</span></span> <span data-ttu-id="8f325-1917">シャドウコピーされるアセンブリは、検索パスに既に配置されている必要があります (<xref:System.AppDomain.BaseDirectory%2A>など)。</span><span class="sxs-lookup"><span data-stu-id="8f325-1917">Assemblies to be shadow-copied must already be located in the search path, for example under <xref:System.AppDomain.BaseDirectory%2A>.</span></span> <span data-ttu-id="8f325-1918"><xref:System.AppDomain.SetShadowCopyPath%2A> メソッドは、シャドウコピーの対象となる検索パスを指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1918">The <xref:System.AppDomain.SetShadowCopyPath%2A> method specifies which search paths are eligible to be shadow-copied.</span></span>  
  
 <span data-ttu-id="8f325-1919">このメソッドは、このインスタンスに関連付けられている内部 <xref:System.AppDomainSetup> の <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> プロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1919">This method sets the <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> property of the internal <xref:System.AppDomainSetup> associated with this instance.</span></span>  
  
 <span data-ttu-id="8f325-1920">シャドウコピーの詳細については、「[アセンブリのシャドウコピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1920">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1921">このメソッドは互換性のために残されています。新規の開発には使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1921">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1922">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1922">The operation is attempted on an unloaded application domain.</span></span></exception>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="8f325-1923">アセンブリのシャドウ コピー</span><span class="sxs-lookup"><span data-stu-id="8f325-1923">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="abstract member SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit&#xA;override this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal"><span data-ttu-id="8f325-1924">スレッドに関連付けるプリンシパル オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8f325-1924">The principal object to attach to threads.</span></span></param>
        <summary><span data-ttu-id="8f325-1925">アプリケーション ドメインでスレッドを実行中に、スレッドがプリンシパルにバインドしようとした場合に、そのスレッドに関連付ける既定のプリンシパル オブジェクトを設定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1925">Sets the default principal object to be attached to threads if they attempt to bind to a principal while executing in this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8f325-1926">次の例は、<xref:System.AppDomain.SetThreadPrincipal%2A> メソッドを使用して、アプリケーションドメインで実行されているスレッドにアタッチできるプリンシパルを変更した場合の効果を示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1926">The following example shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads that are executing in the application domain.</span></span> <span data-ttu-id="8f325-1927">また、<xref:System.AppDomain.SetPrincipalPolicy%2A> メソッドを使用して、アプリケーションドメインのプリンシパルポリシーを変更するスレッドへの影響についても示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1927">It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.</span></span>  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-1928"><paramref name="principal" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1928"><paramref name="principal" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Policy.PolicyException"><span data-ttu-id="8f325-1929">スレッドのプリンシパルが既に設定されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1929">The thread principal has already been set.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1930">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1930">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1931">このインスタンスのアプリケーション ドメイン構成情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1931">Gets the application domain configuration information for this instance.</span></span></summary>
        <value><span data-ttu-id="8f325-1932">アプリケーション ドメインの初期化情報。</span><span class="sxs-lookup"><span data-stu-id="8f325-1932">The application domain initialization information.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1933">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1933">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1934">アプリケーション ドメインでファイルのシャドウ コピーを実行するよう設定されているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1934">Gets an indication whether the application domain is configured to shadow copy files.</span></span></summary>
        <value><span data-ttu-id="8f325-1935">アプリケーション ドメインでファイルのシャドウ コピーを実行するよう設定されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="8f325-1935"><see langword="true" /> if the application domain is configured to shadow copy files; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1936">詳細については、「アセンブリの <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> と[シャドウコピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1936">For more information, see <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1937">アンロードされたアプリケーション ドメインで操作しようとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-1937">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="8f325-1938">アセンブリのシャドウ コピー</span><span class="sxs-lookup"><span data-stu-id="8f325-1938">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberSignature Language="F#" Value="abstract member System._AppDomain.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System._AppDomain.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit" Usage="appDomain.System._AppDomain.GetIDsOfNames (riid, rgszNames, cNames, lcid, rgDispId)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="8f325-1939">将来利用するために予約されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1939">Reserved for future use.</span></span> <span data-ttu-id="8f325-1940">IID_NULL にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1940">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="8f325-1941">マッピング対象として渡される名前の配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-1941">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="8f325-1942">マッピングされる名前のカウント。</span><span class="sxs-lookup"><span data-stu-id="8f325-1942">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="8f325-1943">名前を解釈するロケール コンテキスト。</span><span class="sxs-lookup"><span data-stu-id="8f325-1943">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="8f325-1944">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</span><span class="sxs-lookup"><span data-stu-id="8f325-1944">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="8f325-1945">一連の名前を対応する一連のディスパッチ識別子に割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1945">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1946">このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1946">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8f325-1947">`IDispatch::GetIDsOfNames`の詳細については、MSDN ライブラリを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1947">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8f325-1948">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1948">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberSignature Language="F#" Value="abstract member System._AppDomain.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System._AppDomain.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit" Usage="appDomain.System._AppDomain.GetTypeInfo (iTInfo, lcid, ppTInfo)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="8f325-1949">返される型情報。</span><span class="sxs-lookup"><span data-stu-id="8f325-1949">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="8f325-1950">型情報のロケール ID。</span><span class="sxs-lookup"><span data-stu-id="8f325-1950">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="8f325-1951">要求された型情報オブジェクトへのポインターを取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1951">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="8f325-1952">オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1952">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1953">このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1953">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8f325-1954">`IDispatch::GetTypeInfo`の詳細については、MSDN ライブラリを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1954">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8f325-1955">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1955">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberSignature Language="F#" Value="abstract member System._AppDomain.GetTypeInfoCount : uint32 -&gt; unit&#xA;override this.System._AppDomain.GetTypeInfoCount : uint32 -&gt; unit" Usage="appDomain.System._AppDomain.GetTypeInfoCount pcTInfo" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="8f325-1956">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1956">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="8f325-1957">オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1957">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1958">このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1958">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8f325-1959">`IDispatch::GetTypeInfoCount`の詳細については、MSDN ライブラリを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1959">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8f325-1960">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1960">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberSignature Language="F#" Value="abstract member System._AppDomain.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit&#xA;override this.System._AppDomain.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit" Usage="appDomain.System._AppDomain.Invoke (dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="8f325-1961">メンバーを識別します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1961">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="8f325-1962">将来利用するために予約されています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1962">Reserved for future use.</span></span> <span data-ttu-id="8f325-1963">IID_NULL にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1963">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="8f325-1964">引数を解釈する対象のロケール コンテキスト。</span><span class="sxs-lookup"><span data-stu-id="8f325-1964">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="8f325-1965">呼び出しのコンテキストを記述するフラグ。</span><span class="sxs-lookup"><span data-stu-id="8f325-1965">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="8f325-1966">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</span><span class="sxs-lookup"><span data-stu-id="8f325-1966">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="8f325-1967">結果が格納される場所へのポインター。</span><span class="sxs-lookup"><span data-stu-id="8f325-1967">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="8f325-1968">例外情報を格納する構造体へのポインター。</span><span class="sxs-lookup"><span data-stu-id="8f325-1968">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="8f325-1969">エラーが存在する最初の引数のインデックス。</span><span class="sxs-lookup"><span data-stu-id="8f325-1969">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="8f325-1970">オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1970">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1971">このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1971">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8f325-1972">`IDispatch::Invoke`の詳細については、MSDN ライブラリを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1972">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8f325-1973">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1973">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8f325-1974">アプリケーション ドメインの表示名とコンテキスト ポリシーを含む文字列形式を取得します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1974">Obtains a string representation that includes the friendly name of the application domain and any context policies.</span></span></summary>
        <returns><span data-ttu-id="8f325-1975">アプリケーション ドメインの表示名であるリテラル文字列 "Name:" と、コンテキスト ポリシーの文字列形式または "There are no context policies." という文字列のどちらかを連結した文字列。</span><span class="sxs-lookup"><span data-stu-id="8f325-1975">A string formed by concatenating the literal string "Name:", the friendly name of the application domain, and either string representations of the context policies or the string "There are no context policies."</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8f325-1976"><xref:System.AppDomain.ToString%2A> メソッドの戻り値を表示するコード例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1976">The following code example displays the return value of the <xref:System.AppDomain.ToString%2A> method.</span></span>  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="8f325-1977">現在の <see cref="T:System.AppDomain" /> によって表されるアプリケーション ドメインは既にアンロードされています。</span><span class="sxs-lookup"><span data-stu-id="8f325-1977">The application domain represented by the current <see cref="T:System.AppDomain" /> has been unloaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ TypeResolve;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1978">型の解決が失敗したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1978">Occurs when the resolution of a type fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1979"><xref:System.AppDomain.TypeResolve> イベントは、要求された型を作成できるアセンブリを共通言語ランタイムが特定できない場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1979">The <xref:System.AppDomain.TypeResolve> event occurs when the common language runtime is unable to determine the assembly that can create the requested type.</span></span> <span data-ttu-id="8f325-1980">これは、型が動的アセンブリで定義されている場合、または型が動的アセンブリで定義されていない場合に、その型が定義されているアセンブリがランタイムによって認識されない場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1980">This can occur if the type is defined in a dynamic assembly, or the type is not defined in a dynamic assembly but the runtime does not know which assembly the type is defined in.</span></span> <span data-ttu-id="8f325-1981">後者の状況は、アセンブリ名で修飾されていない型名を使用して <xref:System.Type.GetType%2A?displayProperty=nameWithType> が呼び出された場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1981">The latter situation can occur when <xref:System.Type.GetType%2A?displayProperty=nameWithType> is called with a type name that is not qualified with the assembly name.</span></span>  
  
 <span data-ttu-id="8f325-1982">このイベントの <xref:System.ResolveEventHandler> は、型の検索と作成を試みることができます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1982">The <xref:System.ResolveEventHandler> for this event can attempt to locate and create the type.</span></span>  
  
 <span data-ttu-id="8f325-1983">ただし、ランタイムが特定のアセンブリ内の型を見つけることができないことを認識している場合、<xref:System.AppDomain.TypeResolve> イベントは発生しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1983">However, the <xref:System.AppDomain.TypeResolve> event does not occur if the runtime knows it is not possible to find a type in certain assemblies.</span></span> <span data-ttu-id="8f325-1984">たとえば、静的アセンブリに型が見つからない場合、このイベントは発生しません。これは、ランタイムが静的アセンブリに動的に追加できないことを認識しているためです。</span><span class="sxs-lookup"><span data-stu-id="8f325-1984">For example, this event does not occur if the type is not found in a static assembly because the runtime knows types cannot be added dynamically to static assemblies.</span></span>  
  
 <span data-ttu-id="8f325-1985">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> プロパティに、型を要求したアセンブリが格納されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1985">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property contains the assembly that requested the type.</span></span> <span data-ttu-id="8f325-1986">詳細については、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1986">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="8f325-1987">このイベントのイベントハンドラーを登録するには、必要なアクセス許可が必要です。または、<xref:System.Security.SecurityException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1987">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="8f325-1988">イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1988">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-1989"><xref:System.AppDomain.TypeResolve> イベントの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1989">The following sample demonstrates the <xref:System.AppDomain.TypeResolve> event.</span></span>  
  
 <span data-ttu-id="8f325-1990">このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1990">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="8f325-1991">完全修飾アセンブリ名を取得する方法については、「[アセンブリ名](~/docs/standard/assembly/names.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-1991">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/standard/assembly/names.md).</span></span>  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event UnhandledExceptionEventHandler ^ UnhandledException;" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8f325-1992">例外がキャッチされない場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1992">Occurs when an exception is not caught.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-1993">このイベントは、キャッチされていない例外の通知を提供します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1993">This event provides notification of uncaught exceptions.</span></span> <span data-ttu-id="8f325-1994">これにより、アプリケーションは例外に関する情報をログに記録してから、システムの既定のハンドラーがユーザーに例外を報告し、アプリケーションを終了します。</span><span class="sxs-lookup"><span data-stu-id="8f325-1994">It allows the application to log information about the exception before the system default handler reports the exception to the user and terminates the application.</span></span> <span data-ttu-id="8f325-1995">アプリケーションの状態に関する十分な情報が利用可能な場合は、後で回復するためにプログラムデータを保存するなど、他の操作が実行される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8f325-1995">If sufficient information about the state of the application is available, other actions may be undertaken - such as saving program data for later recovery.</span></span> <span data-ttu-id="8f325-1996">例外が処理されない場合、プログラムデータが破損する可能性があるため、注意が必要です。</span><span class="sxs-lookup"><span data-stu-id="8f325-1996">Caution is advised, because program data can become corrupted when exceptions are not handled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-1997">.NET Framework バージョン1.0 および1.1 では、以降ではなく、このイベントが発生する前に、アプリケーションの終了オプションとデバッグオプションがユーザーに報告されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1997">In the .NET Framework versions 1.0 and 1.1, application termination and debugging options are reported to the user before this event is raised, rather than after.</span></span>  
  
 <span data-ttu-id="8f325-1998">このイベントは、任意のアプリケーションドメインで処理できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-1998">This event can be handled in any application domain.</span></span> <span data-ttu-id="8f325-1999">ただし、イベントは、例外が発生したアプリケーションドメインで必ずしも発生するとは限りません。</span><span class="sxs-lookup"><span data-stu-id="8f325-1999">However, the event is not necessarily raised in the application domain where the exception occurred.</span></span> <span data-ttu-id="8f325-2000">例外がハンドルされないのは、該当する例外ハンドラーを検出せずに、スレッドのスタック全体がアンワインドされている場合のみです。そのため、イベントが発生する最初の場所は、スレッドが発生したアプリケーションドメインにあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-2000">An exception is unhandled only if the entire stack for the thread has been unwound without finding an applicable exception handler, so the first place the event can be raised is in the application domain where the thread originated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-2001">.NET Framework バージョン1.0 および1.1 では、このイベントは、アプリケーションの起動時にシステムによって作成された既定のアプリケーションドメインに対してのみ発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-2001">In the .NET Framework versions 1.0 and 1.1, this event occurs only for the default application domain that is created by the system when an application is started.</span></span> <span data-ttu-id="8f325-2002">アプリケーションで追加のアプリケーションドメインを作成する場合、これらのアプリケーションドメインにこのイベントのデリゲートを指定しても効果はありません。</span><span class="sxs-lookup"><span data-stu-id="8f325-2002">If an application creates additional application domains, specifying a delegate for this event in those applications domains has no effect.</span></span>  
  
 <span data-ttu-id="8f325-2003"><xref:System.AppDomain.UnhandledException> イベントが既定のアプリケーションドメインで処理される場合、スレッドがどのアプリケーションドメインで開始されたかにかかわらず、任意のスレッドでハンドルされない例外が発生すると、そのイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-2003">If the <xref:System.AppDomain.UnhandledException> event is handled in the default application domain, it is raised there for any unhandled exception in any thread, no matter what application domain the thread started in.</span></span> <span data-ttu-id="8f325-2004"><xref:System.AppDomain.UnhandledException>のイベントハンドラーを持つアプリケーションドメインでスレッドが開始された場合、そのアプリケーションドメインでイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-2004">If the thread started in an application domain that has an event handler for <xref:System.AppDomain.UnhandledException>, the event is raised in that application domain.</span></span> <span data-ttu-id="8f325-2005">そのアプリケーションドメインが既定のアプリケーションドメインではなく、既定のアプリケーションドメインにもイベントハンドラーがある場合は、両方のアプリケーションドメインでイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-2005">If that application domain is not the default application domain, and there is also an event handler in the default application domain, the event is raised in both application domains.</span></span>  
  
 <span data-ttu-id="8f325-2006">たとえば、アプリケーションドメイン "AD1" でスレッドが開始され、アプリケーションドメイン "AD2" でメソッドが呼び出され、そこからアプリケーションドメイン "AD3" 内のメソッドが呼び出され、そこで例外がスローされたとします。</span><span class="sxs-lookup"><span data-stu-id="8f325-2006">For example, suppose a thread starts in application domain "AD1", calls a method in application domain "AD2", and from there calls a method in application domain "AD3", where it throws an exception.</span></span> <span data-ttu-id="8f325-2007"><xref:System.AppDomain.UnhandledException> イベントが発生する最初のアプリケーションドメインは "AD1" です。</span><span class="sxs-lookup"><span data-stu-id="8f325-2007">The first application domain in which the <xref:System.AppDomain.UnhandledException> event can be raised is "AD1".</span></span> <span data-ttu-id="8f325-2008">そのアプリケーションドメインが既定のアプリケーションドメインでない場合は、既定のアプリケーションドメインでイベントを発生させることもできます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2008">If that application domain is not the default application domain, the event can also be raised in the default application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-2009">共通言語ランタイムは、<xref:System.AppDomain.UnhandledException> イベントのイベントハンドラーの実行中に、スレッドの中止を中断します。</span><span class="sxs-lookup"><span data-stu-id="8f325-2009">The common language runtime suspends thread aborts while event handlers for the <xref:System.AppDomain.UnhandledException> event are executing.</span></span>  
  
 <span data-ttu-id="8f325-2010">イベントハンドラーが適切なフラグを持つ <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> 属性を持っている場合、イベントハンドラーは制約された実行領域として扱われます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2010">If the event handler has a <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute with the appropriate flags, the event handler is treated as a constrained execution region.</span></span>  
  
 <span data-ttu-id="8f325-2011">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、イベントハンドラーがセキュリティクリティカルで、<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> 属性を持っている場合を除き、プロセスの状態が破損している例外 (スタックオーバーフローやアクセス違反など) に対して、このイベントは発生しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-2011">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], this event is not raised for exceptions that corrupt the state of the process, such as stack overflows or access violations, unless the event handler is security-critical and has the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute.</span></span>  
  
 <span data-ttu-id="8f325-2012">.NET Framework バージョン1.0 および1.1 では、メインアプリケーションスレッド以外のスレッドで発生するハンドルされない例外がランタイムによってキャッチされるため、アプリケーションは終了しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-2012">In the .NET Framework versions 1.0 and 1.1, an unhandled exception that occurs in a thread other than the main application thread is caught by the runtime and therefore does not cause the application to terminate.</span></span> <span data-ttu-id="8f325-2013">したがって、アプリケーションを終了せずに <xref:System.AppDomain.UnhandledException> イベントを発生させることができます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2013">Thus, it is possible for the <xref:System.AppDomain.UnhandledException> event to be raised without the application terminating.</span></span> <span data-ttu-id="8f325-2014">.NET Framework バージョン2.0 以降では、子スレッドで未処理の例外に対するこの関する安全策が削除されました。このようなサイレントエラーの累積的な影響には、パフォーマンスの低下、データの破損、およびハングアップが含まれていました。これらはすべて、デバック.</span><span class="sxs-lookup"><span data-stu-id="8f325-2014">Starting with the .NET Framework version 2.0, this backstop for unhandled exceptions in child threads was removed, because the cumulative effect of such silent failures included performance degradation, corrupted data, and lockups, all of which were difficult to debug.</span></span> <span data-ttu-id="8f325-2015">ランタイムが終了しないケースの一覧など、詳細については、「[マネージスレッドの例外](~/docs/standard/threading/exceptions-in-managed-threads.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-2015">For more information, including a list of cases in which the runtime does not terminate, see [Exceptions in Managed Threads](~/docs/standard/threading/exceptions-in-managed-threads.md).</span></span>  
  
 <span data-ttu-id="8f325-2016">このイベントのイベントハンドラーを登録するには、必要なアクセス許可が必要です。または、<xref:System.Security.SecurityException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2016">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="8f325-2017">イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-2017">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
## <a name="other-events-for-unhandled-exceptions"></a><span data-ttu-id="8f325-2018">未処理の例外に関するその他のイベント</span><span class="sxs-lookup"><span data-stu-id="8f325-2018">Other Events for Unhandled Exceptions</span></span>  
 <span data-ttu-id="8f325-2019">特定のアプリケーションモデルでは、メインアプリケーションスレッドでハンドルされない例外が発生した場合に、<xref:System.AppDomain.UnhandledException> イベントが他のイベントによって割り込まれることがあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-2019">For certain application models, the <xref:System.AppDomain.UnhandledException> event can be preempted by other events if the unhandled exception occurs in the main application thread.</span></span>  
  
 <span data-ttu-id="8f325-2020">Windows フォームを使用するアプリケーションでは、メインアプリケーションスレッドでハンドルされない例外が発生すると、<xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-2020">In applications that use Windows Forms, unhandled exceptions in the main application thread cause the <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> event to be raised.</span></span> <span data-ttu-id="8f325-2021">このイベントが処理される場合、既定の動作では、ハンドルされない例外によってアプリケーションが終了することはありませんが、アプリケーションは不明な状態のままになります。</span><span class="sxs-lookup"><span data-stu-id="8f325-2021">If this event is handled, the default behavior is that the unhandled exception does not terminate the application, although the application is left in an unknown state.</span></span> <span data-ttu-id="8f325-2022">この場合、<xref:System.AppDomain.UnhandledException> イベントは発生しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-2022">In that case, the <xref:System.AppDomain.UnhandledException> event is not raised.</span></span> <span data-ttu-id="8f325-2023">この動作は、アプリケーション構成ファイルを使用するか、<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> メソッドを使用して、<xref:System.Windows.Forms.Application.ThreadException> イベントハンドラーがフックされる前に <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> にモードを変更することによって変更できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2023">This behavior can be changed by using the application configuration file, or by using the <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> method to change the mode to <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> before the <xref:System.Windows.Forms.Application.ThreadException> event handler is hooked up.</span></span> <span data-ttu-id="8f325-2024">これは、メインアプリケーションスレッドにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2024">This applies only to the main application thread.</span></span> <span data-ttu-id="8f325-2025"><xref:System.AppDomain.UnhandledException> イベントは、他のスレッドでスローされた未処理の例外に対して発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-2025">The <xref:System.AppDomain.UnhandledException> event is raised for unhandled exceptions thrown in other threads.</span></span>  
  
 <span data-ttu-id="8f325-2026">Microsoft Visual Studio 2005 以降、Visual Basic アプリケーションフレームワークは、メインアプリケーションスレッドでハンドルされない例外に対して別のイベントを提供します。</span><span class="sxs-lookup"><span data-stu-id="8f325-2026">Starting with Microsoft Visual Studio 2005, the Visual Basic application framework provides another event for unhandled exceptions in the main application thread.</span></span> <span data-ttu-id="8f325-2027"><xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> イベントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8f325-2027">See the <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="8f325-2028">このイベントには、<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>によって使用されるイベント引数オブジェクトと同じ名前のイベント引数オブジェクトがありますが、プロパティは異なります。</span><span class="sxs-lookup"><span data-stu-id="8f325-2028">This event has an event arguments object with the same name as the event arguments object used by <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, but with different properties.</span></span> <span data-ttu-id="8f325-2029">特に、このイベント引数オブジェクトには <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> プロパティがあります。このプロパティを使用すると、アプリケーションの実行を継続でき、未処理の例外は無視され、アプリケーションは不明な状態のままになります。</span><span class="sxs-lookup"><span data-stu-id="8f325-2029">In particular, this event arguments object has an <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> property that allows the application to continue running, ignoring the unhandled exception (and leaving the application in an unknown state).</span></span> <span data-ttu-id="8f325-2030">この場合、<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> イベントは発生しません。</span><span class="sxs-lookup"><span data-stu-id="8f325-2030">In that case, the <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> event is not raised.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-2031"><xref:System.AppDomain.UnhandledException>イベントの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="8f325-2031">The following example demonstrates the <xref:System.AppDomain.UnhandledException> event.</span></span> <span data-ttu-id="8f325-2032">既定のアプリケーションドメインでハンドルされない例外がスローされるたびに呼び出されるイベントハンドラー (`MyHandler`) を定義します。</span><span class="sxs-lookup"><span data-stu-id="8f325-2032">It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain.</span></span> <span data-ttu-id="8f325-2033">その後、2つの例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2033">It then throws two exceptions.</span></span> <span data-ttu-id="8f325-2034">最初のは**try/catch**ブロックによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2034">The first is handled by a **try/catch** block.</span></span> <span data-ttu-id="8f325-2035">2番目のは処理されないので、アプリケーションが終了する前に `MyHandle` ルーチンを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8f325-2035">The second is unhandled and invokes the `MyHandle` routine before the application terminates.</span></span>  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain"><span data-ttu-id="8f325-2036">アンロードするアプリケーション ドメイン。</span><span class="sxs-lookup"><span data-stu-id="8f325-2036">An application domain to unload.</span></span></param>
        <summary><span data-ttu-id="8f325-2037">指定したアプリケーション ドメインをアンロードします。</span><span class="sxs-lookup"><span data-stu-id="8f325-2037">Unloads the specified application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8f325-2038">.NET Framework バージョン2.0 では、アプリケーションドメインのアンロード専用のスレッドがあります。</span><span class="sxs-lookup"><span data-stu-id="8f325-2038">In the .NET Framework version 2.0 there is a thread dedicated to unloading application domains.</span></span> <span data-ttu-id="8f325-2039">これにより、特に .NET Framework がホストされている場合に、信頼性が向上します。</span><span class="sxs-lookup"><span data-stu-id="8f325-2039">This improves reliability, especially when the .NET Framework is hosted.</span></span> <span data-ttu-id="8f325-2040">スレッドが <xref:System.AppDomain.Unload%2A>を呼び出すと、ターゲットドメインにアンロードのマークが付けられます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2040">When a thread calls <xref:System.AppDomain.Unload%2A>, the target domain is marked for unloading.</span></span> <span data-ttu-id="8f325-2041">専用スレッドがドメインのアンロードを試行し、ドメイン内のすべてのスレッドが中止されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2041">The dedicated thread attempts to unload the domain, and all threads in the domain are aborted.</span></span> <span data-ttu-id="8f325-2042">アンマネージコードを実行しているなどの理由でスレッドが中止されない場合、またはスレッドが `finally` ブロックを実行している場合は、<xref:System.AppDomain.Unload%2A>を最初に呼び出したスレッドで <xref:System.CannotUnloadAppDomainException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2042">If a thread does not abort, for example because it is executing unmanaged code, or because it is executing a `finally` block, then after a period of time a <xref:System.CannotUnloadAppDomainException> is thrown in the thread that originally called <xref:System.AppDomain.Unload%2A>.</span></span> <span data-ttu-id="8f325-2043">中止できなかったスレッドが最終的に終了した場合、ターゲットドメインはアンロードされません。</span><span class="sxs-lookup"><span data-stu-id="8f325-2043">If the thread that could not be aborted eventually ends, the target domain is not unloaded.</span></span> <span data-ttu-id="8f325-2044">したがって、.NET Framework バージョン2.0 では、実行中のスレッドを終了できない可能性があるため、`domain` はアンロードされることは保証されていません。</span><span class="sxs-lookup"><span data-stu-id="8f325-2044">Thus, in the .NET Framework version 2.0 `domain` is not guaranteed to unload, because it might not be possible to terminate executing threads.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8f325-2045">場合によっては、<xref:System.AppDomain.Unload%2A> を呼び出すと、ファイナライザーで呼び出された場合など、イミディエイト <xref:System.CannotUnloadAppDomainException>が発生します。</span><span class="sxs-lookup"><span data-stu-id="8f325-2045">In some cases, calling <xref:System.AppDomain.Unload%2A> causes an immediate <xref:System.CannotUnloadAppDomainException>, for example if it is called in a finalizer.</span></span>  
  
 <span data-ttu-id="8f325-2046">`domain` 内のスレッドは、<xref:System.Threading.Thread.Abort%2A> メソッドを使用して終了します。これにより、スレッドで <xref:System.Threading.ThreadAbortException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2046">The threads in `domain` are terminated using the <xref:System.Threading.Thread.Abort%2A> method, which throws a <xref:System.Threading.ThreadAbortException> in the thread.</span></span> <span data-ttu-id="8f325-2047">スレッドはすぐに終了する必要がありますが、`finally` 句では、予期しない時間に実行を継続できます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2047">Although the thread should terminate promptly, it can continue executing for an unpredictable amount of time in a `finally` clause.</span></span>  
  
## <a name="version-compatibility"></a><span data-ttu-id="8f325-2048">バージョンの互換性</span><span class="sxs-lookup"><span data-stu-id="8f325-2048">Version Compatibility</span></span>  
 <span data-ttu-id="8f325-2049">.NET Framework バージョン1.0 および1.1 では、<xref:System.AppDomain.Unload%2A> を呼び出すスレッドが `domain`で実行されている場合、アンロード操作を実行するために別のスレッドが開始されます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2049">In the .NET Framework version 1.0 and 1.1 if the thread that calls <xref:System.AppDomain.Unload%2A> is running in `domain`, another thread is started to perform the unload operation.</span></span> <span data-ttu-id="8f325-2050">`domain` をアンロードできない場合は、<xref:System.AppDomain.Unload%2A>を呼び出した元のスレッドではなく、そのスレッドで <xref:System.CannotUnloadAppDomainException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8f325-2050">If `domain` cannot be unloaded, a <xref:System.CannotUnloadAppDomainException> is thrown in that thread, not in the original thread that called <xref:System.AppDomain.Unload%2A>.</span></span> <span data-ttu-id="8f325-2051">ただし、<xref:System.AppDomain.Unload%2A> を呼び出すスレッドが `domain`の外部で実行されている場合、そのスレッドは例外を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="8f325-2051">However, if the thread that calls <xref:System.AppDomain.Unload%2A> is running outside `domain`, that thread receives the exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8f325-2052">次のコード例は、アプリケーションドメインをアンロードする方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8f325-2052">The following code example shows how to unload an application domain.</span></span>  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8f325-2053"><paramref name="domain" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8f325-2053"><paramref name="domain" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.CannotUnloadAppDomainException"><span data-ttu-id="8f325-2054"><paramref name="domain" /> をアンロードできませんでした。</span><span class="sxs-lookup"><span data-stu-id="8f325-2054"><paramref name="domain" /> could not be unloaded.</span></span></exception>
        <exception cref="T:System.Exception"><span data-ttu-id="8f325-2055">アンロード処理中にエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="8f325-2055">An error occurred during the unload process.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
