<Type Name="FlagsAttribute" FullName="System.FlagsAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bc8b21fc3c07b69515c1ab00e964b833b7dda975" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75042415" /></Metadata><TypeSignature Language="C#" Value="public class FlagsAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FlagsAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.FlagsAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class FlagsAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlagsAttribute : Attribute" />
  <TypeSignature Language="F#" Value="type FlagsAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Enum, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="a0e6b-101">列挙体をビット フィールド、つまりフラグのセットとして扱えることを示します。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-101">Indicates that an enumeration can be treated as a bit field; that is, a set of flags.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0e6b-102">通常、ビットフィールドは、組み合わせて出現する可能性のある要素のリストに使用されます。一方、列挙定数は、相互に排他的な要素のリストに使用されます。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-102">Bit fields are generally used for lists of elements that might occur in combination, whereas enumeration constants are generally used for lists of mutually exclusive elements.</span></span> <span data-ttu-id="a0e6b-103">したがって、ビットフィールドは、名前のない値を生成するためにビットごとの OR 演算と組み合わせて使用するように設計されていますが、列挙定数は使用できません。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-103">Therefore, bit fields are designed to be combined with a bitwise OR operation to generate unnamed values, whereas enumerated constants are not.</span></span> <span data-ttu-id="a0e6b-104">言語は、列挙定数と比較して、ビットフィールドの使用方法によって異なります。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-104">Languages vary in their use of bit fields compared to enumeration constants.</span></span>  
  
## <a name="attributes-of-the-flagsattribute"></a><span data-ttu-id="a0e6b-105">FlagsAttribute の属性</span><span class="sxs-lookup"><span data-stu-id="a0e6b-105">Attributes of the FlagsAttribute</span></span>  
 <span data-ttu-id="a0e6b-106">このクラスには <xref:System.AttributeUsageAttribute> が適用され、その <xref:System.AttributeUsageAttribute.Inherited%2A> プロパティは `false`を指定します。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-106"><xref:System.AttributeUsageAttribute> is applied to this class, and its <xref:System.AttributeUsageAttribute.Inherited%2A> property specifies `false`.</span></span> <span data-ttu-id="a0e6b-107">この属性は、列挙型にのみ適用できます。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-107">This attribute can only be applied to enumerations.</span></span>  
  
## <a name="guidelines-for-flagsattribute-and-enum"></a><span data-ttu-id="a0e6b-108">FlagsAttribute と Enum のガイドライン</span><span class="sxs-lookup"><span data-stu-id="a0e6b-108">Guidelines for FlagsAttribute and Enum</span></span>  
  
-   <span data-ttu-id="a0e6b-109">数値に対してビットごとの演算 (AND、OR、EXCLUSIVE OR) を実行する場合にのみ、列挙体の<xref:System.FlagsAttribute>カスタム属性を使用します。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-109">Use the <xref:System.FlagsAttribute> custom attribute for an enumeration only if a bitwise operation (AND, OR, EXCLUSIVE OR) is to be performed on a numeric value.</span></span>  
  
-   <span data-ttu-id="a0e6b-110">1、2、4、8 など、2 の累乗で列挙定数を定義します。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-110">Define enumeration constants in powers of two, that is, 1, 2, 4, 8, and so on.</span></span> <span data-ttu-id="a0e6b-111">これは、結合された列挙定数内の個々のフラグが重複しないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-111">This means the individual flags in combined enumeration constants do not overlap.</span></span>  
  
-   <span data-ttu-id="a0e6b-112">よく使用されるフラグの組み合わせに対して列挙定数を作成することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-112">Consider creating an enumerated constant for commonly used flag combinations.</span></span> <span data-ttu-id="a0e6b-113">たとえば、列挙定数`Read = 1`と`Write = 2`を含むファイル I/O 操作に使用する列挙体がある場合、`ReadWrite = Read OR Write`と`Read`を組み合わせた`Write`列挙定数を作成することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-113">For example, if you have an enumeration used for file I/O operations that contains the enumerated constants `Read = 1` and `Write = 2`, consider creating the enumerated constant `ReadWrite = Read OR Write`, which combines the `Read` and `Write` flags.</span></span> <span data-ttu-id="a0e6b-114">また、フラグを結合するために使用されるビットごとの OR 演算は、単純なタスクにとって不必要に高度な概念と見なされる場合があります。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-114">In addition, the bitwise OR operation used to combine the flags might be considered an advanced concept in some circumstances that should not be required for simple tasks.</span></span>  
  
-   <span data-ttu-id="a0e6b-115">フラグの列挙定数として負の数を定義すると、多くのフラグ位置が1に設定されることがあるため、注意してください。これにより、コードの混乱を招く可能性があり、コーディングエラーを助長します。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-115">Use caution if you define a negative number as a flag enumerated constant because many flag positions might be set to 1, which might make your code confusing and encourage coding errors.</span></span>  
  
-   <span data-ttu-id="a0e6b-116">数値でフラグが設定されているかどうかをテストする便利な方法は、数値とフラグ列挙定数の間でビットごとの AND 演算を実行することです。これにより、数値のすべてのビットがフラグに対応しないゼロに設定されます。次に、その操作の結果がフラグ列挙定数と等しいかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-116">A convenient way to test whether a flag is set in a numeric value is to perform a bitwise AND operation between the numeric value and the flag enumerated constant, which sets all bits in the numeric value to zero that do not correspond to the flag, then test whether the result of that operation is equal to the flag enumerated constant.</span></span>  
  
-   <span data-ttu-id="a0e6b-117">値が 0 であるフラグ列挙定数の名前として`None`を使用します。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-117">Use `None` as the name of the flag enumerated constant whose value is zero.</span></span> <span data-ttu-id="a0e6b-118">ビットごとの and 演算では、結果が常に0であるため、`None`列挙定数を使用してフラグをテストすることはできません。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-118">You cannot use the `None` enumerated constant in a bitwise AND operation to test for a flag because the result is always zero.</span></span> <span data-ttu-id="a0e6b-119">ただし、数値内のビットが設定されているかどうかを判断するために、数値と`None`に、数値と列挙定数の間でビットごとの比較ではなく論理演算を実行することができます。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-119">However, you can perform a logical, not a bitwise, comparison between the numeric value and the `None` enumerated constant to determine whether any bits in the numeric value are set.</span></span>  
  
     <span data-ttu-id="a0e6b-120">Flags 列挙ではなく値の列挙体を作成する場合でも、`None` 列挙定数を作成することは意味があります。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-120">If you create a value enumeration instead of a flags enumeration, it is still worthwhile to create a `None` enumerated constant.</span></span> <span data-ttu-id="a0e6b-121">これは、既定では、列挙体に使用されるメモリが共通言語ランタイムによって0に初期化されるためです。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-121">The reason is that by default the memory used for the enumeration is initialized to zero by the common language runtime.</span></span> <span data-ttu-id="a0e6b-122">その結果、値が 0 である定数を定義しなかった場合、列挙体の作成時に無効な値が含まれます。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-122">Consequently, if you do not define a constant whose value is zero, the enumeration will contain an illegal value when it is created.</span></span>  
  
     <span data-ttu-id="a0e6b-123">アプリケーションで表現する必要がある、明確な既定のケースがある場合は、既定値を表すゼロの値を持つ列挙定数を使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-123">If there is an obvious default case your application needs to represent, consider using an enumerated constant whose value is zero to represent the default.</span></span> <span data-ttu-id="a0e6b-124">既定のケースがない場合は、値が0である列挙定数を使用することを検討してください。これは、他の列挙定数で表されないケースを意味します。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-124">If there is no default case, consider using an enumerated constant whose value is zero that means the case that is not represented by any of the other enumerated constants.</span></span>  
  
-   <span data-ttu-id="a0e6b-125">列挙型自体の状態を反映するためだけに列挙値を定義しないでください。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-125">Do not define an enumeration value solely to mirror the state of the enumeration itself.</span></span> <span data-ttu-id="a0e6b-126">たとえば、列挙型の末尾を示すだけの列挙定数は定義しないでください。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-126">For example, do not define an enumerated constant that merely marks the end of the enumeration.</span></span> <span data-ttu-id="a0e6b-127">列挙体の最後の値を確認する必要がある場合は、その値を明示的に確認します。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-127">If you need to determine the last value of the enumeration, check for that value explicitly.</span></span> <span data-ttu-id="a0e6b-128">また、範囲内のすべての値が有効な場合は、最初と最後に列挙された定数の範囲チェックを実行できます。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-128">In addition, you can perform a range check for the first and last enumerated constant if all values within the range are valid.</span></span>  
  
-   <span data-ttu-id="a0e6b-129">将来使用するために予約されている列挙定数を指定しないでください。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-129">Do not specify enumerated constants that are reserved for future use.</span></span>  
  
-   <span data-ttu-id="a0e6b-130">列挙定数を値として受け取るメソッドまたはプロパティを定義する場合は、値を検証することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-130">When you define a method or property that takes an enumerated constant as a value, consider validating the value.</span></span> <span data-ttu-id="a0e6b-131">その数値が列挙体で定義されていない場合でも、数値を列挙型にキャストできることが原因です。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-131">The reason is that you can cast a numeric value to the enumeration type even if that numeric value is not defined in the enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0e6b-132">次の例は、`FlagsAttribute` 属性の使用方法を示しています。また、<xref:System.Enum> 宣言で `FlagsAttribute` を使用する <xref:System.Enum.ToString%2A> メソッドに与える影響を示しています。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-132">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 <span data-ttu-id="a0e6b-133">次の例では、`SingleHue` と `MultiHue`の2つの色に関連する列挙を定義します。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-133">The following example defines two color-related enumerations, `SingleHue` and `MultiHue`.</span></span> <span data-ttu-id="a0e6b-134">後者には `FlagsAttribute` 属性があります。前者は無効です。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-134">The latter has the `FlagsAttribute` attribute; the former does not.</span></span> <span data-ttu-id="a0e6b-135">この例では、列挙型の基になる値を表さない整数を含む整数の範囲が列挙型にキャストされ、その文字列表現が表示される場合の動作の違いを示しています。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-135">The example shows the difference in behavior when a range of integers, including integers that do not represent underlying values of the enumeration type, are cast to the enumeration type and their string representations displayed.</span></span>   <span data-ttu-id="a0e6b-136">たとえば、3が `SingleHue` メンバーの基になる値ではなく、`FlagsAttribute` 属性によって、`Black, Red`の `MultiHue` 値として3を表すことができるため、3は `SingleHue` 値として表すことができません。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-136">For example, note that 3 cannot be represented as a `SingleHue` value because 3 is not the underlying value of any `SingleHue` member, whereas the `FlagsAttribute` attribute makes it possible to represent 3 as a `MultiHue` value of `Black, Red`.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlagsAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FlagsAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlagsAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a0e6b-137"><see cref="T:System.FlagsAttribute" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-137">Initializes a new instance of the <see cref="T:System.FlagsAttribute" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a0e6b-138">次の例では、電話会社によって提供される形式の通信を表す `PhoneService` 列挙体を定義します。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-138">The following example defines a `PhoneService` enumeration that represents forms of communication provided by a telephone company.</span></span> <span data-ttu-id="a0e6b-139">この例では、3つの異なる世帯に提供されるサービスを表す3つの変数を初期化した後、サービスがない世帯があることを示します。これには、携帯電話サービスのみが含まれ、携帯電話と土地ラインサービスの両方を備えた世帯があります。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-139">It initializes three variables representing the service provided to three different households, and then indicates which households have no service, which households have only cell phone service, and which households have both cell phone and land line service.</span></span> <span data-ttu-id="a0e6b-140">最後に、<xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> メソッドを暗黙的に呼び出して、各家庭に提供されるサービスの種類を表示します。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-140">Finally, it implicitly calls the <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> method to display the types of service provided to each household.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 <span data-ttu-id="a0e6b-141">次の例は、`FlagsAttribute` 属性の使用方法を示しています。また、<xref:System.Enum> 宣言で `FlagsAttribute` を使用する <xref:System.Enum.ToString%2A> メソッドに与える影響を示しています。</span><span class="sxs-lookup"><span data-stu-id="a0e6b-141">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
