<Type Name="BufferedStream" FullName="System.IO.BufferedStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="064727922832dc40096469cd05924718af184d80" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73388235" /></Metadata><TypeSignature Language="C#" Value="public sealed class BufferedStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BufferedStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.BufferedStream" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BufferedStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class BufferedStream sealed : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type BufferedStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="b8c0a-101">他のストリームの読み取りおよび書き込み操作に対してバッファリング レイヤーを追加します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-101">Adds a buffering layer to read and write operations on another stream.</span></span> <span data-ttu-id="b8c0a-102">このクラスは継承できません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-103">バッファーは、データをキャッシュするために使用されるメモリ内のバイトのブロックです。これにより、オペレーティングシステムへの呼び出しの回数が減少します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-103">A buffer is a block of bytes in memory used to cache data, thereby reducing the number of calls to the operating system.</span></span> <span data-ttu-id="b8c0a-104">バッファーにより、読み取りと書き込みのパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-104">Buffers improve read and write performance.</span></span> <span data-ttu-id="b8c0a-105">バッファーは、読み取りまたは書き込みのいずれかに使用できますが、両方同時に使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-105">A buffer can be used for either reading or writing, but never both simultaneously.</span></span> <span data-ttu-id="b8c0a-106">`BufferedStream` の <xref:System.IO.BufferedStream.Read%2A> および <xref:System.IO.BufferedStream.Write%2A> メソッドは、バッファーを自動的に保持します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-106">The <xref:System.IO.BufferedStream.Read%2A> and <xref:System.IO.BufferedStream.Write%2A> methods of `BufferedStream` automatically maintain the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b8c0a-107">この型は <xref:System.IDisposable> インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-107">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="b8c0a-108">型の使用が完了したら、直接的または間接的に型を破棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-108">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="b8c0a-109">直接的に型を破棄するには、`try` / `catch` ブロック内で <xref:System.IDisposable.Dispose%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-109">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="b8c0a-110">間接的に型を破棄するには、`using` (C# の場合) または `Using` (Visual Basic 言語) などの言語構成要素を使用します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-110">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="b8c0a-111">詳細については、<xref:System.IDisposable> インターフェイスに関するトピック内の「IDisposable を実装するオブジェクトの使用」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-111">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="b8c0a-112">`BufferedStream` は、特定の種類のストリームに対して構成できます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-112">`BufferedStream` can be composed around certain types of streams.</span></span> <span data-ttu-id="b8c0a-113">このメソッドは、基になるデータソースまたはリポジトリへのバイトの読み取りおよび書き込みを行うための実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-113">It provides implementations for reading and writing bytes to an underlying data source or repository.</span></span> <span data-ttu-id="b8c0a-114"><xref:System.IO.BinaryReader> と <xref:System.IO.BinaryWriter> を使用して、他のデータ型の読み取りと書き込みを行います。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-114">Use <xref:System.IO.BinaryReader> and <xref:System.IO.BinaryWriter> for reading and writing other data types.</span></span> <span data-ttu-id="b8c0a-115">`BufferedStream` は、バッファーが不要な場合に、バッファーが入力と出力の速度を低下させないように設計されています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-115">`BufferedStream` is designed to prevent the buffer from slowing down input and output when the buffer is not needed.</span></span> <span data-ttu-id="b8c0a-116">内部バッファーサイズよりも大きいサイズの読み取りと書き込みを常に行う場合は、`BufferedStream` が内部バッファーを割り当てないこともあります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-116">If you always read and write for sizes greater than the internal buffer size, then `BufferedStream` might not even allocate the internal buffer.</span></span> <span data-ttu-id="b8c0a-117">`BufferedStream` は、共有バッファーでの読み取りと書き込みもバッファリングします。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-117">`BufferedStream` also buffers reads and writes in a shared buffer.</span></span> <span data-ttu-id="b8c0a-118">ほとんどの場合、一連の読み取りまたは書き込みを実行しますが、2つの間ではあまり別のものを使用しないことを前提としています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-118">It is assumed that you will almost always be doing a series of reads or writes, but rarely alternate between the two of them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8c0a-119">次のコード例は、`NetworkStream` クラスで `BufferedStream` クラスを使用して、特定の i/o 操作のパフォーマンスを向上させる方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-119">The following code examples show how to use the `BufferedStream` class over the `NetworkStream` class to increase the performance of certain I/O operations.</span></span> <span data-ttu-id="b8c0a-120">クライアントを起動する前に、リモートコンピューターでサーバーを起動します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-120">Start the server on a remote computer before starting the client.</span></span> <span data-ttu-id="b8c0a-121">クライアントを起動するときに、コマンドライン引数としてリモートコンピューター名を指定します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-121">Specify the remote computer name as a command-line argument when starting the client.</span></span> <span data-ttu-id="b8c0a-122">パフォーマンスへの影響を表示するには、`dataArraySize` 定数と `streamBufferSize` 定数を変更します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-122">Vary the `dataArraySize` and `streamBufferSize` constants to view their effect on performance.</span></span>  
  
 <span data-ttu-id="b8c0a-123">最初の例は、クライアントで実行されるコードを示しています。2番目の例は、サーバーで実行されるコードを示しています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-123">The first example shows the code that runs on the client, and the second example shows the code that runs on the server.</span></span>  
  
 <span data-ttu-id="b8c0a-124">**例 1: クライアントで実行されるコード**</span><span class="sxs-lookup"><span data-stu-id="b8c0a-124">**Example 1: Code that runs on the client**</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#1)]
 [!code-csharp[System.IO.BufferedStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#1)]
 [!code-vb[System.IO.BufferedStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#1)]  
  
 <span data-ttu-id="b8c0a-125">**例 2: サーバーで実行されるコード**</span><span class="sxs-lookup"><span data-stu-id="b8c0a-125">**Example 2: Code that runs on the server**</span></span>  
  
 [!code-cpp[System.IO.BufferedStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CPP/server.cpp#1)]
 [!code-csharp[System.IO.BufferedStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream2/CS/server.cs#1)]
 [!code-vb[System.IO.BufferedStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream2/VB/server.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.FileStream" />
    <altmember cref="T:System.IO.MemoryStream" />
    <altmember cref="T:System.IO.Stream" />
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-126">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-126">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-127">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-127">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-128">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-128">How to: Write Text to a File</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b8c0a-129"><see cref="T:System.IO.BufferedStream" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-129">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="b8c0a-130">現在のストリーム。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-130">The current stream.</span></span></param>
        <summary><span data-ttu-id="b8c0a-131"><see cref="T:System.IO.BufferedStream" /> クラスの新しいインスタンスを、4,096 バイトの既定のバッファー サイズを使用して初期化します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-131">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class with a default buffer size of 4096 bytes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-132">このコンストラクターを使用して `BufferedStream` オブジェクトが初めて初期化されるときに、共有の読み取り/書き込みバッファーが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-132">A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor.</span></span> <span data-ttu-id="b8c0a-133">すべての読み取りと書き込みが `bufferSize`以上の場合、共有バッファーは使用されません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-133">The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b8c0a-134"><paramref name="stream" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-134"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-135">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-135">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-136">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-136">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-137">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-137">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BufferedStream (System.IO.Stream stream, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.#ctor(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BufferedStream(System::IO::Stream ^ stream, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.BufferedStream : System.IO.Stream * int -&gt; System.IO.BufferedStream" Usage="new System.IO.BufferedStream (stream, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="b8c0a-138">現在のストリーム。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-138">The current stream.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="b8c0a-139">バイト単位のバッファー サイズ。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-139">The buffer size in bytes.</span></span></param>
        <summary><span data-ttu-id="b8c0a-140"><see cref="T:System.IO.BufferedStream" /> クラスの新しいインスタンスを、指定したバッファー サイズを使用して初期化します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-140">Initializes a new instance of the <see cref="T:System.IO.BufferedStream" /> class with the specified buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-141">このコンストラクターを使用して `BufferedStream` オブジェクトが初めて初期化されるときに、共有の読み取り/書き込みバッファーが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-141">A shared read/write buffer is allocated the first time a `BufferedStream` object is initialized with this constructor.</span></span> <span data-ttu-id="b8c0a-142">すべての読み取りと書き込みが `bufferSize`以上の場合、共有バッファーは使用されません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-142">The shared buffer is not used if all reads and writes are greater than or equal to `bufferSize`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8c0a-143">このコード例は、<xref:System.IO.BufferedStream> クラス用に用意されている大規模な例の一部です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-143">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#2)]
 [!code-csharp[System.IO.BufferedStream1#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#2)]
 [!code-vb[System.IO.BufferedStream1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b8c0a-144"><paramref name="stream" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-144"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b8c0a-145"><paramref name="bufferSize" /> が負の値です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-145"><paramref name="bufferSize" /> is negative.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-146">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-146">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-147">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-147">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-148">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-148">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginRead (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b8c0a-149">データを読み込むバッファー。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-149">The buffer to read the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="b8c0a-150">ストリームから読み込んだデータの書き込み開始位置を示す <paramref name="buffer" /> 内のバイト オフセット。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-150">The byte offset in <paramref name="buffer" /> at which to begin writing data read from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="b8c0a-151">読み取る最大バイト数。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-151">The maximum number of bytes to read.</span></span></param>
        <param name="callback"><span data-ttu-id="b8c0a-152">読み取り完了時に呼び出されるオプションの非同期コールバック。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-152">An optional asynchronous callback, to be called when the read is complete.</span></span></param>
        <param name="state"><span data-ttu-id="b8c0a-153">この特定の非同期読み取り要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-153">A user-provided object that distinguishes this particular asynchronous read request from other requests.</span></span></param>
        <summary><span data-ttu-id="b8c0a-154">非同期の読み込み動作を開始します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-154">Begins an asynchronous read operation.</span></span> <span data-ttu-id="b8c0a-155">(代わりに、<see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> の使用を検討してください。)</span><span class="sxs-lookup"><span data-stu-id="b8c0a-155">(Consider using <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="b8c0a-156">まだ保留中である可能性がある非同期読み取りを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-156">An object that represents the asynchronous read, which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-157">.NET Framework 4 以前のバージョンでは、<xref:System.IO.Stream.BeginRead%2A> や <xref:System.IO.Stream.EndRead%2A> などのメソッドを使用して、非同期ファイル操作を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-157">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="b8c0a-158">これらのメソッドは、レガシコードをサポートするために [!INCLUDE[net_v45](~/includes/net-v45-md.md)] で引き続き使用できます。ただし、<xref:System.IO.BufferedStream.ReadAsync%2A>、<xref:System.IO.BufferedStream.WriteAsync%2A>、<xref:System.IO.BufferedStream.FlushAsync%2A>などの新しい非同期メソッドを使用すると、非同期のファイル操作をより簡単に実装できます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-158">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="b8c0a-159"><xref:System.IO.BufferedStream.BeginRead%2A>を呼び出すたびに、<xref:System.IO.BufferedStream.EndWrite%2A> を1回だけ呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-159"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>.</span></span> <span data-ttu-id="b8c0a-160">読み取りプロセスを終了してから別の読み取りを開始すると、デッドロックなどの望ましくない動作が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-160">Failing to end a read process before beginning another read can cause undesirable behavior such as deadlock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b8c0a-161">現在のインスタンスが読み取りをサポートしているかどうかを判断するには、<xref:System.IO.BufferedStream.CanRead%2A> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-161">Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>  
  
 <span data-ttu-id="b8c0a-162">読み取られたバイト数を調べるには、この <xref:System.IAsyncResult> で <xref:System.IO.BufferedStream.EndRead%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-162"><xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b8c0a-163"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-163"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b8c0a-164"><paramref name="offset" /> または <paramref name="count" /> が負の値です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-164"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b8c0a-165">ストリームの末尾を越える位置で非同期読み取りを実行しようとしました。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-165">Attempted an asynchronous read past the end of the stream.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b8c0a-166">バッファーの長さから <paramref name="offset" /> を引いた値が <paramref name="count" /> 未満です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-166">The buffer length minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b8c0a-167">現在のストリームは、読み取り操作をサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-167">The current stream does not support the read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="bufferedStream.BeginWrite (buffer, offset, count, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b8c0a-168">現在のストリームに書き込むデータを格納しているバッファー。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-168">The buffer containing data to write to the current stream.</span></span></param>
        <param name="offset"><span data-ttu-id="b8c0a-169">現在のストリームへのバイトのコピーを開始する位置を示す <paramref name="buffer" /> 内のバイト オフセット。インデックス番号は 0 から始まります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-169">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</span></span></param>
        <param name="count"><span data-ttu-id="b8c0a-170">書き込む最大バイト数。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-170">The maximum number of bytes to write.</span></span></param>
        <param name="callback"><span data-ttu-id="b8c0a-171">非同期の書き込み操作が完了したときに呼び出されるメソッド。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-171">The method to be called when the asynchronous write operation is completed.</span></span></param>
        <param name="state"><span data-ttu-id="b8c0a-172">この特定の非同期書き込み要求を他の要求と区別するために使用するユーザー指定のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-172">A user-provided object that distinguishes this particular asynchronous write request from other requests.</span></span></param>
        <summary><span data-ttu-id="b8c0a-173">非同期の書き込み操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-173">Begins an asynchronous write operation.</span></span> <span data-ttu-id="b8c0a-174">(代わりに、<see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> の使用を検討してください。)</span><span class="sxs-lookup"><span data-stu-id="b8c0a-174">(Consider using <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="b8c0a-175">まだ保留中である可能性がある非同期書き込みを参照するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-175">An object that references the asynchronous write which could still be pending.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-176">.NET Framework 4 以前のバージョンでは、<xref:System.IO.Stream.BeginWrite%2A> や <xref:System.IO.Stream.EndWrite%2A> などのメソッドを使用して、非同期ファイル操作を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-176">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="b8c0a-177">これらのメソッドは、レガシコードをサポートするために [!INCLUDE[net_v45](~/includes/net-v45-md.md)] で引き続き使用できます。ただし、<xref:System.IO.BufferedStream.ReadAsync%2A>、<xref:System.IO.BufferedStream.WriteAsync%2A>、<xref:System.IO.BufferedStream.FlushAsync%2A>などの新しい非同期メソッドを使用すると、非同期のファイル操作をより簡単に実装できます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-177">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="b8c0a-178"><xref:System.IO.BufferedStream.EndWrite%2A> は、<xref:System.IO.BufferedStream.BeginWrite%2A>からのすべての <xref:System.IAsyncResult> で1回だけ呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-178"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once on every <xref:System.IAsyncResult> from <xref:System.IO.BufferedStream.BeginWrite%2A>.</span></span> <span data-ttu-id="b8c0a-179">i/o 操作が完了するまで、<xref:System.IO.BufferedStream.EndWrite%2A> はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-179"><xref:System.IO.BufferedStream.EndWrite%2A> will block until the I/O operation has completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b8c0a-180"><paramref name="buffer" /> の長さから <paramref name="offset" /> を引いた長さが <paramref name="count" /> 未満です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-180"><paramref name="buffer" /> length minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b8c0a-181"><paramref name="buffer" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-181"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b8c0a-182"><paramref name="offset" /> または <paramref name="count" /> が負の値です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-182"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b8c0a-183">ストリームは書き込みをサポートしません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-183">The stream does not support writing.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BufferSize">
      <MemberSignature Language="C#" Value="public int BufferSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.BufferSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BufferSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BufferSize : int" Usage="System.IO.BufferedStream.BufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b8c0a-184">このバッファー ストリームのバッファー サイズをバイト単位で取得します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-184">Gets the buffer size in bytes for this buffered stream.</span></span></summary>
        <value><span data-ttu-id="b8c0a-185">バッファーサイズをバイト単位で表す整数。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-185">An integer representing the buffer size in bytes.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.BufferedStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b8c0a-186">現在のストリームが読み取りをサポートしているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-186">Gets a value indicating whether the current stream supports reading.</span></span></summary>
        <value><span data-ttu-id="b8c0a-187">ストリームが読み取りをサポートしている場合は <see langword="true" />。ストリームが閉じているか、書き込み専用アクセスで開かれた場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-187"><see langword="true" /> if the stream supports reading; <see langword="false" /> if the stream is closed or was opened with write-only access.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-188"><xref:System.IO.Stream> から派生したクラスで読み取りがサポートされていない場合、<xref:System.IO.BufferedStream.Read%2A>、<xref:System.IO.BufferedStream.ReadByte%2A>、<xref:System.IO.Stream.BeginRead%2A>、<xref:System.IO.Stream.EndRead%2A>、`Peek` の <xref:System.IO.StreamReader>メソッド、<xref:System.IO.StringReader>、および <xref:System.IO.TextReader> の呼び出しが <xref:System.NotSupportedException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-188">If a class derived from <xref:System.IO.Stream> does not support reading, calls to the <xref:System.IO.BufferedStream.Read%2A>, <xref:System.IO.BufferedStream.ReadByte%2A>, <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.EndRead%2A>, and the `Peek` methods of <xref:System.IO.StreamReader>, <xref:System.IO.StringReader>, and <xref:System.IO.TextReader> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="b8c0a-189">ストリームが閉じている場合、このプロパティは `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-189">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8c0a-190">このコード例は、<xref:System.IO.BufferedStream> クラス用に用意されている大規模な例の一部です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-190">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#5)]
 [!code-csharp[System.IO.BufferedStream1#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#5)]
 [!code-vb[System.IO.BufferedStream1#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-191">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-191">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-192">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-192">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-193">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-193">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.BufferedStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b8c0a-194">現在のストリームがシークをサポートしているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-194">Gets a value indicating whether the current stream supports seeking.</span></span></summary>
        <value><span data-ttu-id="b8c0a-195">ストリームがシークをサポートしている場合は <see langword="true" />。ストリームが閉じているか、ストリームがパイプまたはコンソールへの出力などのオペレーティング システム ハンドルから構築された場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-195"><see langword="true" /> if the stream supports seeking; <see langword="false" /> if the stream is closed or if the stream was constructed from an operating system handle such as a pipe or output to the console.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-196"><xref:System.IO.Stream> から派生したクラスがシークをサポートしていない場合、<xref:System.IO.BufferedStream.Length%2A>、<xref:System.IO.BufferedStream.SetLength%2A>、<xref:System.IO.BufferedStream.Position%2A>、および <xref:System.IO.BufferedStream.Seek%2A> を呼び出すと、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-196">If a class derived from <xref:System.IO.Stream> does not support seeking, calls to <xref:System.IO.BufferedStream.Length%2A>, <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Position%2A>, and <xref:System.IO.BufferedStream.Seek%2A> throw a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="b8c0a-197">ストリームが閉じている場合、このプロパティは `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-197">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8c0a-198">このコード例は、<xref:System.IO.BufferedStream> クラス用に用意されている大規模な例の一部です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-198">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#3)]
 [!code-csharp[System.IO.BufferedStream1#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#3)]
 [!code-vb[System.IO.BufferedStream1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.SetLength(System.Int64)" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-199">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-199">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-200">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-200">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-201">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-201">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.BufferedStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b8c0a-202">現在のストリームが書き込みをサポートしているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-202">Gets a value indicating whether the current stream supports writing.</span></span></summary>
        <value><span data-ttu-id="b8c0a-203">ストリームが書き込みをサポートしている場合は <see langword="true" />。ストリームが閉じているか、読み取り専用アクセスで開かれた場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-203"><see langword="true" /> if the stream supports writing; <see langword="false" /> if the stream is closed or was opened with read-only access.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-204"><xref:System.IO.Stream> から派生したクラスが書き込みをサポートしていない場合、<xref:System.IO.BufferedStream.SetLength%2A>、<xref:System.IO.BufferedStream.Write%2A>、または <xref:System.IO.BufferedStream.WriteByte%2A> を呼び出すと、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-204">If a class derived from <xref:System.IO.Stream> does not support writing, a call to <xref:System.IO.BufferedStream.SetLength%2A>, <xref:System.IO.BufferedStream.Write%2A>, or <xref:System.IO.BufferedStream.WriteByte%2A> throws a <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="b8c0a-205">ストリームが閉じている場合、このプロパティは `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-205">If the stream is closed, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8c0a-206">このコード例は、<xref:System.IO.BufferedStream> クラス用に用意されている大規模な例の一部です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-206">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#4)]
 [!code-csharp[System.IO.BufferedStream1#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#4)]
 [!code-vb[System.IO.BufferedStream1#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-207">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-207">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-208">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-208">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-209">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-209">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="bufferedStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b8c0a-210">ストリームを閉じ、現在のバッファー済みストリームに関連付けられているすべてのリソース (特に、ソケットやファイル ハンドルなどのシステム リソース) を解放します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-210">Closes the stream and releases any resources (especially system resources such as sockets and file handles) associated with the current buffered stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="b8c0a-211">バッファーに書き込まれたすべてのデータは、バッファーストリームが閉じられる前に、基になるデータソースまたはリポジトリにコピーされます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-211">Any data previously written to the buffer is copied to the underlying data source or repository before the buffered stream is closed.</span></span> <span data-ttu-id="b8c0a-212">そのため、Close を呼び出す前に <xref:System.IO.BufferedStream.Flush> を呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-212">Therefore, it is not necessary to call <xref:System.IO.BufferedStream.Flush> before invoking Close.</span></span> <span data-ttu-id="b8c0a-213">Close の呼び出しの後に、バッファーストリームに対する操作を実行すると、例外が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-213">Following a call to Close, any operations on the buffered stream might raise exceptions.</span></span>

<span data-ttu-id="b8c0a-214">明示的に <xref:System.IO.BufferedStream.Flush> または閉じる場合を除き、ストリームをフラッシュしても、基になるエンコーダーはフラッシュされません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-214">Flushing the stream will not flush its underlying encoder unless you explicitly call <xref:System.IO.BufferedStream.Flush> or Close.</span></span> <span data-ttu-id="b8c0a-215"><xref:System.IO.StreamWriter.AutoFlush> を true に設定すると、バッファーからストリームにデータがフラッシュされますが、エンコーダーの状態はフラッシュされません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-215">Setting <xref:System.IO.StreamWriter.AutoFlush> to true means that data will be flushed from the buffer to the stream, but the encoder state will not be flushed.</span></span> <span data-ttu-id="b8c0a-216">これにより、エンコーダーは次の文字ブロックを正しくエンコードできるように、その状態 (部分文字) を保持できます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-216">This allows the encoder to keep its state (partial characters) so that it can encode the next block of characters correctly.</span></span> <span data-ttu-id="b8c0a-217">このシナリオは、エンコーダーが隣接する文字を受け取ると、特定の文字のみをエンコードできる UTF8 と UTF7 に影響します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-217">This scenario affects UTF8 and UTF7 where certain characters can only be encoded after the encoder receives the adjacent character or characters.</span></span>

<span data-ttu-id="b8c0a-218">閉じた後でストリームを操作しようとすると、<xref:System.ObjectDisposedException>がスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-218">Attempting to manipulate a stream after it has been closed might throw an <xref:System.ObjectDisposedException>.</span></span>

## Examples  
<span data-ttu-id="b8c0a-219">このコード例は、<xref:System.IO.BufferedStream> クラス用に用意されている大規模な例の一部です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-219">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>

```vb
' When bufStream is closed, netStream is in turn 
' closed, which in turn shuts down the connection 
' and closes clientSocket.
Console.WriteLine(vbCrLf & "Shutting down the connection.")
bufStream.Close()
```

```csharp
// When bufStream is closed, netStream is in turn
// closed, which in turn shuts down the connection
// and closes clientSocket.
Console.WriteLine("\nShutting down the connection.");
bufStream.Close();
```

```cpp
// When bufStream is closed, netStream is in turn closed,
// which in turn shuts down the connection and closes
// clientSocket.
Console::WriteLine( "\nShutting down connection." );
bufStream->Close();

```

]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b8c0a-220">ストリームを閉じようとしてエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-220">An error occurred while trying to close the stream.</span></span></exception>
        <altmember cref="M:System.IO.BufferedStream.Flush" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-221">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-221">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-222">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-222">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-223">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-223">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public override void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CopyTo (destination As Stream, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CopyTo(System::IO::Stream ^ destination, int bufferSize);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.IO.Stream * int -&gt; unit" Usage="bufferedStream.CopyTo (destination, bufferSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="b8c0a-224">現在のバッファー ストリームの内容のコピー先のストリーム。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-224">The stream to which the contents of the current buffered stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="b8c0a-225">バッファーのサイズ。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-225">The size of the buffer.</span></span> <span data-ttu-id="b8c0a-226">これは、0 より大きい値である必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-226">This value must be greater than zero.</span></span> <span data-ttu-id="b8c0a-227">既定のサイズは 81920 です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-227">The default size is 81920.</span></span></param>
        <summary><span data-ttu-id="b8c0a-228">現在のバッファー ストリームからバイトを読み取り、別のストリームに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-228">Reads the bytes from the current buffered stream and writes them to another stream.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b8c0a-229"><paramref name="destination" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-229"><paramref name="destination" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b8c0a-230"><paramref name="bufferSize" /> が負の値またはゼロです。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-230"><paramref name="bufferSize" /> is negative or zero.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b8c0a-231">現在のストリームは読み取りをサポートしません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-231">The current stream does not support reading.</span></span>

<span data-ttu-id="b8c0a-232">- または -</span><span class="sxs-lookup"><span data-stu-id="b8c0a-232">-or-</span></span>

<span data-ttu-id="b8c0a-233"><paramref name="destination" /> は、書き込みをサポートしません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-233"><paramref name="destination" /> does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b8c0a-234"><see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> メソッドが呼び出される前に、現在のストリームまたは <paramref name="destination" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-234">Either the current stream or <paramref name="destination" /> was closed before the <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> method was called.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b8c0a-235">I/O エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-235">An I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ CopyToAsync(System::IO::Stream ^ destination, int bufferSize, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.CopyToAsync : System.IO.Stream * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.CopyToAsync (destination, bufferSize, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="b8c0a-236">現在のバッファー ストリームの内容のコピー先のストリーム。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-236">The stream to which the contents of the current buffered stream will be copied.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="b8c0a-237">バッファーのサイズ (バイト数)。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-237">The size, in bytes, of the buffer.</span></span> <span data-ttu-id="b8c0a-238">これは、0 より大きい値である必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-238">This value must be greater than zero.</span></span> <span data-ttu-id="b8c0a-239">既定のサイズは 81920 です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-239">The default sizer is 81920.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b8c0a-240">キャンセル要求を監視するためのトークン。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-240">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="b8c0a-241">既定値は <see cref="P:System.Threading.CancellationToken.None" /> です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-241">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="b8c0a-242">現在のバッファー ストリームからバイトを非同期に読み取り、指定されたバッファー サイズとキャンセル トークンを使用して、別のストリームに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-242">Asynchronously reads the bytes from the current buffered stream and writes them to another stream, using a specified buffer size and cancellation token.</span></span></summary>
        <returns><span data-ttu-id="b8c0a-243">非同期のコピー操作を表すタスク。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-243">A task that represents the asynchronous copy operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="b8c0a-244">`CopyToAsync` メソッドを使用すると、メインスレッドをブロックせずに、リソースを集中的に使用する i/o 操作を実行できます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-244">The `CopyToAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="b8c0a-245">このパフォーマンスに関する考慮事項は、時間のかかるストリーム操作によって UI スレッドがブロックされ、アプリが動作していないと見なされる可能性がある [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリまたは[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] アプリで特に重要です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-245">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="b8c0a-246">非同期メソッドは Visual Basic およびC#の `async` および `await` キーワードと組み合わせて使用されます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-246">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>  

<span data-ttu-id="b8c0a-247">操作が完了前にキャンセルされた場合、返されたタスクには、<xref:System.Threading.Tasks.Task.Status%2A> プロパティの <xref:System.Threading.Tasks.TaskStatus.Canceled> 値が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-247">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled> value for the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span>  

<span data-ttu-id="b8c0a-248">コピーは、現在のストリームの現在位置から開始します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-248">Copying begins at the current position in the current stream.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="bufferedStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="b8c0a-249">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-249"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="b8c0a-250">バッファー ストリームで使用しているアンマネージド リソースを解放し、オプションでマネージド リソースも解放します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-250">Releases the unmanaged resources used by the buffered stream and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="b8c0a-251">`disposing`に `true` を指定して、すべてのリソースを解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-251">You should release all resources by specifying `true` for `disposing`.</span></span> <span data-ttu-id="b8c0a-252">`disposing` が `true`場合、ストリームは、基になるバッファーにデータがフラッシュされることを確認し、その他のファイナライズ可能なオブジェクトにアクセスすることもできます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-252">When `disposing` is `true`, the stream can also ensure data is flushed to the underlying buffer, and access other finalizable objects.</span></span> <span data-ttu-id="b8c0a-253">ファイナライザーの順序が不足しているためにファイナライザーから呼び出された場合は、これが不可能になることがあります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-253">This may not be possible when called from a finalizer due a lack of ordering among finalizers.</span></span>

<span data-ttu-id="b8c0a-254">ストリームがソースとの通信にオペレーティングシステムハンドルを使用している場合は、このために <xref:System.Runtime.InteropServices.SafeHandle> のサブクラスを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-254">If your stream is using an operating system handle to communicate with its source, consider using a subclass of <xref:System.Runtime.InteropServices.SafeHandle> for this purpose.</span></span>

<span data-ttu-id="b8c0a-255">このメソッドは、パブリック <xref:System.ComponentModel.Component.Dispose> メソッドと <xref:System.Object.Finalize%2A> メソッドによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-255">This method is called by the public <xref:System.ComponentModel.Component.Dispose> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="b8c0a-256"><xref:System.ComponentModel.Component.Dispose> は、`disposing` パラメーターを `true` に設定して、protected `Dispose(Boolean)` メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-256"><xref:System.ComponentModel.Component.Dispose> invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="b8c0a-257"><xref:System.Object.Finalize%2A> は、`disposing` が `false` に設定された `Dispose(Boolean)` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-257"><xref:System.Object.Finalize%2A> invokes `Dispose(Boolean)` with `disposing` set to `false`.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="bufferedStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b8c0a-258">バッファー ストリームで使用されているアンマネージ リソースを非同期に解放します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-258">Asynchronously releases the unmanaged resources used by the buffered stream.</span></span></summary>
        <returns><span data-ttu-id="b8c0a-259">非同期の破棄操作を表すタスク。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-259">A task that represents the asynchronous dispose operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b8c0a-260">`DisposeAsync` メソッドを使用すると、メインスレッドをブロックせずに、リソースを集中的に使用する dispose 操作を実行できます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-260">The `DisposeAsync` method enables you to perform a resource-intensive dispose operation without blocking the main thread.</span></span> <span data-ttu-id="b8c0a-261">このパフォーマンスに関する考慮事項は、時間のかかるストリーム操作によって UI スレッドがブロックされ、アプリが動作していないと見なされる可能性がある [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリまたは[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] アプリで特に重要です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-261">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="b8c0a-262">非同期メソッドは Visual Basic およびC#の `async` および `await` キーワードと組み合わせて使用されます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-262">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="b8c0a-263">このメソッドは、バッキングストアに変更を書き込んでストリームを破棄し、リソースを解放するためにストリームを閉じます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-263">This method disposes the stream by writing any changes to the backing store and closing the stream to release resources.</span></span>

<span data-ttu-id="b8c0a-264">`DisposeAsync` を呼び出すと、<xref:System.IO.BufferedStream> によって使用されるリソースを他の目的で再割り当てできます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-264">Calling `DisposeAsync` allows the resources used by the <xref:System.IO.BufferedStream> to be reallocated for other purposes.</span></span> <span data-ttu-id="b8c0a-265">詳細については、「[アンマネージリソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-265">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="bufferedStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="b8c0a-266">待機する保留状態の非同期要求への参照。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-266">The reference to the pending asynchronous request to wait for.</span></span></param>
        <summary><span data-ttu-id="b8c0a-267">保留中の非同期の読み取り操作が完了するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-267">Waits for the pending asynchronous read operation to complete.</span></span> <span data-ttu-id="b8c0a-268">(代わりに、<see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> の使用を検討してください。)</span><span class="sxs-lookup"><span data-stu-id="b8c0a-268">(Consider using <see cref="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <returns><span data-ttu-id="b8c0a-269">ストリームから読み取ったバイト数 (0 ～要求したバイト数の数値)。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-269">The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested.</span></span> <span data-ttu-id="b8c0a-270">ストリームの末尾では 0 が返されるだけです、それ以外の場合は、少なくとも 1 バイトが読み込み可能になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-270">Streams only return 0 only at the end of the stream, otherwise, they should block until at least 1 byte is available.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-271">.NET Framework 4 以前のバージョンでは、<xref:System.IO.Stream.BeginRead%2A> や <xref:System.IO.Stream.EndRead%2A> などのメソッドを使用して、非同期ファイル操作を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-271">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginRead%2A> and <xref:System.IO.Stream.EndRead%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="b8c0a-272">これらのメソッドは、レガシコードをサポートするために [!INCLUDE[net_v45](~/includes/net-v45-md.md)] で引き続き使用できます。ただし、<xref:System.IO.BufferedStream.ReadAsync%2A>、<xref:System.IO.BufferedStream.WriteAsync%2A>、<xref:System.IO.BufferedStream.FlushAsync%2A>などの新しい非同期メソッドを使用すると、非同期のファイル操作をより簡単に実装できます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-272">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="b8c0a-273">読み取られたバイト数を調べるには、この <xref:System.IAsyncResult> で <xref:System.IO.BufferedStream.EndRead%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-273"><xref:System.IO.BufferedStream.EndRead%2A> must be called with this <xref:System.IAsyncResult> to find out how many bytes were read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b8c0a-274"><paramref name="asyncResult" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-274"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b8c0a-275">この <see cref="T:System.IAsyncResult" /> オブジェクトは、このクラスで <see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> を呼び出すことによって作成されませんでした。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-275">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.BufferedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="bufferedStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="b8c0a-276">保留中の非同期の要求。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-276">The pending asynchronous request.</span></span></param>
        <summary><span data-ttu-id="b8c0a-277">非同期の書き込み操作を終了し、I/O 操作が完了するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-277">Ends an asynchronous write operation and blocks until the I/O operation is complete.</span></span> <span data-ttu-id="b8c0a-278">(代わりに、<see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> の使用を検討してください。)</span><span class="sxs-lookup"><span data-stu-id="b8c0a-278">(Consider using <see cref="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead.)</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-279">.NET Framework 4 以前のバージョンでは、<xref:System.IO.Stream.BeginWrite%2A> や <xref:System.IO.Stream.EndWrite%2A> などのメソッドを使用して、非同期ファイル操作を実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-279">In the .NET Framework 4 and earlier versions, you have to use methods such as <xref:System.IO.Stream.BeginWrite%2A> and <xref:System.IO.Stream.EndWrite%2A> to implement asynchronous file operations.</span></span> <span data-ttu-id="b8c0a-280">これらのメソッドは、レガシコードをサポートするために [!INCLUDE[net_v45](~/includes/net-v45-md.md)] で引き続き使用できます。ただし、<xref:System.IO.BufferedStream.ReadAsync%2A>、<xref:System.IO.BufferedStream.WriteAsync%2A>、<xref:System.IO.BufferedStream.FlushAsync%2A>などの新しい非同期メソッドを使用すると、非同期のファイル操作をより簡単に実装できます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-280">These methods are still available in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] to support legacy code; however, the new async methods, such as <xref:System.IO.BufferedStream.ReadAsync%2A>, <xref:System.IO.BufferedStream.WriteAsync%2A>, and <xref:System.IO.BufferedStream.FlushAsync%2A>, help you implement asynchronous file operations more easily.</span></span>  
  
 <span data-ttu-id="b8c0a-281"><xref:System.IO.BufferedStream.BeginRead%2A>を呼び出すたびに、<xref:System.IO.BufferedStream.EndWrite%2A> を1回だけ呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-281"><xref:System.IO.BufferedStream.EndWrite%2A> must be called exactly once for every call to <xref:System.IO.BufferedStream.BeginRead%2A>.</span></span> <span data-ttu-id="b8c0a-282">読み取りプロセスを終了してから別の読み取り操作を開始すると、デッドロックまたはその他の望ましくない動作が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-282">Failing to end a read process before beginning another read operation can cause deadlock or other undesirable behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b8c0a-283"><paramref name="asyncResult" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-283"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b8c0a-284">この <see cref="T:System.IAsyncResult" /> オブジェクトは、このクラスで <see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> を呼び出すことによって作成されませんでした。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-284">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.BufferedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="bufferedStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b8c0a-285">このストリームに対応するすべてのバッファーをクリアし、バッファー内のデータを基になるデバイスに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-285">Clears all buffers for this stream and causes any buffered data to be written to the underlying device.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-286">明示的に `Flush` または <xref:System.IO.Stream.Close%2A> を呼び出さない限り、ストリームをフラッシュしても、基になるエンコーダーはフラッシュされません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-286">Flushing the stream will not flush its underlying encoder unless you explicitly call `Flush` or <xref:System.IO.Stream.Close%2A>.</span></span>  
  
 <span data-ttu-id="b8c0a-287"><xref:System.IO.BufferedStream.%23ctor%2A> コンストラクターを使用して、`BufferedStream` オブジェクトの作成中にバッファーサイズを指定すると、バッファーサイズに達したときにコンテンツがフラッシュされます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-287">If you use the <xref:System.IO.BufferedStream.%23ctor%2A> constructor, thus specifying the buffer size while creating the `BufferedStream` object, the content is flushed when it reaches the buffer size.</span></span> <span data-ttu-id="b8c0a-288">たとえば、`BufferedStream bs = new BufferedStream(bs, 5)` などのコードは、バッファーサイズが5バイトに達したときにコンテンツをフラッシュします。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-288">For example, code such as `BufferedStream bs = new BufferedStream(bs, 5)` will flush the content when the buffer size reaches 5 bytes.</span></span>  
  
 <span data-ttu-id="b8c0a-289">`BufferedStream` のすべての読み取りおよび書き込みのメソッドは、バッファーを自動的に保持するため、読み取りと書き込みを切り替えるときに `Flush` を呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-289">All the read and write methods of `BufferedStream` automatically maintain the buffer, so there is no need to invoke `Flush` when switching back and forth between reading and writing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8c0a-290">このコード例は、<xref:System.IO.BufferedStream> クラス用に用意されている大規模な例の一部です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-290">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b8c0a-291">ストリームは破棄されています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-291">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b8c0a-292">データ ソースまたはリポジトリが開いていません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-292">The data source or repository is not open.</span></span></exception>
        <altmember cref="M:System.IO.Stream.Close" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-293">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-293">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-294">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-294">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-295">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-295">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="b8c0a-296">キャンセル要求を監視するためのトークン。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-296">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="b8c0a-297">ストリームに対応するすべてのバッファーを非同期にクリアし、バッファー内のデータを基になるデバイスに書き込み、キャンセル要求を監視します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-297">Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="b8c0a-298">非同期のフラッシュ操作を表すタスク。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-298">A task that represents the asynchronous flush operation.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b8c0a-299">ストリームは破棄されています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-299">The stream has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.BufferedStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b8c0a-300">ストリームの長さ (バイト単位) を取得します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-300">Gets the stream length in bytes.</span></span></summary>
        <value><span data-ttu-id="b8c0a-301">バイト単位のストリーム長。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-301">The stream length in bytes.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b8c0a-302">基になるストリームが <see langword="null" /> であるか、閉じています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-302">The underlying stream is <see langword="null" /> or closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b8c0a-303">このストリームはシークをサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-303">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b8c0a-304">ストリームが閉じた後でメソッドが呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-304">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-305">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-305">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-306">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-306">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-307">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-307">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.BufferedStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b8c0a-308">現在のストリーム内の位置を取得します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-308">Gets the position within the current stream.</span></span></summary>
        <value><span data-ttu-id="b8c0a-309">現在のストリーム内の位置。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-309">The position within the current stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-310">`get` アクセサーは、基になるストリーム内の現在位置を取得するために <xref:System.IO.BufferedStream.Seek%2A> を呼び出し、バッファー内の現在位置に応じてこの値を調整します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-310">The `get` accessor invokes <xref:System.IO.BufferedStream.Seek%2A> to obtain the current position within the underlying stream and then adjusts this value according to the current position within the buffer.</span></span>  
  
 <span data-ttu-id="b8c0a-311">`set` アクセサーは、以前にバッファーに書き込まれたすべてのデータを基になるストリームにコピーし、<xref:System.IO.BufferedStream.Seek%2A>を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-311">The `set` accessor copies any data previously written to the buffer to the underlying stream, and then invokes <xref:System.IO.BufferedStream.Seek%2A>.</span></span>  
  
 <span data-ttu-id="b8c0a-312">ストリームの長さを超えた場所へのシークはサポートされています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-312">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b8c0a-313"><see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /> に渡される値が負の値です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-313">The value passed to <see cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b8c0a-314">ストリームが閉じられているなどの I/O エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-314">An I/O error occurs, such as the stream being closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b8c0a-315">このストリームはシークをサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-315">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b8c0a-316">ストリームが閉じた後でメソッドが呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-316">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="P:System.IO.BufferedStream.CanSeek" />
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-317">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-317">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-318">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-318">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-319">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-319">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="bufferedStream.Read destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="b8c0a-320">メモリの領域。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-320">A region of memory.</span></span> <span data-ttu-id="b8c0a-321">このメソッドが戻ると、この領域のコンテンツは現在のソースから読み取られたバイトに置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-321">When this method returns, the contents of this region are replaced by the bytes read from the current source.</span></span></param>
        <summary><span data-ttu-id="b8c0a-322">現在のバッファー ストリームからバイトの範囲にバイトをコピーし、読み取ったバイト数だけバッファー ストリーム内の現在位置を進めます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-322">Copies bytes from the current buffered stream to a byte span and advances the position within the buffered stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="b8c0a-323">バッファーに読み取られた合計バイト数。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-323">The total number of bytes read into the buffer.</span></span> <span data-ttu-id="b8c0a-324">要求しただけのバイト数を読み取ることができなかった場合、この値はバッファーに割り当てられているバイト数より小さくなります。ストリームの末尾に到達した場合は 0 (ゼロ) になることがあります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-324">This can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="b8c0a-325">現在のインスタンスが読み取りをサポートしているかどうかを判断するには、<xref:System.IO.BufferedStream.CanRead%2A> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-325">Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span> <span data-ttu-id="b8c0a-326">現在のストリームから非同期的に読み取るには、<xref:System.IO.BufferedStream.ReadAsync%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-326">Use the <xref:System.IO.BufferedStream.ReadAsync%2A> method to read asynchronously from the current stream.</span></span>

<span data-ttu-id="b8c0a-327">このメソッドの実装では、現在のストリームから最大 `buffer.Length` バイトを読み取り、`buffer`に格納します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-327">Implementations of this method read a maximum of `buffer.Length` bytes from the current stream and store them in `buffer`.</span></span> <span data-ttu-id="b8c0a-328">ストリーム内の現在位置は、読み取ったバイト数だけ進んでいます。ただし、例外が発生した場合、ストリーム内の現在位置は変更されません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-328">The current position within the stream is advanced by the number of bytes read; however, if an exception occurs, the current position within the stream remains unchanged.</span></span> <span data-ttu-id="b8c0a-329">実装は、読み取ったバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-329">Implementations return the number of bytes read.</span></span> <span data-ttu-id="b8c0a-330">データが使用できない場合は、少なくとも1バイトのデータを読み取ることができるようになるまで、実装はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-330">The implementation will block until at least one byte of data can be read, in the event that no data is available.</span></span> <span data-ttu-id="b8c0a-331">`Read` は、ストリームにデータがこれ以上ない場合にのみ0を返します。これ以上のデータは必要ありません (閉じているソケットやファイルの終端など)。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-331">`Read` returns 0 only when there is no more data in the stream and no more is expected (such as a closed socket or end of file).</span></span> <span data-ttu-id="b8c0a-332">の実装では、ストリームの末尾に到達していない場合でも、要求されたバイト数よりも小さい値を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-332">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>

<span data-ttu-id="b8c0a-333">プリミティブデータ型を読み取るには <xref:System.IO.BinaryReader> を使用します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-333">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] array, int32 offset, int32 count) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="bufferedStream.Read (array, offset, count)" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="b8c0a-334">バイトをコピーするバッファー。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-334">The buffer to which bytes are to be copied.</span></span></param>
        <param name="offset"><span data-ttu-id="b8c0a-335">バイトの読み取りを開始するバッファーのバイト オフセット。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-335">The byte offset in the buffer at which to begin reading bytes.</span></span></param>
        <param name="count"><span data-ttu-id="b8c0a-336">読み取るバイト数。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-336">The number of bytes to be read.</span></span></param>
        <summary><span data-ttu-id="b8c0a-337">現在のバッファー ストリームから配列にバイトをコピーします。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-337">Copies bytes from the current buffered stream to an array.</span></span></summary>
        <returns><span data-ttu-id="b8c0a-338"><paramref name="array" /> に読み取る合計バイト数。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-338">The total number of bytes read into <paramref name="array" />.</span></span> <span data-ttu-id="b8c0a-339">要求しただけのバイト数を読み取れなかった場合、この値は要求したバイト数より小さくなります。データを読み取る前にストリームの末尾に到達した場合は 0 になります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-339">This can be less than the number of bytes requested if that many bytes are not currently available, or 0 if the end of the stream has been reached before any data can be read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-340">`Read` メソッドは、ストリームの末尾に到達した場合にのみ0を返します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-340">The `Read` method will return 0 only if the end of the stream is reached.</span></span> <span data-ttu-id="b8c0a-341">それ以外の場合は、を返す前に、`Read` は常にストリームから少なくとも1バイトを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-341">In all other cases, `Read` always reads at least one byte from the stream before returning.</span></span> <span data-ttu-id="b8c0a-342">定義上、`Read`の呼び出し時にストリームから使用できるデータがない場合、`Read` メソッドは 0 (ストリームの末尾に自動的に到達) を返します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-342">By definition, if no data is available from the stream upon a call to `Read`, the `Read` method returns 0 (the end of the stream is reached automatically).</span></span> <span data-ttu-id="b8c0a-343">の実装では、ストリームの末尾に到達していない場合でも、要求されたバイト数よりも小さい値を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-343">An implementation is free to return fewer bytes than requested even if the end of the stream has not been reached.</span></span>  
  
 <span data-ttu-id="b8c0a-344">プリミティブデータ型を読み取るには <xref:System.IO.BinaryReader> を使用します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-344">Use <xref:System.IO.BinaryReader> for reading primitive data types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b8c0a-345">このコード例は、<xref:System.IO.BufferedStream> クラス用に用意されている大規模な例の一部です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-345">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#7)]
 [!code-csharp[System.IO.BufferedStream1#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#7)]
 [!code-vb[System.IO.BufferedStream1#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b8c0a-346"><paramref name="array" /> の長さから <paramref name="offset" /> を引いた値が <paramref name="count" /> 未満です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-346">Length of <paramref name="array" /> minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b8c0a-347"><paramref name="array" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-347"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b8c0a-348"><paramref name="offset" /> または <paramref name="count" /> が負の値です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-348"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b8c0a-349">ストリームが開いていないか、<see langword="null" /> になっています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-349">The stream is not open or is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b8c0a-350">ストリームは読み取りをサポートしません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-350">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b8c0a-351">ストリームが閉じた後でメソッドが呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-351">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="M:System.Buffer.BlockCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="P:System.IO.BufferedStream.CanRead" />
        <altmember cref="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-352">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-352">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-353">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-353">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-354">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-354">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="bufferedStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b8c0a-355">データを書き込むメモリの領域。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-355">The region of memory to write the data into.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b8c0a-356">キャンセル要求を監視するためのトークン。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-356">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="b8c0a-357">既定値は <see cref="P:System.Threading.CancellationToken.None" /> です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-357">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="b8c0a-358">現在のバッファー ストリームからバイト シーケンスを非同期に読み取り、読み取ったバイト数だけバッファー ストリーム内の位置を進めます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-358">Asynchronously reads a sequence of bytes from the current buffered stream and advances the position within the buffered stream by the number of bytes read.</span></span></summary>
        <returns><span data-ttu-id="b8c0a-359">非同期の読み取り操作を表すタスク。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-359">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="b8c0a-360">その <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> プロパティの値には、バッファーに読み取られるバイトの合計数が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-360">The value of its <see cref="P:System.Threading.Tasks.ValueTask`1.Result" /> property contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="b8c0a-361">要求しただけのバイト数を読み取ることができなかった場合、結果の値はバッファーに割り当てられているバイト数より小さくなります。ストリームの末尾に到達した場合は 0 (ゼロ) になることがあります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-361">The result value can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="b8c0a-362">`ReadAsync` メソッドを使用すると、メインスレッドをブロックせずに、リソースを集中的に使用する i/o 操作を実行できます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-362">The `ReadAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="b8c0a-363">このパフォーマンスに関する考慮事項は、時間のかかるストリーム操作によって UI スレッドがブロックされ、アプリが動作していないと見なされる可能性がある [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリまたは[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] アプリで特に重要です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-363">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="b8c0a-364">非同期メソッドは Visual Basic およびC#の `async` および `await` キーワードと組み合わせて使用されます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-364">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="b8c0a-365">現在のインスタンスが読み取りをサポートしているかどうかを判断するには、<xref:System.IO.BufferedStream.CanRead%2A> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-365">Use the <xref:System.IO.BufferedStream.CanRead%2A> property to determine whether the current instance supports reading.</span></span>

<span data-ttu-id="b8c0a-366">操作が完了前にキャンセルされた場合、返されたタスクには、<xref:System.Threading.Tasks.Task.Status> プロパティの <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 値が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-366">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status> property.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="bufferedStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b8c0a-367">データを書き込むバッファー。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-367">The buffer to write the data into.</span></span></param>
        <param name="offset"><span data-ttu-id="b8c0a-368">ストリームからのデータの書き込み開始位置を示す <paramref name="buffer" /> 内のバイト オフセット。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-368">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</span></span></param>
        <param name="count"><span data-ttu-id="b8c0a-369">読み取る最大バイト数。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-369">The maximum number of bytes to read.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b8c0a-370">キャンセル要求を監視するためのトークン。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-370">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="b8c0a-371">現在のストリームからバイト シーケンスを非同期に読み取り、読み取ったバイト数だけストリーム内の位置を進め、キャンセル要求を監視します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-371">Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="b8c0a-372">非同期の読み取り操作を表すタスク。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-372">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="b8c0a-373"><paramref name="TResult" /> パラメーターの値には、バッファーに読み込まれるバイトの合計数が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-373">The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer.</span></span> <span data-ttu-id="b8c0a-374">現在使用できるバイト数が要求した数より小さい場合、結果の値は要求したバイト数より小さくなることがあります。また、ストリームの末尾に到達した場合は 0 になることがあります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-374">The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-375"><xref:System.Threading.CancellationTokenSource> クラスのインスタンスを作成し、<xref:System.Threading.CancellationTokenSource.Token%2A> プロパティを `cancellationToken` パラメーターとして渡すことによって、キャンセルトークンを作成できます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-375">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b8c0a-376"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-376"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b8c0a-377"><paramref name="offset" /> または <paramref name="count" /> が負の値です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-377"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b8c0a-378"><paramref name="offset" /> と <paramref name="count" /> の合計が、バッファーの長さよりも大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-378">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b8c0a-379">ストリームは読み取りをサポートしません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-379">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b8c0a-380">ストリームは破棄されています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-380">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b8c0a-381">ストリームは、前の読み取り操作によって現在使用されています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-381">The stream is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="bufferedStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b8c0a-382">基になるストリームからバイトを読み取り、<see langword="int" /> にキャストしたバイトを返すか、ストリームの末尾から読み取る場合は -1 を返します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-382">Reads a byte from the underlying stream and returns the byte cast to an <see langword="int" />, or returns -1 if reading from the end of the stream.</span></span></summary>
        <returns><span data-ttu-id="b8c0a-383"><see langword="int" /> にキャストしたバイト。またはストリームの末尾から読み取る場合は -1。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-383">The byte cast to an <see langword="int" />, or -1 if reading from the end of the stream.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b8c0a-384">ストリームが閉じられているなどの I/O エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-384">An I/O error occurs, such as the stream being closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b8c0a-385">ストリームは読み取りをサポートしません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-385">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b8c0a-386">ストリームが閉じた後でメソッドが呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-386">Methods were called after the stream was closed.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="b8c0a-387"><see langword="Stream" /> の既定の実装では、新しい1バイト配列が作成され、<see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-387">The default implementation on <see langword="Stream" /> creates a new single-byte array and then calls <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />.</span></span> <span data-ttu-id="b8c0a-388">これは正式には正しくありますが、非効率的です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-388">While this is formally correct, it is inefficient.</span></span> <span data-ttu-id="b8c0a-389">内部バッファーを持つすべてのストリームは、このメソッドをオーバーライドして、バッファーを直接読み取るより効率的なバージョンを提供する必要があります。これにより、すべての呼び出しで追加の配列割り当てが回避されます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-389">Any stream with an internal buffer should override this method and provide a much more efficient version that reads the buffer directly, avoiding the extra array allocation on every call.</span></span></para></block>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-390">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-390">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-391">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-391">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-392">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-392">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="bufferedStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="b8c0a-393"><paramref name="origin" /> からのバイト オフセット。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-393">A byte offset relative to <paramref name="origin" />.</span></span></param>
        <param name="origin"><span data-ttu-id="b8c0a-394">新しい位置を取得するための参照ポイントを示す <see cref="T:System.IO.SeekOrigin" /> 型の値。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-394">A value of type <see cref="T:System.IO.SeekOrigin" /> indicating the reference point from which to obtain the new position.</span></span></param>
        <summary><span data-ttu-id="b8c0a-395">現在のバッファー ストリーム内の位置を設定します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-395">Sets the position within the current buffered stream.</span></span></summary>
        <returns><span data-ttu-id="b8c0a-396">現在のバッファー ストリーム内の新しい位置。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-396">The new position within the current buffered stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-397">`offset`が負の値の場合は、`origin`で指定した位置から `offset` で指定したバイト数だけさかのぼった位置が新しい位置になります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-397">If `offset` is negative, the new position will precede the position specified by `origin` by the number of bytes specified by `offset`.</span></span> <span data-ttu-id="b8c0a-398">`offset` が0の場合、`origin`によって指定された位置が新しい位置になります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-398">If `offset` is 0, the new position will be the position specified by `origin`.</span></span> <span data-ttu-id="b8c0a-399">`offset`が正の値の場合は、`origin`で指定した位置から `offset` で指定したバイト数だけ進んだ位置が新しい位置になります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-399">If `offset` is positive, the new position will follow the position specified by `origin` by the number of bytes specified by `offset`.</span></span>  
  
 <span data-ttu-id="b8c0a-400"><xref:System.IO.BufferedStream> オブジェクトが <xref:System.IO.StreamReader> オブジェクトの基本ストリームである場合、<xref:System.IO.BufferedStream.Seek%2A> メソッドを呼び出すと、ストリームの位置がリーダーの内部バッファーの位置と一致しなくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-400">When a <xref:System.IO.BufferedStream> object is the base stream for a <xref:System.IO.StreamReader> object, calling the <xref:System.IO.BufferedStream.Seek%2A> method can cause the position of the stream to no longer match the position of the internal buffer in the reader.</span></span> <span data-ttu-id="b8c0a-401">内部バッファーをリセットするには、<xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType> メソッドを呼び出します。ただし、このメソッドはパフォーマンスを低下させるため、絶対に必要な場合にのみ呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-401">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A?displayProperty=nameWithType> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="b8c0a-402">ストリームの長さを超えた場所へのシークはサポートされています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-402">Seeking to any location beyond the length of the stream is supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b8c0a-403">ストリームが開いていないか、<see langword="null" /> になっています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-403">The stream is not open or is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b8c0a-404">このストリームはシークをサポートしていません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-404">The stream does not support seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b8c0a-405">ストリームが閉じた後でメソッドが呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-405">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="T:System.IO.SeekOrigin" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-406">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-406">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-407">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-407">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-408">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-408">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="bufferedStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b8c0a-409">必要な現在のバッファー ストリーム長を示す整数 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-409">An integer indicating the desired length of the current buffered stream in bytes.</span></span></param>
        <summary><span data-ttu-id="b8c0a-410">バッファー ストリーム長を設定します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-410">Sets the length of the buffered stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-411">バッファーは、基になるデータソースまたはリポジトリの長さを設定する前にフラッシュされます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-411">The buffer is flushed before setting the length of the underlying data source or repository.</span></span> <span data-ttu-id="b8c0a-412">指定した値がバッファーストリームの現在の長さよりも小さい場合は、バッファーストリームが切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-412">If the specified value is less than the current length of the buffered stream, the buffered stream is truncated.</span></span> <span data-ttu-id="b8c0a-413">指定した値がバッファーストリームの現在の長さより大きい場合は、バッファーストリームが展開されます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-413">If the specified value is larger than the current length of the buffered stream, the buffered stream is expanded.</span></span> <span data-ttu-id="b8c0a-414">バッファーストリームが展開されている場合は、古い長と新しい長さの間のバッファーストリームの内容が定義されていません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-414">If the buffered stream is expanded, the contents of the buffered stream between the old and the new lengths are not defined.</span></span>  
  
 <span data-ttu-id="b8c0a-415">`SetLength` は、必要に応じてバッファー書き込みをフラッシュします。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-415">`SetLength` flushes any buffered writes if necessary.</span></span>  
  
 <span data-ttu-id="b8c0a-416">ストリームは、`SetLength` が機能するための書き込みとシークの両方をサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-416">A stream must support both writing and seeking for `SetLength` to work.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b8c0a-417"><paramref name="value" /> が負の値です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-417"><paramref name="value" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b8c0a-418">ストリームが開いていないか、<see langword="null" /> になっています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-418">The stream is not open or is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b8c0a-419">ストリームでは、書き込みとシークの両方は使用できません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-419">The stream does not support both writing and seeking.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b8c0a-420">ストリームが閉じた後でメソッドが呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-420">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="M:System.IO.BufferedStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-421">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-421">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-422">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-422">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-423">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-423">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream UnderlyingStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream UnderlyingStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.BufferedStream.UnderlyingStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ UnderlyingStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingStream : System.IO.Stream" Usage="System.IO.BufferedStream.UnderlyingStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b8c0a-424">このバッファー ストリームの基になる <see cref="T:System.IO.Stream" /> インスタンスを取得します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-424">Gets the underlying <see cref="T:System.IO.Stream" /> instance for this buffered stream.</span></span></summary>
        <value><span data-ttu-id="b8c0a-425">基になるストリームインスタンス。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-425">The underlying stream instance.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="bufferedStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b8c0a-426">メモリの領域。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-426">A region of memory.</span></span> <span data-ttu-id="b8c0a-427">このメソッドでは、この領域のコンテンツが現在のバッファー ストリームにコピーされます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-427">This method copies the contents of this region to the current buffered stream.</span></span></param>
        <summary><span data-ttu-id="b8c0a-428">現在のバッファー ストリームにバイト シーケンスを書き込み、書き込んだバイト数だけこのバッファー ストリーム内の現在位置を進めます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-428">Writes a sequence of bytes to the current buffered stream and advances the current position within this buffered stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="b8c0a-429">現在のインスタンスが書き込みをサポートしているかどうかを判断するには、<xref:System.IO.BufferedStream.CanWrite%2A> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-429">Use the <xref:System.IO.BufferedStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span> <span data-ttu-id="b8c0a-430">現在のバッファーストリームに非同期に書き込むには、<xref:System.IO.BufferedStream.WriteAsync%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-430">Use the <xref:System.IO.BufferedStream.WriteAsync%2A> method to write asynchronously to the current buffered stream.</span></span>

<span data-ttu-id="b8c0a-431">書き込み操作が成功した場合、バッファーストリーム内の位置は、書き込まれたバイト数だけ進みます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-431">If the write operation is successful, the position within the buffered stream advances by the number of bytes written.</span></span> <span data-ttu-id="b8c0a-432">例外が発生した場合、バッファーストリーム内の位置は変更されません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-432">If an exception occurs, the position within the buffered stream remains unchanged.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="bufferedStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="b8c0a-433">現在のバッファー ストリームに対する <paramref name="count" /> バイトのコピー元のバイト配列。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-433">The byte array from which to copy <paramref name="count" /> bytes to the current buffered stream.</span></span></param>
        <param name="offset"><span data-ttu-id="b8c0a-434">現在のバッファー ストリームへのバイトのコピーを開始する位置のバッファーのオフセット。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-434">The offset in the buffer at which to begin copying bytes to the current buffered stream.</span></span></param>
        <param name="count"><span data-ttu-id="b8c0a-435">現在のバッファー ストリームに書き込むバイト数。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-435">The number of bytes to be written to the current buffered stream.</span></span></param>
        <summary><span data-ttu-id="b8c0a-436">バッファー ストリームにバイトをコピーし、書き込んだバイト数だけバッファー ストリーム内の現在位置を進めます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-436">Copies bytes to the buffered stream and advances the current position within the buffered stream by the number of bytes written.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b8c0a-437">このコード例は、<xref:System.IO.BufferedStream> クラス用に用意されている大規模な例の一部です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-437">This code example is part of a larger example provided for the <xref:System.IO.BufferedStream> class.</span></span>  
  
 [!code-cpp[System.IO.BufferedStream1#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CPP/client.cpp#6)]
 [!code-csharp[System.IO.BufferedStream1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.BufferedStream1/CS/client.cs#6)]
 [!code-vb[System.IO.BufferedStream1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.BufferedStream1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b8c0a-438"><paramref name="array" /> の長さから <paramref name="offset" /> を引いた値が <paramref name="count" /> 未満です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-438">Length of <paramref name="array" /> minus <paramref name="offset" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b8c0a-439"><paramref name="array" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-439"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b8c0a-440"><paramref name="offset" /> または <paramref name="count" /> が負の値です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-440"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="b8c0a-441">ストリームが閉じているか、<see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-441">The stream is closed or <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b8c0a-442">ストリームは書き込みをサポートしません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-442">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b8c0a-443">ストリームが閉じた後でメソッドが呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-443">Methods were called after the stream was closed.</span></span></exception>
        <altmember cref="P:System.IO.BufferedStream.CanWrite" />
        <altmember cref="M:System.IO.BufferedStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-444">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-444">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-445">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-445">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-446">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-446">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="bufferedStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b8c0a-447">データを書き込む元のメモリの領域。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-447">The region of memory to write data from.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b8c0a-448">キャンセル要求を監視するためのトークン。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-448">The token to monitor for cancellation requests.</span></span> <span data-ttu-id="b8c0a-449">既定値は <see cref="P:System.Threading.CancellationToken.None" /> です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-449">The default value is <see cref="P:System.Threading.CancellationToken.None" />.</span></span></param>
        <summary><span data-ttu-id="b8c0a-450">現在のバッファー ストリームにバイト シーケンスを非同期に書き込み、書き込んだバイト数だけこのバッファー ストリーム内の現在位置を進め、キャンセル要求を監視します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-450">Asynchronously writes a sequence of bytes to the current buffered stream, advances the current position within this buffered stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="b8c0a-451">非同期の書き込み操作を表すタスク。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-451">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="b8c0a-452">`WriteAsync` メソッドを使用すると、メインスレッドをブロックせずに、リソースを集中的に使用する i/o 操作を実行できます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-452">The `WriteAsync` method enables you to perform resource-intensive I/O operations without blocking the main thread.</span></span> <span data-ttu-id="b8c0a-453">このパフォーマンスに関する考慮事項は、時間のかかるストリーム操作によって UI スレッドがブロックされ、アプリが動作していないと見なされる可能性がある [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリまたは[!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] アプリで特に重要です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-453">This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working.</span></span> <span data-ttu-id="b8c0a-454">非同期メソッドは Visual Basic およびC#の `async` および `await` キーワードと組み合わせて使用されます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-454">The async methods are used in conjunction with the `async` and `await` keywords in Visual Basic and C#.</span></span>

<span data-ttu-id="b8c0a-455">現在のインスタンスが書き込みをサポートしているかどうかを判断するには、<xref:System.IO.BufferedStream.CanWrite%2A> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-455">Use the <xref:System.IO.BufferedStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

<span data-ttu-id="b8c0a-456">操作が完了前にキャンセルされた場合、返されたタスクには、<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> プロパティの <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> 値が含まれます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-456">If the operation is canceled before it completes, the returned task contains the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> value for the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property.</span></span>

            ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="bufferedStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="b8c0a-457">データの書き込み元となるバッファー。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-457">The buffer to write data from.</span></span></param>
        <param name="offset"><span data-ttu-id="b8c0a-458">ストリームへのバイトのコピーを開始する位置を示す <paramref name="buffer" /> 内のバイト オフセット。インデックス番号は 0 から始まります。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-458">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</span></span></param>
        <param name="count"><span data-ttu-id="b8c0a-459">書き込む最大バイト数。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-459">The maximum number of bytes to write.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="b8c0a-460">キャンセル要求を監視するためのトークン。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-460">The token to monitor for cancellation requests.</span></span></param>
        <summary><span data-ttu-id="b8c0a-461">現在のストリームにバイト シーケンスを非同期に書き込み、書き込んだバイト数だけストリーム内の現在位置を進め、キャンセル要求を監視します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-461">Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</span></span></summary>
        <returns><span data-ttu-id="b8c0a-462">非同期の書き込み操作を表すタスク。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-462">A task that represents the asynchronous write operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b8c0a-463"><xref:System.Threading.CancellationTokenSource> クラスのインスタンスを作成し、<xref:System.Threading.CancellationTokenSource.Token%2A> プロパティを `cancellationToken` パラメーターとして渡すことによって、キャンセルトークンを作成できます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-463">You can create a cancellation token by creating an instance of the <xref:System.Threading.CancellationTokenSource> class and passing the <xref:System.Threading.CancellationTokenSource.Token%2A> property as the `cancellationToken` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b8c0a-464"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-464"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="b8c0a-465"><paramref name="offset" /> または <paramref name="count" /> が負の値です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-465"><paramref name="offset" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="b8c0a-466"><paramref name="offset" /> と <paramref name="count" /> の合計が、バッファーの長さよりも大きいです。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-466">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b8c0a-467">ストリームは書き込みをサポートしません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-467">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b8c0a-468">ストリームは破棄されています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-468">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="b8c0a-469">ストリームは、前の書き込み操作によって現在使用されています。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-469">The stream is currently in use by a previous write operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.BufferedStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="bufferedStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b8c0a-470">ストリームに書き込むバイト。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-470">A byte to write to the stream.</span></span></param>
        <summary><span data-ttu-id="b8c0a-471">バッファー ストリームの現在位置にバイトを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-471">Writes a byte to the current position in the buffered stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="b8c0a-472">現在のインスタンスが書き込みをサポートしているかどうかを判断するには、<xref:System.IO.BufferedStream.CanWrite%2A> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-472">Use the <xref:System.IO.BufferedStream.CanWrite%2A> property to determine whether the current instance supports writing.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="b8c0a-473">ストリームは書き込みをサポートしません。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-473">The stream does not support writing.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="b8c0a-474"><paramref name="value" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-474"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="b8c0a-475">ストリームが閉じた後でメソッドが呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="b8c0a-475">Methods were called after the stream was closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="b8c0a-476">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="b8c0a-476">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="b8c0a-477">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="b8c0a-477">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="b8c0a-478">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="b8c0a-478">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
