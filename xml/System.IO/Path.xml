<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bbceb05c56c65218177af6b97840c0c9b2ab8ae0" /><Meta Name="ms.sourcegitcommit" Value="2b0967e04b047f6709322418d97215dfcef6a938" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="11/20/2019" /><Meta Name="ms.locfileid" Value="74235872" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="9a684-101">ファイルまたはディレクトリのパス情報を格納する <see cref="T:System.String" /> インスタンスで操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="9a684-101">Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information.</span></span> <span data-ttu-id="9a684-102">これらの操作は、プラットフォーム間で実行されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-102">These operations are performed in a cross-platform manner.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="9a684-103">パスは、ファイルまたはディレクトリの場所を提供する文字列です。</span><span class="sxs-lookup"><span data-stu-id="9a684-103">A path is a string that provides the location of a file or directory.</span></span> <span data-ttu-id="9a684-104">パスがディスク上の場所を指しているとは限りません。たとえば、パスは、メモリ内またはデバイス上の場所にマップされる場合があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-104">A path does not necessarily point to a location on disk; for example, a path might map to a location in memory or on a device.</span></span> <span data-ttu-id="9a684-105">パスの正確な形式は、現在のプラットフォームによって決まります。</span><span class="sxs-lookup"><span data-stu-id="9a684-105">The exact format of a path is determined by the current platform.</span></span> <span data-ttu-id="9a684-106">たとえば、一部のシステムでは、パスはドライブまたはボリューム文字で開始できますが、この要素は他のシステムには存在しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-106">For example, on some systems, a path can start with a drive or volume letter, while this element is not present in other systems.</span></span> <span data-ttu-id="9a684-107">一部のシステムでは、ファイルパスに拡張子を含めることができます。拡張子は、ファイルに格納されている情報の種類を示します。</span><span class="sxs-lookup"><span data-stu-id="9a684-107">On some systems, file paths can contain extensions, which indicate the type of information stored in the file.</span></span> <span data-ttu-id="9a684-108">ファイル名拡張子の形式はプラットフォームに依存します。たとえば、一部のシステムでは拡張機能を3文字に制限していますが、そうでない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="9a684-108">The format of a file name extension is platform-dependent; for example, some systems limit extensions to three characters, and others do not.</span></span> <span data-ttu-id="9a684-109">また、現在のプラットフォームでは、パスの要素を区切るために使用する文字セットと、パスを指定するときに使用できない文字のセットも決定されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-109">The current platform also determines the set of characters used to separate the elements of a path, and the set of characters that cannot be used when specifying paths.</span></span> <span data-ttu-id="9a684-110">これらの違いにより、`Path` クラスのフィールドと、`Path` クラスの一部のメンバーの正確な動作は、プラットフォームに依存しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-110">Because of these differences, the fields of the `Path` class as well as the exact behavior of some members of the `Path` class are platform-dependent.</span></span>  
  
 <span data-ttu-id="9a684-111">パスには、絶対または相対位置情報を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="9a684-111">A path can contain absolute or relative location information.</span></span> <span data-ttu-id="9a684-112">絶対パスは、場所を完全に指定します。ファイルまたはディレクトリは、現在の場所に関係なく一意に識別できます。</span><span class="sxs-lookup"><span data-stu-id="9a684-112">Absolute paths fully specify a location: the file or directory can be uniquely identified regardless of the current location.</span></span> <span data-ttu-id="9a684-113">相対パスは、部分的な場所を指定します。相対パスで指定されたファイルを検索するときに、現在の場所が開始点として使用されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-113">Relative paths specify a partial location: the current location is used as the starting point when locating a file specified with a relative path.</span></span> <span data-ttu-id="9a684-114">現在のディレクトリを特定するには、<xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9a684-114">To determine the current directory, call <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>.</span></span>  

 <span data-ttu-id="9a684-115">.NET Core 1.1 以降のバージョンと .NET Framework 4.6.2 以降のバージョンでは、"\\? \C:\"などのデバイス名を持つファイルシステムオブジェクトへのアクセスもサポートされます。</span><span class="sxs-lookup"><span data-stu-id="9a684-115">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support access to file system objects that are device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="9a684-116">Windows でのファイルパス形式の詳細については、「 [windows システムでのファイルパス形式](~/docs/standard/io/file-path-formats.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-116">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span>

 <span data-ttu-id="9a684-117">`Path` クラスのほとんどのメンバーは、ファイルシステムとはやり取りせず、パス文字列によって指定されたファイルが存在するかどうかを検証しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-117">Most members of the `Path` class do not interact with the file system and do not verify the existence of the file specified by a path string.</span></span> <span data-ttu-id="9a684-118">パス文字列を変更する `Path` クラスメンバー (<xref:System.IO.Path.ChangeExtension%2A>など) は、ファイルシステム内のファイルの名前には影響しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-118">`Path` class members that modify a path string, such as <xref:System.IO.Path.ChangeExtension%2A>, have no effect on names of files in the file system.</span></span> <span data-ttu-id="9a684-119">ただし `Path` メンバーは、指定されたパス文字列の内容を検証し、<xref:System.IO.Path.GetInvalidPathChars%2A> メソッドから返された文字で定義されているように、文字列にパス文字列で無効な文字が含まれている場合は <xref:System.ArgumentException> 例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="9a684-119">`Path` members do, however, validate the contents of a specified path string, and throw an <xref:System.ArgumentException> exception if the string contains characters that are not valid in path strings, as defined in the characters returned from the <xref:System.IO.Path.GetInvalidPathChars%2A> method.</span></span> <span data-ttu-id="9a684-120">たとえば、Windows ベースのデスクトッププラットフォームでは、無効なパス文字に引用符 (")、小なり (\<)、より大きい (>)、パイプ (&#124;)、バックスペース (\b)、null (\ 0)、Unicode 文字 16 ~ 18、20 ~ 25 があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-120">For example, on Windows-based desktop platforms, invalid path characters might include quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0), and Unicode characters 16 through 18 and 20 through 25.</span></span>  
  
 <span data-ttu-id="9a684-121">`Path` クラスのメンバーを使用すると、ファイル名拡張子がパスの一部であるかどうかを判断したり、2つの文字列を1つのパス名に結合したりするなど、一般的な操作をすばやく簡単に実行できます。</span><span class="sxs-lookup"><span data-stu-id="9a684-121">The members of the `Path` class enable you to quickly and easily perform common operations such as determining whether a file name extension is part of a path, and combining two strings into one path name.</span></span>  
  
 <span data-ttu-id="9a684-122">`Path` クラスのすべてのメンバーは静的であるため、パスのインスタンスを使用せずに呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9a684-122">All members of the `Path` class are static and can therefore be called without having an instance of a path.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9a684-123">パスを入力文字列として受け取るメンバーでは、そのパスは適切な形式である必要があります。そうでない場合、例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="9a684-123">In members that accept a path as an input string, that path must be well-formed or an exception is raised.</span></span> <span data-ttu-id="9a684-124">たとえば、パスが完全修飾されていても、スペースで始まる場合は、クラスのメソッドでパスがトリムされません。</span><span class="sxs-lookup"><span data-stu-id="9a684-124">For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class.</span></span> <span data-ttu-id="9a684-125">そのため、パスの形式が正しくないため、例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="9a684-125">Therefore, the path is malformed and an exception is raised.</span></span> <span data-ttu-id="9a684-126">同様に、パスまたはパスの組み合わせを2回完全に修飾することはできません。</span><span class="sxs-lookup"><span data-stu-id="9a684-126">Similarly, a path or a combination of paths cannot be fully qualified twice.</span></span> <span data-ttu-id="9a684-127">たとえば、"c:\temp c:\windows" は、ほとんどの場合に例外を発生させます。</span><span class="sxs-lookup"><span data-stu-id="9a684-127">For example, "c:\temp c:\windows" also raises an exception in most cases.</span></span> <span data-ttu-id="9a684-128">パス文字列を受け取るメソッドを使用する場合は、パスが適切な形式であることを確認します。</span><span class="sxs-lookup"><span data-stu-id="9a684-128">Ensure that your paths are well-formed when using methods that accept a path string.</span></span>  
  
 <span data-ttu-id="9a684-129">パスを受け入れるメンバーでは、ファイルまたはディレクトリのみを参照できます。</span><span class="sxs-lookup"><span data-stu-id="9a684-129">In members that accept a path, the path can refer to a file or just a directory.</span></span> <span data-ttu-id="9a684-130">指定されたパスは、サーバーと共有名の相対パスまたは UNC (汎用名前付け規則) パスを参照することもできます。</span><span class="sxs-lookup"><span data-stu-id="9a684-130">The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name.</span></span> <span data-ttu-id="9a684-131">たとえば、次のすべてが許容されるパスです。</span><span class="sxs-lookup"><span data-stu-id="9a684-131">For example, all the following are acceptable paths:</span></span>  
  
-   <span data-ttu-id="9a684-132">Visual Basic の "c:\\\MyDir\\\MyFile.txt C#" または "c:\MyDir\MyFile.txt"。</span><span class="sxs-lookup"><span data-stu-id="9a684-132">"c:\\\MyDir\\\MyFile.txt" in C#, or "c:\MyDir\MyFile.txt" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="9a684-133">Visual Basic の "c:\\\MyDir C#"、または "c:\MyDir"。</span><span class="sxs-lookup"><span data-stu-id="9a684-133">"c:\\\MyDir" in C#, or "c:\MyDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="9a684-134">"の MyDir\\\MySubdir" C#、または Visual Basic の "MyDir\MySubDir"。</span><span class="sxs-lookup"><span data-stu-id="9a684-134">"MyDir\\\MySubdir" in C#, or "MyDir\MySubDir" in Visual Basic.</span></span>  
  
-   <span data-ttu-id="9a684-135">"\\\\\\\ MyServer\\\MyShare" C#、または\\の "Visual Basic 「\myserver\myshare」"。</span><span class="sxs-lookup"><span data-stu-id="9a684-135">"\\\\\\\MyServer\\\MyShare" in C#, or "\\\MyServer\MyShare" in Visual Basic.</span></span>  
  
 <span data-ttu-id="9a684-136">これらのすべての操作は文字列に対して実行されるため、結果がすべてのシナリオで有効であることを確認することはできません。</span><span class="sxs-lookup"><span data-stu-id="9a684-136">Because all these operations are performed on strings, it is impossible to verify that the results are valid in all scenarios.</span></span> <span data-ttu-id="9a684-137">たとえば、<xref:System.IO.Path.GetExtension%2A> メソッドは、渡された文字列を解析し、その文字列から拡張を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-137">For example, the <xref:System.IO.Path.GetExtension%2A> method parses a string that you pass to it and returns the extension from that string.</span></span> <span data-ttu-id="9a684-138">ただし、その拡張子を持つファイルがディスク上に存在することを意味するわけではありません。</span><span class="sxs-lookup"><span data-stu-id="9a684-138">However, this does not mean that a file with that extension exists on the disk.</span></span>  
  
 <span data-ttu-id="9a684-139">共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-139">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>   
  
## Examples  
 <span data-ttu-id="9a684-140">次の例は、`Path` クラスの主なメンバーの一部を示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-140">The following example demonstrates some of the main members of the `Path` class.</span></span>  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-141">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-141">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-142">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-142">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-143">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-143">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="9a684-144">方法 : 新しく作成されたデータ ファイルに対して読み書きする</span><span class="sxs-lookup"><span data-stu-id="9a684-144">How to: Read and Write to a Newly Created Data File</span></span></related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-145">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-145">File path formats on Windows systems</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9a684-146">階層ファイル システム編成を反映するパス文字列の、ディレクトリ レベルを区切るために使用する、プラットフォーム固有の代替文字を提供します。</span><span class="sxs-lookup"><span data-stu-id="9a684-146">Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="9a684-147">このフィールドは、<xref:System.IO.Path.DirectorySeparatorChar>と同じ値を持つことができます。</span><span class="sxs-lookup"><span data-stu-id="9a684-147">This field can have the same value as <xref:System.IO.Path.DirectorySeparatorChar>.</span></span> <span data-ttu-id="9a684-148">`AltDirectorySeparatorChar` と <xref:System.IO.Path.DirectorySeparatorChar> は両方とも、パス文字列内のディレクトリレベルを区切るために有効です。</span><span class="sxs-lookup"><span data-stu-id="9a684-148">`AltDirectorySeparatorChar` and <xref:System.IO.Path.DirectorySeparatorChar> are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="9a684-149">このフィールドの値は、Windows と Unix ベースの両方のオペレーティングシステムのスラッシュ ('/') です。</span><span class="sxs-lookup"><span data-stu-id="9a684-149">The value of this field is a slash ('/') on both Windows and Unix-based operating systems.</span></span>  
  
## Examples  

<span data-ttu-id="9a684-150">次の例では、Windows および Unix ベースのシステムで <xref:System.IO.Path> フィールド値を表示します。</span><span class="sxs-lookup"><span data-stu-id="9a684-150">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="9a684-151">Windows では、スラッシュ (<xref:System.IO.Path.AltDirectorySeparatorChar> フィールドによって返されます) または円記号 (<xref:System.IO.Path.DirectorySeparatorChar> フィールドから返されます) のいずれかがパス区切り文字としてサポートされていますが、Unix ベースのシステムではスラッシュのみがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9a684-151">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-152">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-152">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-153">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-153">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-154">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-154">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-155">変更するパス情報。</span><span class="sxs-lookup"><span data-stu-id="9a684-155">The path information to modify.</span></span> <span data-ttu-id="9a684-156">パスに、<see cref="M:System.IO.Path.GetInvalidPathChars" /> で定義された文字を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="9a684-156">The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></param>
        <param name="extension"><span data-ttu-id="9a684-157">新しい拡張子 (先行ピリオド付き、またはなし)。</span><span class="sxs-lookup"><span data-stu-id="9a684-157">The new extension (with or without a leading period).</span></span> <span data-ttu-id="9a684-158"><see langword="null" /> を指定して、<paramref name="path" /> から既存の拡張子を削除します。</span><span class="sxs-lookup"><span data-stu-id="9a684-158">Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</span></span></param>
        <summary><span data-ttu-id="9a684-159">パス文字列の拡張子を変更します。</span><span class="sxs-lookup"><span data-stu-id="9a684-159">Changes the extension of a path string.</span></span></summary>
        <returns><span data-ttu-id="9a684-160">変更されたパス情報。</span><span class="sxs-lookup"><span data-stu-id="9a684-160">The modified path information.</span></span>  
  
<span data-ttu-id="9a684-161">Windows ベースのデスクトップ プラットフォームでは、<paramref name="path" /> が <see langword="null" /> または空の文字列 ("") の場合、パス情報は変更されずに返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-161">On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified.</span></span> <span data-ttu-id="9a684-162"><paramref name="extension" /> が <see langword="null" /> の場合は、返される文字列に、削除した拡張子が付いた指定したパスが含まれます。</span><span class="sxs-lookup"><span data-stu-id="9a684-162">If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed.</span></span> <span data-ttu-id="9a684-163"><paramref name="path" /> に拡張子がなく、<paramref name="extension" /> が <see langword="null" /> でない場合は、返されるパス文字列に <paramref name="path" /> の末尾に追加される <paramref name="extension" /> が含まれます。</span><span class="sxs-lookup"><span data-stu-id="9a684-163">If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-164">`path` も `extension` にもピリオド (.) が含まれていない場合、`ChangeExtension` はピリオドを追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-164">If neither `path` nor `extension` contains a period (.), `ChangeExtension` adds the period.</span></span>  
  
 <span data-ttu-id="9a684-165">`extension` パラメーターには、複数のピリオドと有効なパス文字を含めることができ、任意の長さを指定できます。</span><span class="sxs-lookup"><span data-stu-id="9a684-165">The `extension` parameter can contain multiple periods and any valid path characters, and can be any length.</span></span> <span data-ttu-id="9a684-166">`extension` が `null`の場合、返される文字列には、最後の期間に続く `path` の内容と、その後のすべての文字が含まれます。</span><span class="sxs-lookup"><span data-stu-id="9a684-166">If `extension` is `null`, the returned string contains the contents of `path` with the last period and all characters following it removed.</span></span>  
  
 <span data-ttu-id="9a684-167">`extension` が空の文字列の場合、返されるパス文字列には、最後の期間が削除された後の文字を含む `path` の内容が含まれます。</span><span class="sxs-lookup"><span data-stu-id="9a684-167">If `extension` is an empty string, the returned path string contains the contents of `path` with any characters following the last period removed.</span></span>  
  
 <span data-ttu-id="9a684-168">`path` に拡張子がなく、`extension` が `null`ない場合、返される文字列には、`path` 後に `extension`が格納されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-168">If `path` does not have an extension and `extension` is not `null`, the returned string contains `path` followed by `extension`.</span></span>  
  
 <span data-ttu-id="9a684-169">`extension` が `null` ず、先頭のピリオドが含まれていない場合は、期間が追加されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-169">If `extension` is not `null` and does not contain a leading period, the period is added.</span></span>  
  
 <span data-ttu-id="9a684-170">複数のピリオドで区切られた複数の拡張子が `path` に含まれている場合、返される文字列には、最後の期間の `path` の内容と、それに続くすべての文字が `extension`に置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="9a684-170">If `path` contains a multiple extension separated by multiple periods, the returned string contains the contents of `path` with the last period and all characters following it replaced by `extension`.</span></span> <span data-ttu-id="9a684-171">たとえば、`path` が "\Dir1\examples\pathtests.csx.txt" で `extension` が "cs" の場合、変更されたパスは "\Dir1\examples\pathtests.csx.cs" になります。</span><span class="sxs-lookup"><span data-stu-id="9a684-171">For example, if `path` is "\Dir1\examples\pathtests.csx.txt" and `extension` is "cs", the modified path is "\Dir1\examples\pathtests.csx.cs".</span></span>  
  
 <span data-ttu-id="9a684-172">返された結果がすべてのシナリオで有効であることを確認することはできません。</span><span class="sxs-lookup"><span data-stu-id="9a684-172">It is not possible to verify that the returned results are valid in all scenarios.</span></span> <span data-ttu-id="9a684-173">たとえば、`path` が空の場合、`extension` が追加されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-173">For example, if `path` is empty, `extension` is appended.</span></span>  
  
 <span data-ttu-id="9a684-174">共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-174">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-175">次の例は、`ChangeExtension` メソッドの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-175">The following example demonstrates a use of the `ChangeExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9a684-176"><paramref name="path" /> が、<see cref="M:System.IO.Path.GetInvalidPathChars" /> で定義されている無効な文字を 1 つ以上含んでいます。</span><span class="sxs-lookup"><span data-stu-id="9a684-176"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-177">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-177">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-178">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-178">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-179">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-179">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-180">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-180">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9a684-181">複数の文字列を 1 つのパスに結合します。</span><span class="sxs-lookup"><span data-stu-id="9a684-181">Combines strings into a path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="9a684-182">このメソッドは、個々の文字列を、ファイルパスを表す1つの文字列に連結することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="9a684-182">This method is intended to concatenate individual strings into a single string that represents a file path.</span></span> <span data-ttu-id="9a684-183">ただし、最初の以外の引数にルート化されたパスが含まれている場合、前のパスコンポーネントは無視され、返された文字列はルートパスコンポーネントで始まります。</span><span class="sxs-lookup"><span data-stu-id="9a684-183">However, if an argument other than the first contains a rooted path, any previous path components are ignored, and the returned string begins with that rooted path component.</span></span> <span data-ttu-id="9a684-184">`Combine` メソッドの代わりに、<xref:System.IO.Path.Join%2A> メソッドまたは <xref:System.IO.Path.TryJoin%2A> メソッドの使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-184">As an alternative to the `Combine` method, consider using the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> methods.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="9a684-185">このメソッドは、最初の引数が絶対パスであり、次の引数が相対パスであることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="9a684-185">This method assumes that the first argument is an absolute path and that the following argument or arguments are relative paths.</span></span> <span data-ttu-id="9a684-186">そうでない場合、特に後続の引数がユーザーによって入力された文字列の場合は、代わりに <xref:System.IO.Path.Join%2A> または <xref:System.IO.Path.TryJoin%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9a684-186">If this is not the case, and particularly if any subsequent arguments are strings input by the user, call the <xref:System.IO.Path.Join%2A> or <xref:System.IO.Path.TryJoin%2A> method instead.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="9a684-187">パスの構成要素の配列。</span><span class="sxs-lookup"><span data-stu-id="9a684-187">An array of parts of the path.</span></span></param>
        <summary><span data-ttu-id="9a684-188">文字列の配列を 1 つのパスに結合します。</span><span class="sxs-lookup"><span data-stu-id="9a684-188">Combines an array of strings into a path.</span></span></summary>
        <returns><span data-ttu-id="9a684-189">結合されたパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-189">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="9a684-190">`paths` は、結合するパスの部分の配列である必要があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-190">`paths` should be an array of the parts of the path to combine.</span></span> <span data-ttu-id="9a684-191">後続のパスのいずれかが絶対パスの場合、結合操作はその絶対パスで開始され、前に結合されたすべてのパスを破棄してリセットされます。</span><span class="sxs-lookup"><span data-stu-id="9a684-191">If the one of the subsequent paths is an absolute path, then the combine operation resets starting with that absolute path, discarding all previous combined paths.</span></span>  

<span data-ttu-id="9a684-192">`paths` 内のいずれかの要素が、最後の要素がドライブではなく、<xref:System.IO.Path.DirectorySeparatorChar> または <xref:System.IO.Path.AltDirectorySeparatorChar> 文字で終了しない場合、`Combine` メソッドはその要素と次の要素の間に <xref:System.IO.Path.DirectorySeparatorChar> 文字を追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-192">If any element in `paths` but the last one is not a drive and does not end with either the <xref:System.IO.Path.DirectorySeparatorChar> or the <xref:System.IO.Path.AltDirectorySeparatorChar> character, the `Combine` method adds a <xref:System.IO.Path.DirectorySeparatorChar> character between that element and the next one.</span></span> <span data-ttu-id="9a684-193">要素がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Combine` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-193">Note that, if the element ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="9a684-194">次の例では、円記号がパスの区切り文字として使用されている場合に、Windows と Unix ベースのシステムの結果を比較します。</span><span class="sxs-lookup"><span data-stu-id="9a684-194">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 <span data-ttu-id="9a684-195">長さ0の文字列は、組み合わせたパスから省略されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-195">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="9a684-196">空白の場合、パラメーターは解析されません。</span><span class="sxs-lookup"><span data-stu-id="9a684-196">The parameters are not parsed if they have white space.</span></span>  
  
 <span data-ttu-id="9a684-197">検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Combine` メソッドでは許容されないと解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-197">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="9a684-198">たとえば、ファイルからファイルを作成した場合、`Path.Combine("c:\\", "*.txt")` は無効になることがありますが、検索文字列として有効です。</span><span class="sxs-lookup"><span data-stu-id="9a684-198">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="9a684-199">したがって、`Combine` メソッドによって正常に解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-199">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
## Examples  
 <span data-ttu-id="9a684-200">次の例では、文字列の配列を1つのパスに結合します。</span><span class="sxs-lookup"><span data-stu-id="9a684-200">The following example combines an array of strings into a path.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9a684-201">配列内の文字列の 1 つが、<see cref="M:System.IO.Path.GetInvalidPathChars" /> で定義された無効な文字を 1 つ以上含んでいます。</span><span class="sxs-lookup"><span data-stu-id="9a684-201">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9a684-202">配列内の文字列の 1 つが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9a684-202">One of the strings in the array is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-203">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-203">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="9a684-204">結合する 1 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-204">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="9a684-205">結合する 2 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-205">The second path to combine.</span></span></param>
        <summary><span data-ttu-id="9a684-206">2 つの文字列を 1 つのパスに結合します。</span><span class="sxs-lookup"><span data-stu-id="9a684-206">Combines two strings into a path.</span></span></summary>
        <returns><span data-ttu-id="9a684-207">結合されたパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-207">The combined paths.</span></span> <span data-ttu-id="9a684-208">指定したパスの 1 つが長さ 0 の文字列の場合、このメソッドは別のパスを返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-208">If one of the specified paths is a zero-length string, this method returns the other path.</span></span> <span data-ttu-id="9a684-209"><paramref name="path2" /> に絶対パスが含まれる場合、このメソッドは <paramref name="path2" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-209">If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-210">`path1` がドライブ参照 (つまり "C:" または "D:") ではなく、<xref:System.IO.Path.DirectorySeparatorChar>、<xref:System.IO.Path.AltDirectorySeparatorChar>、または <xref:System.IO.Path.VolumeSeparatorChar>で定義されている有効な区切り文字で終了していない場合、連結の前に <xref:System.IO.Path.DirectorySeparatorChar> に `path1` が追加されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-210">If `path1` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` before concatenation.</span></span> <span data-ttu-id="9a684-211">ターゲットプラットフォームに適していないパス区切り文字で `path1` が終了した場合、`Combine` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-211">Note that if `path1` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="9a684-212">次の例では、円記号がパスの区切り文字として使用されている場合に、Windows と Unix ベースのシステムの結果を比較します。</span><span class="sxs-lookup"><span data-stu-id="9a684-212">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span>  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 <span data-ttu-id="9a684-213">`path2` にルートが含まれていない場合 (たとえば、`path2` が区切り文字またはドライブ指定で始まらない場合)、結果は2つのパスを連結したものであり、区切り文字が介在します。</span><span class="sxs-lookup"><span data-stu-id="9a684-213">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="9a684-214">`path2` にルートが含まれている場合は、`path2` が返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-214">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="9a684-215">空白の場合、パラメーターは解析されません。</span><span class="sxs-lookup"><span data-stu-id="9a684-215">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="9a684-216">したがって、`path2` に空白が含まれている場合 (たとえば、"\file.txt")、<xref:System.IO.Path.Combine%2A> メソッドは `path2`だけを返すのではなく、`path1` に `path2` を追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-216">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1` instead of returning only `path2`.</span></span>  
  
 <span data-ttu-id="9a684-217">検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Combine` メソッドでは許容されないと解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-217">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="9a684-218">たとえば、ファイルからファイルを作成した場合、`Path.Combine("c:\\", "*.txt")` は無効になることがありますが、検索文字列として有効です。</span><span class="sxs-lookup"><span data-stu-id="9a684-218">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="9a684-219">したがって、`Combine` メソッドによって正常に解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-219">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
 <span data-ttu-id="9a684-220">共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-220">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-221">次の例は、Windows ベースのデスクトッププラットフォームで `Combine` メソッドを使用する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-221">The following example demonstrates using the `Combine` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9a684-222"><paramref name="path1" /> または <paramref name="path2" /> が、<see cref="M:System.IO.Path.GetInvalidPathChars" /> で定義されている無効な文字を 1 つ以上含んでいます。</span><span class="sxs-lookup"><span data-stu-id="9a684-222"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9a684-223"><paramref name="path1" /> または <paramref name="path2" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9a684-223"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-224">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-224">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-225">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-225">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-226">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-226">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-227">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-227">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="9a684-228">結合する 1 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-228">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="9a684-229">結合する 2 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-229">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="9a684-230">結合する 3 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-230">The third path to combine.</span></span></param>
        <summary><span data-ttu-id="9a684-231">3 つの文字列を 1 つのパスに結合します。</span><span class="sxs-lookup"><span data-stu-id="9a684-231">Combines three strings into a path.</span></span></summary>
        <returns><span data-ttu-id="9a684-232">結合されたパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-232">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-233">`path1` は絶対パス (たとえば、"d:\archives" または "\\\archives\public") にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-233">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").</span></span> <span data-ttu-id="9a684-234">`path2` または `path3` が絶対パスでもある場合、結合操作は以前に結合されたすべてのパスを破棄し、その絶対パスにリセットします。</span><span class="sxs-lookup"><span data-stu-id="9a684-234">If `path2` or `path3` is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="9a684-235">長さ0の文字列は、組み合わせたパスから省略されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-235">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="9a684-236">`path1` または `path2` がドライブ参照 (つまり、"C:" または "D:") ではなく、<xref:System.IO.Path.DirectorySeparatorChar>、<xref:System.IO.Path.AltDirectorySeparatorChar>、または <xref:System.IO.Path.VolumeSeparatorChar>で定義されている有効な区切り文字で終了しない場合は、連結の前に <xref:System.IO.Path.DirectorySeparatorChar> または `path1` に追加されます。`path2`</span><span class="sxs-lookup"><span data-stu-id="9a684-236">If `path1` or `path2` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to `path1` or `path2` before concatenation.</span></span> <span data-ttu-id="9a684-237">`path1` または `path2` がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Combine` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-237">Note that if `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="9a684-238">次の例では、円記号がパスの区切り文字として使用されている場合に、Windows と Unix ベースのシステムの結果を比較します。</span><span class="sxs-lookup"><span data-stu-id="9a684-238">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 <span data-ttu-id="9a684-239">`path2` にルートが含まれていない場合 (たとえば、`path2` が区切り文字またはドライブ指定で始まらない場合)、結果は2つのパスを連結したものであり、区切り文字が介在します。</span><span class="sxs-lookup"><span data-stu-id="9a684-239">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="9a684-240">`path2` にルートが含まれている場合は、`path2` が返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-240">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="9a684-241">空白の場合、パラメーターは解析されません。</span><span class="sxs-lookup"><span data-stu-id="9a684-241">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="9a684-242">したがって、`path2` に空白が含まれている場合 (たとえば、"\file.txt")、<xref:System.IO.Path.Combine%2A> メソッドは `path1`に `path2` を追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-242">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="9a684-243">検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Combine` メソッドでは許容されないと解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-243">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="9a684-244">たとえば、ファイルからファイルを作成した場合、`Path.Combine("c:\\", "*.txt")` は無効になることがありますが、検索文字列として有効です。</span><span class="sxs-lookup"><span data-stu-id="9a684-244">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="9a684-245">したがって、`Combine` メソッドによって正常に解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-245">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-246">次の例では、3つのパスを結合します。</span><span class="sxs-lookup"><span data-stu-id="9a684-246">The following example combines three paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9a684-247"><paramref name="path1" />、<paramref name="path2" />、または <paramref name="path3" /> が、<see cref="M:System.IO.Path.GetInvalidPathChars" /> で定義されている無効な文字を 1 つ以上含んでいます。</span><span class="sxs-lookup"><span data-stu-id="9a684-247"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9a684-248"><paramref name="path1" />、<paramref name="path2" />、または <paramref name="path3" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9a684-248"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-249">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-249">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="9a684-250">結合する 1 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-250">The first path to combine.</span></span></param>
        <param name="path2"><span data-ttu-id="9a684-251">結合する 2 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-251">The second path to combine.</span></span></param>
        <param name="path3"><span data-ttu-id="9a684-252">結合する 3 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-252">The third path to combine.</span></span></param>
        <param name="path4"><span data-ttu-id="9a684-253">結合する 4 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-253">The fourth path to combine.</span></span></param>
        <summary><span data-ttu-id="9a684-254">4 つの文字列を 1 つのパスに結合します。</span><span class="sxs-lookup"><span data-stu-id="9a684-254">Combines four strings into a path.</span></span></summary>
        <returns><span data-ttu-id="9a684-255">結合されたパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-255">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-256">`path1` は絶対パス (たとえば、"d:\archives" または "\\\archives\public") にする必要があります。後続のパスのいずれかが絶対パスでもある場合、結合操作は以前に結合されたすべてのパスを破棄し、その絶対パスにリセットします。</span><span class="sxs-lookup"><span data-stu-id="9a684-256">`path1` should be an absolute path (for example, "d:\archives" or "\\\archives\public").If one of the subsequent paths is also an absolute path, the combine operation discards all previously combined paths and resets to that absolute path.</span></span>  
  
 <span data-ttu-id="9a684-257">長さ0の文字列は、組み合わせたパスから省略されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-257">Zero-length strings are omitted from the combined path.</span></span>  
  
 <span data-ttu-id="9a684-258">`path1`、`path2`、または `path3` がドライブ参照 (つまり、"C:" または "D:") ではなく、<xref:System.IO.Path.DirectorySeparatorChar>、<xref:System.IO.Path.AltDirectorySeparatorChar>、または <xref:System.IO.Path.VolumeSeparatorChar>で定義されている有効な区切り文字で終了していない場合、連結の前に <xref:System.IO.Path.DirectorySeparatorChar> が追加されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-258">If `path1`, `path2`, or `path3` is not a drive reference (that is, "C:" or "D:") and does not end with a valid separator character as defined in <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar>, <xref:System.IO.Path.DirectorySeparatorChar> is appended to it before concatenation.</span></span> <span data-ttu-id="9a684-259">`path1`、`path2`、または `path3` がターゲットプラットフォームに適していないパス区切り文字で終了する場合、`Combine` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-259">Note that if `path1`, `path2`, or `path3` ends in a path separator character that is not appropriate for the target platform, the `Combine` method preserves the original path separator character and appends a supported one.</span></span> <span data-ttu-id="9a684-260">次の例では、円記号がパスの区切り文字として使用されている場合に、Windows と Unix ベースのシステムの結果を比較します。</span><span class="sxs-lookup"><span data-stu-id="9a684-260">The following example compares the result on Windows and Unix-based systems when the backslash is used as a path separator character.</span></span> 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 <span data-ttu-id="9a684-261">`path2` にルートが含まれていない場合 (たとえば、`path2` が区切り文字またはドライブ指定で始まらない場合)、結果は2つのパスを連結したものであり、区切り文字が介在します。</span><span class="sxs-lookup"><span data-stu-id="9a684-261">If `path2` does not include a root (for example, if `path2` does not start with a separator character or a drive specification), the result is a concatenation of the two paths, with an intervening separator character.</span></span> <span data-ttu-id="9a684-262">`path2` にルートが含まれている場合は、`path2` が返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-262">If `path2` includes a root, `path2` is returned.</span></span>  
  
 <span data-ttu-id="9a684-263">空白の場合、パラメーターは解析されません。</span><span class="sxs-lookup"><span data-stu-id="9a684-263">The parameters are not parsed if they have white space.</span></span> <span data-ttu-id="9a684-264">したがって、`path2` に空白が含まれている場合 (たとえば、"\file.txt")、<xref:System.IO.Path.Combine%2A> メソッドは `path1`に `path2` を追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-264">Therefore, if `path2` includes white space (for example, " \file.txt "), the <xref:System.IO.Path.Combine%2A> method appends `path2` to `path1`.</span></span>  
  
 <span data-ttu-id="9a684-265">検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Combine` メソッドでは許容されないと解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-265">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Combine` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="9a684-266">たとえば、ファイルからファイルを作成した場合、`Path.Combine("c:\\", "*.txt")` は無効になることがありますが、検索文字列として有効です。</span><span class="sxs-lookup"><span data-stu-id="9a684-266">For example, while `Path.Combine("c:\\", "*.txt")` might be invalid if you were to create a file from it, it is valid as a search string.</span></span> <span data-ttu-id="9a684-267">したがって、`Combine` メソッドによって正常に解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-267">It is therefore successfully interpreted by the `Combine` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-268">次の例では、4つのパスを結合します。</span><span class="sxs-lookup"><span data-stu-id="9a684-268">The following example combines four paths.</span></span>  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9a684-269"><paramref name="path1" />、<paramref name="path2" />、<paramref name="path3" />、または <paramref name="path4" /> が、<see cref="M:System.IO.Path.GetInvalidPathChars" /> で定義されている無効な文字を 1 つ以上含んでいます。</span><span class="sxs-lookup"><span data-stu-id="9a684-269"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9a684-270"><paramref name="path1" />、<paramref name="path2" />、<paramref name="path3" />、または <paramref name="path4" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9a684-270"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-271">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-271">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9a684-272">階層ファイル システム編成を反映するパス文字列の、ディレクトリ レベルを区切るために使用する、プラットフォーム固有の文字を提供します。</span><span class="sxs-lookup"><span data-stu-id="9a684-272">Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="9a684-273"><xref:System.IO.Path.AltDirectorySeparatorChar> と `DirectorySeparatorChar` は両方とも、パス文字列内のディレクトリレベルを区切るために有効です。</span><span class="sxs-lookup"><span data-stu-id="9a684-273"><xref:System.IO.Path.AltDirectorySeparatorChar> and `DirectorySeparatorChar` are both valid for separating directory levels in a path string.</span></span>  
  
<span data-ttu-id="9a684-274">.NET Core を使用して、複数のプラットフォームで実行されるアプリケーションを開発する場合は、次のようにします。</span><span class="sxs-lookup"><span data-stu-id="9a684-274">When you are using .NET Core to develop applications that run on multiple platforms:</span></span>

- <span data-ttu-id="9a684-275">ディレクトリ区切り記号をハードコーディングする場合は、スラッシュ (`/`) 文字を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-275">If you prefer to hard-code the directory separator character, you should use the forward slash (`/`) character.</span></span> <span data-ttu-id="9a684-276">Unix システムで認識されているディレクトリ区切り文字は、この例の出力に示されているものだけであり、Windows では <xref:System.IO.Path.AltDirectorySeparatorChar> です。</span><span class="sxs-lookup"><span data-stu-id="9a684-276">It is the only recognized directory separator character on Unix systems, as the output from the example shows, and is the <xref:System.IO.Path.AltDirectorySeparatorChar> on Windows.</span></span>

- <span data-ttu-id="9a684-277">実行時にパスの区切り文字を動的に取得し、ファイルシステムパスに組み込むには、文字列の連結を使用します。</span><span class="sxs-lookup"><span data-stu-id="9a684-277">Use string concatenation to dynamically retrieve the path separator character at runtime and incorporate it into file system paths.</span></span> <span data-ttu-id="9a684-278">たとえば、オブジェクトに適用された</span><span class="sxs-lookup"><span data-stu-id="9a684-278">For example,</span></span> 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```

   ```vb
   separator = Path.DirectorySeparatorChar
   path = $"{separator}users{separator}user1{separator}"
   ``` 

   <span data-ttu-id="9a684-279"><xref:System.IO.Path.AltDirectorySeparatorChar> プロパティから値を取得することもできます。これは、Windows と Unx の両方のシステムで同じであるためです。</span><span class="sxs-lookup"><span data-stu-id="9a684-279">You can also retrieve the value from the <xref:System.IO.Path.AltDirectorySeparatorChar> property, since it is the same on both Windows and Unx-based systems.</span></span>

- <span data-ttu-id="9a684-280"><xref:System.IO.Path.AltDirectorySeparatorChar> プロパティを取得する</span><span class="sxs-lookup"><span data-stu-id="9a684-280">Retrieve the <xref:System.IO.Path.AltDirectorySeparatorChar> property</span></span>

<span data-ttu-id="9a684-281">アプリケーションがクロスプラットフォームでない場合は、システムに適した区切り記号を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9a684-281">If your application is not cross-platform, you can use the separator appropriate for your system.</span></span>

## Examples  

<span data-ttu-id="9a684-282">次の例では、Windows および Unix ベースのシステムで <xref:System.IO.Path> フィールド値を表示します。</span><span class="sxs-lookup"><span data-stu-id="9a684-282">The following example displays <xref:System.IO.Path> field values on Windows and on Unix-based systems.</span></span> <span data-ttu-id="9a684-283">Windows では、スラッシュ (<xref:System.IO.Path.AltDirectorySeparatorChar> フィールドによって返されます) または円記号 (<xref:System.IO.Path.DirectorySeparatorChar> フィールドから返されます) のいずれかがパス区切り文字としてサポートされていますが、Unix ベースのシステムではスラッシュのみがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9a684-283">Note that Windows supports either the forward slash (which is returned by the <xref:System.IO.Path.AltDirectorySeparatorChar> field) or the backslash (which is returned by the <xref:System.IO.Path.DirectorySeparatorChar> field) as path separator characters, while Unix-based systems support only the forward slash.</span></span>  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-284">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-284">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-285">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-285">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-286">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-286">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-287">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-287">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-288">分析するパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-288">The path to analyze.</span></span></param>
        <summary><span data-ttu-id="9a684-289">読み取り専用スパンとして指定されているパスが、ディレクトリ区切り記号で終了するかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-289">Returns a value that indicates whether the path, specified as a read-only span, ends in a directory separator.</span></span></summary>
        <returns><span data-ttu-id="9a684-290">パスがディレクトリ区切り記号で終わる場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-290"><see langword="true" /> if the path ends in a directory separator; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : string -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-291">分析するパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-291">The path to analyze.</span></span></param>
        <summary><span data-ttu-id="9a684-292">指定されているパスが、ディレクトリ区切り記号で終了するかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-292">Returns a value that indicates whether the specified path ends in a directory separator.</span></span></summary>
        <returns><span data-ttu-id="9a684-293">パスがディレクトリ区切り記号で終わる場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-293"><see langword="true" /> if the path ends in a directory separator; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-294">ディレクトリ情報を取得するパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-294">The path to retrieve the directory information from.</span></span></param>
        <summary><span data-ttu-id="9a684-295">文字範囲で表された、指定されたパスのディレクトリ情報を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-295">Returns the directory information for the specified path represented by a character span.</span></span></summary>
        <returns><span data-ttu-id="9a684-296"><paramref name="path" /> のディレクトリ情報。<paramref name="path" /> が <see langword="null" />、空の範囲、またはルート (\, C:、または \\server\share) の場合は空の範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-296">Directory information for <paramref name="path" />, or an empty span if <paramref name="path" /> is <see langword="null" />, an empty span, or a root (such as \, C:, or \\server\share).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9a684-297">文字列のオーバーロードとは異なり、このメソッドはディレクトリの区切り記号を正規化しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-297">Unlike the string overload, this method doesn't normalize directory separators.</span></span>

          ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-298">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-298">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-299">ファイルまたはディレクトリのパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-299">The path of a file or directory.</span></span></param>
        <summary><span data-ttu-id="9a684-300">指定したパス文字列のディレクトリ情報を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-300">Returns the directory information for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="9a684-301"><paramref name="path" /> のディレクトリ情報。<paramref name="path" /> がルート ディレクトリを示しているか null である場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-301">Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null.</span></span> <span data-ttu-id="9a684-302"><paramref name="path" /> にディレクトリ情報が含まれていない場合は、<see cref="F:System.String.Empty" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-302">Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-303">ほとんどの場合、このメソッドによって返される文字列は、パス内のすべての文字で構成されますが、最後の <xref:System.IO.Path.DirectorySeparatorChar> や <xref:System.IO.Path.AltDirectorySeparatorChar>は含まれません。</span><span class="sxs-lookup"><span data-stu-id="9a684-303">In most cases, the string returned by this method consists of all characters in the path up to but not including the last <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span> <span data-ttu-id="9a684-304">パスがルートディレクトリ ("c:\\" など) で構成されている場合は、null が返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-304">If the path consists of a root directory, such as "c:\\", null is returned.</span></span> <span data-ttu-id="9a684-305">このメソッドは、"file:" を使用したパスをサポートしていないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-305">Note that this method does not support paths using "file:".</span></span> <span data-ttu-id="9a684-306">返されたパスには <xref:System.IO.Path.DirectorySeparatorChar> または <xref:System.IO.Path.AltDirectorySeparatorChar>が含まれていないため、返されたパスを <xref:System.IO.Path.GetDirectoryName%2A> メソッドに渡すと、結果文字列の後続の呼び出しごとに1つのフォルダーレベルが切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="9a684-306">Because the returned path does not include the <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar>, passing the returned path back into the <xref:System.IO.Path.GetDirectoryName%2A> method will result in the truncation of one folder level per subsequent call on the result string.</span></span> <span data-ttu-id="9a684-307">たとえば、パス "C:\Directory\SubDirectory\test.txt" を <xref:System.IO.Path.GetDirectoryName%2A> メソッドに渡すと、"C:\Directory\SubDirectory" が返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-307">For example, passing the path "C:\Directory\SubDirectory\test.txt" into the <xref:System.IO.Path.GetDirectoryName%2A> method will return "C:\Directory\SubDirectory".</span></span> <span data-ttu-id="9a684-308">その文字列 "C:\Directory\SubDirectory" を <xref:System.IO.Path.GetDirectoryName%2A> に渡すと、"C:\ ディレクトリ" になります。</span><span class="sxs-lookup"><span data-stu-id="9a684-308">Passing that string, "C:\Directory\SubDirectory", into <xref:System.IO.Path.GetDirectoryName%2A> will result in "C:\Directory".</span></span>  
  
 <span data-ttu-id="9a684-309">共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-309">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-310">次の例は、Windows ベースのデスクトッププラットフォームで `GetDirectoryName` メソッドを使用する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-310">The following example demonstrates using the `GetDirectoryName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9a684-311"><paramref name="path" /> パラメーターは正しくない文字を含んでおり、空か、空白のみで構成されています。</span><span class="sxs-lookup"><span data-stu-id="9a684-311">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="9a684-312"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。</span><span class="sxs-lookup"><span data-stu-id="9a684-312">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="9a684-313"><paramref name="path" /> パラメーターは、システムで定義された最大長を超えています。</span><span class="sxs-lookup"><span data-stu-id="9a684-313">The <paramref name="path" /> parameter is longer than the system-defined maximum length.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-314">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-314">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-315">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-315">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-316">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-316">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-317">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-317">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-318">拡張子の取得元のファイル パス。</span><span class="sxs-lookup"><span data-stu-id="9a684-318">The file path from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="9a684-319">読み取り専用の文字範囲で表されたファイル パスの拡張子を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-319">Returns the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="9a684-320">指定されたパスの拡張子 (ピリオド "." を含む)。<paramref name="path" /> に拡張子情報が含まれていない場合は <see cref="P:System.ReadOnlySpan`1.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-320">The extension of the specified path (including the period, "."), or <see cref="P:System.ReadOnlySpan`1.Empty" /> if <paramref name="path" /> does not have extension information.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="9a684-321">このメソッドは、`path` の拡張機能を取得します。そのためには、読み取り専用スパンの最後の文字から始まり、その最初の文字に向かって、ピリオド (".") の `path` を検索します。</span><span class="sxs-lookup"><span data-stu-id="9a684-321">This method obtains the extension of `path` by searching `path` for a period ("."), starting from the last character in the read-only span and continuing toward its first character.</span></span> <span data-ttu-id="9a684-322"><xref:System.IO.Path.DirectorySeparatorChar> または <xref:System.IO.Path.AltDirectorySeparatorChar> 文字の前にピリオドがある場合、返される読み取り専用の範囲には、その後のピリオドと文字が含まれます。それ以外の場合は <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> が返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-322">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned read-only span contains the period and the characters after it; otherwise, <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> is returned.</span></span>  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-323">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-323">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-324">拡張子の取得元のパス文字列。</span><span class="sxs-lookup"><span data-stu-id="9a684-324">The path string from which to get the extension.</span></span></param>
        <summary><span data-ttu-id="9a684-325">指定のパス文字列の拡張子 (ピリオド "." を含む) を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-325">Returns the extension (including the period ".") of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="9a684-326">指定したパスの拡張子 (ピリオド "." を含む)、<see langword="null" />、または <see cref="F:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-326">The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="9a684-327"><paramref name="path" /> が <see langword="null" /> の場合、<see cref="M:System.IO.Path.GetExtension(System.String)" /> は <see langword="null" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-327">If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />.</span></span> <span data-ttu-id="9a684-328"><paramref name="path" /> が拡張子情報を持たない場合、<see cref="M:System.IO.Path.GetExtension(System.String)" /> は <see cref="F:System.String.Empty" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-328">If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="9a684-329">このメソッドは、`path` の拡張機能を取得します。そのためには、`path` をピリオド (.) で検索し `path` の最後の文字から始まり、最初の文字に進みます。</span><span class="sxs-lookup"><span data-stu-id="9a684-329">This method obtains the extension of `path` by searching `path` for a period (.), starting with the last character in `path` and continuing toward the first character.</span></span> <span data-ttu-id="9a684-330"><xref:System.IO.Path.DirectorySeparatorChar> または <xref:System.IO.Path.AltDirectorySeparatorChar> 文字の前にピリオドがある場合、返される文字列にはピリオドとその後の文字が含まれます。それ以外の場合は <xref:System.String.Empty?displayProperty=nameWithType> が返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-330">If a period is found before a <xref:System.IO.Path.DirectorySeparatorChar> or <xref:System.IO.Path.AltDirectorySeparatorChar> character, the returned string contains the period and the characters after it; otherwise, <xref:System.String.Empty?displayProperty=nameWithType> is returned.</span></span>  
  
 <span data-ttu-id="9a684-331">共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-331">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
 
## Examples  
 <span data-ttu-id="9a684-332">次の例は、Windows ベースのデスクトッププラットフォームで `GetExtension` メソッドを使用する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-332">The following example demonstrates using the `GetExtension` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9a684-333"><paramref name="path" /> が、<see cref="M:System.IO.Path.GetInvalidPathChars" /> で定義されている無効な文字を 1 つ以上含んでいます。</span><span class="sxs-lookup"><span data-stu-id="9a684-333"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-334">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-334">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-335">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-335">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-336">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-336">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-337">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-337">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-338">ファイル名と拡張子の取得元のパスを含む読み取り専用の範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-338">A read-only span that contains the path from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="9a684-339">読み取り専用の文字範囲で表されたファイル パスのファイル名と拡張子を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-339">Returns the file name and extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="9a684-340"><paramref name="path" /> の最後のディレクトリ区切り文字の後の文字。</span><span class="sxs-lookup"><span data-stu-id="9a684-340">The characters after the last directory separator character in <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="9a684-341">返される読み取り専用スパンには、`path`の最後の区切り記号の後に続くパスの文字が含まれます。</span><span class="sxs-lookup"><span data-stu-id="9a684-341">The returned read-only span contains the characters of the path that follow the last separator in `path`.</span></span> <span data-ttu-id="9a684-342">`path` の最後の文字がボリュームまたはディレクトリの区切り文字の場合、メソッドは <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-342">If the last character in `path` is a volume or directory separator character, the method returns <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9a684-343">`path` に区切り文字が含まれていない場合、メソッドは `path`を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-343">If `path` contains no separator character, the method returns `path`.</span></span>

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-344">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-344">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-345">ファイル名と拡張子の取得元のパス文字列。</span><span class="sxs-lookup"><span data-stu-id="9a684-345">The path string from which to obtain the file name and extension.</span></span></param>
        <summary><span data-ttu-id="9a684-346">指定したパス文字列のファイル名と拡張子を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-346">Returns the file name and extension of the specified path string.</span></span></summary>
        <returns><span data-ttu-id="9a684-347"><paramref name="path" /> の最後のディレクトリ区切り文字の後の文字。</span><span class="sxs-lookup"><span data-stu-id="9a684-347">The characters after the last directory separator character in <paramref name="path" />.</span></span> <span data-ttu-id="9a684-348"><paramref name="path" /> の最後の文字がディレクトリ区切り記号またはボリューム区切り記号の場合、このメソッドは <see cref="F:System.String.Empty" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-348">If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />.</span></span> <span data-ttu-id="9a684-349"><paramref name="path" /> が <see langword="null" /> の場合、このメソッドは <see langword="null" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-349">If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="9a684-350">ファイルパスが `null`場合、戻り値は `null` です。</span><span class="sxs-lookup"><span data-stu-id="9a684-350">The returned value is `null` if the file path is `null`.</span></span>  
  
<span data-ttu-id="9a684-351">ファイル名の先頭を決定するために使用される区切り文字は <xref:System.IO.Path.DirectorySeparatorChar> と <xref:System.IO.Path.AltDirectorySeparatorChar>です。</span><span class="sxs-lookup"><span data-stu-id="9a684-351">The separator characters used to determine the start of the file name are <xref:System.IO.Path.DirectorySeparatorChar> and <xref:System.IO.Path.AltDirectorySeparatorChar>.</span></span>  

<span data-ttu-id="9a684-352">*\\*は unix 上の有効なファイル名であるため、unix ベースのプラットフォームで実行されている `GetFileName` は、 *C:\\mydir\\myfile.txt*のような Windows ベースのパスからファイル名を正しく返すことはできません `GetFileName` が、Windows ベースのプラットフォームでは、 */tmp/myfile.ext*のような unix ベースのパスからファイル名を正しく返すことができます。そのため、`GetFileName` 方法の動作は、unix ベースおよび Windows ベースのプラットフォームでは厳密には同じではありません。</span><span class="sxs-lookup"><span data-stu-id="9a684-352">Because *\\* is a legal file name on Unix, `GetFileName` running under Unix-based platforms cannot correctly return the file name from a Windows-based path like *C:\\mydir\\myfile.ext*, but `GetFileName` running under Windows-based platforms can correctly return the file name from a Unix-based path like */tmp/myfile.ext*, so the behavior of the `GetFileName` method is not strictly the same on Unix-based and Windows-based platforms.</span></span>

<span data-ttu-id="9a684-353">共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-353">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-354">次の例は、Windows ベースのデスクトッププラットフォームでの `GetFileName` メソッドの動作を示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-354">The following example demonstrates the behavior of the `GetFileName` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9a684-355"><paramref name="path" /> が、<see cref="M:System.IO.Path.GetInvalidPathChars" /> で定義されている無効な文字を 1 つ以上含んでいます。</span><span class="sxs-lookup"><span data-stu-id="9a684-355"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-356">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-356">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-357">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-357">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-358">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-358">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-359">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-359">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-360">拡張子のないファイル名の取得元のパスを含む読み取り専用の範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-360">A read-only span that contains the path from which to obtain the file name without the extension.</span></span></param>
        <summary><span data-ttu-id="9a684-361">読み取り専用の文字範囲で表されたファイル パスの拡張子のないファイル名を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-361">Returns the file name without the extension of a file path that is represented by a read-only character span.</span></span></summary>
        <returns><span data-ttu-id="9a684-362"><see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> によって返された読み取り専用の範囲内の文字 (最後のピリオド (.) と、その後に続くすべての文字を除く)。</span><span class="sxs-lookup"><span data-stu-id="9a684-362">The characters in the read-only span returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-363">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-363">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-364">ファイルのパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-364">The path of the file.</span></span></param>
        <summary><span data-ttu-id="9a684-365">指定したパス文字列のファイル名を拡張子を付けずに返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-365">Returns the file name of the specified path string without the extension.</span></span></summary>
        <returns><span data-ttu-id="9a684-366"><see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" /> によって返された文字列 (最後のピリオド (.) と、その後ろのすべての文字を除く)。</span><span class="sxs-lookup"><span data-stu-id="9a684-366">The string returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-367">このメソッドでは、パスまたはファイル名が存在するかどうかは検証されません。</span><span class="sxs-lookup"><span data-stu-id="9a684-367">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="9a684-368">共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-368">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-369">次の例は、`GetFileNameWithoutExtension` メソッドの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-369">The following example demonstrates a use of the `GetFileNameWithoutExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9a684-370"><paramref name="path" /> が、<see cref="M:System.IO.Path.GetInvalidPathChars" /> で定義されている無効な文字を 1 つ以上含んでいます。</span><span class="sxs-lookup"><span data-stu-id="9a684-370"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-371">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-371">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-372">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-372">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-373">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-373">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-374">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-374">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-375">絶対パス情報を取得する対象のファイルまたはディレクトリ。</span><span class="sxs-lookup"><span data-stu-id="9a684-375">The file or directory for which to obtain absolute path information.</span></span></param>
        <summary><span data-ttu-id="9a684-376">指定したパス文字列の絶対パスを返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-376">Returns the absolute path for the specified path string.</span></span></summary>
        <returns><span data-ttu-id="9a684-377">"C:\MyFile.txt" など、<paramref name="path" /> の完全修飾位置。</span><span class="sxs-lookup"><span data-stu-id="9a684-377">The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="9a684-378">絶対パスには、システム上のファイルまたはディレクトリを検索するために必要なすべての情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="9a684-378">The absolute path includes all information required to locate a file or directory on a system.</span></span>  
  
 <span data-ttu-id="9a684-379">`path` によって指定されたファイルまたはディレクトリが存在している必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9a684-379">The file or directory specified by `path` is not required to exist.</span></span> <span data-ttu-id="9a684-380">たとえば、 *c:\temp\newdir*が現在のディレクトリである場合、 *test.txt*などのファイル名に対して `GetFullPath` を呼び出すと、 *c:\temp\newdir\test.txt*が返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-380">For example, if *c:\temp\newdir* is the current directory, calling `GetFullPath` on a file name such as *test.txt* returns *c:\temp\newdir\test.txt*.</span></span> <span data-ttu-id="9a684-381">ファイルは存在していない必要があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-381">The file need not exist.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="9a684-382">`path` が相対パスの場合、このオーバーロードは、現在のドライブと現在のディレクトリに基づいている可能性がある絶対パスを返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-382">If `path` is a relative path, this overload returns a fully qualified path that can be based on the current drive and current directory.</span></span> <span data-ttu-id="9a684-383">現在のドライブと現在のディレクトリは、アプリケーションの実行時にいつでも変更できます。</span><span class="sxs-lookup"><span data-stu-id="9a684-383">The current drive and current directory can change at any time as an application executes.</span></span> <span data-ttu-id="9a684-384">このため、このオーバーロードによって返されるパスは事前に決定できません。</span><span class="sxs-lookup"><span data-stu-id="9a684-384">As a result, the path returned by this overload cannot be determined in advance.</span></span> <span data-ttu-id="9a684-385">決定的パスを返すには、<xref:System.IO.Path.GetFullPath(System.String,System.String)> オーバーロードを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9a684-385">To return a deterministic path, call the <xref:System.IO.Path.GetFullPath(System.String,System.String)> overload.</span></span> <span data-ttu-id="9a684-386">また、<xref:System.IO.Path.IsPathFullyQualified%2A> メソッドを呼び出して、パスが完全に修飾されているか、相対パスであるかを判断し、`GetFullPath` の呼び出しが必要であるかどうかを確認することもできます。</span><span class="sxs-lookup"><span data-stu-id="9a684-386">You can also call the <xref:System.IO.Path.IsPathFullyQualified%2A> method to determine whether a path is fully qualified or relative and therefore whether a call to `GetFullPath` is necessary.</span></span>

 <span data-ttu-id="9a684-387">ただし、`path` が存在する場合は、呼び出し元に `path`のパス情報を取得するためのアクセス許可が必要です。</span><span class="sxs-lookup"><span data-stu-id="9a684-387">However, if `path` does exist, the caller must have permission to obtain path information for `path`.</span></span> <span data-ttu-id="9a684-388"><xref:System.IO.Path> クラスのほとんどのメンバーとは異なり、このメソッドはファイルシステムにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="9a684-388">Note that unlike most members of the <xref:System.IO.Path> class, this method accesses the file system.</span></span>  
  
 <span data-ttu-id="9a684-389">このメソッドでは、現在のディレクトリと現在のボリューム情報を使用して、`path`を完全に修飾します。</span><span class="sxs-lookup"><span data-stu-id="9a684-389">This method uses the current directory and current volume information to fully qualify `path`.</span></span> <span data-ttu-id="9a684-390">`path`にのみファイル名を指定した場合、`GetFullPath` は現在のディレクトリの完全修飾パスを返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-390">If you specify a file name only in `path`, `GetFullPath` returns the fully qualified path of the current directory.</span></span>  
  
 <span data-ttu-id="9a684-391">短いファイル名を渡すと、長いファイル名に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-391">If you pass in a short file name, it is expanded to a long file name.</span></span>  
  
 <span data-ttu-id="9a684-392">パスに有意な文字が含まれていない場合、1つ以上の "." 文字の後に任意の数の空白が続くと無効になります。次に、"." または ".." として解析されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-392">If a path contains no significant characters, it is invalid unless it contains one or more "." characters followed by any number of spaces; then it will be parsed as either "." or "..".</span></span>  

<span data-ttu-id="9a684-393">.NET Core 1.1 以降のバージョンと .NET Framework 4.6.2 以降のバージョンでは、"\\? \C:\"などのデバイス名を含むパスもサポートしています。</span><span class="sxs-lookup"><span data-stu-id="9a684-393">.NET Core 1.1 and later versions and .NET Framework 4.6.2 and later versions also support paths that include device names, such as "\\?\C:\".</span></span>

<span data-ttu-id="9a684-394">Windows でのファイルパス形式の詳細については、「 [windows システムでのファイルパス形式](~/docs/standard/io/file-path-formats.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-394">For more information on file path formats on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="9a684-395">共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-395">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>
  
## Examples  
 <span data-ttu-id="9a684-396">次の例は、Windows ベースのデスクトッププラットフォームでの `GetFullPath` メソッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-396">The following example demonstrates the `GetFullPath` method on a Windows-based desktop platform.</span></span>  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9a684-397"><paramref name="path" /> が、長さが 0 の文字列であるか、空白しか含んでいないか、または <see cref="M:System.IO.Path.GetInvalidPathChars" /> で定義されている無効な文字を 1 つ以上含んでいます。</span><span class="sxs-lookup"><span data-stu-id="9a684-397"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>  
  
<span data-ttu-id="9a684-398">- または -</span><span class="sxs-lookup"><span data-stu-id="9a684-398">-or-</span></span> 
<span data-ttu-id="9a684-399">システムが絶対パスを取得できませんでした。</span><span class="sxs-lookup"><span data-stu-id="9a684-399">The system could not retrieve the absolute path.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9a684-400">呼び出し元に、必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="9a684-400">The caller does not have the required permissions.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9a684-401"><paramref name="path" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9a684-401"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9a684-402"><paramref name="path" /> に、ボリュームの識別子 ("C:\\") の一部ではないコロン (:) が含まれています。</span><span class="sxs-lookup"><span data-stu-id="9a684-402"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="9a684-403">指定したパス、ファイル名、またはその両方がシステム定義の最大長を超えています。</span><span class="sxs-lookup"><span data-stu-id="9a684-403">The specified path, file name, or both exceed the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="9a684-404">パスへのアクセスに使用します。</span><span class="sxs-lookup"><span data-stu-id="9a684-404">for access to the path.</span></span></permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-405">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-405">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-406">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-406">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-407">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-407">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-408">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-408">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-409"><paramref name="basePath" /> に連結する相対パス。</span><span class="sxs-lookup"><span data-stu-id="9a684-409">A relative path to concatenate to <paramref name="basePath" />.</span></span></param>
        <param name="basePath"><span data-ttu-id="9a684-410">完全修飾パスの先頭。</span><span class="sxs-lookup"><span data-stu-id="9a684-410">The beginning of a fully qualified path.</span></span></param>
        <summary><span data-ttu-id="9a684-411">完全修飾ベース パスと相対パスから絶対パスを返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-411">Returns an absolute path from a fully qualified base path and a relative path.</span></span></summary>
        <returns><span data-ttu-id="9a684-412">絶対パス。</span><span class="sxs-lookup"><span data-stu-id="9a684-412">The absolute path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="9a684-413">`path` が空のパスの場合、メソッドは `basePath`を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-413">If `path` is an empty path, the method returns `basePath`.</span></span> <span data-ttu-id="9a684-414">`path` が完全修飾パスの場合、メソッドは `path` を <xref:System.IO.Path.GetFullPath(System.String)> メソッドに渡し、結果を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-414">If `path` is a fully qualified path, the method passes `path` to the <xref:System.IO.Path.GetFullPath(System.String)> method and returns the result.</span></span>

<span data-ttu-id="9a684-415">相対パスを使用している場合は、このメソッドを使用して、指定したボリュームおよびルート化されたディレクトリに基づいて決定論的パスを返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-415">Use this method to return a deterministic path based on a specified volume and rooted directory when you're using relative paths.</span></span> <span data-ttu-id="9a684-416">現在のドライブのディレクトリに基づいて定義されているのではなく、定義済みの `basePath` を使用すると、現在のドライブとディレクトリで予期しない変更が発生したことが原因で望ましくないファイルパスに対する保護が</span><span class="sxs-lookup"><span data-stu-id="9a684-416">Using a predefined `basePath` rather than one based on the current drive directory guards against unwanted file paths caused by unexpected changes in the current drive and directory.</span></span> 

## <a name="example"></a><span data-ttu-id="9a684-417">例</span><span class="sxs-lookup"><span data-stu-id="9a684-417">Example</span></span>

<span data-ttu-id="9a684-418">次の例では、アプリケーションの現在のディレクトリを表す変数 `basePath`を定義します。</span><span class="sxs-lookup"><span data-stu-id="9a684-418">The following example defines a variable, `basePath`, to represent an application's current directory.</span></span> <span data-ttu-id="9a684-419">次に、それを `GetFullPath` メソッドに渡して、アプリケーションのデータディレクトリへの完全修飾パスを取得します。</span><span class="sxs-lookup"><span data-stu-id="9a684-419">It then passes it to the `GetFullPath` method to get a fully qualified path to the application's data directory.</span></span>

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9a684-420"><paramref name="path" /> または <paramref name="basePath" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9a684-420"><paramref name="path" /> or <paramref name="basePath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9a684-421"><paramref name="basePath" /> が完全修飾パスではありません。</span><span class="sxs-lookup"><span data-stu-id="9a684-421"><paramref name="basePath" /> is not a fully qualified path.</span></span>

<span data-ttu-id="9a684-422">- または -</span><span class="sxs-lookup"><span data-stu-id="9a684-422">-or-</span></span>

<span data-ttu-id="9a684-423"><paramref name="path" /> または <paramref name="basePath" /> に無効なパス文字 (U+0000 など) が含まれています。</span><span class="sxs-lookup"><span data-stu-id="9a684-423"><paramref name="path" /> or <paramref name="basePath" /> contains invalid path characters, such as U+0000.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9a684-424">ファイル名に使用できない文字を含む配列を取得します。</span><span class="sxs-lookup"><span data-stu-id="9a684-424">Gets an array containing the characters that are not allowed in file names.</span></span></summary>
        <returns><span data-ttu-id="9a684-425">ファイル名に使用できない文字を含む配列。</span><span class="sxs-lookup"><span data-stu-id="9a684-425">An array containing the characters that are not allowed in file names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-426">このメソッドから返される配列には、ファイル名とディレクトリ名で無効な文字の完全なセットが含まれているとは限りません。</span><span class="sxs-lookup"><span data-stu-id="9a684-426">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="9a684-427">無効な文字の完全なセットは、ファイルシステムによって異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-427">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="9a684-428">たとえば、Windows ベースのデスクトッププラットフォームでは、無効なパス文字には、ASCII/Unicode 文字 1 ~ 31 のほか、引用符 (")、小なり (\<)、より大きい (>)、パイプ&#124;()、バックスペース (\b)、null (\ 0)、およびタブ (\t) が含まれます。</span><span class="sxs-lookup"><span data-stu-id="9a684-428">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-429">次の例は、<xref:System.IO.Path.GetInvalidFileNameChars%2A> メソッドと、無効な文字を取得するための <xref:System.IO.Path.GetInvalidPathChars%2A> メソッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-429">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9a684-430">パス名に使用できない文字を含む配列を取得します。</span><span class="sxs-lookup"><span data-stu-id="9a684-430">Gets an array containing the characters that are not allowed in path names.</span></span></summary>
        <returns><span data-ttu-id="9a684-431">パス名に使用できない文字を含む配列。</span><span class="sxs-lookup"><span data-stu-id="9a684-431">An array containing the characters that are not allowed in path names.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-432">このメソッドから返される配列には、ファイル名とディレクトリ名で無効な文字の完全なセットが含まれているとは限りません。</span><span class="sxs-lookup"><span data-stu-id="9a684-432">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="9a684-433">無効な文字の完全なセットは、ファイルシステムによって異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-433">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="9a684-434">たとえば、Windows ベースのデスクトッププラットフォームでは、無効なパス文字には、ASCII/Unicode 文字 1 ~ 31 のほか、引用符 (")、小なり (\<)、より大きい (>)、パイプ&#124;()、バックスペース (\b)、null (\ 0)、およびタブ (\t) が含まれます。</span><span class="sxs-lookup"><span data-stu-id="9a684-434">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-435">次の例は、<xref:System.IO.Path.GetInvalidFileNameChars%2A> メソッドと、無効な文字を取得するための <xref:System.IO.Path.GetInvalidPathChars%2A> メソッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-435">The following example demonstrates the <xref:System.IO.Path.GetInvalidFileNameChars%2A> method and the <xref:System.IO.Path.GetInvalidPathChars%2A> method to retrieve invalid characters.</span></span>  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-436">ルート ディレクトリ情報の取得元のパスを含む文字の読み取り専用スパン。</span><span class="sxs-lookup"><span data-stu-id="9a684-436">A read-only span of characters containing the path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="9a684-437">指定した文字範囲に含まれるパスから、ルート ディレクトリ情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="9a684-437">Gets the root directory information from the path contained in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="9a684-438"><paramref name="path" /> のルート ディレクトリを含む文字の読み取り専用スパン。</span><span class="sxs-lookup"><span data-stu-id="9a684-438">A read-only span of characters containing the root directory of <paramref name="path" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9a684-439">このメソッドでは、パスまたはファイルが存在するかどうかは検証されません。</span><span class="sxs-lookup"><span data-stu-id="9a684-439">This method does not verify that the path or file exists.</span></span>

<span data-ttu-id="9a684-440">文字列のオーバーロードとは異なり、このメソッドはディレクトリの区切り記号を正規化しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-440">Unlike the string overload, this method doesn't normalize directory separators.</span></span>

<span data-ttu-id="9a684-441">次の場合、`ReadOnlySpan<System.Char>` は "実質的に空" になります。</span><span class="sxs-lookup"><span data-stu-id="9a684-441">A `ReadOnlySpan<System.Char>` is "effectively empty" if:</span></span>

- <span data-ttu-id="9a684-442">Windows では、この文字の範囲に対して <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> を呼び出すと、`true`が返されます。または、すべての文字が空白 (' ') になります。</span><span class="sxs-lookup"><span data-stu-id="9a684-442">In Windows, calling <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> on this span of characters returns `true`, or all its characters are spaces (' ').</span></span>
- <span data-ttu-id="9a684-443">Unix では、この文字の範囲で <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> を呼び出すと、`true`が返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-443">In Unix, calling <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> on this span of characters returns `true`.</span></span>

<span data-ttu-id="9a684-444">このメソッドによって返される読み取り専用の文字範囲に使用できるパターンは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="9a684-444">Possible patterns for the read-only character span returned by this method are as follows:</span></span>

- <span data-ttu-id="9a684-445"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` は <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>でした。</span><span class="sxs-lookup"><span data-stu-id="9a684-445"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` was <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="9a684-446"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` 現在のドライブまたはボリューム上の相対パスを指定しています)。</span><span class="sxs-lookup"><span data-stu-id="9a684-446"><xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` specified a relative path on the current drive or volume).</span></span>

- <span data-ttu-id="9a684-447">"\" (Unix: `path` は現在のドライブの絶対パスを指定しています)。</span><span class="sxs-lookup"><span data-stu-id="9a684-447">"\" (Unix: `path` specified an absolute path on the current drive).</span></span>

- <span data-ttu-id="9a684-448">"X:" (Windows: `path` はドライブの相対パスを指定します。 *X*はドライブまたはボリューム文字を表します)。</span><span class="sxs-lookup"><span data-stu-id="9a684-448">"X:" (Windows: `path` specified a relative path on a drive, where *X* represents a drive or volume letter).</span></span>

- <span data-ttu-id="9a684-449">"X:\" (Windows: `path` 指定されたドライブの絶対パス)。</span><span class="sxs-lookup"><span data-stu-id="9a684-449">"X:\" (Windows: `path` specified an absolute path on a given drive).</span></span>

- <span data-ttu-id="9a684-450">"\\\ コンピューター名 sharedfolder" (Windows: UNC パス)。</span><span class="sxs-lookup"><span data-stu-id="9a684-450">"\\\ComputerName\SharedFolder" (Windows: a UNC path).</span></span>

- <span data-ttu-id="9a684-451">"\\\\\?\C:" (Windows: DOS デバイスパス。 .NET Core 1.1 以降のバージョンでサポートされています。また、.NET Framework 4.6.2 以降のバージョンでもサポートされています)。</span><span class="sxs-lookup"><span data-stu-id="9a684-451">"\\\\\?\C:" (Windows: a DOS device path, supported in .NET Core 1.1 and later versions, and in .NET Framework 4.6.2 and later versions).</span></span>
 
<span data-ttu-id="9a684-452">Windows 上のファイルパスの詳細については、「 [windows システムでのファイルパス形式](~/docs/standard/io/file-path-formats.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-452">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="9a684-453">共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-453">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>


          ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-454">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-454">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-455">ルート ディレクトリ情報の取得元のパスを含む文字列。</span><span class="sxs-lookup"><span data-stu-id="9a684-455">A string containing the path from which to obtain root directory information.</span></span></param>
        <summary><span data-ttu-id="9a684-456">指定した文字列に含まれるパスから、ルート ディレクトリ情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="9a684-456">Gets the root directory information from the path contained in the specified string.</span></span></summary>
        <returns><span data-ttu-id="9a684-457">ルートである場合は <paramref name="path" /> のルート ディレクトリ。</span><span class="sxs-lookup"><span data-stu-id="9a684-457">The root directory of <paramref name="path" /> if it is rooted.</span></span>

<span data-ttu-id="9a684-458">- または -</span><span class="sxs-lookup"><span data-stu-id="9a684-458">-or-</span></span> 
<span data-ttu-id="9a684-459"><paramref name="path" /> にルート ディレクトリ情報が含まれていない場合は <see cref="P:System.String.Empty" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-459"><see cref="P:System.String.Empty" /> if <paramref name="path" /> does not contain root directory information.</span></span>

<span data-ttu-id="9a684-460">- または -</span><span class="sxs-lookup"><span data-stu-id="9a684-460">-or-</span></span> 
<span data-ttu-id="9a684-461"><paramref name="path" /> が <see langword="null" /> の場合、またはが実質的に空の場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-461"><see langword="null" /> if <paramref name="path" /> is <see langword="null" /> or is effectively empty.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9a684-462">このメソッドでは、パスまたはファイルが存在するかどうかは検証されません。</span><span class="sxs-lookup"><span data-stu-id="9a684-462">This method does not verify that the path or file exists.</span></span>

<span data-ttu-id="9a684-463">このメソッドは、ディレクトリの区切り記号を正規化します。</span><span class="sxs-lookup"><span data-stu-id="9a684-463">This method will normalize directory separators.</span></span>

<span data-ttu-id="9a684-464">次の場合、文字列は "実質的に空" になります。</span><span class="sxs-lookup"><span data-stu-id="9a684-464">A string is "effectively empty" if:</span></span>

- <span data-ttu-id="9a684-465">Windows では、この文字列に対して `IsEmpty` を呼び出すと `true`が返されるか、またはすべての文字が空白 (' ') になります。</span><span class="sxs-lookup"><span data-stu-id="9a684-465">In Windows, calling `IsEmpty` on this string returns `true`, or all its characters are spaces (' ').</span></span>
- <span data-ttu-id="9a684-466">Unix では、この文字列に対して <xref:System.String.IsNullOrEmpty%2A> を呼び出すと `true`が返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-466">In Unix, calling <xref:System.String.IsNullOrEmpty%2A> on this string returns `true`.</span></span>

<span data-ttu-id="9a684-467">このメソッドによって返される文字列には、次のようなパターンがあります。</span><span class="sxs-lookup"><span data-stu-id="9a684-467">Possible patterns for the string returned by this method are as follows:</span></span>

- <span data-ttu-id="9a684-468">`null` (`path` が null または空の文字列) です。</span><span class="sxs-lookup"><span data-stu-id="9a684-468">`null` (`path` was null or an empty string).</span></span>

- <span data-ttu-id="9a684-469">空の文字列 (`path` は、現在のドライブまたはボリューム上の相対パスを指定しています)。</span><span class="sxs-lookup"><span data-stu-id="9a684-469">An empty string (`path` specified a relative path on the current drive or volume).</span></span>

- <span data-ttu-id="9a684-470">"\" (Unix: `path` は現在のドライブの絶対パスを指定しています)。</span><span class="sxs-lookup"><span data-stu-id="9a684-470">"\" (Unix: `path` specified an absolute path on the current drive).</span></span>

- <span data-ttu-id="9a684-471">"X:" (Windows: `path` はドライブの相対パスを指定します。 *X*はドライブまたはボリューム文字を表します)。</span><span class="sxs-lookup"><span data-stu-id="9a684-471">"X:" (Windows: `path` specified a relative path on a drive, where *X* represents a drive or volume letter).</span></span>

- <span data-ttu-id="9a684-472">"X:\" (Windows: `path` 指定されたドライブの絶対パス)。</span><span class="sxs-lookup"><span data-stu-id="9a684-472">"X:\" (Windows: `path` specified an absolute path on a given drive).</span></span>

- <span data-ttu-id="9a684-473">"\\\ コンピューター名 sharedfolder" (Windows: UNC パス)。</span><span class="sxs-lookup"><span data-stu-id="9a684-473">"\\\ComputerName\SharedFolder" (Windows: a UNC path).</span></span>

- <span data-ttu-id="9a684-474">"\\\\\?\C:" (Windows: DOS デバイスパス。 .NET Core 1.1 以降のバージョンでサポートされています。また、.NET Framework 4.6.2 以降のバージョンでもサポートされています)。</span><span class="sxs-lookup"><span data-stu-id="9a684-474">"\\\\\?\C:" (Windows: a DOS device path, supported in .NET Core 1.1 and later versions, and in .NET Framework 4.6.2 and later versions).</span></span>
 
<span data-ttu-id="9a684-475">Windows 上のファイルパスの詳細については、「 [windows システムでのファイルパス形式](~/docs/standard/io/file-path-formats.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-475">For more information on file paths on Windows, see [File path formats on Windows systems](~/docs/standard/io/file-path-formats.md).</span></span> <span data-ttu-id="9a684-476">共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-476">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>

## Examples
<span data-ttu-id="9a684-477">次の例は、`GetPathRoot` メソッドの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-477">The following example demonstrates a use of the `GetPathRoot` method.</span></span>

[!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
[!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
[!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9a684-478">.NET Framework のみ: <paramref name="path" /> には <see cref="M:System.IO.Path.GetInvalidPathChars" /> で定義されている無効な文字が 1 つ以上含まれています。</span><span class="sxs-lookup"><span data-stu-id="9a684-478">.NET Framework only: <paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span>

<span data-ttu-id="9a684-479">- または -</span><span class="sxs-lookup"><span data-stu-id="9a684-479">-or-</span></span>

<span data-ttu-id="9a684-480">.NET Framework のみ: <see cref="F:System.String.Empty" /> が <paramref name="path" /> に渡されました。</span><span class="sxs-lookup"><span data-stu-id="9a684-480">.NET Framework only: <see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-481">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-481">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-482">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-482">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-483">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-483">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-484">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-484">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9a684-485">ランダムなフォルダー名またはファイル名を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-485">Returns a random folder name or file name.</span></span></summary>
        <returns><span data-ttu-id="9a684-486">ランダムなフォルダー名またはファイル名。</span><span class="sxs-lookup"><span data-stu-id="9a684-486">A random folder name or file name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-487"><xref:System.IO.Path.GetRandomFileName%2A> メソッドは、フォルダー名またはファイル名のいずれかとして使用できる暗号強度の高いランダムな文字列を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-487">The <xref:System.IO.Path.GetRandomFileName%2A> method returns a cryptographically strong, random string that can be used as either a folder name or a file name.</span></span> <span data-ttu-id="9a684-488"><xref:System.IO.Path.GetTempFileName%2A>とは異なり、<xref:System.IO.Path.GetRandomFileName%2A> ではファイルは作成されません。</span><span class="sxs-lookup"><span data-stu-id="9a684-488">Unlike <xref:System.IO.Path.GetTempFileName%2A>, <xref:System.IO.Path.GetRandomFileName%2A> does not create a file.</span></span> <span data-ttu-id="9a684-489">ファイルシステムのセキュリティが最優先事項である場合は、<xref:System.IO.Path.GetTempFileName%2A>の代わりにこの方法を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-489">When the security of your file system is paramount, this method should be used instead of <xref:System.IO.Path.GetTempFileName%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-490">次の例では、<xref:System.IO.Path.GetRandomFileName%2A> メソッドからの出力を示します。</span><span class="sxs-lookup"><span data-stu-id="9a684-490">The following example show output from the <xref:System.IO.Path.GetRandomFileName%2A> method.</span></span>  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><span data-ttu-id="9a684-491">結果の基準となるソース パス。</span><span class="sxs-lookup"><span data-stu-id="9a684-491">The source path the result should be relative to.</span></span> <span data-ttu-id="9a684-492">このパスは常にディレクトリと見なされます。</span><span class="sxs-lookup"><span data-stu-id="9a684-492">This path is always considered to be a directory.</span></span></param>
        <param name="path"><span data-ttu-id="9a684-493">ターゲット パス。</span><span class="sxs-lookup"><span data-stu-id="9a684-493">The destination path.</span></span></param>
        <summary><span data-ttu-id="9a684-494">あるパスから別のパスへの相対パスを返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-494">Returns a relative path from one path to another.</span></span></summary>
        <returns><span data-ttu-id="9a684-495">相対パス。パスが同じルートを共有していない場合は <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-495">The relative path, or <paramref name="path" /> if the paths don't share the same root.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="9a684-496">パスは、差異を計算する前に <xref:System.IO.Path.GetFullPath%2A> メソッドを呼び出すことによって解決されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-496">Paths are resolved by calling the <xref:System.IO.Path.GetFullPath%2A> method before calculating the difference.</span></span> <span data-ttu-id="9a684-497">このメソッドは、現在のプラットフォームの既定のファイルパス比較 (Windows の場合は<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>、Linux の場合は <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> を使用します。</span><span class="sxs-lookup"><span data-stu-id="9a684-497">The method uses the default file path comparison for the current platform (<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> for Windows and MacOs, <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> for Linux.</span></span> 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9a684-498"><paramref name="relativeTo" /> または <paramref name="path" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9a684-498"><paramref name="relativeTo" /> or <paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-499">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-499">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9a684-500">一意な名前を持つ 0 バイトの一時ファイルをディスク上に作成し、そのファイルの完全パスを返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-500">Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</span></span></summary>
        <returns><span data-ttu-id="9a684-501">一時ファイルの完全パス。</span><span class="sxs-lookup"><span data-stu-id="9a684-501">The full path of the temporary file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-502">このメソッドは、「.TMP」という拡張子の一時ファイルを作成します。</span><span class="sxs-lookup"><span data-stu-id="9a684-502">This method creates a temporary file with a .TMP file extension.</span></span> <span data-ttu-id="9a684-503">一時ファイルは、 <xref:System.IO.Path.GetTempPath%2A> メソッドによりパスを取得される、ユーザーの一時フォルダー内に作成されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-503">The temporary file is created within the user's temporary folder, which is the path returned by the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
 <span data-ttu-id="9a684-504"><xref:System.IO.Path.GetTempFileName%2A> メソッドは、以前の一時ファイルを削除することなく 65535 を超えるファイルを作成しようとした場合に、 <xref:System.IO.IOException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="9a684-504">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if it is used to create more than 65535 files without deleting previous temporary files.</span></span>  
  
 <span data-ttu-id="9a684-505"><xref:System.IO.Path.GetTempFileName%2A> メソッドが発生する <xref:System.IO.IOException> 一意の一時ファイル名が使用できない場合。</span><span class="sxs-lookup"><span data-stu-id="9a684-505">The <xref:System.IO.Path.GetTempFileName%2A> method will raise an <xref:System.IO.IOException> if no unique temporary file name is available.</span></span> <span data-ttu-id="9a684-506">このエラーを解決するには、不要な一時ファイルをすべて削除してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-506">To resolve this error, delete all unneeded temporary files.</span></span>  
  
 <span data-ttu-id="9a684-507">共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-507">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9a684-508">I/O エラー（例：一意の一時ファイル名を取得できない）が発生しました</span><span class="sxs-lookup"><span data-stu-id="9a684-508">An I/O error occurs, such as no unique temporary file name is available.</span></span>  
  
<span data-ttu-id="9a684-509">- または -</span><span class="sxs-lookup"><span data-stu-id="9a684-509">-or-</span></span>
  
 <span data-ttu-id="9a684-510">あるいは、このメソッドで一時ファイルを作成できませんでした。</span><span class="sxs-lookup"><span data-stu-id="9a684-510">This method was unable to create a temporary file.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="9a684-511">一時フォルダーに書き込むために必要です。</span><span class="sxs-lookup"><span data-stu-id="9a684-511">for writing to the temporary directory.</span></span> <span data-ttu-id="9a684-512">関連付けられた列挙型: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span><span class="sxs-lookup"><span data-stu-id="9a684-512">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-513">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-513">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-514">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-514">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-515">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-515">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9a684-516">現在のユーザーの一時フォルダーのパスを返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-516">Returns the path of the current user's temporary folder.</span></span></summary>
        <returns><span data-ttu-id="9a684-517">一時フォルダーのパス。バックスラッシュで終わります。</span><span class="sxs-lookup"><span data-stu-id="9a684-517">The path to the temporary folder, ending with a backslash.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-518">このメソッドは、次の順序で環境変数の存在を確認し、見つかった最初のパスを使用します。</span><span class="sxs-lookup"><span data-stu-id="9a684-518">This method checks for the existence of environment variables in the following order and uses the first path found:</span></span>  
  
1.  <span data-ttu-id="9a684-519">TMP 環境変数によって指定されたパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-519">The path specified by the TMP environment variable.</span></span>  
  
2.  <span data-ttu-id="9a684-520">TEMP 環境変数によって指定されたパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-520">The path specified by the TEMP environment variable.</span></span>  
  
3.  <span data-ttu-id="9a684-521">USERPROFILE 環境変数によって指定されたパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-521">The path specified by the USERPROFILE environment variable.</span></span>  
  
4.  <span data-ttu-id="9a684-522">Windows ディレクトリ。</span><span class="sxs-lookup"><span data-stu-id="9a684-522">The Windows directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-523"><xref:System.IO.Path.GetTempPath%2A> メソッドを呼び出す方法を次のコード例に示します。</span><span class="sxs-lookup"><span data-stu-id="9a684-523">The following code shows how to call the <xref:System.IO.Path.GetTempPath%2A> method.</span></span>  
  
```vb  
Dim result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 <span data-ttu-id="9a684-524">この例では、次のような出力が生成されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-524">This example produces output similar to the following.</span></span>  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9a684-525">呼び出し元に、必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="9a684-525">The caller does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission"><span data-ttu-id="9a684-526">環境変数に無制限でアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="9a684-526">for unrestricted access to environment variables.</span></span> <span data-ttu-id="9a684-527">関連付けられた列挙型: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span><span class="sxs-lookup"><span data-stu-id="9a684-527">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></span></span></permission>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-528">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-528">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-529">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-529">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-530">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-530">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-531">拡張子を検索するパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-531">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="9a684-532">指定された文字範囲で表されたパスにファイル名拡張子が含まれているかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="9a684-532">Determines whether the path represented by the specified character span includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="9a684-533">パスの最後のディレクトリ区切り文字またはボリューム区切り記号の後に続く文字にピリオド (".") が含まれ、その後に 1 つ以上の文字が続く場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-533"><see langword="true" /> if the characters that follow the last directory separator character or volume separator in the path include a period (".") followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="9a684-534">`path` の末尾のピリオドは、拡張機能とは見なされません。</span><span class="sxs-lookup"><span data-stu-id="9a684-534">A trailing period in `path` is not considered an extension.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-535">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-535">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-536">拡張子を検索するパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-536">The path to search for an extension.</span></span></param>
        <summary><span data-ttu-id="9a684-537">パスにファイル名の拡張子が含まれているか判定します。</span><span class="sxs-lookup"><span data-stu-id="9a684-537">Determines whether a path includes a file name extension.</span></span></summary>
        <returns><span data-ttu-id="9a684-538">パスの最後のディレクトリ区切り記号 (\\\ または /) またはボリューム区切り記号 (:) の後に続く文字にピリオド (.) が含まれ、その後に 1 つ以上の文字が続く場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-538"><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-539">`path`の末尾から、このメソッドはピリオド (.) と1つ以上の文字を検索します。</span><span class="sxs-lookup"><span data-stu-id="9a684-539">Starting from the end of `path`, this method searches for a period (.) followed by at least one character.</span></span> <span data-ttu-id="9a684-540"><xref:System.IO.Path.DirectorySeparatorChar>、<xref:System.IO.Path.AltDirectorySeparatorChar>、または <xref:System.IO.Path.VolumeSeparatorChar> 文字が検出される前にこのパターンが見つかった場合、このメソッドは `true`を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-540">If this pattern is found before a <xref:System.IO.Path.DirectorySeparatorChar>, <xref:System.IO.Path.AltDirectorySeparatorChar>, or <xref:System.IO.Path.VolumeSeparatorChar> character is encountered, this method returns `true`.</span></span>  
  
 <span data-ttu-id="9a684-541">共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-541">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-542">`HasExtension` メソッドの使用例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="9a684-542">The following example demonstrates the use of the `HasExtension` method.</span></span>  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9a684-543"><paramref name="path" /> が、<see cref="M:System.IO.Path.GetInvalidPathChars" /> で定義されている無効な文字を 1 つ以上含んでいます。</span><span class="sxs-lookup"><span data-stu-id="9a684-543"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-544">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-544">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-545">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-545">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-546">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-546">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-547">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-547">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9a684-548"><see cref="T:System.IO.Path" /> クラスのメンバーに渡されるパス文字列引数で指定できないプラットフォーム固有の文字配列を提供します。</span><span class="sxs-lookup"><span data-stu-id="9a684-548">Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-549">このメソッドから返される配列には、ファイル名とディレクトリ名で無効な文字の完全なセットが含まれているとは限りません。</span><span class="sxs-lookup"><span data-stu-id="9a684-549">The array returned from this method is not guaranteed to contain the complete set of characters that are invalid in file and directory names.</span></span> <span data-ttu-id="9a684-550">無効な文字の完全なセットは、ファイルシステムによって異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-550">The full set of invalid characters can vary by file system.</span></span> <span data-ttu-id="9a684-551">たとえば、Windows ベースのデスクトッププラットフォームでは、無効なパス文字には、ASCII/Unicode 文字 1 ~ 31 のほか、引用符 (")、小なり (\<)、より大きい (>)、パイプ&#124;()、バックスペース (\b)、null (\ 0)、およびタブ (\t) が含まれます。</span><span class="sxs-lookup"><span data-stu-id="9a684-551">For example, on Windows-based desktop platforms, invalid path characters might include ASCII/Unicode characters 1 through 31, as well as quote ("), less than (\<), greater than (>), pipe (&#124;), backspace (\b), null (\0) and tab (\t).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="9a684-552">コードが信頼できないコードと同じアプリケーションドメインで実行される可能性がある場合は、<xref:System.IO.Path.InvalidPathChars> を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="9a684-552">Do not use <xref:System.IO.Path.InvalidPathChars> if you think your code might execute in the same application domain as untrusted code.</span></span> <span data-ttu-id="9a684-553"><xref:System.IO.Path.InvalidPathChars> は配列であるため、要素を上書きできます。</span><span class="sxs-lookup"><span data-stu-id="9a684-553"><xref:System.IO.Path.InvalidPathChars> is an array, so its elements can be overwritten.</span></span> <span data-ttu-id="9a684-554">信頼できないコードによって <xref:System.IO.Path.InvalidPathChars>の要素が上書きされると、コードが悪用される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-554">If untrusted code overwrites elements of <xref:System.IO.Path.InvalidPathChars>, it might cause your code to malfunction in ways that could be exploited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-555">次の例では、`InvalidPathChars` プロパティの使用方法を示します。</span><span class="sxs-lookup"><span data-stu-id="9a684-555">The following example demonstrates the use of the `InvalidPathChars` property.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-556">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-556">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-557">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-557">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-558">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-558">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary><span data-ttu-id="9a684-559">ファイル パスが完全修飾されているかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-559">Returns a value that indicates whether a file path is fully qualified.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="9a684-560">`IsPathFullyQualified` メソッドのオーバーロードは、<xref:System.IO.Path.DirectorySeparatorChar> と <xref:System.IO.Path.AltDirectorySeparatorChar> の両方の文字を使用するパスを処理します。</span><span class="sxs-lookup"><span data-stu-id="9a684-560">The overloads of the `IsPathFullyQualified` method handle paths that use both the <xref:System.IO.Path.DirectorySeparatorChar> and the <xref:System.IO.Path.AltDirectorySeparatorChar> characters.</span></span> <span data-ttu-id="9a684-561">引数として渡されるパスに対して検証は実行されません。</span><span class="sxs-lookup"><span data-stu-id="9a684-561">It does not perform any validation on the path that is passed to it as an argument.</span></span> <span data-ttu-id="9a684-562">その結果、Uri は相対パスとして解釈され、`false`を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-562">As a result, URIs are interpreted as relative paths and return `false`.</span></span> 

<span data-ttu-id="9a684-563">完全修飾パス (`IsPathFullyQualified` メソッドによって示される) とルート化されたパス (<xref:System.IO.Path.IsPathRooted%2A> メソッドによって示される) の間には違いがあります。</span><span class="sxs-lookup"><span data-stu-id="9a684-563">There is a difference between a fully qualified path (as indicated by the `IsPathFullyQualified` method) and a rooted path (as indicated by the <xref:System.IO.Path.IsPathRooted%2A> method).</span></span> <span data-ttu-id="9a684-564">*完全修飾パス*または*絶対パス*は、特定のドライブまたはデバイスからターゲットファイルまたはディレクトリへの正確なパスを常に定義し、現在のドライブまたは現在のディレクトリに依存しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-564">A *fully qualified path* or *absolute path* always defines an exact path from a particular drive or device to a target file or directory, and does not depend on the current drive or current directory.</span></span> <span data-ttu-id="9a684-565">たとえば、Windows システムの場合、 *c:/users/user1/documents/reports/2019/1 月/ハイライト。 .pdf*は、c: ドライブのルートからターゲットファイルへの絶対パスを定義し、 *.pdf を強調*表示します。</span><span class="sxs-lookup"><span data-stu-id="9a684-565">For example, on Windows systems, *C:/users/user1/documents/reports/2019/january/highlights.pdf* defines an absolute path from the root of the C: drive to the target file, *highlights.pdf*.</span></span> <span data-ttu-id="9a684-566">ルート*パス*は、開始ドライブまたはルートディレクトリのいずれかを指定しますが、現在のディレクトリ (指定されたドライブがルートになっている場合) または現在のドライブ (ルートディレクトリがルートになっている場合) のいずれかに依存します。</span><span class="sxs-lookup"><span data-stu-id="9a684-566">A *rooted path* specifies either a starting drive or root directory, but depends on either the current directory (if it is rooted by a specified drive) or the current drive (if it is rooted by the root directory).</span></span> <span data-ttu-id="9a684-567">次の例は、完全修飾パスとルート化されたパスの違いを示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-567">The following example illustrates the difference between fully qualified paths and rooted paths.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-568">ファイル パス。</span><span class="sxs-lookup"><span data-stu-id="9a684-568">A file path.</span></span></param>
        <summary><span data-ttu-id="9a684-569">指定された文字範囲で表されたファイル パスが、特定のドライブまたは UNC パスに固定されているかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-569">Returns a value that indicates whether the file path represented by the specified character span is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="9a684-570">パスが特定のドライブまたは UNC パスに固定されている場合は <see langword="true" />。パスが現在のドライブまたは作業ディレクトリを基準としている場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-570"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-571">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-571">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-572">ファイル パス。</span><span class="sxs-lookup"><span data-stu-id="9a684-572">A file path.</span></span></param>
        <summary><span data-ttu-id="9a684-573">指定されたファイル パスが特定のドライブまたは UNC パスに固定されているかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-573">Returns a value that indicates whether the specified file path is fixed to a specific drive or UNC path.</span></span></summary>
        <returns><span data-ttu-id="9a684-574">パスが特定のドライブまたは UNC パスに固定されている場合は <see langword="true" />。パスが現在のドライブまたは作業ディレクトリを基準としている場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-574"><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9a684-575">このメソッドは、代替ディレクトリ区切り記号を使用するパスを処理します。</span><span class="sxs-lookup"><span data-stu-id="9a684-575">This method handles paths that use the alternate directory separator.</span></span> <span data-ttu-id="9a684-576">ルート化されたパス (<xref:System.IO.Path.IsPathRooted(System.String)>) が相対的ではないと想定するのは、よくある間違いです。</span><span class="sxs-lookup"><span data-stu-id="9a684-576">It's a frequent mistake to assume that rooted paths (<xref:System.IO.Path.IsPathRooted(System.String)>) aren't relative.</span></span> <span data-ttu-id="9a684-577">たとえば、"C:a" はドライブ相対で、C: の現在のディレクトリに対して解決されます (ルートはありますが、相対)。</span><span class="sxs-lookup"><span data-stu-id="9a684-577">For example, "C:a" is drive relative, that is, it's resolved against the current directory for C: (rooted, but relative).</span></span> <span data-ttu-id="9a684-578">"C:\ a" はルートであり、相対ではありません。つまり、現在のディレクトリがパスの変更に使用されることはありません。</span><span class="sxs-lookup"><span data-stu-id="9a684-578">"C:\a" is rooted and not relative, that is, the current directory isn't used to modify the path.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9a684-579"><paramref name="path" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9a684-579"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-580">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-580">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary><span data-ttu-id="9a684-581">ファイル パスにルートが含まれているかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-581">Returns a value that indicates whether a file path contains a root.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="9a684-582">ルート化された**パス**は、特定のドライブまたは非 ic パスに固定されたファイルパスです。現在のドライブまたは作業ディレクトリに対する相対パスとは対照的です。</span><span class="sxs-lookup"><span data-stu-id="9a684-582">A **rooted path** is file path that is fixed to a specific drive or UNIC path; it contrasts with a path that is relative to the current drive or working directory.</span></span> <span data-ttu-id="9a684-583">たとえば、Windows システムでは、ルート化されたパスは、円記号 ("\Documents" など) またはドライブ文字とコロン (たとえば、"C:Documents") で始まります。</span><span class="sxs-lookup"><span data-stu-id="9a684-583">For example, on Windows systems, a rooted path begins with a backslash (for example, "\Documents") or a drive letter and colon (for example, "C:Documents").</span></span> 

<span data-ttu-id="9a684-584">ルート化されたパスは、絶対パス (完全修飾名) または相対パスのいずれかになることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-584">Note that rooted paths can be either absolute (that is, fully qualified) or relative.</span></span> <span data-ttu-id="9a684-585">絶対ルートパスは、ドライブのルートから特定のディレクトリへの完全修飾パスです。</span><span class="sxs-lookup"><span data-stu-id="9a684-585">An absolute rooted path is a fully qualified path from the root of a drive to a specific directory.</span></span> <span data-ttu-id="9a684-586">相対ルートパスはドライブを指定しますが、その完全修飾パスは現在のディレクトリに対して解決されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-586">A relative rooted path specifies a drive, but its fully qualified path is resolved against the current directory.</span></span> <span data-ttu-id="9a684-587">この違いを次の例に示します。</span><span class="sxs-lookup"><span data-stu-id="9a684-587">The following example illustrates the difference.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-588">テストするパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-588">The path to test.</span></span></param>
        <summary><span data-ttu-id="9a684-589">ファイル パスを表す指定された文字範囲にルートが含まれているかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-589">Returns a value that indicates whether the specified character span that represents a file path contains a root.</span></span></summary>
        <returns><span data-ttu-id="9a684-590"><paramref name="path" /> にルートが含まれている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-590"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-591">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-591">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-592">テストするパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-592">The path to test.</span></span></param>
        <summary><span data-ttu-id="9a684-593">指定されたパス文字列にルートが含まれているかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-593">Returns a value indicating whether the specified path string contains a root.</span></span></summary>
        <returns><span data-ttu-id="9a684-594"><paramref name="path" /> にルートが含まれている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-594"><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-595"><xref:System.IO.Path.IsPathRooted%2A> メソッドは、最初の文字が "\\" などのディレクトリ区切り文字である場合、またはパスがドライブ文字とコロン (:) で始まる場合に `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-595">The <xref:System.IO.Path.IsPathRooted%2A> method returns `true` if the first character is a directory separator character such as "\\", or if the path starts with a drive letter and colon (:).</span></span> <span data-ttu-id="9a684-596">たとえば、"\\\MyDir\\\MyFile.txt"、"C:\\\MyDir"、"C:MyDir" などの `path` 文字列の `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-596">For example, it returns `true` for `path` strings such as "\\\MyDir\\\MyFile.txt", "C:\\\MyDir", or "C:MyDir".</span></span> <span data-ttu-id="9a684-597">"MyDir" などの `path` 文字列の `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-597">It returns `false` for `path` strings such as "MyDir".</span></span>  
  
 <span data-ttu-id="9a684-598">このメソッドでは、パスまたはファイル名が存在するかどうかは検証されません。</span><span class="sxs-lookup"><span data-stu-id="9a684-598">This method does not verify that the path or file name exists.</span></span>  
  
 <span data-ttu-id="9a684-599">共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a684-599">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  

## Examples  
 <span data-ttu-id="9a684-600">次の例では、`IsPathRooted` メソッドを使用して、3つの文字列をテストする方法を示します。</span><span class="sxs-lookup"><span data-stu-id="9a684-600">The following example demonstrates how the `IsPathRooted` method can be used to test three strings.</span></span>  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9a684-601"><paramref name="path" /> が、<see cref="M:System.IO.Path.GetInvalidPathChars" /> で定義されている無効な文字を 1 つ以上含んでいます。</span><span class="sxs-lookup"><span data-stu-id="9a684-601"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</span></span></exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-602">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-602">File path formats on Windows systems</span></span></related>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-603">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-603">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-604">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-604">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-605">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-605">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Join : string[] -&gt; string" Usage="System.IO.Path.Join paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths"><span data-ttu-id="9a684-606">パスの配列。</span><span class="sxs-lookup"><span data-stu-id="9a684-606">An array of paths.</span></span></param>
        <summary><span data-ttu-id="9a684-607">パスの配列を連結して 1 つのパスにします。</span><span class="sxs-lookup"><span data-stu-id="9a684-607">Concatenates an array of paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="9a684-608">連結されたパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-608">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9a684-609">このメソッドは、単に `paths` 内のすべての文字列を連結し、パスコンポーネントがまだ存在しない場合は、そのディレクトリの区切り文字を追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-609">This method simply concatenates all the strings in `paths` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="9a684-610">`paths` 内のいずれかのパスの <xref:System.String.Length> がゼロの場合、メソッドは残りの引数を連結します。</span><span class="sxs-lookup"><span data-stu-id="9a684-610">If the <xref:System.String.Length> of any of the paths in `paths` is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="9a684-611">結果として得られる文字列の長さが0の場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-611">If the resulting concatenated string's length is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="9a684-612">`paths`内のいずれかのパス (最後のパスを除く) がターゲットプラットフォームに適していないパス区切り文字で終わる場合、`Join` メソッドは元のパス区切り文字を保持し、サポートされているパス区切り文字を追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-612">If any of the paths in `paths`, except for the last one, ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="9a684-613">この問題は、Unix ベースのシステムでパスの区切りとして認識されない Windows の円記号 ("\") 文字を使用するハードコードされたパスで発生します。</span><span class="sxs-lookup"><span data-stu-id="9a684-613">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="9a684-614">この問題を回避するには、次の操作を行います。</span><span class="sxs-lookup"><span data-stu-id="9a684-614">To work around this issue, you can:</span></span>

- <span data-ttu-id="9a684-615">ディレクトリの区切り文字をハードコーディングするのではなく、<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="9a684-615">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="9a684-616">ディレクトリの区切り記号としてスラッシュ ("/") を使用します。</span><span class="sxs-lookup"><span data-stu-id="9a684-616">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="9a684-617">この文字は、Unix ベースのシステムの <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティと、Windows システムの <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-617">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="9a684-618"><xref:System.IO.Path.Combine%2A> メソッドとは異なり、<xref:System.IO.Path.Join%2A> メソッドは、返されたパスのルートを試行しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-618">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="9a684-619">(つまり、`paths`内のいずれかのパス (最後のパスを除く) が絶対パスの場合、`Join` メソッドは <xref:System.IO.Path.Combine%2A> メソッドと同じ前のパスを破棄しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-619">(That is, if any of the paths in `paths`, except for the last one, is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="9a684-620">検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Join` メソッドでは許容されないと解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-620">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="9a684-621">たとえば、ファイルの作成時に `Path.Join("c:\\", "temp", "*.txt")` が無効になる場合がありますが、検索文字列として有効です。</span><span class="sxs-lookup"><span data-stu-id="9a684-621">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="9a684-622">したがって、`Join` メソッドによって正常に解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-622">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="9a684-623">結合する最初のパスを含む文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-623">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="9a684-624">結合する 2 番目のパスを含む文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-624">A character span that contains the second path to join.</span></span></param>
        <summary><span data-ttu-id="9a684-625">2 つのパス コンポーネントを単一のパスに連結します。</span><span class="sxs-lookup"><span data-stu-id="9a684-625">Concatenates two path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="9a684-626">結合されたパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-626">The combined paths.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="9a684-627">このメソッドは、`path` と `path2` を連結するだけで、`path1` の最後または `path2`の先頭にまだ存在していない場合は、2つのパスコンポーネントの間にディレクトリ区切り文字を追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-627">This method simply concatenates `path` and `path2` and adds a directory separator character between the two path components if one is not already present at the end of `path1` or the beginning of `path2`.</span></span> <span data-ttu-id="9a684-628">`path1` または `path2` の <xref:System.ReadOnlySpan%601.Length> がゼロの場合、メソッドはもう一方のパスを返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-628">If the <xref:System.ReadOnlySpan%601.Length> of either `path1` or `path2` is zero, the method returns the other path.</span></span> <span data-ttu-id="9a684-629">`path1` と `path2` の両方の <xref:System.ReadOnlySpan%601.Length> がゼロの場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-629">If the <xref:System.ReadOnlySpan%601.Length> of both `path1` and `path2` is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> 

<span data-ttu-id="9a684-630">`path1` がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Join` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-630">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="9a684-631">この問題は、Unix ベースのシステムでパスの区切りとして認識されない Windows の円記号 ("\") 文字を使用するハードコードされたパスで発生します。</span><span class="sxs-lookup"><span data-stu-id="9a684-631">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="9a684-632">この問題を回避するには、次の操作を行います。</span><span class="sxs-lookup"><span data-stu-id="9a684-632">To work around this issue, you can:</span></span>

- <span data-ttu-id="9a684-633">ディレクトリの区切り文字をハードコーディングするのではなく、<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="9a684-633">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="9a684-634">ディレクトリの区切り記号としてスラッシュ ("/") を使用します。</span><span class="sxs-lookup"><span data-stu-id="9a684-634">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="9a684-635">この文字は、Unix ベースのシステムの <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティと、Windows システムの <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-635">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span> 

<span data-ttu-id="9a684-636"><xref:System.IO.Path.Combine%2A> メソッドとは異なり、<xref:System.IO.Path.Join%2A> メソッドは、返されたパスのルートを試行しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-636">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="9a684-637">(`path2` が絶対パスの場合、`Join` メソッドは `path1` を破棄せず、<xref:System.IO.Path.Combine%2A> メソッドと同様に `path2` を返します)。次の例は、2つのメソッドによって返されるパスの違いを示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-637">(That is, if `path2` is an absolute path, the `Join` method does not discard `path1` and return `path2` as the <xref:System.IO.Path.Combine%2A> method does.) The following example illustrates the difference in the paths returned by the two methods.</span></span> <span data-ttu-id="9a684-638">`path2` のソースがユーザー入力である場合、<xref:System.IO.Path.Combine%2A> メソッドを使用すると、ユーザーは、アプリケーションがアクセスできないように意図したファイルシステムリソース (例の場合は、 *C:/Users/User1/Documents/財務*など) にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="9a684-638">If the source of `path2` is user input, the <xref:System.IO.Path.Combine%2A> method makes it possible for a user to access a file system resource (such as *C:/Users/User1/Documents/Financial/* in the case of the example) that the application did not intend to make accessible.</span></span>  

<span data-ttu-id="9a684-639">検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Join` メソッドでは許容されないと解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-639">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="9a684-640">たとえば、ファイルの作成時に `Path.Join("c:\\", "*.txt")` が無効になる場合がありますが、検索文字列として有効です。</span><span class="sxs-lookup"><span data-stu-id="9a684-640">For example, while `Path.Join("c:\\", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="9a684-641">したがって、`Join` メソッドによって正常に解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-641">The `Join` method therefore successfully interprets it.</span></span> 

## <a name="example"></a><span data-ttu-id="9a684-642">例</span><span class="sxs-lookup"><span data-stu-id="9a684-642">Example</span></span>

<span data-ttu-id="9a684-643">次の例は、<xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> メソッドと <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> メソッドによって返されるパスの違いを示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-643">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="9a684-644">最初の文字列がドライブおよびルートディレクトリを含む完全修飾パスで、2番目の文字列が最初のパスからの相対パスである場合、2つのメソッドは同じ結果を生成します。</span><span class="sxs-lookup"><span data-stu-id="9a684-644">When the first string is an fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="9a684-645">2番目と3回目の `ShowPathInformation` メソッドの呼び出しでは、2つのメソッドによって返される文字列は分岐します。</span><span class="sxs-lookup"><span data-stu-id="9a684-645">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="9a684-646">2番目のメソッド呼び出しでは、最初の文字列引数はドライブ、2番目の文字列はルート化されたディレクトリです。</span><span class="sxs-lookup"><span data-stu-id="9a684-646">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="9a684-647">`Join` メソッドは、2つの文字列を連結し、重複するパス区切り記号を保持します。</span><span class="sxs-lookup"><span data-stu-id="9a684-647">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="9a684-648">`Combine` メソッドはドライブを破棄し、現在のドライブ上のルート化されたディレクトリを返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-648">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="9a684-649">アプリケーションの現在のドライブが C:\ の場合また、この文字列は、ディレクトリ内のファイルにアクセスするために使用され、d: ではなく C: にアクセスします。</span><span class="sxs-lookup"><span data-stu-id="9a684-649">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="9a684-650">最後に、`ShowPathInformation` の3番目の呼び出しの両方の引数がルートになっているため、`Join` メソッドは単にそれらを追加して無意味ファイルパスを作成します。一方、`Combine` メソッドは最初の文字列を破棄し、2番目の文字列を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-650">Finally, because both arguments in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends them to create a nonsensical file path, while the `Combine` method discards the first string and returns the second.</span></span> <span data-ttu-id="9a684-651">ファイルアクセスにこの文字列を使用すると、アプリケーションが機密ファイルに意図せずアクセスする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-651">Using this string for file access could give the application unintended access to sensitive files.</span></span>  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-vb[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-652">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-652">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="9a684-653">結合する 1 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-653">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="9a684-654">結合する 2 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-654">The second path to join.</span></span></param>
        <summary><span data-ttu-id="9a684-655">2 つのパスを単一のパスに連結します。</span><span class="sxs-lookup"><span data-stu-id="9a684-655">Concatenates two paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="9a684-656">連結されたパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-656">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9a684-657">このメソッドは、単に `path` と `path2` を連結し、パスコンポーネントがまだ存在しない場合は、そのパスコンポーネントの間にディレクトリ区切り文字を追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-657">This method simply concatenates `path` and `path2` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="9a684-658">`path1` または `path2` のいずれかの長さが0の場合、メソッドは残りの引数を連結します。</span><span class="sxs-lookup"><span data-stu-id="9a684-658">If the length of either `path1` or `path2` is zero, the method concatenates the remaining argument.</span></span> <span data-ttu-id="9a684-659">結果として連結された文字列の長さが0の場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-659">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="9a684-660">`path1` がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Join` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-660">If `path1` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="9a684-661">この問題は、Unix ベースのシステムでパスの区切りとして認識されない Windows の円記号 ("\") 文字を使用するハードコードされたパスで発生します。</span><span class="sxs-lookup"><span data-stu-id="9a684-661">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="9a684-662">この問題を回避するには、次の操作を行います。</span><span class="sxs-lookup"><span data-stu-id="9a684-662">To work around this issue, you can:</span></span>

- <span data-ttu-id="9a684-663">ディレクトリの区切り文字をハードコーディングするのではなく、<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="9a684-663">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="9a684-664">ディレクトリの区切り記号としてスラッシュ ("/") を使用します。</span><span class="sxs-lookup"><span data-stu-id="9a684-664">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="9a684-665">この文字は、Unix ベースのシステムの <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティと、Windows システムの <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-665">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="9a684-666"><xref:System.IO.Path.Combine%2A> メソッドとは異なり、<xref:System.IO.Path.Join%2A> メソッドは、返されたパスのルートを試行しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-666">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="9a684-667">(`path2` が絶対パスの場合、`Join` メソッドは <xref:System.IO.Path.Combine%2A> メソッドと同じ前のパスを破棄しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-667">(That is, if `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="9a684-668">検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Join` メソッドでは許容されないと解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-668">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="9a684-669">たとえば、ファイルの作成時に `Path.Join("c:\\", "temp", "*.txt")` が無効になる場合がありますが、検索文字列として有効です。</span><span class="sxs-lookup"><span data-stu-id="9a684-669">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="9a684-670">したがって、`Join` メソッドによって正常に解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-670">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="9a684-671">結合する最初のパスを含む文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-671">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="9a684-672">結合する 2 番目のパスを含む文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-672">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="9a684-673">結合する 3 番目のパスを含む文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-673">A character span that contains the third path to join.</span></span></param>
        <summary><span data-ttu-id="9a684-674">3 つのパス コンポーネントを単一のパスに連結します。</span><span class="sxs-lookup"><span data-stu-id="9a684-674">Concatenates three path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="9a684-675">連結されたパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-675">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="9a684-676">このメソッドは、単に `path`、`path2`、および `path3` を連結し、パスコンポーネントがまだ存在しない場合は、そのディレクトリの区切り文字を追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-676">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="9a684-677">`path1`、`path2`、または `path3` 引数のいずれかの <xref:System.ReadOnlySpan%601.Length> が0の場合、メソッドは残りの引数を連結します。</span><span class="sxs-lookup"><span data-stu-id="9a684-677">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, or `path3` arguments is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="9a684-678">すべてのコンポーネントの <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> がゼロの場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-678">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="9a684-679">`path1` または `path2` がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Join` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-679">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="9a684-680">この問題は、Unix ベースのシステムでパスの区切りとして認識されない Windows の円記号 ("\") 文字を使用するハードコードされたパスで発生します。</span><span class="sxs-lookup"><span data-stu-id="9a684-680">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="9a684-681">この問題を回避するには、次の操作を行います。</span><span class="sxs-lookup"><span data-stu-id="9a684-681">To work around this issue, you can:</span></span>

- <span data-ttu-id="9a684-682">ディレクトリの区切り文字をハードコーディングするのではなく、<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="9a684-682">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="9a684-683">ディレクトリの区切り記号としてスラッシュ ("/") を使用します。</span><span class="sxs-lookup"><span data-stu-id="9a684-683">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="9a684-684">この文字は、Unix ベースのシステムの <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティと、Windows システムの <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-684">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="9a684-685"><xref:System.IO.Path.Combine%2A> メソッドとは異なり、<xref:System.IO.Path.Join%2A> メソッドは、返されたパスのルートを試行しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-685">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="9a684-686">(つまり、`path2` または `path2` が絶対パスである場合、`Join` メソッドは <xref:System.IO.Path.Combine%2A> メソッドと同様に以前のパスを破棄しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-686">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>
  
<span data-ttu-id="9a684-687">検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Join` メソッドでは許容されないと解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-687">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="9a684-688">たとえば、ファイルの作成時に `Path.Join("c:\\", "temp", "*.txt")` が無効になる場合がありますが、検索文字列として有効です。</span><span class="sxs-lookup"><span data-stu-id="9a684-688">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="9a684-689">したがって、`Join` メソッドによって正常に解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-689">The `Join` method therefore successfully interprets it.</span></span>

## <a name="example"></a><span data-ttu-id="9a684-690">例</span><span class="sxs-lookup"><span data-stu-id="9a684-690">Example</span></span>

<span data-ttu-id="9a684-691">次の例は、<xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> メソッドと <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> メソッドによって返されるパスの違いを示しています。</span><span class="sxs-lookup"><span data-stu-id="9a684-691">The following example illustrates the difference in the paths returned by the <xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> and <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="9a684-692">最初の文字列がドライブおよびルートディレクトリを含む完全修飾パスで、2番目の文字列が最初のパスからの相対パスである場合、2つのメソッドは同じ結果を生成します。</span><span class="sxs-lookup"><span data-stu-id="9a684-692">When the first string is a fully qualified path that includes a drive and root directory and the second is a relative path from the first path, the two methods produce identical results.</span></span> <span data-ttu-id="9a684-693">2番目と3回目の `ShowPathInformation` メソッドの呼び出しでは、2つのメソッドによって返される文字列は分岐します。</span><span class="sxs-lookup"><span data-stu-id="9a684-693">In the second and third calls to the `ShowPathInformation` method, the strings returned by the two methods diverge.</span></span> <span data-ttu-id="9a684-694">2番目のメソッド呼び出しでは、最初の文字列引数はドライブ、2番目の文字列はルート化されたディレクトリです。</span><span class="sxs-lookup"><span data-stu-id="9a684-694">In the second method call, the first string argument is a drive, while the second is a rooted directory.</span></span> <span data-ttu-id="9a684-695">`Join` メソッドは、2つの文字列を連結し、重複するパス区切り記号を保持します。</span><span class="sxs-lookup"><span data-stu-id="9a684-695">The `Join` method concatenates the two strings and preserves duplicate path separators.</span></span> <span data-ttu-id="9a684-696"><xref:System.IO.Path.GetFullPath%2A> メソッドを呼び出すと、重複が除去されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-696">A call to the <xref:System.IO.Path.GetFullPath%2A> method would eliminate the duplication.</span></span> <span data-ttu-id="9a684-697">`Combine` メソッドはドライブを破棄し、現在のドライブ上のルート化されたディレクトリを返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-697">The `Combine` method abandons the drive and returns a rooted directory on the current drive.</span></span> <span data-ttu-id="9a684-698">アプリケーションの現在のドライブが C:\ の場合また、この文字列は、ディレクトリ内のファイルにアクセスするために使用され、d: ではなく C: にアクセスします。</span><span class="sxs-lookup"><span data-stu-id="9a684-698">If the application's current drive is C:\ and the string is used to access a file or files in the directory, it would access C: instead of D:.</span></span> <span data-ttu-id="9a684-699">最後に、`ShowPathInformation` の3番目の呼び出しの最後の引数がルートになっているため、`Join` メソッドは単純にそれを最初の2つの引数に追加して無意味ファイルパスを作成します。一方、`Combine` メソッドは最初の2つの文字列を破棄し、3番目の文字列を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-699">Finally, because the final argument in the third call to `ShowPathInformation` are rooted, the `Join` method simply appends it to the first two arguments to create a nonsensical file path, while the `Combine` method discards the first two strings and returns the third.</span></span> <span data-ttu-id="9a684-700">ファイルアクセスにこの文字列を使用すると、アプリケーションが機密ファイルに意図せずアクセスする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-700">Using this string for file access could give the application unintended access to sensitive files.</span></span>

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)]
[!code-vb[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)]

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-701">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-701">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="9a684-702">結合する 1 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-702">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="9a684-703">結合する 2 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-703">The second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="9a684-704">結合する 3 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-704">The third path to join.</span></span></param>
        <summary><span data-ttu-id="9a684-705">3 つのパスを単一のパスに連結します。</span><span class="sxs-lookup"><span data-stu-id="9a684-705">Concatenates three paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="9a684-706">連結されたパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-706">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9a684-707">このメソッドは、単に `path`、`path2`、および `path3` を連結し、パスコンポーネントがまだ存在しない場合は、そのディレクトリの区切り文字を追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-707">This method simply concatenates `path`, `path2`, and `path3` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="9a684-708">`path1`、`path2` または `path3` 引数のいずれかの長さが0の場合、メソッドは残りの引数を連結します。</span><span class="sxs-lookup"><span data-stu-id="9a684-708">If the length of any of `path1`, `path2` or `path3` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="9a684-709">結果として連結された文字列の長さが0の場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-709">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="9a684-710">`path1` または `path2` がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Join` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-710">If `path1` or `path2` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="9a684-711">この問題は、Unix ベースのシステムでパスの区切りとして認識されない Windows の円記号 ("\") 文字を使用するハードコードされたパスで発生します。</span><span class="sxs-lookup"><span data-stu-id="9a684-711">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="9a684-712">この問題を回避するには、次の操作を行います。</span><span class="sxs-lookup"><span data-stu-id="9a684-712">To work around this issue, you can:</span></span>

- <span data-ttu-id="9a684-713">ディレクトリの区切り文字をハードコーディングするのではなく、<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="9a684-713">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="9a684-714">ディレクトリの区切り記号としてスラッシュ ("/") を使用します。</span><span class="sxs-lookup"><span data-stu-id="9a684-714">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="9a684-715">この文字は、Unix ベースのシステムの <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティと、Windows システムの <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-715">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="9a684-716"><xref:System.IO.Path.Combine%2A> メソッドとは異なり、<xref:System.IO.Path.Join%2A> メソッドは、返されたパスのルートを試行しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-716">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="9a684-717">(つまり、`path2` または `path2` が絶対パスである場合、`Join` メソッドは <xref:System.IO.Path.Combine%2A> メソッドと同様に以前のパスを破棄しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-717">(That is, if `path2` or `path2` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="9a684-718">検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Join` メソッドでは許容されないと解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-718">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="9a684-719">たとえば、ファイルの作成時に `Path.Join("c:\\", "temp", "*.txt")` が無効になる場合がありますが、検索文字列として有効です。</span><span class="sxs-lookup"><span data-stu-id="9a684-719">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="9a684-720">したがって、`Join` メソッドによって正常に解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-720">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.ReadOnlySpan`1&lt;char&gt; path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), path4 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="9a684-721">結合する最初のパスを含む文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-721">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="9a684-722">結合する 2 番目のパスを含む文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-722">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="9a684-723">結合する 3 番目のパスを含む文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-723">A character span that contains the third path to join.</span></span></param>
        <param name="path4"><span data-ttu-id="9a684-724">結合する 4 番目のパスを含む文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-724">A character span that contains the fourth path to join.</span></span></param>
        <summary><span data-ttu-id="9a684-725">4 つのパス コンポーネントを単一のパスに連結します。</span><span class="sxs-lookup"><span data-stu-id="9a684-725">Concatenates four path components into a single path.</span></span></summary>
        <returns><span data-ttu-id="9a684-726">連結されたパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-726">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9a684-727">このメソッドは、単に `path`、`path2`、`path3` および `path4` を連結し、パスコンポーネントがまだ存在しない場合は、そのディレクトリの区切り文字を追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-727">This method simply concatenates `path`, `path2`, `path3` and `path4` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="9a684-728">`path1`、`path2`、`path3`、または `path4` 引数のいずれかの <xref:System.ReadOnlySpan%601.Length> が0の場合、メソッドは残りの引数を連結します。</span><span class="sxs-lookup"><span data-stu-id="9a684-728">If the <xref:System.ReadOnlySpan%601.Length> of any of `path1`, `path2`, `path3` or `path4` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="9a684-729">すべてのコンポーネントの <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> がゼロの場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-729">If the <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> of all components is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="9a684-730">`path1` または `path2` または `path3` がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Join` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-730">If `path1` or `path2` or `path3` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="9a684-731">この問題は、Unix ベースのシステムでパスの区切りとして認識されない Windows の円記号 ("\") 文字を使用するハードコードされたパスで発生します。</span><span class="sxs-lookup"><span data-stu-id="9a684-731">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="9a684-732">この問題を回避するには、次の操作を行います。</span><span class="sxs-lookup"><span data-stu-id="9a684-732">To work around this issue, you can:</span></span>

- <span data-ttu-id="9a684-733">ディレクトリの区切り文字をハードコーディングするのではなく、<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="9a684-733">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="9a684-734">ディレクトリの区切り記号としてスラッシュ ("/") を使用します。</span><span class="sxs-lookup"><span data-stu-id="9a684-734">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="9a684-735">この文字は、Unix ベースのシステムの <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティと、Windows システムの <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-735">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="9a684-736"><xref:System.IO.Path.Combine%2A> メソッドとは異なり、<xref:System.IO.Path.Join%2A> メソッドは、返されたパスのルートを試行しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-736">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="9a684-737">(つまり、`path2` または `path2` または `path3` が絶対パスの場合、<xref:System.IO.Path.Combine%2A> メソッドと同様に、`Join` メソッドは前のパスを破棄しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-737">(That is, if `path2` or `path2` or `path3` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="9a684-738">検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Join` メソッドでは許容されないと解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-738">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="9a684-739">たとえば、ファイルの作成時に `Path.Join("c:\\", "temp", "*.txt")` が無効になる場合がありますが、検索文字列として有効です。</span><span class="sxs-lookup"><span data-stu-id="9a684-739">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="9a684-740">したがって、`Join` メソッドによって正常に解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-740">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="9a684-741">結合する 1 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-741">The first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="9a684-742">結合する 2 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-742">The second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="9a684-743">結合する 3 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-743">The third path to join.</span></span></param>
        <param name="path4"><span data-ttu-id="9a684-744">結合する 4 番目のパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-744">The fourth path to join.</span></span></param>
        <summary><span data-ttu-id="9a684-745">4 つのパスを単一のパスに連結します。</span><span class="sxs-lookup"><span data-stu-id="9a684-745">Concatenates four paths into a single path.</span></span></summary>
        <returns><span data-ttu-id="9a684-746">連結されたパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-746">The concatenated path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="9a684-747">このメソッドは、単に `path`、`path2`、`path3` および `path4` を連結し、パスコンポーネントがまだ存在しない場合は、そのディレクトリの区切り文字を追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-747">This method simply concatenates `path`, `path2`, `path3` and `path4` and adds a directory separator character between any of the path components if one is not already present.</span></span> <span data-ttu-id="9a684-748">`path1`、`path2`、`path3`、または `path4` 引数のいずれかの長さが0の場合、メソッドは残りの引数を連結します。</span><span class="sxs-lookup"><span data-stu-id="9a684-748">If the length of any of `path1`, `path2`, `path3` or `path4` argument is zero, the method concatenates the remaining arguments.</span></span> <span data-ttu-id="9a684-749">結果として連結された文字列の長さが0の場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-749">If the length of the resulting concatenated string is zero, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="9a684-750">`path1` または `path2` または `path3` がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Join` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。</span><span class="sxs-lookup"><span data-stu-id="9a684-750">If `path1` or `path2` or `path3` ends in a path separator character that is not appropriate for the target platform, the `Join` method preserves the original path separator character and appends the supported one.</span></span> <span data-ttu-id="9a684-751">この問題は、Unix ベースのシステムでパスの区切りとして認識されない Windows の円記号 ("\") 文字を使用するハードコードされたパスで発生します。</span><span class="sxs-lookup"><span data-stu-id="9a684-751">This issue arises in hard-coded paths that use the Windows backslash ("\") character, which is not recognized as a path separator on Unix-based systems.</span></span> <span data-ttu-id="9a684-752">この問題を回避するには、次の操作を行います。</span><span class="sxs-lookup"><span data-stu-id="9a684-752">To work around this issue, you can:</span></span>

- <span data-ttu-id="9a684-753">ディレクトリの区切り文字をハードコーディングするのではなく、<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="9a684-753">Retrieve the value of the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property rather than hard-coding a directory separator character.</span></span>

- <span data-ttu-id="9a684-754">ディレクトリの区切り記号としてスラッシュ ("/") を使用します。</span><span class="sxs-lookup"><span data-stu-id="9a684-754">Use a forward slash ("/") as the directory separator character.</span></span> <span data-ttu-id="9a684-755">この文字は、Unix ベースのシステムの <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティと、Windows システムの <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> プロパティによって返されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-755">This character is returned by the <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> property on Unix-based systems and by the <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> property on Windows systems.</span></span>

<span data-ttu-id="9a684-756"><xref:System.IO.Path.Combine%2A> メソッドとは異なり、<xref:System.IO.Path.Join%2A> メソッドは、返されたパスのルートを試行しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-756">Unlike the <xref:System.IO.Path.Combine%2A> method, the <xref:System.IO.Path.Join%2A> method does not attempt to root the returned path.</span></span> <span data-ttu-id="9a684-757">(つまり、`path2` または `path2` または `path3` が絶対パスの場合、<xref:System.IO.Path.Combine%2A> メソッドと同様に、`Join` メソッドは前のパスを破棄しません。</span><span class="sxs-lookup"><span data-stu-id="9a684-757">(That is, if `path2` or `path2` or `path3` is an absolute path, the `Join` method does not discard the previous paths as the <xref:System.IO.Path.Combine%2A> method does.</span></span>

<span data-ttu-id="9a684-758">検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Join` メソッドでは許容されないと解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-758">Not all invalid characters for directory and file names are interpreted as unacceptable by the `Join` method, because you can use these characters for search wildcard characters.</span></span> <span data-ttu-id="9a684-759">たとえば、ファイルの作成時に `Path.Join("c:\\", "temp", "*.txt")` が無効になる場合がありますが、検索文字列として有効です。</span><span class="sxs-lookup"><span data-stu-id="9a684-759">For example, while `Path.Join("c:\\", "temp", "*.txt")` might be invalid when creating a file, it is valid as a search string.</span></span> <span data-ttu-id="9a684-760">したがって、`Join` メソッドによって正常に解釈されます。</span><span class="sxs-lookup"><span data-stu-id="9a684-760">The `Join` method therefore successfully interprets it.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9a684-761">環境変数のパス文字列を区切るために使用するプラットフォーム固有の区切り記号。</span><span class="sxs-lookup"><span data-stu-id="9a684-761">A platform-specific separator character used to separate path strings in environment variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-762">Windows ベースのデスクトッププラットフォームでは、このフィールドの値はセミコロン (;)既定では、他のプラットフォームによって異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-762">On Windows-based desktop platforms, the value of this field is the semicolon (;) by default, but might vary on other platforms.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-763">次の例では、`PathSeparator` フィールドの使用方法を示します。</span><span class="sxs-lookup"><span data-stu-id="9a684-763">The following example demonstrates the use of the `PathSeparator` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-764">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-764">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-765">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-765">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-766">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-766">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEndingDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-767">トリミングするパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-767">The path to trim.</span></span></param>
        <summary><span data-ttu-id="9a684-768">指定したパスのルート以降の末尾の区切り記号をトリミングします。</span><span class="sxs-lookup"><span data-stu-id="9a684-768">Trims one trailing directory separator beyond the root of the specified path.</span></span></summary>
        <returns><span data-ttu-id="9a684-769">末尾のディレクトリ区切り記号を含まない <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-769">The <paramref name="path" /> without any trailing directory separators.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static string TrimEndingDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrimEndingDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrimEndingDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : string -&gt; string" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="9a684-770">トリミングするパス。</span><span class="sxs-lookup"><span data-stu-id="9a684-770">The path to trim.</span></span></param>
        <summary><span data-ttu-id="9a684-771">指定したパスのルート以降の末尾の区切り記号をトリミングします。</span><span class="sxs-lookup"><span data-stu-id="9a684-771">Trims one trailing directory separator beyond the root of the specified path.</span></span></summary>
        <returns><span data-ttu-id="9a684-772">末尾のディレクトリ区切り記号を含まない <paramref name="path" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-772">The <paramref name="path" /> without any trailing directory separators.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary><span data-ttu-id="9a684-773">個々のパス コンポーネントを事前に割り当てられた文字範囲に連結することを試み、この操作が成功したかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-773">Attempts to concatenate individual path components to a preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

<span data-ttu-id="9a684-774">コピー先の文字範囲は、連結されたパスを保持するのに十分な大きさである必要があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-774">The destination character span must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="9a684-775">次の例に示すように、<xref:System.Span%601.Slice%2A?displayProperty=nameWithType> メソッドを呼び出すことによって、連結されたパスを取得できます。</span><span class="sxs-lookup"><span data-stu-id="9a684-775">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the following example illustrates.</span></span>

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="9a684-776">結合する最初のパスを含む文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-776">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="9a684-777">結合する 2 番目のパスを含む文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-777">A character span that contains the second path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="9a684-778">連結されたパスを保持する文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-778">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="9a684-779">メソッドから制御が戻ったときに、<paramref name="destination" /> に書き込まれた文字数を示す値。</span><span class="sxs-lookup"><span data-stu-id="9a684-779">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="9a684-780">2 つのパス コンポーネントを事前に割り当てられた単一の文字範囲に連結することを試み、この操作が成功したかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-780">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="9a684-781">連結操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-781"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="9a684-782">`destination` は、連結されたパスを保持するのに十分な大きさである必要があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-782">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="9a684-783">この例に示すように、<xref:System.Span%601.Slice%2A?displayProperty=nameWithType> メソッドを呼び出すことによって、連結されたパスを取得できます。</span><span class="sxs-lookup"><span data-stu-id="9a684-783">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-784">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-784">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1"><span data-ttu-id="9a684-785">結合する最初のパスを含む文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-785">A character span that contains the first path to join.</span></span></param>
        <param name="path2"><span data-ttu-id="9a684-786">結合する 2 番目のパスを含む文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-786">A character span that contains the second path to join.</span></span></param>
        <param name="path3"><span data-ttu-id="9a684-787">結合する 3 番目のパスを含む文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-787">A character span that contains the third path to join.</span></span></param>
        <param name="destination"><span data-ttu-id="9a684-788">連結されたパスを保持する文字範囲。</span><span class="sxs-lookup"><span data-stu-id="9a684-788">A character span to hold the concatenated path.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="9a684-789">メソッドから制御が戻ったときに、<paramref name="destination" /> に書き込まれた文字数を示す値。</span><span class="sxs-lookup"><span data-stu-id="9a684-789">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</span></span></param>
        <summary><span data-ttu-id="9a684-790">2 つのパス コンポーネントを事前に割り当てられた単一の文字範囲に連結することを試み、この操作が成功したかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="9a684-790">Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="9a684-791">連結操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9a684-791"><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

<span data-ttu-id="9a684-792">`destination` は、連結されたパスを保持するのに十分な大きさである必要があります。</span><span class="sxs-lookup"><span data-stu-id="9a684-792">`destination` must be large enough to hold the concatenated path.</span></span> <span data-ttu-id="9a684-793">この例に示すように、<xref:System.Span%601.Slice%2A?displayProperty=nameWithType> メソッドを呼び出すことによって、連結されたパスを取得できます。</span><span class="sxs-lookup"><span data-stu-id="9a684-793">You can then retrieve the concatenated path by calling the <xref:System.Span%601.Slice%2A?displayProperty=nameWithType> method, as the example illustrates.</span></span>

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md"><span data-ttu-id="9a684-794">Windows システムのファイル パス形式</span><span class="sxs-lookup"><span data-stu-id="9a684-794">File path formats on Windows systems</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9a684-795">プラットフォーム固有のボリューム区切り記号を提供します。</span><span class="sxs-lookup"><span data-stu-id="9a684-795">Provides a platform-specific volume separator character.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9a684-796">このフィールドの値はコロン (:)Windows と Macintosh の場合は、UNIX オペレーティングシステムの場合はスラッシュ (/)。</span><span class="sxs-lookup"><span data-stu-id="9a684-796">The value of this field is a colon (:) on Windows and Macintosh, and a slash (/) on UNIX operating systems.</span></span> <span data-ttu-id="9a684-797">これは、"c:\windows" や "MacVolume: System Folder" などのパスを解析する場合に最も役立ちます。</span><span class="sxs-lookup"><span data-stu-id="9a684-797">This is most useful for parsing paths such as "c:\windows" or "MacVolume:System Folder".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9a684-798">次の例では、`VolumeSeparatorChar` フィールドの使用方法を示します。</span><span class="sxs-lookup"><span data-stu-id="9a684-798">The following example demonstrates the use of the `VolumeSeparatorChar` field.</span></span>  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="9a684-799">ファイルおよびストリーム入出力</span><span class="sxs-lookup"><span data-stu-id="9a684-799">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="9a684-800">方法 : ファイルからテキストを読み取る</span><span class="sxs-lookup"><span data-stu-id="9a684-800">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="9a684-801">方法 : ファイルにテキストを書き込む</span><span class="sxs-lookup"><span data-stu-id="9a684-801">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
