<Type Name="Path" FullName="System.IO.Path">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bbceb05c56c65218177af6b97840c0c9b2ab8ae0" /><Meta Name="ms.sourcegitcommit" Value="385ff23cc00fe9aa1c93460c62603b45c2041d0b" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="11/22/2019" /><Meta Name="ms.locfileid" Value="74386292" /></Metadata><TypeSignature Language="C#" Value="public static class Path" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Path extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Path" />
  <TypeSignature Language="VB.NET" Value="Public Class Path" />
  <TypeSignature Language="C++ CLI" Value="public ref class Path abstract sealed" />
  <TypeSignature Language="F#" Value="type Path = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Performs operations on <see cref="T:System.String" /> instances that contain file or directory path information. These operations are performed in a cross-platform manner.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 パスは、ファイルまたはディレクトリの場所を提供する文字列です。 パスがディスク上の場所を指しているとは限りません。たとえば、パスは、メモリ内またはデバイス上の場所にマップされる場合があります。 パスの正確な形式は、現在のプラットフォームによって決まります。 たとえば、一部のシステムでは、パスはドライブまたはボリューム文字で開始できますが、この要素は他のシステムには存在しません。 一部のシステムでは、ファイルパスに拡張子を含めることができます。拡張子は、ファイルに格納されている情報の種類を示します。 ファイル名拡張子の形式はプラットフォームに依存します。たとえば、一部のシステムでは拡張機能を3文字に制限していますが、そうでない場合もあります。 また、現在のプラットフォームでは、パスの要素を区切るために使用する文字セットと、パスを指定するときに使用できない文字のセットも決定されます。 これらの違いにより、`Path` クラスのフィールドと、`Path` クラスの一部のメンバーの正確な動作は、プラットフォームに依存しています。  
  
 パスには、絶対または相対位置情報を含めることができます。 絶対パスは、場所を完全に指定します。ファイルまたはディレクトリは、現在の場所に関係なく一意に識別できます。 相対パスは、部分的な場所を指定します。相対パスで指定されたファイルを検索するときに、現在の場所が開始点として使用されます。 現在のディレクトリを特定するには、<xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType>を呼び出します。  

 .NET Core 1.1 以降のバージョンと .NET Framework 4.6.2 以降のバージョンでは、"\\? \C:\"などのデバイス名を持つファイルシステムオブジェクトへのアクセスもサポートされます。

Windows でのファイルパス形式の詳細については、「 [windows システムでのファイルパス形式](~/docs/standard/io/file-path-formats.md)」を参照してください。

 `Path` クラスのほとんどのメンバーは、ファイルシステムとはやり取りせず、パス文字列によって指定されたファイルが存在するかどうかを検証しません。 パス文字列を変更する `Path` クラスメンバー (<xref:System.IO.Path.ChangeExtension%2A>など) は、ファイルシステム内のファイルの名前には影響しません。 ただし `Path` メンバーは、指定されたパス文字列の内容を検証し、<xref:System.IO.Path.GetInvalidPathChars%2A> メソッドから返された文字で定義されているように、文字列にパス文字列で無効な文字が含まれている場合は <xref:System.ArgumentException> 例外をスローします。 たとえば、Windows ベースのデスクトッププラットフォームでは、無効なパス文字に引用符 (")、小なり (\<)、より大きい (>)、パイプ (&#124;)、バックスペース (\b)、null (\ 0)、Unicode 文字 16 ~ 18、20 ~ 25 があります。  
  
 `Path` クラスのメンバーを使用すると、ファイル名拡張子がパスの一部であるかどうかを判断したり、2つの文字列を1つのパス名に結合したりするなど、一般的な操作をすばやく簡単に実行できます。  
  
 `Path` クラスのすべてのメンバーは静的であるため、パスのインスタンスを使用せずに呼び出すことができます。  
  
> [!NOTE]
>  パスを入力文字列として受け取るメンバーでは、そのパスは適切な形式である必要があります。そうでない場合、例外が発生します。 たとえば、パスが完全修飾されていても、スペースで始まる場合は、クラスのメソッドでパスがトリムされません。 そのため、パスの形式が正しくないため、例外が発生します。 同様に、パスまたはパスの組み合わせを2回完全に修飾することはできません。 たとえば、"c:\temp c:\windows" は、ほとんどの場合に例外を発生させます。 パス文字列を受け取るメソッドを使用する場合は、パスが適切な形式であることを確認します。  
  
 パスを受け入れるメンバーでは、ファイルまたはディレクトリのみを参照できます。 指定されたパスは、サーバーと共有名の相対パスまたは UNC (汎用名前付け規則) パスを参照することもできます。 たとえば、次のすべてが許容されるパスです。  
  
-   Visual Basic の "c:\\\MyDir\\\MyFile.txt C#" または "c:\MyDir\MyFile.txt"。  
  
-   Visual Basic の "c:\\\MyDir C#"、または "c:\MyDir"。  
  
-   "の MyDir\\\MySubdir" C#、または Visual Basic の "MyDir\MySubDir"。  
  
-   "\\\\\\\ MyServer\\\MyShare" C#、または\\の "Visual Basic 「\myserver\myshare」"。  
  
 これらのすべての操作は文字列に対して実行されるため、結果がすべてのシナリオで有効であることを確認することはできません。 たとえば、<xref:System.IO.Path.GetExtension%2A> メソッドは、渡された文字列を解析し、その文字列から拡張を返します。 ただし、その拡張子を持つファイルがディスク上に存在することを意味するわけではありません。  
  
 共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。   
  
## Examples  
 次の例は、`Path` クラスの主なメンバーの一部を示しています。  
  
 [!code-cpp[path class#1](~/samples/snippets/cpp/VS_Snippets_CLR/Path Class/CPP/path class.cpp#1)]
 [!code-csharp[path class#1](~/samples/snippets/csharp/VS_Snippets_CLR/Path Class/CS/path class.cs#1)]
 [!code-vb[path class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Path Class/VB/path class.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">方法 : 新しく作成されたデータ ファイルに対して読み書きする</related>
    <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
  </Docs>
  <Members>
    <Member MemberName="AltDirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char AltDirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.AltDirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AltDirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char AltDirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable AltDirectorySeparatorChar : char" Usage="System.IO.Path.AltDirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Provides a platform-specific alternate character used to separate directory levels in a path string that reflects a hierarchical file system organization.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
このフィールドは、<xref:System.IO.Path.DirectorySeparatorChar>と同じ値を持つことができます。 `AltDirectorySeparatorChar` と <xref:System.IO.Path.DirectorySeparatorChar> は両方とも、パス文字列内のディレクトリレベルを区切るために有効です。  
  
このフィールドの値は、Windows と Unix ベースの両方のオペレーティングシステムのスラッシュ ('/') です。  
  
## Examples  

次の例では、Windows および Unix ベースのシステムで <xref:System.IO.Path> フィールド値を表示します。 Windows では、スラッシュ (<xref:System.IO.Path.AltDirectorySeparatorChar> フィールドによって返されます) または円記号 (<xref:System.IO.Path.DirectorySeparatorChar> フィールドから返されます) のいずれかがパス区切り文字としてサポートされていますが、Unix ベースのシステムではスラッシュのみがサポートされています。

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="ChangeExtension">
      <MemberSignature Language="C#" Value="public static string ChangeExtension (string path, string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ChangeExtension(string path, string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.ChangeExtension(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChangeExtension (path As String, extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ChangeExtension(System::String ^ path, System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member ChangeExtension : string * string -&gt; string" Usage="System.IO.Path.ChangeExtension (path, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="extension" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path information to modify. The path cannot contain any of the characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</param>
        <param name="extension">The new extension (with or without a leading period). Specify <see langword="null" /> to remove an existing extension from <paramref name="path" />.</param>
        <summary>Changes the extension of a path string.</summary>
        <returns>The modified path information.  
  
On Windows-based desktop platforms, if <paramref name="path" /> is <see langword="null" /> or an empty string (""), the path information is returned unmodified. If <paramref name="extension" /> is <see langword="null" />, the returned string contains the specified path with its extension removed. If <paramref name="path" /> has no extension, and <paramref name="extension" /> is not <see langword="null" />, the returned path string contains <paramref name="extension" /> appended to the end of <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` も `extension` にもピリオド (.) が含まれていない場合、`ChangeExtension` はピリオドを追加します。  
  
 `extension` パラメーターには、複数のピリオドと有効なパス文字を含めることができ、任意の長さを指定できます。 `extension` が `null`の場合、返される文字列には、最後の期間に続く `path` の内容と、その後のすべての文字が含まれます。  
  
 `extension` が空の文字列の場合、返されるパス文字列には、最後の期間が削除された後の文字を含む `path` の内容が含まれます。  
  
 `path` に拡張子がなく、`extension` が `null`ない場合、返される文字列には、`path` 後に `extension`が格納されます。  
  
 `extension` が `null` ず、先頭のピリオドが含まれていない場合は、期間が追加されます。  
  
 複数のピリオドで区切られた複数の拡張子が `path` に含まれている場合、返される文字列には、最後の期間の `path` の内容と、それに続くすべての文字が `extension`に置き換えられます。 たとえば、`path` が "\Dir1\examples\pathtests.csx.txt" で `extension` が "cs" の場合、変更されたパスは "\Dir1\examples\pathtests.csx.cs" になります。  
  
 返された結果がすべてのシナリオで有効であることを確認することはできません。 たとえば、`path` が空の場合、`extension` が追加されます。  
  
 共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。  
  
   
  
## Examples  
 次の例は、`ChangeExtension` メソッドの使用方法を示しています。  
  
 [!code-cpp[System.IO.Path Members#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#1)]
 [!code-csharp[System.IO.Path Members#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#1)]
 [!code-vb[System.IO.Path Members#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Combines strings into a path.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

このメソッドは、個々の文字列を、ファイルパスを表す1つの文字列に連結することを目的としています。 ただし、最初の以外の引数にルート化されたパスが含まれている場合、前のパスコンポーネントは無視され、返された文字列はルートパスコンポーネントで始まります。 `Combine` メソッドの代わりに、<xref:System.IO.Path.Join%2A> メソッドまたは <xref:System.IO.Path.TryJoin%2A> メソッドの使用を検討してください。

> [!IMPORTANT]
> このメソッドは、最初の引数が絶対パスであり、次の引数が相対パスであることを前提としています。 そうでない場合、特に後続の引数がユーザーによって入力された文字列の場合は、代わりに <xref:System.IO.Path.Join%2A> または <xref:System.IO.Path.TryJoin%2A> メソッドを呼び出します。

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Combine : string[] -&gt; string" Usage="System.IO.Path.Combine paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">An array of parts of the path.</param>
        <summary>Combines an array of strings into a path.</summary>
        <returns>The combined paths.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

`paths` は、結合するパスの部分の配列である必要があります。 後続のパスのいずれかが絶対パスの場合、結合操作はその絶対パスで開始され、前に結合されたすべてのパスを破棄してリセットされます。  

`paths` 内のいずれかの要素が、最後の要素がドライブではなく、<xref:System.IO.Path.DirectorySeparatorChar> または <xref:System.IO.Path.AltDirectorySeparatorChar> 文字で終了しない場合、`Combine` メソッドはその要素と次の要素の間に <xref:System.IO.Path.DirectorySeparatorChar> 文字を追加します。 要素がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Combine` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。 次の例では、円記号がパスの区切り文字として使用されている場合に、Windows と Unix ベースのシステムの結果を比較します。

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#1)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#1)]  

 長さ0の文字列は、組み合わせたパスから省略されます。  
  
 空白の場合、パラメーターは解析されません。  
  
 検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Combine` メソッドでは許容されないと解釈されます。 たとえば、ファイルからファイルを作成した場合、`Path.Combine("c:\\", "*.txt")` は無効になることがありますが、検索文字列として有効です。 したがって、`Combine` メソッドによって正常に解釈されます。  
  
## Examples  
 次の例では、文字列の配列を1つのパスに結合します。  
  
 [!code-csharp[System.IO.Path.Combine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#3)]
 [!code-vb[System.IO.Path.Combine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">One of the strings in the array contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">One of the strings in the array is <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">The first path to combine.</param>
        <param name="path2">The second path to combine.</param>
        <summary>Combines two strings into a path.</summary>
        <returns>The combined paths. If one of the specified paths is a zero-length string, this method returns the other path. If <paramref name="path2" /> contains an absolute path, this method returns <paramref name="path2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` がドライブ参照 (つまり "C:" または "D:") ではなく、<xref:System.IO.Path.DirectorySeparatorChar>、<xref:System.IO.Path.AltDirectorySeparatorChar>、または <xref:System.IO.Path.VolumeSeparatorChar>で定義されている有効な区切り文字で終了していない場合、連結の前に <xref:System.IO.Path.DirectorySeparatorChar> に `path1` が追加されます。 ターゲットプラットフォームに適していないパス区切り文字で `path1` が終了した場合、`Combine` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。 次の例では、円記号がパスの区切り文字として使用されている場合に、Windows と Unix ベースのシステムの結果を比較します。  
  
[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#2)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#2)]  

 `path2` にルートが含まれていない場合 (たとえば、`path2` が区切り文字またはドライブ指定で始まらない場合)、結果は2つのパスを連結したものであり、区切り文字が介在します。 `path2` にルートが含まれている場合は、`path2` が返されます。  
  
 空白の場合、パラメーターは解析されません。 したがって、`path2` に空白が含まれている場合 (たとえば、"\file.txt")、<xref:System.IO.Path.Combine%2A> メソッドは `path2`だけを返すのではなく、`path1` に `path2` を追加します。  
  
 検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Combine` メソッドでは許容されないと解釈されます。 たとえば、ファイルからファイルを作成した場合、`Path.Combine("c:\\", "*.txt")` は無効になることがありますが、検索文字列として有効です。 したがって、`Combine` メソッドによって正常に解釈されます。  
  
 共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。  
  
   
  
## Examples  
 次の例は、Windows ベースのデスクトッププラットフォームで `Combine` メソッドを使用する方法を示しています。  
  
 [!code-cpp[pathcombine#1](~/samples/snippets/cpp/VS_Snippets_CLR/pathcombine/CPP/pathcombine.cpp#1)]
 [!code-csharp[pathcombine#1](~/samples/snippets/csharp/VS_Snippets_CLR/pathcombine/CS/pathcombine.cs#1)]
 [!code-vb[pathcombine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/pathcombine/VB/pathcombine.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" /> or <paramref name="path2" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" /> or <paramref name="path2" /> is <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">The first path to combine.</param>
        <param name="path2">The second path to combine.</param>
        <param name="path3">The third path to combine.</param>
        <summary>Combines three strings into a path.</summary>
        <returns>The combined paths.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` は絶対パス (たとえば、"d:\archives" または "\\\archives\public") にする必要があります。 `path2` または `path3` が絶対パスでもある場合、結合操作は以前に結合されたすべてのパスを破棄し、その絶対パスにリセットします。  
  
 長さ0の文字列は、組み合わせたパスから省略されます。  
  
 `path1` または `path2` がドライブ参照 (つまり、"C:" または "D:") ではなく、<xref:System.IO.Path.DirectorySeparatorChar>、<xref:System.IO.Path.AltDirectorySeparatorChar>、または <xref:System.IO.Path.VolumeSeparatorChar>で定義されている有効な区切り文字で終了しない場合は、連結の前に <xref:System.IO.Path.DirectorySeparatorChar> または `path1` に追加されます。`path2` `path1` または `path2` がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Combine` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。 次の例では、円記号がパスの区切り文字として使用されている場合に、Windows と Unix ベースのシステムの結果を比較します。 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#3)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#3)]  

 `path2` にルートが含まれていない場合 (たとえば、`path2` が区切り文字またはドライブ指定で始まらない場合)、結果は2つのパスを連結したものであり、区切り文字が介在します。 `path2` にルートが含まれている場合は、`path2` が返されます。  
  
 空白の場合、パラメーターは解析されません。 したがって、`path2` に空白が含まれている場合 (たとえば、"\file.txt")、<xref:System.IO.Path.Combine%2A> メソッドは `path1`に `path2` を追加します。  
  
 検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Combine` メソッドでは許容されないと解釈されます。 たとえば、ファイルからファイルを作成した場合、`Path.Combine("c:\\", "*.txt")` は無効になることがありますが、検索文字列として有効です。 したがって、`Combine` メソッドによって正常に解釈されます。  
  
   
  
## Examples  
 次の例では、3つのパスを結合します。  
  
 [!code-csharp[System.IO.Path.Combine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#1)]
 [!code-vb[System.IO.Path.Combine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />, <paramref name="path2" />, or <paramref name="path3" /> is <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static string Combine (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Combine(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Combine(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Combine(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Combine : string * string * string * string -&gt; string" Usage="System.IO.Path.Combine (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">The first path to combine.</param>
        <param name="path2">The second path to combine.</param>
        <param name="path3">The third path to combine.</param>
        <param name="path4">The fourth path to combine.</param>
        <summary>Combines four strings into a path.</summary>
        <returns>The combined paths.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path1` は絶対パス (たとえば、"d:\archives" または "\\\archives\public") にする必要があります。後続のパスのいずれかが絶対パスでもある場合、結合操作は以前に結合されたすべてのパスを破棄し、その絶対パスにリセットします。  
  
 長さ0の文字列は、組み合わせたパスから省略されます。  
  
 `path1`、`path2`、または `path3` がドライブ参照 (つまり、"C:" または "D:") ではなく、<xref:System.IO.Path.DirectorySeparatorChar>、<xref:System.IO.Path.AltDirectorySeparatorChar>、または <xref:System.IO.Path.VolumeSeparatorChar>で定義されている有効な区切り文字で終了していない場合、連結の前に <xref:System.IO.Path.DirectorySeparatorChar> が追加されます。 `path1`、`path2`、または `path3` がターゲットプラットフォームに適していないパス区切り文字で終了する場合、`Combine` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。 次の例では、円記号がパスの区切り文字として使用されている場合に、Windows と Unix ベースのシステムの結果を比較します。 

[!code-csharp[Combine and path separator characters](~/samples/snippets/csharp/api/system.io/path/combine/program.cs#4)]
[!code-vb[Combine and path separator characters](~/samples/snippets/visualbasic/api/system.io/path/combine/program.vb#4)]   
  
 `path2` にルートが含まれていない場合 (たとえば、`path2` が区切り文字またはドライブ指定で始まらない場合)、結果は2つのパスを連結したものであり、区切り文字が介在します。 `path2` にルートが含まれている場合は、`path2` が返されます。  
  
 空白の場合、パラメーターは解析されません。 したがって、`path2` に空白が含まれている場合 (たとえば、"\file.txt")、<xref:System.IO.Path.Combine%2A> メソッドは `path1`に `path2` を追加します。  
  
 検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Combine` メソッドでは許容されないと解釈されます。 たとえば、ファイルからファイルを作成した場合、`Path.Combine("c:\\", "*.txt")` は無効になることがありますが、検索文字列として有効です。 したがって、`Combine` メソッドによって正常に解釈されます。  
  
   
  
## Examples  
 次の例では、4つのパスを結合します。  
  
 [!code-csharp[System.IO.Path.Combine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.path.combine/cs/program.cs#2)]
 [!code-vb[System.IO.Path.Combine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.path.combine/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path1" />, <paramref name="path2" />, <paramref name="path3" />, or <paramref name="path4" /> is <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="DirectorySeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char DirectorySeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char DirectorySeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.DirectorySeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DirectorySeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char DirectorySeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable DirectorySeparatorChar : char" Usage="System.IO.Path.DirectorySeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Provides a platform-specific character used to separate directory levels in a path string that reflects a hierarchical file system organization.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.IO.Path.AltDirectorySeparatorChar> と `DirectorySeparatorChar` は両方とも、パス文字列内のディレクトリレベルを区切るために有効です。  
  
.NET Core を使用して、複数のプラットフォームで実行されるアプリケーションを開発する場合は、次のようにします。

- ディレクトリ区切り記号をハードコーディングする場合は、スラッシュ (`/`) 文字を使用する必要があります。 Unix システムで認識されているディレクトリ区切り文字は、この例の出力に示されているものだけであり、Windows では <xref:System.IO.Path.AltDirectorySeparatorChar> です。

- 実行時にパスの区切り文字を動的に取得し、ファイルシステムパスに組み込むには、文字列の連結を使用します。 次に例を示します。 

   ```csharp
   separator = Path.DirectorySeparatorChar;
   path = $"{separator}users{separator}user1{separator}";
   ```

   ```vb
   separator = Path.DirectorySeparatorChar
   path = $"{separator}users{separator}user1{separator}"
   ``` 

   <xref:System.IO.Path.AltDirectorySeparatorChar> プロパティから値を取得することもできます。これは、Windows と Unx の両方のシステムで同じであるためです。

- <xref:System.IO.Path.AltDirectorySeparatorChar> プロパティを取得する

アプリケーションがクロスプラットフォームでない場合は、システムに適した区切り記号を使用できます。

## Examples  

次の例では、Windows および Unix ベースのシステムで <xref:System.IO.Path> フィールド値を表示します。 Windows では、スラッシュ (<xref:System.IO.Path.AltDirectorySeparatorChar> フィールドによって返されます) または円記号 (<xref:System.IO.Path.DirectorySeparatorChar> フィールドから返されます) のいずれかがパス区切り文字としてサポートされていますが、Unix ベースのシステムではスラッシュのみがサポートされています。  

[!code-csharp[DirectorySeparatorChar](~/samples/snippets/csharp/api/system.io/path/directoryseparatorchar/program.cs)]
[!code-vb[DirectorySeparatorChar](~/samples/snippets/visualbasic/api/system.io/path/directoryseparatorchar/program.vb)]
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">The path to analyze.</param>
        <summary>Returns a value that indicates whether the path, specified as a read-only span, ends in a directory separator.</summary>
        <returns><see langword="true" /> if the path ends in a directory separator; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsInDirectorySeparator">
      <MemberSignature Language="C#" Value="public static bool EndsInDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EndsInDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.EndsInDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndsInDirectorySeparator (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EndsInDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member EndsInDirectorySeparator : string -&gt; bool" Usage="System.IO.Path.EndsInDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">The path to analyze.</param>
        <summary>Returns a value that indicates whether the specified path ends in a directory separator.</summary>
        <returns><see langword="true" /> if the path ends in a directory separator; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetDirectoryName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetDirectoryName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetDirectoryName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">The path to retrieve the directory information from.</param>
        <summary>Returns the directory information for the specified path represented by a character span.</summary>
        <returns>Directory information for <paramref name="path" />, or an empty span if <paramref name="path" /> is <see langword="null" />, an empty span, or a root (such as \, C:, or \\server\share).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

文字列のオーバーロードとは異なり、このメソッドはディレクトリの区切り記号を正規化しません。

          ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryName">
      <MemberSignature Language="C#" Value="public static string GetDirectoryName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetDirectoryName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDirectoryName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetDirectoryName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetDirectoryName : string -&gt; string" Usage="System.IO.Path.GetDirectoryName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path of a file or directory.</param>
        <summary>Returns the directory information for the specified path string.</summary>
        <returns>Directory information for <paramref name="path" />, or <see langword="null" /> if <paramref name="path" /> denotes a root directory or is null. Returns <see cref="F:System.String.Empty" /> if <paramref name="path" /> does not contain directory information.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの場合、このメソッドによって返される文字列は、パス内のすべての文字で構成されますが、最後の <xref:System.IO.Path.DirectorySeparatorChar> や <xref:System.IO.Path.AltDirectorySeparatorChar>は含まれません。 パスがルートディレクトリ ("c:\\" など) で構成されている場合は、null が返されます。 このメソッドは、"file:" を使用したパスをサポートしていないことに注意してください。 返されたパスには <xref:System.IO.Path.DirectorySeparatorChar> または <xref:System.IO.Path.AltDirectorySeparatorChar>が含まれていないため、返されたパスを <xref:System.IO.Path.GetDirectoryName%2A> メソッドに渡すと、結果文字列の後続の呼び出しごとに1つのフォルダーレベルが切り捨てられます。 たとえば、パス "C:\Directory\SubDirectory\test.txt" を <xref:System.IO.Path.GetDirectoryName%2A> メソッドに渡すと、"C:\Directory\SubDirectory" が返されます。 その文字列 "C:\Directory\SubDirectory" を <xref:System.IO.Path.GetDirectoryName%2A> に渡すと、"C:\ ディレクトリ" になります。  
  
 共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。  
  
   
  
## Examples  
 次の例は、Windows ベースのデスクトッププラットフォームで `GetDirectoryName` メソッドを使用する方法を示しています。  
  
 [!code-cpp[System.IO.Path Members#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#3)]
 [!code-csharp[System.IO.Path Members#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#3)]
 [!code-vb[System.IO.Path Members#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="path" /> parameter contains invalid characters, is empty, or contains only white spaces.</exception>
        <exception cref="T:System.IO.PathTooLongException"><block subset="none" type="note">
            <para>  
 In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.  
  
</para>
          </block>  
  
 The <paramref name="path" /> parameter is longer than the system-defined maximum length.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">The file path from which to get the extension.</param>
        <summary>Returns the extension of a file path that is represented by a read-only character span.</summary>
        <returns>The extension of the specified path (including the period, "."), or <see cref="P:System.ReadOnlySpan`1.Empty" /> if <paramref name="path" /> does not have extension information.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

このメソッドは、`path` の拡張機能を取得します。そのためには、読み取り専用スパンの最後の文字から始まり、その最初の文字に向かって、ピリオド (".") の `path` を検索します。 <xref:System.IO.Path.DirectorySeparatorChar> または <xref:System.IO.Path.AltDirectorySeparatorChar> 文字の前にピリオドがある場合、返される読み取り専用の範囲には、その後のピリオドと文字が含まれます。それ以外の場合は <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> が返されます。  

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="GetExtension">
      <MemberSignature Language="C#" Value="public static string GetExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetExtension : string -&gt; string" Usage="System.IO.Path.GetExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path string from which to get the extension.</param>
        <summary>Returns the extension (including the period ".") of the specified path string.</summary>
        <returns>The extension of the specified path (including the period "."), or <see langword="null" />, or <see cref="F:System.String.Empty" />. If <paramref name="path" /> is <see langword="null" />, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see langword="null" />. If <paramref name="path" /> does not have extension information, <see cref="M:System.IO.Path.GetExtension(System.String)" /> returns <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

このメソッドは、`path` の拡張機能を取得します。そのためには、`path` をピリオド (.) で検索し `path` の最後の文字から始まり、最初の文字に進みます。 <xref:System.IO.Path.DirectorySeparatorChar> または <xref:System.IO.Path.AltDirectorySeparatorChar> 文字の前にピリオドがある場合、返される文字列にはピリオドとその後の文字が含まれます。それ以外の場合は <xref:System.String.Empty?displayProperty=nameWithType> が返されます。  
  
 共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。
 
## Examples  
 次の例は、Windows ベースのデスクトッププラットフォームで `GetExtension` メソッドを使用する方法を示しています。  
  
 [!code-cpp[System.IO.Path Members#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#4)]
 [!code-csharp[System.IO.Path Members#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#4)]
 [!code-vb[System.IO.Path Members#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileName (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileName(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileName(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">A read-only span that contains the path from which to obtain the file name and extension.</param>
        <summary>Returns the file name and extension of a file path that is represented by a read-only character span.</summary>
        <returns>The characters after the last directory separator character in <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

返される読み取り専用スパンには、`path`の最後の区切り記号の後に続くパスの文字が含まれます。 `path` の最後の文字がボリュームまたはディレクトリの区切り文字の場合、メソッドは <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>を返します。 `path` に区切り文字が含まれていない場合、メソッドは `path`を返します。

         ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileName">
      <MemberSignature Language="C#" Value="public static string GetFileName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileName : string -&gt; string" Usage="System.IO.Path.GetFileName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path string from which to obtain the file name and extension.</param>
        <summary>Returns the file name and extension of the specified path string.</summary>
        <returns>The characters after the last directory separator character in <paramref name="path" />. If the last character of <paramref name="path" /> is a directory or volume separator character, this method returns <see cref="F:System.String.Empty" />. If <paramref name="path" /> is <see langword="null" />, this method returns <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

ファイルパスが `null`場合、戻り値は `null` です。  
  
ファイル名の先頭を決定するために使用される区切り文字は <xref:System.IO.Path.DirectorySeparatorChar> と <xref:System.IO.Path.AltDirectorySeparatorChar>です。  

*\\*は unix 上の有効なファイル名であるため、unix ベースのプラットフォームで実行されている `GetFileName` は、 *C:\\mydir\\myfile.txt*のような Windows ベースのパスからファイル名を正しく返すことはできません `GetFileName` が、Windows ベースのプラットフォームでは、 */tmp/myfile.ext*のような unix ベースのパスからファイル名を正しく返すことができます。そのため、`GetFileName` 方法の動作は、unix ベースおよび Windows ベースのプラットフォームでは厳密には同じではありません。

共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。  
  
   
  
## Examples  
 次の例は、Windows ベースのデスクトッププラットフォームでの `GetFileName` メソッドの動作を示しています。  
  
 [!code-cpp[System.IO.Path Members#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#5)]
 [!code-csharp[System.IO.Path Members#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#5)]
 [!code-vb[System.IO.Path Members#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetFileNameWithoutExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetFileNameWithoutExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">A read-only span that contains the path from which to obtain the file name without the extension.</param>
        <summary>Returns the file name without the extension of a file path that is represented by a read-only character span.</summary>
        <returns>The characters in the read-only span returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNameWithoutExtension">
      <MemberSignature Language="C#" Value="public static string GetFileNameWithoutExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFileNameWithoutExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFileNameWithoutExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFileNameWithoutExtension (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFileNameWithoutExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFileNameWithoutExtension : string -&gt; string" Usage="System.IO.Path.GetFileNameWithoutExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path of the file.</param>
        <summary>Returns the file name of the specified path string without the extension.</summary>
        <returns>The string returned by <see cref="M:System.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})" />, minus the last period (.) and all characters following it.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、パスまたはファイル名が存在するかどうかは検証されません。  
  
 共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。  
  
   
  
## Examples  
 次の例は、`GetFileNameWithoutExtension` メソッドの使用方法を示しています。  
  
 [!code-cpp[System.IO.Path Members#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#6)]
 [!code-csharp[System.IO.Path Members#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#6)]
 [!code-vb[System.IO.Path Members#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string -&gt; string" Usage="System.IO.Path.GetFullPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">The file or directory for which to obtain absolute path information.</param>
        <summary>Returns the absolute path for the specified path string.</summary>
        <returns>The fully qualified location of <paramref name="path" />, such as "C:\MyFile.txt".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 絶対パスには、システム上のファイルまたはディレクトリを検索するために必要なすべての情報が含まれています。  
  
 `path` によって指定されたファイルまたはディレクトリが存在している必要はありません。 たとえば、 *c:\temp\newdir*が現在のディレクトリである場合、 *test.txt*などのファイル名に対して `GetFullPath` を呼び出すと、 *c:\temp\newdir\test.txt*が返されます。 ファイルは存在していない必要があります。  

> [!IMPORTANT]
> `path` が相対パスの場合、このオーバーロードは、現在のドライブと現在のディレクトリに基づいている可能性がある絶対パスを返します。 現在のドライブと現在のディレクトリは、アプリケーションの実行時にいつでも変更できます。 このため、このオーバーロードによって返されるパスは事前に決定できません。 決定的パスを返すには、<xref:System.IO.Path.GetFullPath(System.String,System.String)> オーバーロードを呼び出します。 また、<xref:System.IO.Path.IsPathFullyQualified%2A> メソッドを呼び出して、パスが完全に修飾されているか、相対パスであるかを判断し、`GetFullPath` の呼び出しが必要であるかどうかを確認することもできます。

 ただし、`path` が存在する場合は、呼び出し元に `path`のパス情報を取得するためのアクセス許可が必要です。 <xref:System.IO.Path> クラスのほとんどのメンバーとは異なり、このメソッドはファイルシステムにアクセスします。  
  
 このメソッドでは、現在のディレクトリと現在のボリューム情報を使用して、`path`を完全に修飾します。 `path`にのみファイル名を指定した場合、`GetFullPath` は現在のディレクトリの完全修飾パスを返します。  
  
 短いファイル名を渡すと、長いファイル名に拡張されます。  
  
 パスに有意な文字が含まれていない場合、1つ以上の "." 文字の後に任意の数の空白が続くと無効になります。次に、"." または ".." として解析されます。  

.NET Core 1.1 以降のバージョンと .NET Framework 4.6.2 以降のバージョンでは、"\\? \C:\"などのデバイス名を含むパスもサポートしています。

Windows でのファイルパス形式の詳細については、「 [windows システムでのファイルパス形式](~/docs/standard/io/file-path-formats.md)」を参照してください。 共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。
  
## Examples  
 次の例は、Windows ベースのデスクトッププラットフォームでの `GetFullPath` メソッドを示しています。  
  
 [!code-cpp[System.IO.Path Members#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#7)]
 [!code-csharp[System.IO.Path Members#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#7)]
 [!code-vb[System.IO.Path Members#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> is a zero-length string, contains only white space, or contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
-or- 
The system could not retrieve the absolute path.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> contains a colon (":") that is not part of a volume identifier (for example, "c:\\").</exception>
        <exception cref="T:System.IO.PathTooLongException">The specified path, file name, or both exceed the system-defined maximum length.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスへのアクセスに使用します。</permission>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="GetFullPath">
      <MemberSignature Language="C#" Value="public static string GetFullPath (string path, string basePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFullPath(string path, string basePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetFullPath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFullPath (path As String, basePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFullPath(System::String ^ path, System::String ^ basePath);" />
      <MemberSignature Language="F#" Value="static member GetFullPath : string * string -&gt; string" Usage="System.IO.Path.GetFullPath (path, basePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="basePath" Type="System.String" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">A relative path to concatenate to <paramref name="basePath" />.</param>
        <param name="basePath">The beginning of a fully qualified path.</param>
        <summary>Returns an absolute path from a fully qualified base path and a relative path.</summary>
        <returns>The absolute path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

`path` が空のパスの場合、メソッドは `basePath`を返します。 `path` が完全修飾パスの場合、メソッドは `path` を <xref:System.IO.Path.GetFullPath(System.String)> メソッドに渡し、結果を返します。

相対パスを使用している場合は、このメソッドを使用して、指定したボリュームおよびルート化されたディレクトリに基づいて決定論的パスを返します。 現在のドライブのディレクトリに基づいて定義されているのではなく、定義済みの `basePath` を使用すると、現在のドライブとディレクトリで予期しない変更が発生したことが原因で望ましくないファイルパスに対する保護が 

## <a name="example"></a>例

次の例では、アプリケーションの現在のディレクトリを表す変数 `basePath`を定義します。 次に、それを `GetFullPath` メソッドに渡して、アプリケーションのデータディレクトリへの完全修飾パスを取得します。

[!code-csharp[Path.GetFullPath(String,String)](~/samples/snippets/csharp/api/system.io/path/getfullpath/program.cs)] 
[!code-vb[Path.GetFullPath(String,String)](~/samples/snippets/visualbasic/api/system.io/path/getfullpath/program.vb)] 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> or <paramref name="basePath" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="basePath" /> is not a fully qualified path.

-or-

<paramref name="path" /> or <paramref name="basePath" /> contains invalid path characters, such as U+0000.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidFileNameChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidFileNameChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidFileNameChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidFileNameChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidFileNameChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidFileNameChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidFileNameChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidFileNameChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an array containing the characters that are not allowed in file names.</summary>
        <returns>An array containing the characters that are not allowed in file names.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドから返される配列には、ファイル名とディレクトリ名で無効な文字の完全なセットが含まれているとは限りません。 無効な文字の完全なセットは、ファイルシステムによって異なる場合があります。 たとえば、Windows ベースのデスクトッププラットフォームでは、無効なパス文字には、ASCII/Unicode 文字 1 ~ 31 のほか、引用符 (")、小なり (\<)、より大きい (>)、パイプ&#124;()、バックスペース (\b)、null (\ 0)、およびタブ (\t) が含まれます。  
  
   
  
## Examples  
 次の例は、<xref:System.IO.Path.GetInvalidFileNameChars%2A> メソッドと、無効な文字を取得するための <xref:System.IO.Path.GetInvalidPathChars%2A> メソッドを示しています。  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInvalidPathChars">
      <MemberSignature Language="C#" Value="public static char[] GetInvalidPathChars ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] GetInvalidPathChars() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetInvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetInvalidPathChars () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ GetInvalidPathChars();" />
      <MemberSignature Language="F#" Value="static member GetInvalidPathChars : unit -&gt; char[]" Usage="System.IO.Path.GetInvalidPathChars " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an array containing the characters that are not allowed in path names.</summary>
        <returns>An array containing the characters that are not allowed in path names.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドから返される配列には、ファイル名とディレクトリ名で無効な文字の完全なセットが含まれているとは限りません。 無効な文字の完全なセットは、ファイルシステムによって異なる場合があります。 たとえば、Windows ベースのデスクトッププラットフォームでは、無効なパス文字には、ASCII/Unicode 文字 1 ~ 31 のほか、引用符 (")、小なり (\<)、より大きい (>)、パイプ&#124;()、バックスペース (\b)、null (\ 0)、およびタブ (\t) が含まれます。  
  
   
  
## Examples  
 次の例は、<xref:System.IO.Path.GetInvalidFileNameChars%2A> メソッドと、無効な文字を取得するための <xref:System.IO.Path.GetInvalidPathChars%2A> メソッドを示しています。  
  
 [!code-cpp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/cpp/example.cpp#1)]
 [!code-csharp[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/CS/example.cs#1)]
 [!code-vb[IO.Path.GetInvalidFile-PathChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Path.GetInvalidFile-PathChars/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; GetPathRoot (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; GetPathRoot(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; GetPathRoot(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">A read-only span of characters containing the path from which to obtain root directory information.</param>
        <summary>Gets the root directory information from the path contained in the specified character span.</summary>
        <returns>A read-only span of characters containing the root directory of <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

このメソッドでは、パスまたはファイルが存在するかどうかは検証されません。

文字列のオーバーロードとは異なり、このメソッドはディレクトリの区切り記号を正規化しません。

次の場合、`ReadOnlySpan<System.Char>` は "実質的に空" になります。

- Windows では、この文字の範囲に対して <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> を呼び出すと、`true`が返されます。または、すべての文字が空白 (' ') になります。
- Unix では、この文字の範囲で <xref:System.ReadOnlySpan%601.IsEmpty?displayProperty=nameWithType> を呼び出すと、`true`が返されます。

このメソッドによって返される読み取り専用の文字範囲に使用できるパターンは次のとおりです。

- <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` は <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType>でした。

- <xref:System.ReadOnlySpan%601.Empty?displayProperty=nameWithType> (`path` 現在のドライブまたはボリューム上の相対パスを指定しています)。

- "\" (Unix: `path` は現在のドライブの絶対パスを指定しています)。

- "X:" (Windows: `path` はドライブの相対パスを指定します。 *X*はドライブまたはボリューム文字を表します)。

- "X:\" (Windows: `path` 指定されたドライブの絶対パス)。

- "\\\ コンピューター名 sharedfolder" (Windows: UNC パス)。

- "\\\\\?\C:" (Windows: DOS デバイスパス。 .NET Core 1.1 以降のバージョンでサポートされています。また、.NET Framework 4.6.2 以降のバージョンでもサポートされています)。
 
Windows 上のファイルパスの詳細については、「 [windows システムでのファイルパス形式](~/docs/standard/io/file-path-formats.md)」を参照してください。 共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。


          ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="GetPathRoot">
      <MemberSignature Language="C#" Value="public static string GetPathRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPathRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetPathRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPathRoot (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPathRoot(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetPathRoot : string -&gt; string" Usage="System.IO.Path.GetPathRoot path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">A string containing the path from which to obtain root directory information.</param>
        <summary>Gets the root directory information from the path contained in the specified string.</summary>
        <returns>The root directory of <paramref name="path" /> if it is rooted.

-or- 
<see cref="P:System.String.Empty" /> if <paramref name="path" /> does not contain root directory information.

-or- 
<see langword="null" /> if <paramref name="path" /> is <see langword="null" /> or is effectively empty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

このメソッドでは、パスまたはファイルが存在するかどうかは検証されません。

このメソッドは、ディレクトリの区切り記号を正規化します。

次の場合、文字列は "実質的に空" になります。

- Windows では、この文字列に対して `IsEmpty` を呼び出すと `true`が返されるか、またはすべての文字が空白 (' ') になります。
- Unix では、この文字列に対して <xref:System.String.IsNullOrEmpty%2A> を呼び出すと `true`が返されます。

このメソッドによって返される文字列には、次のようなパターンがあります。

- `null` (`path` が null または空の文字列) です。

- 空の文字列 (`path` は、現在のドライブまたはボリューム上の相対パスを指定しています)。

- "\" (Unix: `path` は現在のドライブの絶対パスを指定しています)。

- "X:" (Windows: `path` はドライブの相対パスを指定します。 *X*はドライブまたはボリューム文字を表します)。

- "X:\" (Windows: `path` 指定されたドライブの絶対パス)。

- "\\\ コンピューター名 sharedfolder" (Windows: UNC パス)。

- "\\\\\?\C:" (Windows: DOS デバイスパス。 .NET Core 1.1 以降のバージョンでサポートされています。また、.NET Framework 4.6.2 以降のバージョンでもサポートされています)。
 
Windows 上のファイルパスの詳細については、「 [windows システムでのファイルパス形式](~/docs/standard/io/file-path-formats.md)」を参照してください。 共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。

## Examples
次の例は、`GetPathRoot` メソッドの使用方法を示しています。

[!code-cpp[System.IO.Path Members#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#8)]
[!code-csharp[System.IO.Path Members#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#8)]
[!code-vb[System.IO.Path Members#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#8)]

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">.NET Framework only: <paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.

-or-

.NET Framework only: <see cref="F:System.String.Empty" /> was passed to <paramref name="path" />.</exception>
        <related type="Article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="GetRandomFileName">
      <MemberSignature Language="C#" Value="public static string GetRandomFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRandomFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRandomFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRandomFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRandomFileName();" />
      <MemberSignature Language="F#" Value="static member GetRandomFileName : unit -&gt; string" Usage="System.IO.Path.GetRandomFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a random folder name or file name.</summary>
        <returns>A random folder name or file name.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Path.GetRandomFileName%2A> メソッドは、フォルダー名またはファイル名のいずれかとして使用できる暗号強度の高いランダムな文字列を返します。 <xref:System.IO.Path.GetTempFileName%2A>とは異なり、<xref:System.IO.Path.GetRandomFileName%2A> ではファイルは作成されません。 ファイルシステムのセキュリティが最優先事項である場合は、<xref:System.IO.Path.GetTempFileName%2A>の代わりにこの方法を使用する必要があります。  
  
   
  
## Examples  
 次の例では、<xref:System.IO.Path.GetRandomFileName%2A> メソッドからの出力を示します。  
  
 [!code-csharp[System.IO.Path Members#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers20.cs#20)]
 [!code-vb[System.IO.Path Members#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers20.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelativePath">
      <MemberSignature Language="C#" Value="public static string GetRelativePath (string relativeTo, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRelativePath(string relativeTo, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetRelativePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRelativePath (relativeTo As String, path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRelativePath(System::String ^ relativeTo, System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member GetRelativePath : string * string -&gt; string" Usage="System.IO.Path.GetRelativePath (relativeTo, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="relativeTo">The source path the result should be relative to. This path is always considered to be a directory.</param>
        <param name="path">The destination path.</param>
        <summary>Returns a relative path from one path to another.</summary>
        <returns>The relative path, or <paramref name="path" /> if the paths don't share the same root.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

パスは、差異を計算する前に <xref:System.IO.Path.GetFullPath%2A> メソッドを呼び出すことによって解決されます。 このメソッドは、現在のプラットフォームの既定のファイルパス比較 (Windows の場合は<xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>、Linux の場合は <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> を使用します。 

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relativeTo" /> or <paramref name="path" /> is <see langword="null" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public static string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="static member GetTempFileName : unit -&gt; string" Usage="System.IO.Path.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file.</summary>
        <returns>The full path of the temporary file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、「.TMP」という拡張子の一時ファイルを作成します。 一時ファイルは、 <xref:System.IO.Path.GetTempPath%2A> メソッドによりパスを取得される、ユーザーの一時フォルダー内に作成されます。  
  
 <xref:System.IO.Path.GetTempFileName%2A> メソッドは、以前の一時ファイルを削除することなく 65535 を超えるファイルを作成しようとした場合に、 <xref:System.IO.IOException> をスローします。  
  
 <xref:System.IO.Path.GetTempFileName%2A> メソッドが発生する <xref:System.IO.IOException> 一意の一時ファイル名が使用できない場合。 このエラーを解決するには、不要な一時ファイルをすべて削除してください。  
  
 共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">An I/O error occurs, such as no unique temporary file name is available.  
  
-or-
  
 This method was unable to create a temporary file.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">一時フォルダーに書き込むために必要です。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempPath">
      <MemberSignature Language="C#" Value="public static string GetTempPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTempPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.GetTempPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTempPath () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTempPath();" />
      <MemberSignature Language="F#" Value="static member GetTempPath : unit -&gt; string" Usage="System.IO.Path.GetTempPath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the path of the current user's temporary folder.</summary>
        <returns>The path to the temporary folder, ending with a backslash.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、次の順序で環境変数の存在を確認し、見つかった最初のパスを使用します。  
  
1.  TMP 環境変数によって指定されたパス。  
  
2.  TEMP 環境変数によって指定されたパス。  
  
3.  USERPROFILE 環境変数によって指定されたパス。  
  
4.  Windows ディレクトリ。  
  
   
  
## Examples  
 <xref:System.IO.Path.GetTempPath%2A> メソッドを呼び出す方法を次のコード例に示します。  
  
```vb  
Dim result As String = Path.GetTempPath()  
Console.WriteLine(result)  
```  
  
```csharp  
string result = Path.GetTempPath();  
Console.WriteLine(result);  
```  
  
 この例では、次のような出力が生成されます。  
  
```  
C:\Users\UserName\AppData\Local\Temp\  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">環境変数に無制限でアクセスできます。 関連付けられた列挙型: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">The path to search for an extension.</param>
        <summary>Determines whether the path represented by the specified character span includes a file name extension.</summary>
        <returns><see langword="true" /> if the characters that follow the last directory separator character or volume separator in the path include a period (".") followed by one or more characters; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

`path` の末尾のピリオドは、拡張機能とは見なされません。

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="HasExtension">
      <MemberSignature Language="C#" Value="public static bool HasExtension (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool HasExtension(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.HasExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HasExtension (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool HasExtension(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member HasExtension : string -&gt; bool" Usage="System.IO.Path.HasExtension path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path to search for an extension.</param>
        <summary>Determines whether a path includes a file name extension.</summary>
        <returns><see langword="true" /> if the characters that follow the last directory separator (\\\ or /) or volume separator (:) in the path include a period (.) followed by one or more characters; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path`の末尾から、このメソッドはピリオド (.) と1つ以上の文字を検索します。 <xref:System.IO.Path.DirectorySeparatorChar>、<xref:System.IO.Path.AltDirectorySeparatorChar>、または <xref:System.IO.Path.VolumeSeparatorChar> 文字が検出される前にこのパターンが見つかった場合、このメソッドは `true`を返します。  
  
 共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。  
  
   
  
## Examples  
 `HasExtension` メソッドの使用例を次に示します。  
  
 [!code-cpp[System.IO.Path Members#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#11)]
 [!code-csharp[System.IO.Path Members#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#11)]
 [!code-vb[System.IO.Path Members#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="InvalidPathChars">
      <MemberSignature Language="C#" Value="public static readonly char[] InvalidPathChars;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char[] InvalidPathChars" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.InvalidPathChars" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InvalidPathChars As Char() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;char&gt; ^ InvalidPathChars;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidPathChars : char[]" Usage="System.IO.Path.InvalidPathChars" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("see GetInvalidPathChars and GetInvalidFileNameChars methods.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Provides a platform-specific array of characters that cannot be specified in path string arguments passed to members of the <see cref="T:System.IO.Path" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドから返される配列には、ファイル名とディレクトリ名で無効な文字の完全なセットが含まれているとは限りません。 無効な文字の完全なセットは、ファイルシステムによって異なる場合があります。 たとえば、Windows ベースのデスクトッププラットフォームでは、無効なパス文字には、ASCII/Unicode 文字 1 ~ 31 のほか、引用符 (")、小なり (\<)、より大きい (>)、パイプ&#124;()、バックスペース (\b)、null (\ 0)、およびタブ (\t) が含まれます。  
  
> [!CAUTION]
>  コードが信頼できないコードと同じアプリケーションドメインで実行される可能性がある場合は、<xref:System.IO.Path.InvalidPathChars> を使用しないでください。 <xref:System.IO.Path.InvalidPathChars> は配列であるため、要素を上書きできます。 信頼できないコードによって <xref:System.IO.Path.InvalidPathChars>の要素が上書きされると、コードが悪用される可能性があります。  
  
   
  
## Examples  
 次の例では、`InvalidPathChars` プロパティの使用方法を示します。  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathFullyQualified">
      <Docs>
        <summary>Returns a value that indicates whether a file path is fully qualified.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

`IsPathFullyQualified` メソッドのオーバーロードは、<xref:System.IO.Path.DirectorySeparatorChar> と <xref:System.IO.Path.AltDirectorySeparatorChar> の両方の文字を使用するパスを処理します。 引数として渡されるパスに対して検証は実行されません。 その結果、Uri は相対パスとして解釈され、`false`を返します。 

完全修飾パス (`IsPathFullyQualified` メソッドによって示される) とルート化されたパス (<xref:System.IO.Path.IsPathRooted%2A> メソッドによって示される) の間には違いがあります。 *完全修飾パス*または*絶対パス*は、特定のドライブまたはデバイスからターゲットファイルまたはディレクトリへの正確なパスを常に定義し、現在のドライブまたは現在のディレクトリに依存しません。 たとえば、Windows システムの場合、 *c:/users/user1/documents/reports/2019/1 月/ハイライト。 .pdf*は、c: ドライブのルートからターゲットファイルへの絶対パスを定義し、 *.pdf を強調*表示します。 ルート*パス*は、開始ドライブまたはルートディレクトリのいずれかを指定しますが、現在のディレクトリ (指定されたドライブがルートになっている場合) または現在のドライブ (ルートディレクトリがルートになっている場合) のいずれかに依存します。 次の例は、完全修飾パスとルート化されたパスの違いを示しています。

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">A file path.</param>
        <summary>Returns a value that indicates whether the file path represented by the specified character span is fixed to a specific drive or UNC path.</summary>
        <returns><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  


         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathFullyQualified">
      <MemberSignature Language="C#" Value="public static bool IsPathFullyQualified (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathFullyQualified(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathFullyQualified(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathFullyQualified (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathFullyQualified(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathFullyQualified : string -&gt; bool" Usage="System.IO.Path.IsPathFullyQualified path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">A file path.</param>
        <summary>Returns a value that indicates whether the specified file path is fixed to a specific drive or UNC path.</summary>
        <returns><see langword="true" /> if the path is fixed to a specific drive or UNC path; <see langword="false" /> if the path is relative to the current drive or working directory.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

このメソッドは、代替ディレクトリ区切り記号を使用するパスを処理します。 ルート化されたパス (<xref:System.IO.Path.IsPathRooted(System.String)>) が相対的ではないと想定するのは、よくある間違いです。 たとえば、"C:a" はドライブ相対で、C: の現在のディレクトリに対して解決されます (ルートはありますが、相対)。 "C:\ a" はルートであり、相対ではありません。つまり、現在のディレクトリがパスの変更に使用されることはありません。

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> is <see langword="null" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPathRooted">
      <Docs>
        <summary>Returns a value that indicates whether a file path contains a root.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

ルート化された**パス**は、特定のドライブまたは非 ic パスに固定されたファイルパスです。現在のドライブまたは作業ディレクトリに対する相対パスとは対照的です。 たとえば、Windows システムでは、ルート化されたパスは、円記号 ("\Documents" など) またはドライブ文字とコロン (たとえば、"C:Documents") で始まります。 

ルート化されたパスは、絶対パス (完全修飾名) または相対パスのいずれかになることに注意してください。 絶対ルートパスは、ドライブのルートから特定のディレクトリへの完全修飾パスです。 相対ルートパスはドライブを指定しますが、その完全修飾パスは現在のディレクトリに対して解決されます。 この違いを次の例に示します。

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/IsPathRooted/program.cs)]
[!code-vb[IsPathRooted](~/samples/snippets/visualbasic/api/system.IO/Path/IsPathRooted/program.vb)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">The path to test.</param>
        <summary>Returns a value that indicates whether the specified character span that represents a file path contains a root.</summary>
        <returns><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="IsPathRooted">
      <MemberSignature Language="C#" Value="public static bool IsPathRooted (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPathRooted(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.IsPathRooted(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPathRooted (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPathRooted(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member IsPathRooted : string -&gt; bool" Usage="System.IO.Path.IsPathRooted path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path to test.</param>
        <summary>Returns a value indicating whether the specified path string contains a root.</summary>
        <returns><see langword="true" /> if <paramref name="path" /> contains a root; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Path.IsPathRooted%2A> メソッドは、最初の文字が "\\" などのディレクトリ区切り文字である場合、またはパスがドライブ文字とコロン (:) で始まる場合に `true` を返します。 たとえば、"\\\MyDir\\\MyFile.txt"、"C:\\\MyDir"、"C:MyDir" などの `path` 文字列の `true` を返します。 "MyDir" などの `path` 文字列の `false` を返します。  
  
 このメソッドでは、パスまたはファイル名が存在するかどうかは検証されません。  
  
 共通 I/O タスクの一覧は、 [共通 I/O タスク](~/docs/standard/io/common-i-o-tasks.md) を参照してください。  

## Examples  
 次の例では、`IsPathRooted` メソッドを使用して、3つの文字列をテストする方法を示します。  
  
 [!code-cpp[System.IO.Path Members#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#12)]
 [!code-csharp[System.IO.Path Members#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#12)]
 [!code-vb[System.IO.Path Members#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> contains one or more of the invalid characters defined in <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (params string[] paths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string[] paths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (ParamArray paths As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(... cli::array &lt;System::String ^&gt; ^ paths);" />
      <MemberSignature Language="F#" Value="static member Join : string[] -&gt; string" Usage="System.IO.Path.Join paths" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="paths" Type="System.String[]" Index="0" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="paths">An array of paths.</param>
        <summary>Concatenates an array of paths into a single path.</summary>
        <returns>The concatenated path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

このメソッドは、単に `paths` 内のすべての文字列を連結し、パスコンポーネントがまだ存在しない場合は、そのディレクトリの区切り文字を追加します。 `paths` 内のいずれかのパスの <xref:System.String.Length> がゼロの場合、メソッドは残りの引数を連結します。 結果として得られる文字列の長さが0の場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>を返します。

`paths`内のいずれかのパス (最後のパスを除く) がターゲットプラットフォームに適していないパス区切り文字で終わる場合、`Join` メソッドは元のパス区切り文字を保持し、サポートされているパス区切り文字を追加します。 この問題は、Unix ベースのシステムでパスの区切りとして認識されない Windows の円記号 ("\") 文字を使用するハードコードされたパスで発生します。 この問題を回避するには、次の操作を行います。

- ディレクトリの区切り文字をハードコーディングするのではなく、<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティの値を取得します。

- ディレクトリの区切り記号としてスラッシュ ("/") を使用します。 この文字は、Unix ベースのシステムの <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティと、Windows システムの <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> プロパティによって返されます。

<xref:System.IO.Path.Combine%2A> メソッドとは異なり、<xref:System.IO.Path.Join%2A> メソッドは、返されたパスのルートを試行しません。 (つまり、`paths`内のいずれかのパス (最後のパスを除く) が絶対パスの場合、`Join` メソッドは <xref:System.IO.Path.Combine%2A> メソッドと同じ前のパスを破棄しません。

検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Join` メソッドでは許容されないと解釈されます。 たとえば、ファイルの作成時に `Path.Join("c:\\", "temp", "*.txt")` が無効になる場合がありますが、検索文字列として有効です。 したがって、`Join` メソッドによって正常に解釈されます。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">A character span that contains the first path to join.</param>
        <param name="path2">A character span that contains the second path to join.</param>
        <summary>Concatenates two path components into a single path.</summary>
        <returns>The combined paths.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
このメソッドは、`path` と `path2` を連結するだけで、`path1` の最後または `path2`の先頭にまだ存在していない場合は、2つのパスコンポーネントの間にディレクトリ区切り文字を追加します。 `path1` または `path2` の <xref:System.ReadOnlySpan%601.Length> がゼロの場合、メソッドはもう一方のパスを返します。 `path1` と `path2` の両方の <xref:System.ReadOnlySpan%601.Length> がゼロの場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>を返します。 

`path1` がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Join` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。 この問題は、Unix ベースのシステムでパスの区切りとして認識されない Windows の円記号 ("\") 文字を使用するハードコードされたパスで発生します。 この問題を回避するには、次の操作を行います。

- ディレクトリの区切り文字をハードコーディングするのではなく、<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティの値を取得します。

- ディレクトリの区切り記号としてスラッシュ ("/") を使用します。 この文字は、Unix ベースのシステムの <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティと、Windows システムの <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> プロパティによって返されます。 

<xref:System.IO.Path.Combine%2A> メソッドとは異なり、<xref:System.IO.Path.Join%2A> メソッドは、返されたパスのルートを試行しません。 (`path2` が絶対パスの場合、`Join` メソッドは `path1` を破棄せず、<xref:System.IO.Path.Combine%2A> メソッドと同様に `path2` を返します)。次の例は、2つのメソッドによって返されるパスの違いを示しています。 `path2` のソースがユーザー入力である場合、<xref:System.IO.Path.Combine%2A> メソッドを使用すると、ユーザーは、アプリケーションがアクセスできないように意図したファイルシステムリソース (例の場合は、 *C:/Users/User1/Documents/財務*など) にアクセスできます。  

検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Join` メソッドでは許容されないと解釈されます。 たとえば、ファイルの作成時に `Path.Join("c:\\", "*.txt")` が無効になる場合がありますが、検索文字列として有効です。 したがって、`Join` メソッドによって正常に解釈されます。 

## <a name="example"></a>例

次の例は、<xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> メソッドと <xref:System.IO.Path.Combine(System.String,System.String)?displayProperty=nameWithType> メソッドによって返されるパスの違いを示しています。 最初の文字列がドライブおよびルートディレクトリを含む完全修飾パスで、2番目の文字列が最初のパスからの相対パスである場合、2つのメソッドは同じ結果を生成します。 2番目と3回目の `ShowPathInformation` メソッドの呼び出しでは、2つのメソッドによって返される文字列は分岐します。 2番目のメソッド呼び出しでは、最初の文字列引数はドライブ、2番目の文字列はルート化されたディレクトリです。 `Join` メソッドは、2つの文字列を連結し、重複するパス区切り記号を保持します。 `Combine` メソッドはドライブを破棄し、現在のドライブ上のルート化されたディレクトリを返します。 アプリケーションの現在のドライブが C:\ の場合また、この文字列は、ディレクトリ内のファイルにアクセスするために使用され、d: ではなく C: にアクセスします。 最後に、`ShowPathInformation` の3番目の呼び出しの両方の引数がルートになっているため、`Join` メソッドは単にそれらを追加して無意味ファイルパスを作成します。一方、`Combine` メソッドは最初の文字列を破棄し、2番目の文字列を返します。 ファイルアクセスにこの文字列を使用すると、アプリケーションが機密ファイルに意図せずアクセスする可能性があります。  

[!code-csharp[Path.Join(String,String)](~/samples/snippets/csharp/api/system.io/path/combine2/program.cs)]
[!code-vb[Path.Join(String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine2/program.vb)]


       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2);" />
      <MemberSignature Language="F#" Value="static member Join : string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">The first path to join.</param>
        <param name="path2">The second path to join.</param>
        <summary>Concatenates two paths into a single path.</summary>
        <returns>The concatenated path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

このメソッドは、単に `path` と `path2` を連結し、パスコンポーネントがまだ存在しない場合は、そのパスコンポーネントの間にディレクトリ区切り文字を追加します。 `path1` または `path2` のいずれかの長さが0の場合、メソッドは残りの引数を連結します。 結果として連結された文字列の長さが0の場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>を返します。

`path1` がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Join` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。 この問題は、Unix ベースのシステムでパスの区切りとして認識されない Windows の円記号 ("\") 文字を使用するハードコードされたパスで発生します。 この問題を回避するには、次の操作を行います。

- ディレクトリの区切り文字をハードコーディングするのではなく、<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティの値を取得します。

- ディレクトリの区切り記号としてスラッシュ ("/") を使用します。 この文字は、Unix ベースのシステムの <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティと、Windows システムの <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> プロパティによって返されます。

<xref:System.IO.Path.Combine%2A> メソッドとは異なり、<xref:System.IO.Path.Join%2A> メソッドは、返されたパスのルートを試行しません。 (`path2` が絶対パスの場合、`Join` メソッドは <xref:System.IO.Path.Combine%2A> メソッドと同じ前のパスを破棄しません。

検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Join` メソッドでは許容されないと解釈されます。 たとえば、ファイルの作成時に `Path.Join("c:\\", "temp", "*.txt")` が無効になる場合がありますが、検索文字列として有効です。 したがって、`Join` メソッドによって正常に解釈されます。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">A character span that contains the first path to join.</param>
        <param name="path2">A character span that contains the second path to join.</param>
        <param name="path3">A character span that contains the third path to join.</param>
        <summary>Concatenates three path components into a single path.</summary>
        <returns>The concatenated path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
このメソッドは、単に `path`、`path2`、および `path3` を連結し、パスコンポーネントがまだ存在しない場合は、そのディレクトリの区切り文字を追加します。 `path1`、`path2`、または `path3` 引数のいずれかの <xref:System.ReadOnlySpan%601.Length> が0の場合、メソッドは残りの引数を連結します。 すべてのコンポーネントの <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> がゼロの場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>を返します。

`path1` または `path2` がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Join` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。 この問題は、Unix ベースのシステムでパスの区切りとして認識されない Windows の円記号 ("\") 文字を使用するハードコードされたパスで発生します。 この問題を回避するには、次の操作を行います。

- ディレクトリの区切り文字をハードコーディングするのではなく、<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティの値を取得します。

- ディレクトリの区切り記号としてスラッシュ ("/") を使用します。 この文字は、Unix ベースのシステムの <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティと、Windows システムの <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> プロパティによって返されます。

<xref:System.IO.Path.Combine%2A> メソッドとは異なり、<xref:System.IO.Path.Join%2A> メソッドは、返されたパスのルートを試行しません。 (つまり、`path2` または `path2` が絶対パスである場合、`Join` メソッドは <xref:System.IO.Path.Combine%2A> メソッドと同様に以前のパスを破棄しません。
  
検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Join` メソッドでは許容されないと解釈されます。 たとえば、ファイルの作成時に `Path.Join("c:\\", "temp", "*.txt")` が無効になる場合がありますが、検索文字列として有効です。 したがって、`Join` メソッドによって正常に解釈されます。

## <a name="example"></a>例

次の例は、<xref:System.IO.Path.Join(System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D,System.ReadOnlySpan%7BSystem.Char%7D)?displayProperty=nameWithType> メソッドと <xref:System.IO.Path.Combine(System.String,System.String,System.String)?displayProperty=nameWithType> メソッドによって返されるパスの違いを示しています。 最初の文字列がドライブおよびルートディレクトリを含む完全修飾パスで、2番目の文字列が最初のパスからの相対パスである場合、2つのメソッドは同じ結果を生成します。 2番目と3回目の `ShowPathInformation` メソッドの呼び出しでは、2つのメソッドによって返される文字列は分岐します。 2番目のメソッド呼び出しでは、最初の文字列引数はドライブ、2番目の文字列はルート化されたディレクトリです。 `Join` メソッドは、2つの文字列を連結し、重複するパス区切り記号を保持します。 <xref:System.IO.Path.GetFullPath%2A> メソッドを呼び出すと、重複が除去されます。 `Combine` メソッドはドライブを破棄し、現在のドライブ上のルート化されたディレクトリを返します。 アプリケーションの現在のドライブが C:\ の場合また、この文字列は、ディレクトリ内のファイルにアクセスするために使用され、d: ではなく C: にアクセスします。 最後に、`ShowPathInformation` の3番目の呼び出しの最後の引数がルートになっているため、`Join` メソッドは単純にそれを最初の2つの引数に追加して無意味ファイルパスを作成します。一方、`Combine` メソッドは最初の2つの文字列を破棄し、3番目の文字列を返します。 ファイルアクセスにこの文字列を使用すると、アプリケーションが機密ファイルに意図せずアクセスする可能性があります。

[!code-csharp[Path.Join(String,String,String)](~/samples/snippets/csharp/api/system.io/path/combine3/program.cs)]
[!code-vb[Path.Join(String,String,String)](~/samples/snippets/visualbasic/api/system.io/path/combine3/program.vb)]

       ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">The first path to join.</param>
        <param name="path2">The second path to join.</param>
        <param name="path3">The third path to join.</param>
        <summary>Concatenates three paths into a single path.</summary>
        <returns>The concatenated path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

このメソッドは、単に `path`、`path2`、および `path3` を連結し、パスコンポーネントがまだ存在しない場合は、そのディレクトリの区切り文字を追加します。 `path1`、`path2` または `path3` 引数のいずれかの長さが0の場合、メソッドは残りの引数を連結します。 結果として連結された文字列の長さが0の場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>を返します。

`path1` または `path2` がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Join` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。 この問題は、Unix ベースのシステムでパスの区切りとして認識されない Windows の円記号 ("\") 文字を使用するハードコードされたパスで発生します。 この問題を回避するには、次の操作を行います。

- ディレクトリの区切り文字をハードコーディングするのではなく、<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティの値を取得します。

- ディレクトリの区切り記号としてスラッシュ ("/") を使用します。 この文字は、Unix ベースのシステムの <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティと、Windows システムの <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> プロパティによって返されます。

<xref:System.IO.Path.Combine%2A> メソッドとは異なり、<xref:System.IO.Path.Join%2A> メソッドは、返されたパスのルートを試行しません。 (つまり、`path2` または `path2` が絶対パスである場合、`Join` メソッドは <xref:System.IO.Path.Combine%2A> メソッドと同様に以前のパスを破棄しません。

検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Join` メソッドでは許容されないと解釈されます。 たとえば、ファイルの作成時に `Path.Join("c:\\", "temp", "*.txt")` が無効になる場合がありますが、検索文字列として有効です。 したがって、`Join` メソッドによって正常に解釈されます。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.ReadOnlySpan`1&lt;char&gt; path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), path4 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, ReadOnlySpan&lt;char&gt; path4);" />
      <MemberSignature Language="F#" Value="static member Join : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">A character span that contains the first path to join.</param>
        <param name="path2">A character span that contains the second path to join.</param>
        <param name="path3">A character span that contains the third path to join.</param>
        <param name="path4">A character span that contains the fourth path to join.</param>
        <summary>Concatenates four path components into a single path.</summary>
        <returns>The concatenated path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

このメソッドは、単に `path`、`path2`、`path3` および `path4` を連結し、パスコンポーネントがまだ存在しない場合は、そのディレクトリの区切り文字を追加します。 `path1`、`path2`、`path3`、または `path4` 引数のいずれかの <xref:System.ReadOnlySpan%601.Length> が0の場合、メソッドは残りの引数を連結します。 すべてのコンポーネントの <xref:System.ReadOnlySpan%601.Length?displayProperty=nameWithType> がゼロの場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>を返します。

`path1` または `path2` または `path3` がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Join` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。 この問題は、Unix ベースのシステムでパスの区切りとして認識されない Windows の円記号 ("\") 文字を使用するハードコードされたパスで発生します。 この問題を回避するには、次の操作を行います。

- ディレクトリの区切り文字をハードコーディングするのではなく、<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティの値を取得します。

- ディレクトリの区切り記号としてスラッシュ ("/") を使用します。 この文字は、Unix ベースのシステムの <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティと、Windows システムの <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> プロパティによって返されます。

<xref:System.IO.Path.Combine%2A> メソッドとは異なり、<xref:System.IO.Path.Join%2A> メソッドは、返されたパスのルートを試行しません。 (つまり、`path2` または `path2` または `path3` が絶対パスの場合、<xref:System.IO.Path.Combine%2A> メソッドと同様に、`Join` メソッドは前のパスを破棄しません。

検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Join` メソッドでは許容されないと解釈されます。 たとえば、ファイルの作成時に `Path.Join("c:\\", "temp", "*.txt")` が無効になる場合がありますが、検索文字列として有効です。 したがって、`Join` メソッドによって正常に解釈されます。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string path1, string path2, string path3, string path4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string path1, string path2, string path3, string path4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.Join(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (path1 As String, path2 As String, path3 As String, path4 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ path1, System::String ^ path2, System::String ^ path3, System::String ^ path4);" />
      <MemberSignature Language="F#" Value="static member Join : string * string * string * string -&gt; string" Usage="System.IO.Path.Join (path1, path2, path3, path4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path2" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path3" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="path4" Type="System.String" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path1">The first path to join.</param>
        <param name="path2">The second path to join.</param>
        <param name="path3">The third path to join.</param>
        <param name="path4">The fourth path to join.</param>
        <summary>Concatenates four paths into a single path.</summary>
        <returns>The concatenated path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

このメソッドは、単に `path`、`path2`、`path3` および `path4` を連結し、パスコンポーネントがまだ存在しない場合は、そのディレクトリの区切り文字を追加します。 `path1`、`path2`、`path3`、または `path4` 引数のいずれかの長さが0の場合、メソッドは残りの引数を連結します。 結果として連結された文字列の長さが0の場合、メソッドは <xref:System.String.Empty?displayProperty=nameWithType>を返します。

`path1` または `path2` または `path3` がターゲットプラットフォームに適していないパス区切り文字で終了した場合、`Join` メソッドは元のパス区切り文字を保持し、サポートされているものを追加します。 この問題は、Unix ベースのシステムでパスの区切りとして認識されない Windows の円記号 ("\") 文字を使用するハードコードされたパスで発生します。 この問題を回避するには、次の操作を行います。

- ディレクトリの区切り文字をハードコーディングするのではなく、<xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティの値を取得します。

- ディレクトリの区切り記号としてスラッシュ ("/") を使用します。 この文字は、Unix ベースのシステムの <xref:System.IO.Path.DirectorySeparatorChar?displayProperty=nameWithType> プロパティと、Windows システムの <xref:System.IO.Path.AltDirectorySeparatorChar?displayProperty=nameWithType> プロパティによって返されます。

<xref:System.IO.Path.Combine%2A> メソッドとは異なり、<xref:System.IO.Path.Join%2A> メソッドは、返されたパスのルートを試行しません。 (つまり、`path2` または `path2` または `path3` が絶対パスの場合、<xref:System.IO.Path.Combine%2A> メソッドと同様に、`Join` メソッドは前のパスを破棄しません。

検索ワイルドカード文字にはこれらの文字を使用できるため、ディレクトリ名とファイル名の一部の無効な文字は、`Join` メソッドでは許容されないと解釈されます。 たとえば、ファイルの作成時に `Path.Join("c:\\", "temp", "*.txt")` が無効になる場合がありますが、検索文字列として有効です。 したがって、`Join` メソッドによって正常に解釈されます。

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public static readonly char PathSeparator;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char PathSeparator" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.PathSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PathSeparator As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char PathSeparator;" />
      <MemberSignature Language="F#" Value=" staticval mutable PathSeparator : char" Usage="System.IO.Path.PathSeparator" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A platform-specific separator character used to separate path strings in environment variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows ベースのデスクトッププラットフォームでは、このフィールドの値はセミコロン (;)既定では、他のプラットフォームによって異なる場合があります。  
  
   
  
## Examples  
 次の例では、`PathSeparator` フィールドの使用方法を示します。  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator (ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ReadOnlySpan`1&lt;char&gt; TrimEndingDirectorySeparator(valuetype System.ReadOnlySpan`1&lt;char&gt; path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As ReadOnlySpan(Of Char)) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ReadOnlySpan&lt;char&gt; TrimEndingDirectorySeparator(ReadOnlySpan&lt;char&gt; path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : ReadOnlySpan&lt;char&gt; -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">The path to trim.</param>
        <summary>Trims one trailing directory separator beyond the root of the specified path.</summary>
        <returns>The <paramref name="path" /> without any trailing directory separators.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEndingDirectorySeparator">
      <MemberSignature Language="C#" Value="public static string TrimEndingDirectorySeparator (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string TrimEndingDirectorySeparator(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TrimEndingDirectorySeparator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrimEndingDirectorySeparator (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ TrimEndingDirectorySeparator(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member TrimEndingDirectorySeparator : string -&gt; string" Usage="System.IO.Path.TrimEndingDirectorySeparator path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="path">The path to trim.</param>
        <summary>Trims one trailing directory separator beyond the root of the specified path.</summary>
        <returns>The <paramref name="path" /> without any trailing directory separators.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryJoin">
      <Docs>
        <summary>Attempts to concatenate individual path components to a preallocated character span, and returns a value that indicates whether the operation succeeded.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Remarks  

コピー先の文字範囲は、連結されたパスを保持するのに十分な大きさである必要があります。 次の例に示すように、<xref:System.Span%601.Slice%2A?displayProperty=nameWithType> メソッドを呼び出すことによって、連結されたパスを取得できます。

[!code-csharp[IsPathRooted](~/samples/snippets/csharp/api/system.IO/Path/TryJoin/program.cs)]

         ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">A character span that contains the first path to join.</param>
        <param name="path2">A character span that contains the second path to join.</param>
        <param name="destination">A character span to hold the concatenated path.</param>
        <param name="charsWritten">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</param>
        <summary>Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</summary>
        <returns><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination` は、連結されたパスを保持するのに十分な大きさである必要があります。 この例に示すように、<xref:System.Span%601.Slice%2A?displayProperty=nameWithType> メソッドを呼び出すことによって、連結されたパスを取得できます。

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="TryJoin">
      <MemberSignature Language="C#" Value="public static bool TryJoin (ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryJoin(valuetype System.ReadOnlySpan`1&lt;char&gt; path1, valuetype System.ReadOnlySpan`1&lt;char&gt; path2, valuetype System.ReadOnlySpan`1&lt;char&gt; path3, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Path.TryJoin(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryJoin (path1 As ReadOnlySpan(Of Char), path2 As ReadOnlySpan(Of Char), path3 As ReadOnlySpan(Of Char), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryJoin(ReadOnlySpan&lt;char&gt; path1, ReadOnlySpan&lt;char&gt; path2, ReadOnlySpan&lt;char&gt; path3, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryJoin : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.IO.Path.TryJoin (path1, path2, path3, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="path3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path1">A character span that contains the first path to join.</param>
        <param name="path2">A character span that contains the second path to join.</param>
        <param name="path3">A character span that contains the third path to join.</param>
        <param name="destination">A character span to hold the concatenated path.</param>
        <param name="charsWritten">When the method returns, a value that indicates the number of characters written to the <paramref name="destination" />.</param>
        <summary>Attempts to concatenate two path components to a single preallocated character span, and returns a value that indicates whether the operation succeeded.</summary>
        <returns><see langword="true" /> if the concatenation operation is successful; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

`destination` は、連結されたパスを保持するのに十分な大きさである必要があります。 この例に示すように、<xref:System.Span%601.Slice%2A?displayProperty=nameWithType> メソッドを呼び出すことによって、連結されたパスを取得できます。

         ]]></format>
        </remarks>
        <related type="article" href="~/docs/standard/io/file-path-formats.md">Windows システムのファイル パス形式</related>
      </Docs>
    </Member>
    <Member MemberName="VolumeSeparatorChar">
      <MemberSignature Language="C#" Value="public static readonly char VolumeSeparatorChar;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char VolumeSeparatorChar" />
      <MemberSignature Language="DocId" Value="F:System.IO.Path.VolumeSeparatorChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VolumeSeparatorChar As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char VolumeSeparatorChar;" />
      <MemberSignature Language="F#" Value=" staticval mutable VolumeSeparatorChar : char" Usage="System.IO.Path.VolumeSeparatorChar" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Provides a platform-specific volume separator character.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドの値はコロン (:)Windows と Macintosh の場合は、UNIX オペレーティングシステムの場合はスラッシュ (/)。 これは、"c:\windows" や "MacVolume: System Folder" などのパスを解析する場合に最も役立ちます。  
  
   
  
## Examples  
 次の例では、`VolumeSeparatorChar` フィールドの使用方法を示します。  
  
 [!code-cpp[System.IO.Path Members#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Path Members/CPP/pathmembers.cpp#13)]
 [!code-csharp[System.IO.Path Members#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Path Members/CS/pathmembers.cs#13)]
 [!code-vb[System.IO.Path Members#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Path Members/VB/pathmembers.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">ファイルおよびストリーム入出力</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">方法 : ファイルからテキストを読み取る</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">方法 : ファイルにテキストを書き込む</related>
      </Docs>
    </Member>
  </Members>
</Type>
