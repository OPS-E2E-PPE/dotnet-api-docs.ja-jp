<Type Name="DynamicObject" FullName="System.Dynamic.DynamicObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8aa844ca254fc0aa66843ae517e627f7417df303" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83524484" /></Metadata><TypeSignature Language="C#" Value="public class DynamicObject : System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Dynamic.DynamicObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicObject&#xA;Implements IDynamicMetaObjectProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicObject : System::Dynamic::IDynamicMetaObjectProvider" />
  <TypeSignature Language="F#" Value="type DynamicObject = class&#xA;    interface IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Core" FromVersion="4.0.0.0" To="System.Dynamic.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Linq.Expressions" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Dynamic.Runtime" FromVersion="5.0.0.0" To="System.Linq.Expressions" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Dynamic.Runtime" FromVersion="4.1.0.0" To="System.Linq.Expressions" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Dynamic.Runtime" FromVersion="4.1.1.0" To="System.Linq.Expressions" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Dynamic.Runtime" FromVersion="4.1.2.0" To="System.Linq.Expressions" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Dynamic.IDynamicMetaObjectProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>実行時の動的な動作を指定する基底クラスを提供します。 このクラスは継承される必要があります。直接インスタンス化することはできません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DynamicObject` クラスを使用すると、動的オブジェクトに対して実行できる操作とそれらの操作を実行する方法を定義できます。 たとえば、オブジェクトのプロパティを取得または設定したり、メソッドを呼び出したり、加算や乗算などの標準的な数値演算を実行しようとしたときに何が起こるかを定義できます。  
  
 このクラスは、ライブラリに対してより便利なプロトコルを作成する場合に便利です。 たとえば、ライブラリのユーザーが `Scriptobj.SetProperty("Count", 1)`のような構文を使用する必要がある場合は、`scriptobj.Count = 1`のように、はるかに簡単な構文を使用できるようにすることができます。  
  
 `DynamicObject` クラスのインスタンスを直接作成することはできません。 動的な動作を実装するには、`DynamicObject` クラスを継承し、必要なメソッドをオーバーライドする必要があります。 たとえば、プロパティを設定および取得するための操作のみが必要な場合は、<xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドと <xref:System.Dynamic.DynamicObject.TryGetMember%2A> メソッドだけをオーバーライドできます。  
  
 でC#は、`DynamicObject` クラスから派生したクラスのインスタンスに対して動的な動作を有効にするには、`dynamic` キーワードを使用する必要があります。 詳細については、「[dynamic 型の使用](~/docs/csharp/programming-guide/types/using-type-dynamic.md)」を参照してください。  
  
 Visual Basic では、動的操作は遅延バインディングによってサポートされます。 詳細については、「[事前バインディングと遅延バインディング (Visual Basic)](~/docs/visual-basic/programming-guide/language-features/early-late-binding/index.md)」を参照してください。  
  
 次のコード例は、`DynamicObject` クラスから派生したクラスのインスタンスを作成する方法を示しています。  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 `DynamicObject` クラスから派生したクラスに独自のメンバーを追加することもできます。 クラスがプロパティを定義し、<xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドもオーバーライドする場合、動的言語ランタイム (DLR) はまず、言語バインダーを使用して、クラス内のプロパティの静的な定義を検索します。 このようなプロパティが存在しない場合、DLR は <xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドを呼び出します。  
  
 `DynamicObject` クラスは、dlr インターフェイス <xref:System.Dynamic.IDynamicMetaObjectProvider>を実装します。これにより、DLR 相互運用性モデルをサポートする言語間で `DynamicObject` クラスのインスタンスを共有できます。 たとえば、でC# `DynamicObject` クラスのインスタンスを作成し、それを IronPython 関数に渡すことができます。 詳細については、「[動的言語ランタイムの概要](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md)」を参照してください。  
  
> [!NOTE]
>  実行時にメンバーを追加および削除できるだけでなく、特定の操作を定義する必要がなく、静的メンバーを持たないオブジェクトが必要な単純なシナリオがある場合は、<xref:System.Dynamic.ExpandoObject> クラスを使用します。  
>   
>  相互運用性プロトコルに動的オブジェクトを含める方法を定義するより高度なシナリオがある場合、または DLR 高速動的ディスパッチキャッシュを管理する必要がある場合は、<xref:System.Dynamic.IDynamicMetaObjectProvider> インターフェイスの独自の実装を作成します。  
  
   
  
## Examples  
 ディクショナリ内の値にアクセスするための別の構文を提供するとします。これにより、`sampleDictionary["Text"] = "Sample text"` (Visual Basic で`sampleDictionary("Text") = "Sample text"`) を記述する代わりに、`sampleDictionary.Text = "Sample text"`を記述できます。 また、この構文で大文字と小文字を区別しないようにして、`sampleDictionary.Text` が `sampleDictionary.text`と同じになるようにします。  
  
 次のコード例は、`DynamicObject` クラスから派生した `DynamicDictionary` クラスを示しています。 `DynamicDictionary` クラスには、キーと値のペアを格納するための `Dictionary<string, object>` 型 (Visual Basic 内の`Dictionary(Of String, Object)`) のオブジェクトが含まれています。また、新しい構文をサポートするために、<xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドと <xref:System.Dynamic.DynamicObject.TryGetMember%2A> メソッドをオーバーライドします。 また、`Count` プロパティも用意されています。このプロパティは、ディクショナリに含まれる動的プロパティの数を示します。  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 その他の例については、よく寄せらC#れる質問ブログの「 [dynamicobject を使用したラッパーの作成](https://devblogs.microsoft.com/csharpfaq/dynamic-in-c-4-0-creating-wrappers-with-dynamicobject/)」を参照してください。  
 
 
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DynamicObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DynamicObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>派生型で <see cref="T:System.Dynamic.DynamicObject" /> 型の新しいインスタンスを初期化できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Dynamic.DynamicObject> クラスのインスタンスを直接作成することはできません。 動的な動作を実装するには、<xref:System.Dynamic.DynamicObject> クラスを継承し、必要なメソッドをオーバーライドする必要があります。  
  
 でC#は、<xref:System.Dynamic.DynamicObject> クラスから派生したクラスのインスタンスに対して動的な動作を有効にするには、`dynamic` キーワードを使用する必要があります。 詳細については、「[dynamic 型の使用](~/docs/csharp/programming-guide/types/using-type-dynamic.md)」を参照してください。  
  
 Visual Basic では、動的操作は遅延バインディングによってサポートされます。 詳細については、「[事前バインディングと遅延バインディング (Visual Basic)](~/docs/visual-basic/programming-guide/language-features/early-late-binding/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Dynamic.DynamicObject> クラスから派生したクラスのインスタンスを作成する方法を示しています。  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicMemberNames">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetDynamicMemberNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetDynamicMemberNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDynamicMemberNames () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetDynamicMemberNames();" />
      <MemberSignature Language="F#" Value="abstract member GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;&#xA;override this.GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;" Usage="dynamicObject.GetDynamicMemberNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべての動的メンバー名の列挙値を返します。</summary>
        <returns>動的メンバー名を含むシーケンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、デバッグ目的でのみ存在します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetaObject">
      <MemberSignature Language="C#" Value="public virtual System.Dynamic.DynamicMetaObject GetMetaObject (System.Linq.Expressions.Expression parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Dynamic.DynamicMetaObject GetMetaObject(class System.Linq.Expressions.Expression parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetaObject (parameter As Expression) As DynamicMetaObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Dynamic::DynamicMetaObject ^ GetMetaObject(System::Linq::Expressions::Expression ^ parameter);" />
      <MemberSignature Language="F#" Value="abstract member GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject&#xA;override this.GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject" Usage="dynamicObject.GetMetaObject parameter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Dynamic.DynamicMetaObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameter">動的仮想メソッドにディスパッチされる <see cref="T:System.Dynamic.DynamicMetaObject" /> を表す式。</param>
        <summary>動的仮想メソッドにディスパッチされる <see cref="T:System.Dynamic.DynamicMetaObject" /> を提供します。 このオブジェクトを別の <see cref="T:System.Dynamic.DynamicMetaObject" /> の内部にカプセル化することにより、個々のアクションのカスタム動作を指定することができます。 このメソッドは言語実装者向けの DLR (動的言語ランタイム) インフラストラクチャをサポートします。コードから直接使用するためのものではありません。</summary>
        <returns><see cref="T:System.Dynamic.DynamicMetaObject" /> 型のオブジェクト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBinaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryBinaryOperation (System.Dynamic.BinaryOperationBinder binder, object arg, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryBinaryOperation(class System.Dynamic.BinaryOperationBinder binder, object arg, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryBinaryOperation (binder As BinaryOperationBinder, arg As Object, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryBinaryOperation(System::Dynamic::BinaryOperationBinder ^ binder, System::Object ^ arg, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj * obj -&gt; bool&#xA;override this.TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj * obj -&gt; bool" Usage="dynamicObject.TryBinaryOperation (binder, arg, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.BinaryOperationBinder" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">二項演算に関する情報を提供します。 <c>binder.Operation</c> プロパティは <see cref="T:System.Linq.Expressions.ExpressionType" /> オブジェクトを返します。 たとえば、<c>sum = first + second</c> ステートメントの場合 (<c>first</c> と <c>second</c> は <see langword="DynamicObject" /> クラスから派生)、<c>binder.Operation</c> クラスは <c>ExpressionType.Add</c> を返します。</param>
        <param name="arg">二項演算の右オペランド。 たとえば、<c>sum = first + second</c> ステートメントの場合 (<c>first</c> と <c>second</c> は <see langword="DynamicObject" /> クラスから派生)、<paramref name="arg" /> は <c>second</c> と等しくなります。</param>
        <param name="result">二項演算の結果。</param>
        <summary>二項演算の実装を提供します。 <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生クラスでこのメソッドをオーバーライドして、加算や乗算などの演算の動的な動作を指定できます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが <see langword="false" /> を返す場合、言語のランタイム バインダーによって動作が決まります (ほとんどの場合、言語固有の実行時例外がスローされます)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Dynamic.DynamicObject> クラスから派生したクラスは、このメソッドをオーバーライドして、動的オブジェクトに対してバイナリ演算を実行する方法を指定できます。 メソッドがオーバーライドされない場合、言語のランタイムバインダーによって動作が決まります。 (ほとんどの場合、言語固有の実行時例外がスローされます)。  
  
 このメソッドは、加算や乗算などの二項演算がある場合に呼び出されます。 たとえば、<xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> メソッドがオーバーライドされると、`sum = first + second` や `multiply = first*second`などのステートメントに対して自動的に呼び出されます。この場合、`first` は `DynamicObject` クラスから派生します。  
  
 バイナリ演算の種類に関する情報を取得するには、`binder` パラメーターの `Operation` プロパティを使用します。  
  
 動的オブジェクトがおよび Visual Basic のみでC#使用される場合、`binder.Operation` プロパティは、<xref:System.Linq.Expressions.ExpressionType> 列挙体の次のいずれかの値を持つことができます。 ただし、IronPython や IronRuby などの他の言語では、他の値を使用できます。
  
|値|説明|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Add`|オーバーフローチェックを行わない加算演算 (数値オペランドの場合)。|`a + b`|`a + b`|  
|`AddAssign`|オーバーフローチェックを行わない、数値オペランドに対する加算の複合代入演算。|`a += b`|サポートされていません。|  
|`And`|ビットごとの `AND` 演算。|`a & b`|`a And b`|  
|`AndAssign`|ビットごとの `AND` 複合代入演算。|`a &= b`|サポートされていません。|  
|`Divide`|算術除算演算です。|`a / b`|`a / b`|  
|`DivideAssign`|算術除算の複合代入演算。|`a /= b`|サポートされていません。|  
|`ExclusiveOr`|ビットごとの `XOR` 演算。|`a ^ b`|`a Xor b`|  
|`ExclusiveOrAssign`|ビットごとの `XOR` 複合代入演算。|`a ^= b`|サポートされていません。|  
|`GreaterThan`|"より大きい" 比較。|`a > b`|`a > b`|  
|`GreaterThanOrEqual`|"以上" の比較。|`a >= b`|サポートされていません。|  
|`LeftShift`|ビットごとの左シフト演算。|`a << b`|`a << b`|  
|`LeftShiftAssign`|ビットごとの左シフトの複合代入演算。|`a <<= b`|サポートされていません。|  
|`LessThan`|"より小さい" 比較。|`a < b`|`a < b`|  
|`LessThanOrEqual`|"以下" の比較。|`a <= b`|サポートされていません。|  
|`Modulo`|算術剰余演算。|`a % b`|`a Mod b`|  
|`ModuloAssign`|算術剰余の複合代入演算。|`a %= b`|サポートされていません。|  
|`Multiply`|数値オペランドに対するオーバーフローチェックを行わない乗算演算。|`a * b`|`a * b`|  
|`MultiplyAssign`|オーバーフローチェックを行わない、数値オペランドに対する乗算の複合代入演算。|`a *= b`|サポートされていません。|  
|`NotEqual`|非等値比較。|`a != b`|`a <> b`|  
|`Or`|ビットごとの or 論理 `OR` 演算。|`a &#124; b`|`a Or b`|  
|`OrAssign`|ビットごとの or 論理 `OR` 複合代入。|`a &#124;= b`|サポートされていません。|  
|`Power`|数値を累乗する数学的演算。|サポートされていません。|`a ^ b`|  
|`RightShift`|ビットごとの右シフト演算。|`a >> b`|`a >> b`|  
|`RightShiftAssign`|ビットごとの右シフトの複合代入演算。|`a >>= b`|サポートされていません。|  
|`Subtract`|数値オペランドに対するオーバーフローチェックを行わない減算演算。|`a - b`|`a - b`|  
|`SubtractAssign`|オーバーフローチェックを行わない、数値オペランドに対する減算の複合代入演算。|`a -= b`|サポートされていません。|  
  
> [!NOTE]
>  でC#動的オブジェクトの `OrElse` (`a || b`) 操作と `AndAlso` (`a && b`) 操作を実装するには、<xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> メソッドと <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> メソッドの両方を実装することが必要になる場合があります。  
>   
>  `OrElse` 操作は、単項 `IsTrue` 操作とバイナリ `Or` 操作で構成されます。 `Or` 操作は、`IsTrue` 操作の結果が `false`場合にのみ実行されます。  
>   
>  `AndAlso` 操作は、単項 `IsFalse` 操作とバイナリ `And` 操作で構成されます。 `And` 操作は、`IsFalse` 操作の結果が `false`場合にのみ実行されます。  
  
   
  
## Examples  
 数値のテキスト表現と数値表現を格納するためのデータ構造が必要であり、そのようなデータの加算や減算などの基本的な算術演算を定義する場合を想定しています。  
  
 次のコード例は、<xref:System.Dynamic.DynamicObject> クラスから派生した `DynamicNumber` クラスを示しています。 `DynamicNumber` は、<xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> メソッドをオーバーライドして数学的演算を有効にします。 また、<xref:System.Dynamic.DynamicObject.TrySetMember%2A> および <xref:System.Dynamic.DynamicObject.TryGetMember%2A> メソッドをオーバーライドして、要素へのアクセスを有効にします。  
  
 この例では、加算および減算演算のみがサポートされています。 `resultNumber = firstNumber*secondNumber`のようなステートメントを記述しようとすると、実行時例外がスローされます。  
  
 [!code-csharp[System.Dynamic.DynamicObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#2)]
 [!code-vb[System.Dynamic.DynamicObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvert">
      <MemberSignature Language="C#" Value="public virtual bool TryConvert (System.Dynamic.ConvertBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryConvert(class System.Dynamic.ConvertBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryConvert (binder As ConvertBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryConvert(System::Dynamic::ConvertBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryConvert : System.Dynamic.ConvertBinder * obj -&gt; bool&#xA;override this.TryConvert : System.Dynamic.ConvertBinder * obj -&gt; bool" Usage="dynamicObject.TryConvert (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.ConvertBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">変換処理に関する情報を提供します。 <c>binder.Type</c> プロパティは、オブジェクトの変換後の型を提供します。 たとえば、C# のステートメント <c>(String)sampleObject</c> (Visual Basic では <c>CType(sampleObject, Type)</c>) の場合 (<c>sampleObject</c> は <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生クラスのインスタンス)、<c>binder.Type</c> は <see cref="T:System.String" /> 型を返します。 <c>binder.Explicit</c> プロパティは、行われる変換の種類に関する情報を提供します。 このプロパティは、明示的な変換の場合は <see langword="true" />、暗黙の変換の場合は <see langword="false" /> を返します。</param>
        <param name="result">型変換演算の結果。</param>
        <summary>型変換演算の実装を提供します。 <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生クラスでこのメソッドをオーバーライドして、オブジェクトの型を別の型に変換する演算の動的な動作を指定できます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが <see langword="false" /> を返す場合、言語のランタイム バインダーによって動作が決まります (ほとんどの場合、言語固有の実行時例外がスローされます)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Dynamic.DynamicObject> クラスから派生したクラスは、このメソッドをオーバーライドして、動的オブジェクトの型変換を実行する方法を指定できます。 メソッドがオーバーライドされない場合、言語のランタイムバインダーによって動作が決まります。 (ほとんどの場合、言語固有の実行時例外がスローされます)。  
  
 でC#は、このメソッドがオーバーライドされた場合、次のコード例に示すように、明示的または暗黙的な変換があるときに、このメソッドが自動的に呼び出されます。  
  
 Visual Basic では、明示的な変換のみがサポートされています。 このメソッドをオーバーライドする場合は、<xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> または <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> 関数を使用して呼び出します。  
  
```csharp  
// Explicit conversion.  
String sampleExplicit = (String)sampleObject;  
// Implicit conversion.  
String sampleImplicit = sampleObject;  
```  
  
```vb  
// Explicit conversion - first variant.  
Dim testExplicit1 = CTypeDynamic(Of String)(sampleObject)  
// Explicit conversion - second variant.  
Dim testExplicit2 = CTypeDynamic(sampleObject, GetType(String))  
```  
  
   
  
## Examples  
 数値のテキスト表現と数値表現を格納するためのデータ構造が必要であり、このデータ構造から文字列と整数への変換を定義する必要があるとします。  
  
 次のコード例は、<xref:System.Dynamic.DynamicObject> クラスから派生した `DynamicNumber` クラスを示しています。 `DynamicNumber` は、<xref:System.Dynamic.DynamicObject.TryConvert%2A> メソッドをオーバーライドして、型変換を有効にします。 また、<xref:System.Dynamic.DynamicObject.TrySetMember%2A> および <xref:System.Dynamic.DynamicObject.TryGetMember%2A> メソッドをオーバーライドして、データ要素へのアクセスを有効にします。  
  
 この例では、文字列と整数への変換のみがサポートされています。 オブジェクトを他の型に変換しようとすると、実行時例外がスローされます。  
  
 [!code-csharp[System.Dynamic.DynamicObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#3)]
 [!code-vb[System.Dynamic.DynamicObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateInstance">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateInstance (System.Dynamic.CreateInstanceBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateInstance(class System.Dynamic.CreateInstanceBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateInstance (binder As CreateInstanceBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCreateInstance(System::Dynamic::CreateInstanceBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] * obj -&gt; bool&#xA;override this.TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TryCreateInstance (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.CreateInstanceBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">初期化演算に関する情報を提供します。</param>
        <param name="args">初期化中にオブジェクトに渡される引数。 たとえば、<c>new SampleType(100)</c> 演算の場合 (<c>SampleType</c> は <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生型)、<c>args[0]</c> は 100 に等しくなります。</param>
        <param name="result">初期化の結果。</param>
        <summary>動的オブジェクトの新しいインスタンスを初期化する演算の実装を提供します。 このメソッドは、C# または Visual Basic で使用するためのものではありません。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが <see langword="false" /> を返す場合、言語のランタイム バインダーによって動作が決まります (ほとんどの場合、言語固有の実行時例外がスローされます)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Dynamic.DynamicObject> クラスから派生したクラスは、このメソッドをオーバーライドして、動的オブジェクトの新しいインスタンスを初期化する方法を指定できます。 メソッドがオーバーライドされない場合、言語のランタイムバインダーによって動作が決まります。 (ほとんどの場合、言語固有の実行時例外がスローされます)。  
  
 C#および Visual Basic コンパイラは、ファーストクラスの型をサポートしていないため、このメソッドを使用するコードを出力しません。 このメソッドは、`dynamic new`のような構文を使用した動的オブジェクトの初期化をサポートする言語を対象としています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteIndex (System.Dynamic.DeleteIndexBinder binder, object[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteIndex(class System.Dynamic.DeleteIndexBinder binder, object[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteIndex (binder As DeleteIndexBinder, indexes As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteIndex(System::Dynamic::DeleteIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool&#xA;override this.TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool" Usage="dynamicObject.TryDeleteIndex (binder, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="binder">削除に関する情報を提供します。</param>
        <param name="indexes">削除するインデックス。</param>
        <summary>インデックスを使用してオブジェクトを削除する演算の実装を提供します。 このメソッドは、C# または Visual Basic で使用するためのものではありません。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが <see langword="false" /> を返す場合、言語のランタイム バインダーによって動作が決まります (ほとんどの場合、言語固有の実行時例外がスローされます)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Dynamic.DynamicObject> クラスから派生したクラスは、このメソッドをオーバーライドして、指定したインデックスを持つ値を削除する方法を指定できます。 メソッドがオーバーライドされない場合、言語のランタイムバインダーによって動作が決まります。 (ほとんどの場合、言語固有の実行時例外がスローされます)。  
  
 C#また、Visual Basic コンパイラは、このような操作をサポートしていないため、このメソッドを使用するコードを出力しません。 このメソッドは、Python の `del sampleObject[1,2]` など、インデックスによってオブジェクトを削除する構文をサポートする言語を対象としています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteMember">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteMember (System.Dynamic.DeleteMemberBinder binder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteMember(class System.Dynamic.DeleteMemberBinder binder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteMember (binder As DeleteMemberBinder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteMember(System::Dynamic::DeleteMemberBinder ^ binder);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool&#xA;override this.TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool" Usage="dynamicObject.TryDeleteMember binder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteMemberBinder" />
      </Parameters>
      <Docs>
        <param name="binder">削除に関する情報を提供します。</param>
        <summary>オブジェクト メンバーを削除する演算の実装を提供します。 このメソッドは、C# または Visual Basic で使用するためのものではありません。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが <see langword="false" /> を返す場合、言語のランタイム バインダーによって動作が決まります (ほとんどの場合、言語固有の実行時例外がスローされます)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Dynamic.DynamicObject> クラスから派生したクラスは、このメソッドをオーバーライドして、オブジェクトメンバーの削除方法を指定できます。 このメソッドがオーバーライドされない場合、言語のランタイムバインダーによって動作が決まります。 (ほとんどの場合、言語固有の実行時例外がスローされます)。  
  
 C#また、Visual Basic コンパイラは、このような操作をサポートしていないため、このメソッドを使用するコードを出力しません。 このメソッドは、Python の `del sampleObject.SampleMember` など、メンバーを削除するための構文をサポートする言語を対象としています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryGetIndex (System.Dynamic.GetIndexBinder binder, object[] indexes, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetIndex(class System.Dynamic.GetIndexBinder binder, object[] indexes, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetIndex (binder As GetIndexBinder, indexes As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetIndex(System::Dynamic::GetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetIndex : System.Dynamic.GetIndexBinder * obj[] * obj -&gt; bool&#xA;override this.TryGetIndex : System.Dynamic.GetIndexBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TryGetIndex (binder, indexes, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">演算に関する情報を提供します。</param>
        <param name="indexes">演算に使用されるインデックス。 たとえば、C# の <c>sampleObject[3]</c> (Visual Basic では <c>sampleObject(3)</c>) 演算の場合 (<c>sampleObject</c> は <see langword="DynamicObject" /> クラスから派生)、<c>indexes[0]</c> は 3 に等しくなります。</param>
        <param name="result">インデックス演算の結果。</param>
        <summary>インデックスを使用して値を取得する演算の実装を提供します。 <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生クラスでこのメソッドをオーバーライドして、インデックス演算の動的な動作を指定できます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが <see langword="false" /> を返す場合、言語のランタイム バインダーによって動作が決まります (ほとんどの場合、実行時例外がスローされます)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Dynamic.DynamicObject> クラスから派生したクラスは、このメソッドをオーバーライドして、インデックスによる値の取得を動的オブジェクトに対して実行する方法を指定できます。 メソッドがオーバーライドされない場合、言語のランタイムバインダーによって動作が決まります。 (ほとんどの場合、実行時例外がスローされます)。  
  
 このメソッドがオーバーライドされると、`sampleObject` が <xref:System.Dynamic.DynamicObject> クラスから派生した Visual Basic でC# `sampleObject(3)` の `sampleObject[3]` などの操作がある場合に、自動的に呼び出されます。  
  
   
  
## Examples  
 たとえば、`Property0`、`Property1`などの名前、またはインデックスを使用してプロパティにアクセスできるオブジェクトを作成するとします。たとえば、`sampleObject.Property0` は、`sampleObject(0)` 内の `sampleObject[0]` C#または Visual Basic に相当します。  
  
 次のコード例は、<xref:System.Dynamic.DynamicObject> クラスから派生した `SampleDynamicObject` クラスを示しています。 `SampleDynamicObject` クラスには、キーと値のペアを格納するための `Dictionary<string, object>` 型 (Visual Basic では`Dictionary(Of String, Object)`) のオブジェクトが含まれています。 `SampleDynamicObject` は、インデックスによるアクセスを有効にするために <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> および <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> メソッドをオーバーライドします。 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドと <xref:System.Dynamic.DynamicObject.TryGetMember%2A> メソッドをオーバーライドして、プロパティ名によるアクセスを有効にします。  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMember">
      <MemberSignature Language="C#" Value="public virtual bool TryGetMember (System.Dynamic.GetMemberBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetMember(class System.Dynamic.GetMemberBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetMember (binder As GetMemberBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetMember(System::Dynamic::GetMemberBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetMember : System.Dynamic.GetMemberBinder * obj -&gt; bool&#xA;override this.TryGetMember : System.Dynamic.GetMemberBinder * obj -&gt; bool" Usage="dynamicObject.TryGetMember (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetMemberBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">動的操作を呼び出したオブジェクトに関する情報を提供します。 <c>binder.Name</c> プロパティは、動的演算の対象であるメンバーの名前を提供します。 たとえば、<c>Console.WriteLine(sampleObject.SampleProperty)</c> ステートメントの場合 (<c>sampleObject</c> は <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生クラスのインスタンス)、<c>binder.Name</c> は "SampleProperty" を返します。 メンバー名で大文字と小文字を区別するかどうかを <c>binder.IgnoreCase</c> プロパティで指定します。</param>
        <param name="result">取得操作の結果。 たとえば、このメソッドがプロパティに対して呼び出された場合、プロパティ値を <paramref name="result" /> に割り当てることができます。</param>
        <summary>メンバー値を取得する操作の実装を提供します。 <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生クラスでこのメソッドをオーバーライドして、プロパティ値の取得などの演算の動的な動作を指定できます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが <see langword="false" /> を返す場合、言語のランタイム バインダーによって動作が決まります (ほとんどの場合、実行時例外がスローされます)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Dynamic.DynamicObject> クラスから派生したクラスは、このメソッドをオーバーライドして、動的オブジェクトに対してメンバー値を取得する操作を実行する方法を指定できます。 メソッドがオーバーライドされない場合、言語のランタイムバインダーによって動作が決まります。 (ほとんどの場合、実行時例外がスローされます)。  
  
 このメソッドは、`Console.WriteLine(sampleObject.SampleProperty)`のようなステートメントがある場合に呼び出されます。 `sampleObject` は <xref:System.Dynamic.DynamicObject> クラスから派生したクラスのインスタンスです。  
  
 `DynamicObject` クラスから派生したクラスに独自のメンバーを追加することもできます。 クラスがプロパティを定義し、<xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドもオーバーライドする場合、動的言語ランタイム (DLR) はまず、言語バインダーを使用して、クラス内のプロパティの静的な定義を検索します。 このようなプロパティが存在しない場合、DLR は <xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドを呼び出します。  
  
   
  
## Examples  
 ディクショナリ内の値にアクセスするための別の構文を提供するとします。これにより、`sampleDictionary["Text"] = "Sample text"` (Visual Basic で`sampleDictionary("Text") = "Sample text"`) を記述する代わりに、`sampleDictionary.Text = "Sample text"`を記述できます。 また、この構文では大文字と小文字を区別しないため、`sampleDictionary.Text` は `sampleDictionary.text`と同じになります。  
  
 次のコード例は、<xref:System.Dynamic.DynamicObject> クラスから派生した `DynamicDictionary` クラスを示しています。 `DynamicDictionary` クラスには、キーと値のペアを格納するための `Dictionary<string, object>` 型 (Visual Basic 内の`Dictionary(Of String, Object)`) のオブジェクトが含まれています。また、新しい構文をサポートするために、<xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドと <xref:System.Dynamic.DynamicObject.TryGetMember%2A> メソッドをオーバーライドします。 また、`Count` プロパティも用意されています。このプロパティは、ディクショナリに含まれる動的プロパティの数を示します。  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvoke">
      <MemberSignature Language="C#" Value="public virtual bool TryInvoke (System.Dynamic.InvokeBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvoke(class System.Dynamic.InvokeBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvoke (binder As InvokeBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvoke(System::Dynamic::InvokeBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvoke : System.Dynamic.InvokeBinder * obj[] * obj -&gt; bool&#xA;override this.TryInvoke : System.Dynamic.InvokeBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TryInvoke (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">呼び出し演算に関する情報を提供します。</param>
        <param name="args">呼び出し演算でオブジェクトに渡される引数。 たとえば、<c>sampleObject(100)</c> 演算の場合 (<c>sampleObject</c> は <see cref="T:System.Dynamic.DynamicObject" /> クラスから派生)、<c>args[0]</c> は 100 に等しくなります。</param>
        <param name="result">オブジェクト呼び出しの結果。</param>
        <summary>オブジェクトを呼び出す演算の実装を提供します。 <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生クラスでこのメソッドをオーバーライドして、オブジェクトやデリゲートの呼び出しなどの演算の動的な動作を指定できます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが <see langword="false" /> を返す場合、言語のランタイム バインダーによって動作が決まります (ほとんどの場合、言語固有の実行時例外がスローされます)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Dynamic.DynamicObject> クラスから派生したクラスは、このメソッドをオーバーライドして、オブジェクトを呼び出す操作を動的オブジェクトに対して実行する方法を指定できます。 メソッドがオーバーライドされない場合、言語のランタイムバインダーによって動作が決まります。 (ほとんどの場合、実行時例外がスローされます)。  
  
 このメソッドがオーバーライドされると、`sampleObject(100)`のような操作が行われたときに自動的に呼び出されます。 `sampleObject` は <xref:System.Dynamic.DynamicObject> クラスから派生します。  
  
 オブジェクトを呼び出す操作はでC#はサポートされていますが、Visual Basic ではサポートされていません。 Visual Basic コンパイラは、このメソッドを使用するコードを出力しません。 Visual Basic 言語では、`sampleObject(100)`のような構文はサポートされていません。  
  
   
  
## Examples  
 数値のテキスト表現と数値表現を格納するためのデータ構造が必要であるとします。 各プロパティの値を個別に指定し、1つのステートメントですべてのプロパティを初期化できるようにする必要があるとします。  
  
 次のコード例は、<xref:System.Dynamic.DynamicObject> クラスから派生した `DynamicNumber` クラスを示しています。 `DynamicNumber` は、<xref:System.Dynamic.DynamicObject.TryInvoke%2A> メソッドをオーバーライドして、すべてのプロパティを一度に初期化できるようにします。 また、<xref:System.Dynamic.DynamicObject.TrySetMember%2A> および <xref:System.Dynamic.DynamicObject.TryGetMember%2A> メソッドをオーバーライドして、個々のオブジェクトのプロパティにアクセスできるようにします。  
  
 [!code-csharp[System.Dynamic.DynamicObject#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvokeMember">
      <MemberSignature Language="C#" Value="public virtual bool TryInvokeMember (System.Dynamic.InvokeMemberBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvokeMember(class System.Dynamic.InvokeMemberBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvokeMember (binder As InvokeMemberBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvokeMember(System::Dynamic::InvokeMemberBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] * obj -&gt; bool&#xA;override this.TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TryInvokeMember (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeMemberBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">動的な操作に関する情報を提供します。 <c>binder.Name</c> プロパティは、動的演算の対象であるメンバーの名前を提供します。 たとえば、ステートメント <c>sampleObject.SampleMethod(100)</c> の場合 (<c>sampleObject</c> は <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生クラスのインスタンス)、<c>binder.Name</c> は "SampleMethod" を返します。 メンバー名で大文字と小文字を区別するかどうかを <c>binder.IgnoreCase</c> プロパティで指定します。</param>
        <param name="args">呼び出し操作の間にオブジェクト メンバーに渡される引数。 たとえば、ステートメント <c>sampleObject.SampleMethod(100)</c> の場合 (<c>sampleObject</c> は <see cref="T:System.Dynamic.DynamicObject" /> クラスから派生)、<c>args[0]</c> は 100 に等しくなります。</param>
        <param name="result">メンバー呼び出しの結果。</param>
        <summary>メンバーを呼び出す操作の実装を提供します。 <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生クラスでこのメソッドをオーバーライドして、メソッドの呼び出しなどの演算の動的な動作を指定できます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが <see langword="false" /> を返す場合、言語のランタイム バインダーによって動作が決まります (ほとんどの場合、言語固有の実行時例外がスローされます)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Dynamic.DynamicObject> クラスから派生したクラスは、このメソッドをオーバーライドして、オブジェクトメンバーを呼び出す操作を動的オブジェクトに対して実行する方法を指定できます。 メソッドがオーバーライドされない場合、言語のランタイムバインダーによって動作が決まります。 (ほとんどの場合、言語固有の実行時例外がスローされます)。  
  
 このメソッドがオーバーライドされると、`sampleObject.SampleMethod(100)`のような操作を実行すると自動的に呼び出されます。 `sampleObject` は `DynamicObject` クラスから派生します。  
  
 <xref:System.Dynamic.DynamicObject> クラスから派生したクラスに独自のメソッドを追加することもできます。 たとえば、<xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> メソッドをオーバーライドする場合、動的ディスパッチシステムは、指定されたメソッドがクラスに存在するかどうかを最初に確認しようとします。 メソッドが見つからない場合は、<xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> の実装を使用します。  
  
 このメソッドでは、`ref` パラメーターと `out` パラメーターはサポートされていません。 `args` 配列内のすべてのパラメーターは、値によって渡されます。  
  
   
  
## Examples  
 ディクショナリ内の値にアクセスするための別の構文を提供するとします。これにより、`sampleDictionary["Text"] = "Sample text"` (Visual Basic で`sampleDictionary("Text") = "Sample text"`) を記述する代わりに、`sampleDictionary.Text = "Sample text"`を記述できます。 また、このディクショナリのすべての標準辞書メソッドを呼び出すこともできます。  
  
 次のコード例は、<xref:System.Dynamic.DynamicObject> クラスから派生した `DynamicDictionary` クラスを示しています。 `DynamicDictionary` クラスには、キーと値のペアを格納するための `Dictionary<string, object>` 型 (Visual Basic では`Dictionary(Of String, Object)`) のオブジェクトが含まれています。 これは、<xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> メソッドをオーバーライドして <xref:System.Collections.Generic.Dictionary%602> クラスのメソッドをサポートし、<xref:System.Dynamic.DynamicObject.TrySetMember%2A> および <xref:System.Dynamic.DynamicObject.TryGetMember%2A> メソッドをオーバーライドして新しい構文をサポートします。 また、`Print` メソッドも用意されています。このメソッドは、すべてのディクショナリキーと値を出力します。  
  
 [!code-csharp[System.Dynamic.DynamicObject#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#6)]
 [!code-vb[System.Dynamic.DynamicObject#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TrySetIndex (System.Dynamic.SetIndexBinder binder, object[] indexes, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetIndex(class System.Dynamic.SetIndexBinder binder, object[] indexes, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetIndex (binder As SetIndexBinder, indexes As Object(), value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetIndex(System::Dynamic::SetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool&#xA;override this.TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TrySetIndex (binder, indexes, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">演算に関する情報を提供します。</param>
        <param name="indexes">演算に使用されるインデックス。 たとえば、C# の <c>sampleObject[3] = 10</c> (Visual Basic では <c>sampleObject(3) = 10</c>) 演算の場合 (<c>sampleObject</c> は <see cref="T:System.Dynamic.DynamicObject" /> クラスから派生)、<c>indexes[0]</c> は 3 に等しくなります。</param>
        <param name="value">指定したインデックスのオブジェクトに設定する値。 たとえば、C# の <c>sampleObject[3] = 10</c> (Visual Basic では <c>sampleObject(3) = 10</c>) 演算の場合 (<c>sampleObject</c> は <see cref="T:System.Dynamic.DynamicObject" /> クラスから派生)、<paramref name="value" /> は 10 に等しくなります。</param>
        <summary>インデックスを使用して値を設定する演算の実装を提供します。 <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生クラスでこのメソッドをオーバーライドして、指定したインデックスを使用してオブジェクトにアクセスする演算の動的な動作を指定できます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが <see langword="false" /> を返す場合、言語のランタイム バインダーによって動作が決まります (ほとんどの場合、言語固有の実行時例外がスローされます)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Dynamic.DynamicObject> クラスから派生したクラスは、このメソッドをオーバーライドして、インデックスによってオブジェクトにアクセスする操作を動的オブジェクトに対して実行する方法を指定できます。 メソッドがオーバーライドされない場合、言語のランタイムバインダーによって動作が決まります。 (ほとんどの場合、言語固有の実行時例外がスローされます)。  
  
 このメソッドがオーバーライドされると、`sampleObject` が <xref:System.Dynamic.DynamicObject> クラスから派生した Visual Basic でC# `sampleObject(3) = 10` の `sampleObject[3] = 10` などの操作がある場合に、自動的に呼び出されます。  
  
   
  
## Examples  
 たとえば、`Property0`、`Property1`などの名前、またはインデックスを使用してプロパティにアクセスできるオブジェクトを作成するとします。たとえば、`sampleObject.Property0` は、`sampleObject(0)` 内の `sampleObject[0]` C#または Visual Basic に相当します。  
  
 次のコード例は、<xref:System.Dynamic.DynamicObject> クラスから派生した `SampleDynamicObject` クラスを示しています。 `SampleDynamicObject` クラスには、キーと値のペアを格納するための `Dictionary<string, object>` 型 (Visual Basic では`Dictionary(Of String, Object)`) のオブジェクトが含まれています。 `SampleDynamicObject` は、インデックスによるアクセスを有効にするために <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> および <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> メソッドをオーバーライドします。 <xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドと <xref:System.Dynamic.DynamicObject.TryGetMember%2A> メソッドをオーバーライドして、プロパティ名によるアクセスを有効にします。  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetMember">
      <MemberSignature Language="C#" Value="public virtual bool TrySetMember (System.Dynamic.SetMemberBinder binder, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetMember(class System.Dynamic.SetMemberBinder binder, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetMember (binder As SetMemberBinder, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetMember(System::Dynamic::SetMemberBinder ^ binder, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool&#xA;override this.TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool" Usage="dynamicObject.TrySetMember (binder, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetMemberBinder" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">動的操作を呼び出したオブジェクトに関する情報を提供します。 <c>binder.Name</c> プロパティは、値の割り当て先のメンバーの名前を提供します。 たとえば、ステートメント <c>sampleObject.SampleProperty = "Test"</c> の場合 (<c>sampleObject</c> は <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生クラスのインスタンス)、<c>binder.Name</c> は "SampleProperty" を返します。 メンバー名で大文字と小文字を区別するかどうかを <c>binder.IgnoreCase</c> プロパティで指定します。</param>
        <param name="value">メンバーに設定する値。 たとえば、<c>sampleObject.SampleProperty = "Test"</c> の場合 (<c>sampleObject</c> は <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生クラスのインスタンス)、<paramref name="value" /> は "Test" となります。</param>
        <summary>メンバー値を設定する操作の実装を提供します。 <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生クラスでこのメソッドをオーバーライドして、プロパティ値の設定などの演算の動的な動作を指定できます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが <see langword="false" /> を返す場合、言語のランタイム バインダーによって動作が決まります (ほとんどの場合、言語固有の実行時例外がスローされます)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Dynamic.DynamicObject> クラスから派生したクラスは、このメソッドをオーバーライドして、メンバーに値を設定する操作を動的オブジェクトに対して実行する方法を指定できます。 メソッドがオーバーライドされない場合、言語のランタイムバインダーによって動作が決まります。 (ほとんどの場合、言語固有の実行時例外がスローされます)。  
  
 このメソッドは、`sampleObject.SampleProperty = "Test"`のようなステートメントがある場合に呼び出されます。 `sampleObject` は、<xref:System.Dynamic.DynamicObject> クラスから派生したクラスのインスタンスです。  
  
 `DynamicObject` クラスから派生したクラスに独自のメンバーを追加することもできます。 クラスがプロパティを定義し、<xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドもオーバーライドする場合、動的言語ランタイム (DLR) はまず、言語バインダーを使用して、クラス内のプロパティの静的な定義を検索します。 このようなプロパティが存在しない場合、DLR は <xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドを呼び出します。  
  
   
  
## Examples  
 ディクショナリ内の値にアクセスするための別の構文を提供するとします。これにより、`sampleDictionary["Text"] = "Sample text"` (Visual Basic で`sampleDictionary("Text") = "Sample text"`) を記述する代わりに、`sampleDictionary.Text = "Sample text"`を記述できます。 また、この構文では大文字と小文字を区別しないため、`sampleDictionary.Text` は `sampleDictionary.text`と同じになります。  
  
 次のコード例は、<xref:System.Dynamic.DynamicObject> クラスから派生した `DynamicDictionary` クラスを示しています。 `DynamicDictionary` クラスには、キーと値のペアを格納するための `Dictionary<string, object>` 型 (Visual Basic 内の`Dictionary(Of String, Object)`) のオブジェクトが含まれています。また、新しい構文をサポートするために、<xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドと <xref:System.Dynamic.DynamicObject.TryGetMember%2A> メソッドをオーバーライドします。 また、`Count` プロパティも用意されています。このプロパティは、ディクショナリに含まれる動的プロパティの数を示します。  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryUnaryOperation (System.Dynamic.UnaryOperationBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUnaryOperation(class System.Dynamic.UnaryOperationBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUnaryOperation (binder As UnaryOperationBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryUnaryOperation(System::Dynamic::UnaryOperationBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryUnaryOperation : System.Dynamic.UnaryOperationBinder * obj -&gt; bool&#xA;override this.TryUnaryOperation : System.Dynamic.UnaryOperationBinder * obj -&gt; bool" Usage="dynamicObject.TryUnaryOperation (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.UnaryOperationBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">単項演算に関する情報を提供します。 <c>binder.Operation</c> プロパティは <see cref="T:System.Linq.Expressions.ExpressionType" /> オブジェクトを返します。 たとえば、<c>negativeNumber = -number</c> ステートメントの場合 (<c>number</c> は <see langword="DynamicObject" /> クラスから派生)、<c>binder.Operation</c> は "Negate" を返します。</param>
        <param name="result">単項演算の結果。</param>
        <summary>単項演算の実装を提供します。 <see cref="T:System.Dynamic.DynamicObject" /> クラスの派生クラスでこのメソッドをオーバーライドして、否定、インクリメント、デクリメントなどの演算の動的な動作を指定できます。</summary>
        <returns>操作が正常に終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドが <see langword="false" /> を返す場合、言語のランタイム バインダーによって動作が決まります (ほとんどの場合、言語固有の実行時例外がスローされます)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Dynamic.DynamicObject> クラスから派生したクラスは、このメソッドをオーバーライドして、動的オブジェクトに対して単項演算を実行する方法を指定できます。 メソッドがオーバーライドされない場合、言語のランタイムバインダーによって動作が決まります。 (ほとんどの場合、言語固有の実行時例外がスローされます)。  
  
 このメソッドは、否定、インクリメント、デクリメントなどの単項演算がある場合に呼び出されます。 たとえば、<xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> メソッドがオーバーライドされると、`negativeNumber = -number`のようなステートメントに対してこのメソッドが自動的に呼び出されます。 `number` は <xref:System.Dynamic.DynamicObject> クラスから派生します。  
  
 `binder` パラメーターの `Operation` プロパティを使用して、単項演算の型に関する情報を取得できます。  
  
 動的オブジェクトがおよび Visual Basic のみでC#使用される場合、`binder.Operation` プロパティは、<xref:System.Linq.Expressions.ExpressionType> 列挙体の次のいずれかの値を持つことができます。 ただし、IronPython や IronRuby などの他の言語では、他の値を使用できます。
  
|値|説明|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Decrement`|単項デクリメント演算。|`a--`|サポートされていません。|  
|`Increment`|単項インクリメント演算。|`a++`|サポートされていません。|  
|`Negate`|算術否定。|`-a`|`-a`|  
|`Not`|論理否定。|`!a`|`Not a`|  
|`OnesComplement`|1を補完します。|`~a`|サポートされていません。|  
|`IsFalse`|False 条件値。|`a && b`|サポートされていません。|  
|`IsTrue`|True の条件値。|`a &#124;&#124; b`|サポートされていません。|  
|`UnaryPlus`|単項プラス。|`+a`|`+a`|  
  
> [!NOTE]
>  でC#動的オブジェクトの `OrElse` (`a || b`) 操作と `AndAlso` (`a && b`) 操作を実装するには、<xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> メソッドと <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> メソッドの両方を実装することが必要になる場合があります。  
>   
>  `OrElse` 操作は、単項 `IsTrue` 操作とバイナリ `Or` 操作で構成されます。 `Or` 操作は、`IsTrue` 操作の結果が `false`場合にのみ実行されます。  
>   
>  `AndAlso` 操作は、単項 `IsFalse` 操作とバイナリ `And` 操作で構成されます。 `And` 操作は、`IsFalse` 操作の結果が `false`場合にのみ実行されます。  
  
   
  
## Examples  
 数値のテキスト表現と数値表現を格納するためのデータ構造が必要であり、そのようなデータに対して数学的否定演算を定義する場合を想定しています。  
  
 次のコード例は、<xref:System.Dynamic.DynamicObject> クラスから派生した `DynamicNumber` クラスを示しています。 `DynamicNumber` は、<xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> メソッドをオーバーライドして、数学的否定演算を有効にします。 は、要素へのアクセスを有効にするために、<xref:System.Dynamic.DynamicObject.TrySetMember%2A> メソッドと <xref:System.Dynamic.DynamicObject.TryGetMember%2A> メソッドもオーバーライドします。  
  
 この例では、算術否定演算のみがサポートされています。 `negativeNumber = +number`のようなステートメントを記述しようとすると、実行時例外が発生します。  
  
 [!code-csharp[System.Dynamic.DynamicObject#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#7)]
 [!code-vb[System.Dynamic.DynamicObject#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
