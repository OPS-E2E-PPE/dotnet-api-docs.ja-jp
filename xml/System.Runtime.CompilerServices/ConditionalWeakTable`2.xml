<Type Name="ConditionalWeakTable&lt;TKey,TValue&gt;" FullName="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;">
  <TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; where TKey : class where TValue : class" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConditionalWeakTable(Of TKey, TValue)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA; where TKey : class where TValue : classpublic ref class ConditionalWeakTable sealed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt; = class" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; where TKey : class where TValue : class" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.IEnumerable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConditionalWeakTable(Of TKey, TValue)&#xA;Implements IEnumerable(Of KeyValuePair(Of TKey, TValue))" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA; where TKey : class where TValue : classpublic ref class ConditionalWeakTable sealed : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt; = class&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="System.Dynamic.Runtime" FromVersion="4.0.10.0" To="System.Runtime" ToVersion="4.0.20.0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Dynamic.Runtime" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Dynamic.Runtime" FromVersion="4.1.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Dynamic.Runtime" FromVersion="4.1.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Dynamic.Runtime" FromVersion="4.1.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <TypeParameters>
    <TypeParameter Name="TKey">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TValue">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey"><span data-ttu-id="4e4c6-101">フィールドがアタッチされる参照型。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-101">The reference type to which the field is attached.</span></span></typeparam>
    <typeparam name="TValue"><span data-ttu-id="4e4c6-102">フィールドの種類。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-102">The field's type.</span></span> <span data-ttu-id="4e4c6-103">参照型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-103">This must be a reference type.</span></span></typeparam>
    <summary><span data-ttu-id="4e4c6-104">コンパイラがマネージド オブジェクトに動的にオブジェクト フィールドをアタッチできるようにします。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-104">Enables compilers to dynamically attach object fields to managed objects.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e4c6-105"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> クラスを使用すると、言語コンパイラは、実行時に任意のプロパティをマネージオブジェクトにアタッチできます。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-105">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class enables language compilers to attach arbitrary properties to managed objects at run time.</span></span> <span data-ttu-id="4e4c6-106"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> オブジェクトは、キーによって表されるマネージオブジェクトを、値で表される添付プロパティにバインドするディクショナリです。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-106">A <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object is a dictionary that binds a managed object, which is represented by a key, to its attached property, which is represented by a value.</span></span> <span data-ttu-id="4e4c6-107">オブジェクトのキーは、プロパティがアタッチされている `TKey` クラスの個別のインスタンスであり、その値は、対応するオブジェクトに割り当てられているプロパティ値です。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-107">The object's keys are the individual instances of the `TKey` class to which the property is attached, and its values are the property values that are assigned to the corresponding objects.</span></span>  
  
 <span data-ttu-id="4e4c6-108">キーは一意である必要があります。つまり、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> クラスは、マネージオブジェクトごとに1つのアタッチされた値をサポートします。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-108">Keys must be unique; in other words, the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class supports one attached value per managed object.</span></span> <span data-ttu-id="4e4c6-109">2つのキーが等しい場合は、<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> メソッドに渡すと、`true`が返されます。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-109">Two keys are equal if passing them to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4e4c6-110">キーのハッシュコードを明示的に設定するために <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> をオーバーライドすることによって、等値比較を制御することはできません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-110">You cannot control equality comparisons by overriding <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> to explicitly set the hash code for a key.</span></span> <span data-ttu-id="4e4c6-111"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> クラスは、<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> メソッドを使用してハッシュコードを計算するのではなく、<xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> のオーバーライドを呼び出しません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-111">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class does not use the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method to compute hash codes, and therefore does not invoke <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> overrides.</span></span>  
  
 <span data-ttu-id="4e4c6-112"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> クラスはキーと値のペアのコレクションを保持しますが、ディクショナリオブジェクトではなくテーブルとして考えることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-112">Although the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class holds a collection of key/value pairs, it is best thought of as a table rather than a dictionary object.</span></span> <span data-ttu-id="4e4c6-113"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> クラスは、いくつかの方法でディクショナリと異なります。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-113">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class differs from a dictionary in several ways:</span></span>  
  
-   <span data-ttu-id="4e4c6-114">キーを保持しません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-114">It does not persist keys.</span></span> <span data-ttu-id="4e4c6-115">つまり、キーが保持されるのは、コレクションのメンバーであるためです。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-115">That is, a key is not kept alive only because it is a member of the collection.</span></span>  
  
-   <span data-ttu-id="4e4c6-116">通常、ディクショナリに含まれるすべてのメソッド (`GetEnumerator` や `Contains`など) は含まれません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-116">It does not include all the methods (such as `GetEnumerator` or `Contains`) that a dictionary typically has.</span></span>  
  
-   <span data-ttu-id="4e4c6-117"><xref:System.Collections.Generic.IDictionary%602> インターフェイスを実装していません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-117">It does not implement the <xref:System.Collections.Generic.IDictionary%602> interface.</span></span>  
  
 <span data-ttu-id="4e4c6-118"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> クラスは、コレクションに格納されているキーのオブジェクトの有効期間の管理において、他のコレクションオブジェクトとは異なります。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-118">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class differs from other collection objects in its management of the object lifetime of keys stored in the collection.</span></span> <span data-ttu-id="4e4c6-119">通常、オブジェクトがコレクションに格納されている場合、その有効期間は、削除されるまで (およびオブジェクトへの追加の参照がない)、またはコレクションオブジェクト自体が破棄されるまで継続されます。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-119">Ordinarily, when an object is stored in a collection, its lifetime lasts until it is removed (and there are no additional references to the object) or until the collection object itself is destroyed.</span></span> <span data-ttu-id="4e4c6-120">ただし、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> クラスでは、テーブルにキーと値のペアを追加しても、テーブルに格納されている値から直接アクセスできる場合でも、キーが保持されることは保証されません (たとえば、テーブルに1つのキーが含まれていて、値が V1 で、2番目のキー B に、への参照</span><span class="sxs-lookup"><span data-stu-id="4e4c6-120">However, in the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> class, adding a key/value pair to the table does not ensure that the key will persist, even if it can be reached directly from a value stored in the table (for example, if the table contains one key, A, with a value V1, and a second key, B, with a value P2 that contains a reference to A).</span></span> <span data-ttu-id="4e4c6-121">代わりに、キーへの他の参照がテーブルの外部に存在しなくなるとすぐに、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> によってキーと値のエントリが自動的に削除されます。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-121">Instead, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> automatically removes the key/value entry as soon as no other references to a key exist outside the table.</span></span> <span data-ttu-id="4e4c6-122">具体的な例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-122">The example provides an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e4c6-123">次の例では、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> テーブルに格納されているキーは、テーブルの外部での参照が破棄された後に保持されないことを示しています。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-123">The following example illustrates that a key stored in the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table does not persist after references to it outside the table are destroyed.</span></span> <span data-ttu-id="4e4c6-124">この例では、テーブルのキーを表す `ManagedClass`と、キーの値を表す `ClassData`の2つのクラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-124">The example defines two classes: `ManagedClass`, which represents the key in the table, and `ClassData`, which represents the key's value.</span></span> <span data-ttu-id="4e4c6-125">この例では、それぞれの型の3つのオブジェクトをインスタンス化します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-125">The example instantiates three objects of each type.</span></span> <span data-ttu-id="4e4c6-126">また、2番目の `ManagedClass`を表す <xref:System.WeakReference> オブジェクトをインスタンス化し、2番目の `ManagedClass` インスタンスを破棄します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-126">It also instantiates a <xref:System.WeakReference> object that represents the second `ManagedClass`, and then destroys the second `ManagedClass` instance.</span></span> <span data-ttu-id="4e4c6-127"><xref:System.WeakReference.Target%2A> プロパティから2番目の `ManagedClass` オブジェクトを取得しようとすると、そのオブジェクトへの参照が残っていないことを示します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-127">The attempt to retrieve the second `ManagedClass` object from the <xref:System.WeakReference.Target%2A> property indicates that no references to the object remain.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/cs/example1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/vb/example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="4e4c6-128"><see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> クラスのインスタンスは、スレッドセーフです。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-128">Instances of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class are thread safe.</span></span> <span data-ttu-id="4e4c6-129">呼び出し元は、追加のロックを行う必要はありません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-129">They do not require callers to do any additional locking.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConditionalWeakTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4e4c6-130"><see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-130">Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e4c6-131"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> コンストラクターは、空の <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> テーブルをインスタンス化します。つまり、テーブルにはキーと値のペアが含まれていません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-131">The <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> constructor instantiates an empty <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table; that is, the table contains no key/value pairs.</span></span> <span data-ttu-id="4e4c6-132">キーと値のペアを追加するには、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>、または <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-132">You can add key/value pairs by calling the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, or <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method.</span></span>  
  
 <span data-ttu-id="4e4c6-133"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> オブジェクト内のすべてのキーは一意である必要があります。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-133">Every key in a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object must be unique.</span></span> <span data-ttu-id="4e4c6-134">キーは、同じオブジェクトを参照している場合は一意ではありません (つまり、<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> メソッドの引数として渡すと、`true`を返します)。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-134">Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.Add : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="4e4c6-135">追加するキー。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-135">The key to add.</span></span> <span data-ttu-id="4e4c6-136"><paramref name="key" /> は、プロパティのアタッチ先となるオブジェクトを表します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-136"><paramref name="key" /> represents the object to which the property is attached.</span></span></param>
        <param name="value"><span data-ttu-id="4e4c6-137">キーのプロパティ値。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-137">The key's property value.</span></span></param>
        <summary><span data-ttu-id="4e4c6-138">テーブルにキーを追加します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-138">Adds a key to the table.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e4c6-139"><xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> オブジェクト内のすべてのキーは一意である必要があります。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-139">Every key in a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> object must be unique.</span></span> <span data-ttu-id="4e4c6-140">キーは、同じオブジェクトを参照している場合は一意ではありません (つまり、<xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> メソッドの引数として渡すと、`true`を返します)。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-140">Keys are not unique if they refer to the same object (that is, if passing them as arguments to the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method returns `true`).</span></span>  
  
 <span data-ttu-id="4e4c6-141">加算操作中にキーがガベージコレクトされると、既存のキーと値のペアが削除され、例外がスローされることなく新しいキーと値のペアが追加されます。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-141">If the key is garbage-collected during the addition operation, the existing key/value pair is removed and the new key/value pair is added without an exception being thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e4c6-142">次の例では、`MainClass` クラスと `MainInfo` クラスを定義しています。このクラスは、`MainClass` インスタンスに関する情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-142">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="4e4c6-143">次に、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> メソッドを呼び出して、`MainClass` オブジェクトとそれに関連付けられている `MainInfo` オブジェクトを <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> テーブルに追加します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-143">The example then calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="4e4c6-144">この例では、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> および <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> メソッドを呼び出して、キー/値のペアをテーブルに追加する方法と、既存のキーの値を取得するための <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> メソッドについても説明します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-144">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e4c6-145"><paramref name="key" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-145"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="4e4c6-146"><paramref name="key" /> が既に存在します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-146"><paramref name="key" /> already exists.</span></span></exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public void AddOrUpdate (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOrUpdate(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOrUpdate (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOrUpdate(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.AddOrUpdate (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="value" Type="TValue" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="4e4c6-147">追加または更新するキー。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-147">The key to add or update.</span></span> <span data-ttu-id="4e4c6-148"><see langword="null" /> は指定できません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-148">May not be <see langword="null" />.</span></span></param>
        <param name="value"><span data-ttu-id="4e4c6-149"><paramref name="key" /> に関連付ける値。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-149">The value to associate with <paramref name="key" />.</span></span></param>
        <summary><span data-ttu-id="4e4c6-150">キーが存在しない場合はキーと値を追加し、存在する場合は既存のキーの値を更新します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-150">Adds the key and value if the key doesn't exist, or updates the existing key's value if it does exist.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e4c6-151"><paramref name="key" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-151"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="conditionalWeakTable.Clear " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4e4c6-152">すべてのキーと値のペアを消去する。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-152">Clears all the key/value pairs.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ConditionalWeakTable`2 ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="conditionalWeakTable.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4e4c6-153">ガベージ コレクターが <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> オブジェクトを再利用しているときに、リソースが解放され、他のクリーンアップ操作が確実に実行されるようにします。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-153">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e4c6-154">現在のオブジェクトを完了する準備が整うと、ガベージコレクターは <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-154">The garbage collector calls <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateValue">
      <MemberSignature Language="C#" Value="public TValue GetOrCreateValue (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrCreateValue(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateValue (key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrCreateValue(TKey key);" />
      <MemberSignature Language="F#" Value="member this.GetOrCreateValue : 'Key -&gt; 'Value" Usage="conditionalWeakTable.GetOrCreateValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="4e4c6-155">検索対象のキー。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-155">The key to search for.</span></span> <span data-ttu-id="4e4c6-156"><paramref name="key" /> は、プロパティのアタッチ先となるオブジェクトを表します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-156"><paramref name="key" /> represents the object to which the property is attached.</span></span></param>
        <summary><span data-ttu-id="4e4c6-157">テーブルで指定されたキーをアトミックに検索し、対応する値を返します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-157">Atomically searches for a specified key in the table and returns the corresponding value.</span></span> <span data-ttu-id="4e4c6-158">キーがテーブルに存在しない場合は、メソッドによって、テーブルの値を表すクラスのパラメーターなしのコンストラクターが呼び出され、指定されたキーにバインドされる値を作成します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-158">If the key does not exist in the table, the method invokes the parameterless constructor of the class that represents the table's value to create a value that is bound to the specified key.</span></span></summary>
        <returns><span data-ttu-id="4e4c6-159"><paramref name="key" /> がテーブル内に既に存在する場合には、<paramref name="key" /> に対応する値。それ以外の場合には、<paramref name="TValue" /> ジェネリック型パラメーターによって定義されるクラスのパラメーターなしのコンストラクターによって作成された新しい値。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-159">The value that corresponds to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, a new value created by the parameterless constructor of the class defined by the <paramref name="TValue" /> generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e4c6-160">テーブルに `key` が存在しない場合、メソッドは、`TValue` ジェネリック型パラメーターによって定義されたクラスのパラメーターなしのコンストラクターを呼び出すことによってインスタンス化されるオブジェクトと共に、それを追加します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-160">If `key` does not exist in the table, the method adds it, along with the object that is instantiated by calling the parameterless constructor of the class defined by the `TValue` generic type parameter.</span></span> <span data-ttu-id="4e4c6-161">`TValue` クラスにパラメーターなしのコンストラクターがない場合は、<xref:System.MissingMethodException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-161">If the `TValue` class has no parameterless constructor, a <xref:System.MissingMethodException> is thrown.</span></span>  
  
 <span data-ttu-id="4e4c6-162">これは、テーブルの値のクラスでパラメーターなしのコンストラクターが定義されている場合に、既存の値を取得したり、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> テーブルに新しい値を追加したりするために推奨される方法です。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-162">This is the recommended method of retrieving an existing value or adding a new value to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table if the class of the table's value defines a parameterless constructor.</span></span> <span data-ttu-id="4e4c6-163">パラメーターなしのコンストラクターを定義しない場合は、代わりに <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> メソッドを呼び出すことができます。これは、コールバックによって提供されるメソッドに依存して、テーブルの値を表すオブジェクトをインスタンス化します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-163">If it does not define a parameterless constructor, you can instead call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method, which relies on a callback-provided method to instantiate the object representing the table's value</span></span>  
  
 <span data-ttu-id="4e4c6-164">キーがテーブルに見つからない場合にキーと値のペアを追加せずに既存のキーの値を取得するには、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-164">To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e4c6-165">次の例では、`MainClass` クラスと `MainInfo` クラスを定義しています。このクラスは、`MainClass` インスタンスに関する情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-165">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="4e4c6-166">この例では、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> メソッドを呼び出して、`MainClass` オブジェクトとそれに関連付けられている `MainInfo` オブジェクトを <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> テーブルに追加します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-166">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="4e4c6-167">この例では、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> および <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> メソッドを呼び出して、キー/値のペアをテーブルに追加する方法と、既存のキーの値を取得するための <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> メソッドについても説明します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-167">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e4c6-168"><paramref name="key" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-168"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="4e4c6-169"></see>Windows ストア アプリ用 .NET<see href="https://go.microsoft.com/fwlink/?LinkID=247912"> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.MissingMemberException" /> を代わりにキャッチします。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-169">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.MissingMemberException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="4e4c6-170">テーブルの値を表すクラスでは、パラメーターなしのコンストラクターが定義されません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-170">The class that represents the table's value does not define a parameterless constructor.</span></span></exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public TValue GetValue (TKey key, System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;.CreateValueCallback createValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetValue(!TKey key, class System.Runtime.CompilerServices.ConditionalWeakTable`2/CreateValueCallback&lt;!TKey, !TValue&gt; createValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (key As TKey, createValueCallback As ConditionalWeakTable(Of TKey, TValue).CreateValueCallback) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetValue(TKey key, System::Runtime::CompilerServices::ConditionalWeakTable&lt;TKey, TValue&gt;::CreateValueCallback ^ createValueCallback);" />
      <MemberSignature Language="F#" Value="member this.GetValue : 'Key * System.Runtime.CompilerServices.ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt;.CreateValueCallback -&gt; 'Value" Usage="conditionalWeakTable.GetValue (key, createValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="createValueCallback" Type="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;+CreateValueCallback" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="4e4c6-171">検索対象のキー。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-171">The key to search for.</span></span> <span data-ttu-id="4e4c6-172"><paramref name="key" /> は、プロパティのアタッチ先となるオブジェクトを表します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-172"><paramref name="key" /> represents the object to which the property is attached.</span></span></param>
        <param name="createValueCallback"><span data-ttu-id="4e4c6-173">指定の <paramref name="key" /> の値を作成可能なメソッドへのデリゲート。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-173">A delegate to a method that can create a value for the given <paramref name="key" />.</span></span> <span data-ttu-id="4e4c6-174"><c>TKey</c> 型の 1 つのパラメーターを持ち、<c>TValue</c> 型の値を戻します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-174">It has a single parameter of type <c>TKey</c>, and returns a value of type <c>TValue</c>.</span></span></param>
        <summary><span data-ttu-id="4e4c6-175">テーブルで指定されたキーをアトミックに検索し、対応する値を返します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-175">Atomically searches for a specified key in the table and returns the corresponding value.</span></span> <span data-ttu-id="4e4c6-176">キーがテーブルに存在しない場合は、メソッドがコールバック メソッドを呼び出して、指定されたキーにバインドされる値を作成します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-176">If the key does not exist in the table, the method invokes a callback method to create a value that is bound to the specified key.</span></span></summary>
        <returns><span data-ttu-id="4e4c6-177"><paramref name="key" /> がテーブル内に既に存在する場合には、<paramref name="key" /> にアタッチされた値。それ以外の場合には、<paramref name="createValueCallback" /> デリゲートによって戻される新しい値。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-177">The value attached to <paramref name="key" />, if <paramref name="key" /> already exists in the table; otherwise, the new value returned by the <paramref name="createValueCallback" /> delegate.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e4c6-178">テーブルに `key` が存在しない場合、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> は `createValueCallback` パラメーターで定義されているメソッドを呼び出し、キーを渡します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-178">If `key` does not exist in the table, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> invokes the method that is defined by the `createValueCallback` parameter and passes it the key.</span></span> <span data-ttu-id="4e4c6-179">新しい値がテーブル内のキーにバインドされ、結果として返されます。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-179">A new value is bound to the key in the table and returned as a result.</span></span>  
  
 <span data-ttu-id="4e4c6-180">このメソッドは、テーブルの値を表すクラスがパラメーターなしのコンストラクターを定義していない場合にのみ使用します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-180">Use this method only when the class that represents the table's value does not define a parameterless constructor.</span></span> <span data-ttu-id="4e4c6-181">パラメーターなしのコンストラクターを定義する場合は、代わりに <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-181">If it does define a parameterless constructor, use the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> method instead.</span></span> <span data-ttu-id="4e4c6-182">キーがテーブルに見つからない場合にキーと値のペアを追加せずに既存のキーの値を取得するには、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-182">To retrieve the value of an existing key without adding the key/value pair if the key is not found in the table, call the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method.</span></span>  
  
 <span data-ttu-id="4e4c6-183">複数のスレッドが同じキーを作成しようとすると、`createValueCallback` は同じキーを使用して複数回呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-183">If multiple threads try to create the same key, `createValueCallback` may be invoked multiple times with the same key.</span></span> <span data-ttu-id="4e4c6-184">これらの呼び出しのうち1つだけが成功し、その戻り値がテーブルに追加されます。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-184">Only one of these calls will succeed, and its returned value will be added to the table.</span></span> <span data-ttu-id="4e4c6-185">値の作成に成功するスレッドは不確定です。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-185">Which thread succeeds in creating the value is indeterminate.</span></span> <span data-ttu-id="4e4c6-186">このルールは、デッドロックを防ぐために、テーブルが内部テーブルロックの外部 `createValueCallback` を呼び出すことを許可します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-186">This rule permits the table to invoke `createValueCallback` outside the internal table lock to prevent deadlocks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e4c6-187">次の例では、`MainClass` クラスと `MainInfo` クラスを定義しています。このクラスは、`MainClass` インスタンスに関する情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-187">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="4e4c6-188">また、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> デリゲートに割り当てて <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> メソッドに渡すことができる静的 (Visual Basic で`Shared`) `CreateAttachedValue` メソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-188">It also defines a static (`Shared` in Visual Basic) `CreateAttachedValue` method that can be assigned to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegate and passed to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method.</span></span> <span data-ttu-id="4e4c6-189">この例では、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> メソッドを呼び出して、`MainClass` オブジェクトとそれに関連付けられている `MainInfo` オブジェクトを <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> テーブルに追加します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-189">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> method to add a `MainClass` object and its attached `MainInfo` object to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="4e4c6-190">この例では、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> および <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> メソッドを呼び出して、キー/値のペアをテーブルに追加する方法と、既存のキーの値を取得するための <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> メソッドについても説明します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-190">The example also illustrates calls to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> methods to add key/value pairs to the table, and to the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to retrieve the value of an existing key.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e4c6-191"><paramref name="key" /> または <paramref name="createValueCallback" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-191"><paramref name="key" /> or <paramref name="createValueCallback" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
        <altmember cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'Key -&gt; bool" Usage="conditionalWeakTable.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="4e4c6-192">削除するキー。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-192">The key to remove.</span></span></param>
        <summary><span data-ttu-id="4e4c6-193">テーブルから、キーとその値を削除します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-193">Removes a key and its value from the table.</span></span></summary>
        <returns><span data-ttu-id="4e4c6-194">キーが見つかり削除された場合には <see langword="true" />。それ以外の場合には <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-194"><see langword="true" /> if the key is found and removed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e4c6-195">この操作中にキーがガベージコレクトされた場合、メソッドは例外を発生させず、戻り値は未定義になります。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-195">If the key is garbage-collected during this operation, the method does not raise an exception and the return value is undefined.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e4c6-196"><paramref name="key" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-196"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;override this.System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt;" Usage="conditionalWeakTable.System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4e4c6-197"><see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> テーブルを反復処理するために使用できる列挙子を返します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-197">Returns an enumerator that can be used to iterate through the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> table.</span></span></summary>
        <returns><span data-ttu-id="4e4c6-198"><see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> テーブルの反復処理に使用できる列挙子。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-198">An enumerator that can be used to iterate through the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> table.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="4e4c6-199">返された列挙子は、現在のものを除く、テーブル内のすべてのオブジェクトペアの有効期間を延長することはありません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-199">The returned enumerator does not extend the lifetime of any object pairs in the table, other than the current one.</span></span> <span data-ttu-id="4e4c6-200">既に収集されているエントリや、列挙子を取得した後に追加されたエントリは返されません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-200">It does not return entries that have already been collected or that were added after the enumerator was retrieved.</span></span> <span data-ttu-id="4e4c6-201">また、列挙子の取得時に収集または削除されたエントリ、列挙される前に収集または削除されたエントリなど、列挙子を取得したときに存在していたすべてのエントリが返されるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-201">Additionally, it may not return all entries that were present when the enumerator was retrieved, for example, entries that were collected or removed after the enumerator was retrieved but before they were enumerated.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="conditionalWeakTable.System.Collections.IEnumerable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4e4c6-202"><see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> テーブルを反復処理するために使用できる列挙子を返します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-202">Returns an enumerator that can be used to iterate through the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> table.</span></span></summary>
        <returns><span data-ttu-id="4e4c6-203"><see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> テーブルの反復処理に使用できる列挙子。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-203">An enumerator that can be used to iterate through the <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> table.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="4e4c6-204">このメンバーは、明示的なインターフェイス メンバーの実装です。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-204">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="4e4c6-205">これは、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> のインスタンスが <xref:System.Collections.IEnumerable> インターフェイスにキャストされる場合のみ、使用できます。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-205">It can be used only when the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> instance is cast to an <xref:System.Collections.IEnumerable> interface.</span></span>

<span data-ttu-id="4e4c6-206">返された列挙子は、現在のものを除く、テーブル内のすべてのオブジェクトペアの有効期間を延長することはありません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-206">The returned enumerator does not extend the lifetime of any object pairs in the table, other than the current one.</span></span> <span data-ttu-id="4e4c6-207">既に収集されているエントリや、列挙子を取得した後に追加されたエントリは返されません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-207">It does not return entries that have already been collected or that were added after the enumerator was retrieved.</span></span> <span data-ttu-id="4e4c6-208">また、列挙子の取得時に収集または削除されたエントリ、列挙される前に収集または削除されたエントリなど、列挙子を取得したときに存在していたすべてのエントリが返されるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-208">Additionally, it may not return all entries that were present when the enumerator was retrieved, for example, entries that were collected or removed after the enumerator was retrieved but before they were enumerated.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key * 'Value -&gt; bool" Usage="conditionalWeakTable.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="4e4c6-209">添付プロパティのオブジェクトを表すキー。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-209">The key that represents an object with an attached property.</span></span></param>
        <param name="value"><span data-ttu-id="4e4c6-210">このメソッドから戻るときに、添付プロパティの値が格納されています。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-210">When this method returns, contains the attached property value.</span></span> <span data-ttu-id="4e4c6-211"><paramref name="key" /> が見つからない場合、<paramref name="value" /> には既定値が入ります。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-211">If <paramref name="key" /> is not found, <paramref name="value" /> contains the default value.</span></span></param>
        <summary><span data-ttu-id="4e4c6-212">指定したキーの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-212">Gets the value of the specified key.</span></span></summary>
        <returns><span data-ttu-id="4e4c6-213"><see langword="true" /> が見つかる場合には <paramref name="key" />。それ以外の場合には <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-213"><see langword="true" /> if <paramref name="key" /> is found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4e4c6-214">この操作中にキーがガベージコレクトされた場合、メソッドは `false` を返し、`value` を既定値に設定することがあります (キーが存在しない場合と同様)。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-214">If the key is garbage-collected during this operation, the method may return `false` and set `value` to the default value (as if the key were not present).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4e4c6-215">次の例では、`MainClass` クラスと `MainInfo` クラスを定義しています。このクラスは、`MainClass` インスタンスに関する情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-215">The following example defines a `MainClass` class and a `MainInfo` class, which provides information about the `MainClass` instance.</span></span> <span data-ttu-id="4e4c6-216">この例では、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>、および <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> メソッドを呼び出して、キーと値のペアを <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> テーブルに追加します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-216">The example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, and <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> methods to add key/value pairs to a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> table.</span></span> <span data-ttu-id="4e4c6-217">どちらの場合も、この例では、<xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> メソッドを呼び出して、キーと値のペアがテーブルに追加されていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-217">In each case, the example calls the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> method to confirm that the key/value pair has been added to the table.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4e4c6-218"><paramref name="key" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="4e4c6-218"><paramref name="key" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
      </Docs>
    </Member>
  </Members>
</Type>
