<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="13cb0b397c269a245c8849487b7fabbedc4a72bb" /><Meta Name="ms.sourcegitcommit" Value="a8ff98b48bda124cfcb2605f5da9b21bc6dcd791" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="02/14/2020" /><Meta Name="ms.locfileid" Value="77220778" /></Metadata><TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>スレッドを作成および制御し、その優先順位の設定およびステータスの取得を実行します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスが開始されると、共通言語ランタイムによって、アプリケーションコードを実行するためのフォアグラウンドスレッドが自動的に1つ作成されます。 プロセスでは、この主要なフォアグラウンドスレッドと共に、プロセスに関連付けられているプログラムコードの一部を実行するために1つ以上のスレッドを作成できます。 これらのスレッドは、フォアグラウンドまたはバックグラウンドで実行できます。 さらに、<xref:System.Threading.ThreadPool> クラスを使用して、共通言語ランタイムによって管理されるワーカースレッドでコードを実行できます。  
  
 このセクションの内容  
  
 [スレッド  を開始し](#Starting)ています  
 [スレッドオブジェクトの取得](#Retrieving)   
 [フォアグラウンドスレッドとバックグラウンドスレッド](#Foreground)   
 [カルチャとスレッド](#Culture)   
 [情報の取得とスレッドの制御](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>スレッドの開始  
 スレッドを開始するには、そのクラスコンストラクターでスレッドが実行するメソッドを表すデリゲートを指定します。 次に、<xref:System.Threading.Thread.Start%2A> メソッドを呼び出して、実行を開始します。  
  
 引数を実行するメソッドに渡すことができるかどうかに応じて、<xref:System.Threading.Thread> コンストラクターは、次の2つのデリゲート型のどちらかを受け取ることができます。  
  
-   メソッドに引数がない場合は、コンストラクターに <xref:System.Threading.ThreadStart> デリゲートを渡します。 署名は次のとおりです。  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     次の例では、`ExecuteInForeground` メソッドを実行するスレッドを作成して開始します。 メソッドは、一部のスレッドプロパティに関する情報を表示した後、0.5 秒間一時停止するループを実行し、経過秒数を表示します。 スレッドが少なくとも5秒間実行されると、ループが終了し、スレッドが実行を終了します。  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   メソッドに引数がある場合は、コンストラクターに <xref:System.Threading.ParameterizedThreadStart> デリゲートを渡します。 署名は次のとおりです。  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     その後、デリゲートによって実行されるメソッドC#は、パラメーターを適切な型にキャスト (では) または変換 (Visual Basic) できます。  
  
     次の例は、前の例と同じですが、<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> コンストラクターを呼び出している点が異なります。 このバージョンの `ExecuteInForeground` メソッドには、ループが実行されるおおよそのミリ秒数を表す1つのパラメーターがあります。  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 スレッドを開始した後は、<xref:System.Threading.Thread> オブジェクトへの参照を保持する必要はありません。 スレッドは、スレッドプロシージャが完了するまで実行を続けます。  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>スレッドオブジェクトの取得  
 静的 (Visual Basic の`Shared`) <xref:System.Threading.Thread.CurrentThread%2A> プロパティを使用して、スレッドが実行しているコードから現在実行中のスレッドへの参照を取得できます。 次の例では、<xref:System.Threading.Thread.CurrentThread%2A> プロパティを使用して、メインアプリケーションスレッド、別のフォアグラウンドスレッド、バックグラウンドスレッド、スレッドプールスレッドに関する情報を表示します。  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>フォアグラウンドスレッドとバックグラウンドスレッド  
 <xref:System.Threading.Thread> クラスのインスタンスは、フォアグラウンドスレッドとバックグラウンドスレッドのどちらかを表します。 バックグラウンドスレッドはフォアグラウンドスレッドと同じですが、例外が1つあります。すべてのフォアグラウンドスレッドが終了した場合、バックグラウンドスレッドはプロセスを実行したままにしません。 すべてのフォアグラウンドスレッドが停止されると、ランタイムはすべてのバックグラウンドスレッドを停止し、シャットダウンします。  
  
 既定では、次のスレッドがフォアグラウンドで実行されます。  
  
-   メインアプリケーションスレッド。  
  
-   <xref:System.Threading.Thread> クラスコンストラクターを呼び出すことによって作成されるすべてのスレッド。  
  
 既定では、次のスレッドがバックグラウンドで実行されます。  
  
-   スレッドプールスレッド。ランタイムによって管理されるワーカースレッドのプールです。  スレッドプールを構成し、<xref:System.Threading.ThreadPool> クラスを使用してスレッドプールスレッドの作業をスケジュールすることができます。  
  
    > [!NOTE]
    >  スレッドプールのスレッドでは、タスクベースの非同期操作が自動的に実行されます。 タスクベースの非同期操作では、<xref:System.Threading.Tasks.Task> クラスと <xref:System.Threading.Tasks.Task%601> クラスを使用して、[タスクベースの非同期パターン](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)を実装します。  
  
-   アンマネージコードからマネージ実行環境に入るすべてのスレッド。  
  
 バックグラウンドで実行するスレッドを変更するには、<xref:System.Threading.Thread.IsBackground%2A> プロパティをいつでも設定します。  バックグラウンドスレッドは、アプリケーションが実行されている間は続行する必要がありますが、ファイルシステムの変更や着信ソケット接続の監視など、アプリケーションの終了を防ぐ必要がない操作には便利です。  
  
 次の例は、フォアグラウンドスレッドとバックグラウンドスレッドの違いを示しています。 これは、スレッドを開始する前にバックグラウンドで実行するようにスレッドを設定している点を除いて、[スレッドの開始](#Starting)に関するセクションの最初の例と似ています。 出力に示されているように、ループは、5秒間実行される前に中断されます。  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>カルチャとスレッド  
 各スレッドには、<xref:System.Threading.Thread.CurrentCulture%2A> プロパティによって表されるカルチャと、<xref:System.Threading.Thread.CurrentUICulture%2A> プロパティによって表される UI カルチャがあります。  現在のカルチャでは、解析と書式設定、文字列の比較と並べ替えなど、カルチャに依存する操作をサポートしています。また、スレッドで使用される書記体系と暦も制御します。 現在の UI カルチャは、リソースファイル内のリソースのカルチャに依存した取得を提供します。  

> [!IMPORTANT]
> <xref:System.Threading.Thread.CurrentCulture> プロパティと <xref:System.Threading.Thread.CurrentUICulture> プロパティは、現在のスレッド以外のスレッドで使用する場合、確実に動作しません。 .NET Framework では、これらのプロパティの読み取りは信頼性がありますが、現在のスレッド以外のスレッドに対してこれらのプロパティを設定することはできません。 .NET Core では、スレッドが別のスレッドでこれらのプロパティの読み取りまたは書き込みを行おうとすると、<xref:System.InvalidOperationException> がスローされます。
> <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> と <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> のプロパティを使用して、現在のカルチャを取得して設定することをお勧めします。

 新しいスレッドがインスタンス化されると、そのカルチャと UI カルチャは、現在のシステムカルチャと ui カルチャによって定義され、新しいスレッドの作成元のスレッドのカルチャおよび UI カルチャによっては定義されません。 たとえば、現在のシステムカルチャが英語 (米国) で、プライマリアプリケーションスレッドの現在のカルチャがフランス語 (フランス) の場合、プライマリスレッドからの <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> コンストラクターを呼び出すことによって作成された新しいスレッドのカルチャは、フランス語 (フランス) ではなく英語 (米国) になります。 詳細については、<xref:System.Globalization.CultureInfo> クラスのトピックの「カルチャとスレッド」セクションを参照してください。  
  
> [!IMPORTANT]
>  これは、[!INCLUDE[net_v46](~/includes/net-v46-md.md)] 以降のバージョンを対象とするアプリに対して非同期操作を実行するスレッドには当てはまりません。この場合、カルチャと UI カルチャは非同期操作のコンテキストの一部になります。非同期操作が既定で実行されるスレッドは、非同期操作の開始元のスレッドのカルチャと UI カルチャを継承します。 詳細については、<xref:System.Globalization.CultureInfo> クラスのトピックの「カルチャとタスク ベースの非同期の操作」セクションをご覧ください。  
  
 アプリケーションで実行されているすべてのスレッドが同じカルチャと UI カルチャを共有するようにするには、次のいずれかを実行します。  
  
-   そのカルチャを表す <xref:System.Globalization.CultureInfo> オブジェクトを <xref:System.Threading.ParameterizedThreadStart> デリゲートまたは <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> メソッドに渡すことができます。  
  
-   [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 以降のバージョンで実行されているアプリでは、<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> と <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> プロパティの値を設定することによって、アプリケーションドメインで作成されたすべてのスレッドに割り当てられるカルチャと UI カルチャを定義できます。 これはアプリケーションごとのドメイン設定であることに注意してください。  

 詳細と例については、<xref:System.Globalization.CultureInfo> クラスのトピックの「カルチャとスレッド」セクションを参照してください。

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>情報の取得とスレッドの制御  
 スレッドに関する情報を提供する多数のプロパティ値を取得できます。 場合によっては、これらのプロパティ値を設定して、スレッドの操作を制御することもできます。 これらのスレッドプロパティは次のとおりです。  
  
-   名前。 <xref:System.Threading.Thread.Name%2A> は、スレッドを識別するために使用できる1回の書き込みプロパティです。  既定値は `null` です。  
  
-   <xref:System.Threading.Thread.GetHashCode%2A> メソッドを呼び出すことによって取得できるハッシュコード。 ハッシュコードは、スレッドを一意に識別するために使用できます。スレッドの有効期間にわたって、そのハッシュコードは、値の取得元のアプリケーションドメインに関係なく、他のスレッドの値と競合しません。  
  
-   スレッド ID。 読み取り専用の <xref:System.Threading.Thread.ManagedThreadId%2A> プロパティの値は、ランタイムによって割り当てられ、プロセス内のスレッドを一意に識別します。  
  
    > [!NOTE]
    >  オペレーティング システム [ThreadId](/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadid) とマネージド スレッドの間には固定的な関係はありません。これは、アンマネージド ホストがマネージド スレッドとアンマネージド スレッドの間の関係を制御できるためです。 具体的には、高度なホストは[CLR ホスティング API](~/docs/framework/unmanaged-api/hosting/index.md)を使用して、同じオペレーティングシステムスレッドに対して多数のマネージスレッドをスケジュールしたり、異なるオペレーティングシステムスレッド間でマネージスレッドを移動したりできます。  
  
-   スレッドの現在の状態。 スレッドは、存在する間は常に、<xref:System.Threading.ThreadState> プロパティによって定義された1つ以上の状態になります。  
  
-   <xref:System.Threading.ThreadPriority> プロパティによって定義されるスケジューリング優先度レベル。 この値は、スレッドの優先順位を要求するように設定できますが、オペレーティングシステムによって受け入れられるとは限りません。  
  
-   スレッドがスレッドプールスレッドであるかどうかを示す読み取り専用の <xref:System.Threading.Thread.IsThreadPoolThread%2A> プロパティ。  
  
-   <xref:System.Threading.Thread.IsBackground%2A> プロパティ。 詳細については、「[フォアグラウンドスレッドとバックグラウンドスレッド](#Foreground)」セクションを参照してください。  
  
## Examples  
 次の例は、単純なスレッド機能を示しています。  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 このコードでは、次のような出力が生成されます。  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">スレッドの使用とスレッド処理</related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96">Thread クラスの参照ソース</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表すデリゲート。</param>
        <summary>スレッドの開始時にオブジェクトをスレッドに渡すことを許可するデリゲートを指定して、<see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドが作成されても、実行は開始されません。 スレッドの実行をスケジュールするには、<xref:System.Threading.Thread.Start%2A> メソッドを呼び出します。 データオブジェクトをスレッドに渡すには、<xref:System.Threading.Thread.Start%28System.Object%29> メソッドのオーバーロードを使用します。  
  
> [!NOTE]
>  Visual Basic ユーザーは、スレッドの作成時に <xref:System.Threading.ThreadStart> コンストラクターを省略できます。 メソッドを渡すときには `AddressOf` 演算子を使用します。たとえば、`Dim t As New Thread(AddressOf ThreadProc)`のようになります。 Visual Basic は、<xref:System.Threading.ThreadStart> コンストラクターを自動的に呼び出します。  
  
   
  
## Examples  
 次の例は、静的メソッドとインスタンスメソッドを使用して <xref:System.Threading.ParameterizedThreadStart> デリゲートを作成および使用するための構文を示しています。  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">スレッドの作成</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ThreadStart" /> デリゲート。</param>
        <summary><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドが作成されても、実行は開始されません。 スレッドの実行をスケジュールするには、<xref:System.Threading.Thread.Start%2A> メソッドを呼び出します。  
  
> [!NOTE]
>  Visual Basic ユーザーは、スレッドの作成時に <xref:System.Threading.ThreadStart> コンストラクターを省略できます。 例 `Dim t As New Thread(AddressOf ThreadProc)`のようにメソッドを渡すときは、`AddressOf` 演算子を使用します。 Visual Basic は、<xref:System.Threading.ThreadStart> コンストラクターを自動的に呼び出します。  
  
   
  
## Examples  
 次のコード例は、静的メソッドを実行するスレッドを作成する方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 インスタンスメソッドを実行するスレッドを作成する方法を次のコード例に示します。  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> パラメーターが <see langword="null" /> です。</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">スレッドの作成</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ParameterizedThreadStart" /> デリゲート。</param>
        <param name="maxStackSize">スレッドが使用する最大スタック サイズ (バイト単位)。実行可能ファイルのヘッダーで指定された既定の最大スタック サイズを使用する場合は 0。  
  
重要: 部分的に信頼されているコードでは、既定のスタック サイズを超える <paramref name="maxStackSize" /> は無視されます。 例外をスローすることはありません。</param>
        <summary><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化して、スレッドの開始時にオブジェクトをスレッドに渡すことを許可するデリゲートとこのスレッドの最大スタック サイズを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターのオーバーロードは使用しないでください。 <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> コンストラクターオーバーロードによって使用される既定のスタックサイズは、スレッドで推奨されるスタックサイズです。 スレッドにメモリの問題がある場合は、無限再帰などのプログラミングエラーが発生する可能性が最も高くなります。  
  
> [!IMPORTANT]
>  [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、完全に信頼されたコードのみが、`maxStackSize` を既定のスタックサイズ (1 メガバイト) より大きい値に設定できます。 部分信頼でコードを実行しているときに `maxStackSize` により大きな値が指定されている場合、`maxStackSize` は無視され、既定のスタックサイズが使用されます。 例外をスローすることはありません。 任意の信頼レベルのコードでは、`maxStackSize` を既定のスタックサイズよりも小さい値に設定できます。  
  
> [!NOTE]
>  部分的に信頼されるコードによって使用される完全に信頼されたライブラリを開発していて、大きなスタックを必要とするスレッドを開始する必要がある場合は、スレッドを作成する前に完全信頼をアサートする必要があります。または、既定のスタックサイズが使用されます。 スレッドで実行されるコードを完全に制御しない限り、この操作は行わないでください。  
  
 `maxStackSize` が最小スタックサイズ未満の場合は、最小スタックサイズが使用されます。 `maxStackSize` がページサイズの倍数でない場合は、ページサイズの次の大きな倍数に丸められます。 たとえば、Windows Vista で .NET Framework バージョン2.0 を使用している場合は、256 KB (262144 バイト) が最小スタックサイズで、ページサイズは 64 KB (65536 バイト) です。  
  
> [!NOTE]
>  Windows XP および Windows Server 2003 より前のバージョンの Microsoft Windows では、`maxStackSize` は無視され、実行可能ファイルヘッダーで指定されているスタックサイズが使用されます。  
  
 非常に小さいスタックサイズを指定する場合は、スタックオーバーフロープローブを無効にする必要があります。 スタックが非常に制限されている場合、プローブによってスタックオーバーフローが発生する可能性があります。 スタックオーバーフロープローブを無効にするには、アプリケーション構成ファイルに次のを追加します。  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxStackSize" /> に 0 より小さい値が指定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ThreadStart" /> デリゲート。</param>
        <param name="maxStackSize">スレッドが使用する最大スタック サイズ (バイト単位)。実行可能ファイルのヘッダーで指定された既定の最大スタック サイズを使用する場合は 0。  
  
重要: 部分的に信頼されているコードでは、既定のスタック サイズを超える <paramref name="maxStackSize" /> は無視されます。 例外をスローすることはありません。</param>
        <summary><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化して、スレッドの最大スタック サイズを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターのオーバーロードは使用しないでください。 <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> コンストラクターオーバーロードによって使用される既定のスタックサイズは、スレッドで推奨されるスタックサイズです。 スレッドにメモリの問題がある場合は、無限再帰などのプログラミングエラーが発生する可能性が最も高くなります。  
  
> [!IMPORTANT]
>  [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、完全に信頼されたコードのみが、`maxStackSize` を既定のスタックサイズ (1 メガバイト) より大きい値に設定できます。 部分信頼でコードを実行しているときに `maxStackSize` により大きな値が指定されている場合、`maxStackSize` は無視され、既定のスタックサイズが使用されます。 例外をスローすることはありません。 任意の信頼レベルのコードでは、`maxStackSize` を既定のスタックサイズよりも小さい値に設定できます。  
  
> [!NOTE]
>  部分的に信頼されるコードによって使用される完全に信頼されたライブラリを開発していて、大きなスタックを必要とするスレッドを開始する必要がある場合は、スレッドを作成する前に完全信頼をアサートする必要があります。または、既定のスタックサイズが使用されます。 スレッドで実行されるコードを完全に制御しない限り、この操作は行わないでください。  
  
 `maxStackSize` が最小スタックサイズ未満の場合は、最小スタックサイズが使用されます。 `maxStackSize` がページサイズの倍数でない場合は、ページサイズの次の大きな倍数に丸められます。 たとえば、Windows Vista で .NET Framework バージョン2.0 を使用している場合は、256 KB (262144 バイト) が最小スタックサイズで、ページサイズは 64 KB (65536 バイト) です。  
  
> [!NOTE]
>  Windows XP および Windows Server 2003 より前のバージョンの Microsoft Windows では、`maxStackSize` は無視され、実行可能ファイルヘッダーで指定されているスタックサイズが使用されます。  
  
 非常に小さいスタックサイズを指定する場合は、スタックオーバーフロープローブを無効にする必要があります。 スタックが非常に制限されている場合、プローブによってスタックオーバーフローが発生する可能性があります。 スタックオーバーフロープローブを無効にするには、アプリケーション構成ファイルに次のを追加します。  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxStackSize" /> に 0 より小さい値が指定されています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このメソッドが呼び出された対象のスレッドで、そのスレッドの終了プロセスを開始する <see cref="T:System.Threading.ThreadAbortException" /> を発生させます。 このメソッドを呼び出すと、通常、スレッドが終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> `Thread.Abort` メソッドは注意して使用する必要があります。 特に、このメソッドを呼び出して、現在のスレッド以外のスレッドを中止すると、<xref:System.Threading.ThreadAbortException> がスローされたときに実行されたコードや実行に失敗したコードがわからなくなります。また、アプリケーションの状態やアプリケーションとユーザーの状態が保持されているかどうかを特定できません。 たとえば、`Thread.Abort` を呼び出すと、静的コンストラクターがアンマネージリソースの解放を実行したり、解放したりするのを防ぐことができます。

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメソッドが呼び出された対象のスレッドで、そのスレッドの終了プロセスを開始する <see cref="T:System.Threading.ThreadAbortException" /> を発生させます。 このメソッドを呼び出すと、通常、スレッドが終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドがスレッドで呼び出されると、システムはスレッド内の <xref:System.Threading.ThreadAbortException> をスローして中止します。 `ThreadAbortException` は、アプリケーションコードでキャッチできる特殊な例外ですが、<xref:System.Threading.Thread.ResetAbort%2A> が呼び出されない限り、`catch` ブロックの最後に再スローされます。 `ResetAbort` は、中止の要求をキャンセルし、`ThreadAbortException` がスレッドを終了できないようにします。 Unexecuted `finally` ブロックは、スレッドが中止される前に実行されます。  
  
> [!NOTE]
>  スレッドがそれ自体で `Abort` を呼び出すと、その効果は例外をスローするのと似ています。<xref:System.Threading.ThreadAbortException> が直ちに発生し、結果は予測可能です。 ただし、あるスレッドが別のスレッドで `Abort` を呼び出した場合、abort は実行されているすべてのコードを中断します。 また、静的コンストラクターが中断される可能性もあります。 まれに、そのクラスのインスタンスがそのアプリケーションドメインで作成されない場合があります。 .NET Framework バージョン1.0 および1.1 では、`finally` ブロックの実行中にスレッドが中止される可能性があります。この場合、`finally` ブロックは中止されます。  
  
 スレッドはすぐに中止されるとは限りません。 この状況は、スレッドが中止プロシージャの一部として呼び出された `finally` ブロックで無制限の計算を実行した場合に発生する可能性があります。これにより、中止が無期限に遅延されます。 スレッドが中止されるまで待機するには、<xref:System.Threading.Thread.Abort%2A> メソッドを呼び出した後にスレッドで <xref:System.Threading.Thread.Join%2A> メソッドを呼び出すことができますが、待機が終了する保証はありません。  
  
> [!NOTE]
>  中断されているスレッドが、`catch` ブロック、`finally` ブロック、または制約された実行領域などのコードの保護された領域内にある場合、<xref:System.Threading.Thread.Abort%2A> を呼び出すスレッドがブロックする可能性があります。 <xref:System.Threading.Thread.Abort%2A> を呼び出すスレッドが、中止されたスレッドが必要とするロックを保持している場合、デッドロックが発生する可能性があります。  
  
 開始されていないスレッドで `Abort` が呼び出されると、<xref:System.Threading.Thread.Start%2A> が呼び出されたときにスレッドが中止されます。 ブロックされている、またはスリープ状態のスレッドで `Abort` が呼び出された場合、スレッドは中断されてから中止されます。  
  
 中断されたスレッドで `Abort` が呼び出されると、<xref:System.Threading.Thread.Abort%2A>を呼び出したスレッドで <xref:System.Threading.ThreadStateException> がスローされ、中止されるスレッドの <xref:System.Threading.Thread.ThreadState%2A> プロパティに <xref:System.Threading.ThreadState.AbortRequested> が追加されます。 <xref:System.Threading.Thread.Resume%2A> が呼び出されるまで、<xref:System.Threading.ThreadAbortException> は中断されたスレッドでスローされません。  
  
 アンマネージコードの実行中にマネージスレッドで `Abort` が呼び出された場合、そのスレッドがマネージコードに戻るまで、`ThreadAbortException` はスローされません。  
  
 `Abort` の2回の呼び出しが同時に発生した場合、1回の呼び出しで状態情報を設定し、もう一方の呼び出しで `Abort`を実行することができます。 ただし、アプリケーションでこの状況を検出することはできません。  
  
 スレッドで `Abort` が呼び出されると、スレッドの状態に <xref:System.Threading.ThreadState.AbortRequested>が含まれます。 `Abort`の呼び出しが成功した結果としてスレッドが終了すると、スレッドの状態が <xref:System.Threading.ThreadState.Stopped>に変更されます。 十分な権限を持っている場合、`Abort` のターゲットであるスレッドは、`ResetAbort` メソッドを使用して中止を取り消すことができます。 `ResetAbort` メソッドの呼び出しを示す例については、`ThreadAbortException` クラスを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core のみ: このメンバーはサポートされていません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">中止しようとしているスレッドが現在中断されています。</exception>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">スレッドの使用とスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">スレッドの破棄</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="stateInfo">中止するスレッドで使用できる、状態などのアプリケーション固有の情報を格納するオブジェクト。</param>
        <summary>このメソッドが呼び出された対象のスレッドで、スレッドの終了プロセスを開始する <see cref="T:System.Threading.ThreadAbortException" /> を発生させます。またスレッドの終了に関する例外情報も提供します。 このメソッドを呼び出すと、通常、スレッドが終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドがスレッドで呼び出されると、システムはスレッド内の <xref:System.Threading.ThreadAbortException> をスローして中止します。 `ThreadAbortException` は、アプリケーションコードでキャッチできる特殊な例外ですが、<xref:System.Threading.Thread.ResetAbort%2A> が呼び出されない限り、`catch` ブロックの最後に再スローされます。 `ResetAbort` は、中止の要求をキャンセルし、`ThreadAbortException` がスレッドを終了できないようにします。 Unexecuted `finally` ブロックは、スレッドが中止される前に実行されます。  
  
> [!NOTE]
>  スレッドがそれ自体で `Abort` を呼び出すと、その効果は例外をスローするのと似ています。<xref:System.Threading.ThreadAbortException> が直ちに発生し、結果は予測可能です。 ただし、あるスレッドが別のスレッドで `Abort` を呼び出した場合、abort は実行されているすべてのコードを中断します。 静的コンストラクターが中断される可能性があります。 まれに、そのクラスのインスタンスがそのアプリケーションドメインで作成されない場合があります。 .NET Framework バージョン1.0 および1.1 では、`finally` ブロックの実行中にスレッドが中止される可能性があります。この場合、`finally` ブロックは中止されます。  
  
 スレッドはすぐに中止されるとは限りません。 この状況は、スレッドが中止プロシージャの一部として呼び出された `finally` ブロックで無制限の計算を実行した場合に発生する可能性があります。これにより、中止が無期限に遅延されます。 スレッドが中止されるまで待機するには、<xref:System.Threading.Thread.Abort%2A> メソッドを呼び出した後にスレッドで <xref:System.Threading.Thread.Join%2A> メソッドを呼び出すことができますが、待機が終了する保証はありません。  
  
> [!NOTE]
>  中断されているスレッドが、`catch` ブロック、`finally` ブロック、または制約された実行領域などのコードの保護された領域内にある場合、<xref:System.Threading.Thread.Abort%2A> を呼び出すスレッドがブロックする可能性があります。 <xref:System.Threading.Thread.Abort%2A> を呼び出すスレッドが、中止されたスレッドが必要とするロックを保持している場合、デッドロックが発生する可能性があります。  
  
 開始されていないスレッドで `Abort` が呼び出されると、<xref:System.Threading.Thread.Start%2A> が呼び出されたときにスレッドが中止されます。 ブロックされている、またはスリープ状態のスレッドで `Abort` が呼び出された場合、スレッドは中断されてから中止されます。  
  
 中断されたスレッドで `Abort` が呼び出されると、<xref:System.Threading.Thread.Abort%2A>を呼び出したスレッドで <xref:System.Threading.ThreadStateException> がスローされ、中止されるスレッドの <xref:System.Threading.Thread.ThreadState%2A> プロパティに <xref:System.Threading.ThreadState.AbortRequested> が追加されます。 <xref:System.Threading.Thread.Resume%2A> が呼び出されるまで、<xref:System.Threading.ThreadAbortException> は中断されたスレッドでスローされません。  
  
 アンマネージコードの実行中にマネージスレッドで `Abort` が呼び出された場合、そのスレッドがマネージコードに戻るまで、`ThreadAbortException` はスローされません。  
  
 `Abort` の2回の呼び出しが同時に発生した場合、1回の呼び出しで状態情報を設定し、もう一方の呼び出しで `Abort`を実行することができます。 ただし、アプリケーションでこの状況を検出することはできません。  
  
 スレッドで `Abort` が呼び出されると、スレッドの状態に <xref:System.Threading.ThreadState.AbortRequested>が含まれます。 `Abort`の呼び出しが成功した結果としてスレッドが終了すると、スレッドの状態が <xref:System.Threading.ThreadState.Stopped>に変更されます。 十分な権限を持っている場合、`Abort` のターゲットであるスレッドは、`ResetAbort` メソッドを使用して中止を取り消すことができます。 `ResetAbort` メソッドの呼び出しを示す例については、`ThreadAbortException` クラスを参照してください。  
  
   
  
## Examples  
 次のコード例は、中断されているスレッドに情報を渡す方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core のみ: このメンバーはサポートされていません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">中止しようとしているスレッドが現在中断されています。</exception>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">スレッドの使用とスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">スレッドの破棄</related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>無名のデータ スロットをすべてのスレッドに割り当てます。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>すべてのスレッドに割り当てられた名前付きのデータ スロット。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッドローカルストレージ (TLS) を使用するための2つのメカニズムが用意されています。スレッド相対静的フィールド (つまり、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールド) とデータスロットです。 スレッド相対静的フィールドは、データスロットよりもはるかに優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。 TLS の使用の詳細については、「[スレッドローカルストレージ: スレッド相対静的フィールドとデータスロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)」を参照してください。  
  
 スロットはすべてのスレッドに割り当てられます。  
  
 スレッドは、ローカルストアのメモリ機構を使用して、スレッド固有のデータを格納します。 共通言語ランタイムは、作成時に各プロセスに複数スロットのデータストア配列を割り当てます。 スレッドは、データストアにデータスロットを割り当て、スロットにデータ値を格納して取得し、スレッドの有効期限が切れた後で再利用できるようにスロットを解放します。 データスロットはスレッドごとに一意です。 他のスレッド (子スレッドでもありません) は、そのデータを取得できません。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例では、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示します。 2番目の例では、データスロットを使用して同じ処理を行う方法を示します。  
  
 **最初の例**  
  
 次の例は、<xref:System.ThreadStaticAttribute> でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示しています。 この手法は、2番目の例に示す手法よりもパフォーマンスが優れています。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2番目の例**  
  
 データスロットを使用してスレッド固有の情報を格納する方法を次のコード例に示します。  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name">割り当てられるデータ スロットの名前。</param>
        <summary>名前付きのデータ スロットをすべてのスレッドに割り当てます。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>すべてのスレッドに割り当てられた名前付きのデータ スロット。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッドローカルストレージ (TLS) を使用するための2つのメカニズムが用意されています。スレッド相対静的フィールド (つまり、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールド) とデータスロットです。 スレッド相対静的フィールドは、データスロットよりもはるかに優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。 TLS の使用の詳細については、「[スレッドローカルストレージ: スレッド相対静的フィールドとデータスロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)」を参照してください。  
  
 スレッドは、ローカルストアのメモリ機構を使用して、スレッド固有のデータを格納します。 共通言語ランタイムは、作成時に各プロセスに複数スロットのデータストア配列を割り当てます。 スレッドは、データストアにデータスロットを割り当て、スロットにデータ値を格納して取得し、スレッドの有効期限が切れた後で再利用できるようにスロットを解放します。 データスロットはスレッドごとに一意です。 他のスレッド (子スレッドでもありません) は、そのデータを取得できません。  
  
 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> メソッドを使用して名前付きデータスロットを割り当てる必要はありません。これは、<xref:System.Threading.Thread.GetNamedDataSlot%2A> メソッドが割り当てられていない場合にスロットが割り当てられるためです。  
  
> [!NOTE]
>  <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> メソッドを使用する場合は、プログラムの起動時にメインスレッドで呼び出す必要があります。これは、指定した名前のスロットが既に割り当てられている場合に例外がスローされるためです。 スロットが既に割り当てられているかどうかをテストする方法はありません。  
  
 このメソッドで割り当てられたスロットは、<xref:System.Threading.Thread.FreeNamedDataSlot%2A>で解放する必要があります。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例では、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示します。 2番目の例では、データスロットを使用して同じ処理を行う方法を示します。  
  
 **最初の例**  
  
 次の例は、<xref:System.ThreadStaticAttribute> でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示しています。 この手法は、2番目の例に示す手法よりもパフォーマンスが優れています。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2番目の例**  
  
 次の例は、名前付きデータスロットを使用してスレッド固有の情報を格納する方法を示しています。  
  
> [!NOTE]
>  このコード例では、<xref:System.Threading.Thread.GetNamedDataSlot%2A> メソッドがまだ割り当てられていない場合にスロットを割り当てるため、<xref:System.Threading.Thread.AllocateNamedDataSlot%2A> メソッドは使用しません。 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> メソッドを使用する場合は、プログラムの起動時にメインスレッドで呼び出す必要があります。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された名前の名前付きデータ スロットは、すでに存在します。</exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このスレッドのアパートメント状態を取得または設定します。</summary>
        <value><see cref="T:System.Threading.ApartmentState" /> 値のいずれか 1 つです。 初期値は <see langword="Unknown" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **<xref:System.Threading.Thread.ApartmentState%2A> プロパティは互換性のために残されています。**  旧式ではない代替手段は、アパートメント状態を取得するための <xref:System.Threading.Thread.GetApartmentState%2A> メソッドと、アパートメント状態を設定するための <xref:System.Threading.Thread.SetApartmentState%2A> メソッドです。  
  
 .NET Framework バージョン1.0 および1.1 では、`ApartmentState` プロパティは、スレッドがシングルスレッドまたはマルチスレッドアパートメントで実行されることを示すようにマークします。 このプロパティは、スレッドが `Unstarted` または `Running` スレッド状態のときに設定できます。ただし、スレッドに対して設定できるのは1回だけです。 プロパティが設定されていない場合は、`Unknown`を返します。  
  
 <xref:System.Threading.Thread.ApartmentState%2A> プロパティを使用して、アパートメント状態が既に設定されているスレッドのアパートメント状態を設定しようとしましたが、無視されます。 ただし、この場合は、<xref:System.Threading.Thread.SetApartmentState%2A> メソッドによって <xref:System.InvalidOperationException> がスローされます。  
  
> [!IMPORTANT]
>  .NET Framework バージョン2.0 では、開始する前にアパートメント状態が設定されていない場合、新しいスレッドは <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> として初期化されます。 メインアプリケーションスレッドは、既定で <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> に初期化されます。 最初のコード行で <xref:System.Threading.ApartmentState?displayProperty=nameWithType> プロパティを設定することにより、メインアプリケーションスレッドを <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> に設定できなくなりました。 代わりに <xref:System.STAThreadAttribute> を使用してください。  
  
 .NET Framework バージョン2.0 では、 [/CLRTHREADATTRIBUTE (CLR スレッド属性の設定)](/cpp/build/reference/clrthreadattribute-set-clr-thread-attribute)リンカー C++オプションを使用して、アプリケーションの COM スレッドモデルを指定できます。  
  
   
  
## Examples  
 次のコード例は、スレッドのアパートメント状態を設定する方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このプロパティを、有効ではないアパートメント状態に設定しようとしました (シングル スレッド アパートメント (<see langword="STA" />) またはマルチ スレッド アパートメント (<see langword="MTA" />) 以外の状態)。</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>スレッドの中止または処理されない例外の影響によりアプリケーション ドメイン内の他のタスクが悪影響を受ける可能性があるコード領域に実行が入ることをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005 などの共通言語ランタイム (CLR) のホストは、コードの重要な領域や重要ではない領域のエラーに対してさまざまなポリシーを確立できます。 クリティカルな領域とは、スレッドの中止またはハンドルされない例外の影響が現在のタスクに限定されない場合があることです。 これに対し、クリティカルでないコード領域の中止または失敗は、エラーが発生したタスクにのみ影響します。  
  
 たとえば、ロックを保持しながらメモリの割り当てを試みるタスクを考えてみます。 メモリ割り当てが失敗した場合は、同じロックを待機している他のタスクがドメイン内に存在する可能性があるため、現在のタスクを中止するだけでは <xref:System.AppDomain>の安定性を確保することはできません。 現在のタスクが終了している場合は、他のタスクがデッドロックしている可能性があります。  
  
 重大なリージョンで障害が発生した場合、ホストは、不安定な状態で実行を継続するリスクを負うのではなく、<xref:System.AppDomain> 全体をアンロードすることになる可能性があります。 コードがクリティカルな領域に入ることをホストに通知するには、<xref:System.Threading.Thread.BeginCriticalRegion%2A>を呼び出します。 実行がコードの重要でない領域に戻るときに <xref:System.Threading.Thread.EndCriticalRegion%2A> を呼び出します。  
  
 SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最高のホスト保護レベルでコードを実行する必要があります。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Thread.BeginCriticalRegion%2A> メソッドと <xref:System.Threading.Thread.EndCriticalRegion%2A> メソッドを使用して、コードのブロックを重要な領域と重要でない領域に分割する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>マネージド コードが現在のオペレーティング システムの物理スレッドの ID に依存する命令の実行を開始することをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005 などの共通言語ランタイムの一部のホストには、独自のスレッド管理が用意されています。 独自のスレッド管理を提供するホストは、実行中のタスクを1つの物理オペレーティングシステムスレッドから別のシステムスレッドにいつでも移動できます。 ほとんどのタスクはこの切り替えの影響を受けません。 ただし、スレッドアフィニティがあるタスクもあります。つまり、オペレーティングシステムの物理スレッドの id によって異なります。 これらのタスクは、切り替える必要があるコードを実行するときに、ホストに通知する必要があります。  
  
 たとえば、アプリケーションがシステム API を呼び出して、Win32 CRITICAL_SECTION などのスレッドアフィニティを持つオペレーティングシステムロックを取得する場合は、ロックを取得する前に <xref:System.Threading.Thread.BeginThreadAffinity%2A> を呼び出し、ロックを解放した後で <xref:System.Threading.Thread.EndThreadAffinity%2A> する必要があります。  
  
 SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最高のホスト保護レベルでコードを実行する必要があります。  
  
   
  
## Examples  
 次の例は、<xref:System.Threading.Thread.BeginThreadAffinity%2A> および <xref:System.Threading.Thread.EndThreadAffinity%2A> メソッドを使用して、コードのブロックが物理オペレーティングシステムのスレッドの id に依存することをホストに通知する方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドが実行されている現在のコンテキストを取得します。</summary>
        <value>現在のスレッド コンテキストを表す <see cref="T:System.Runtime.Remoting.Contexts.Context" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドのカルチャを取得または設定します。</summary>
        <value>現在のスレッドでカルチャを表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される <xref:System.Globalization.CultureInfo> オブジェクトは、関連付けられたオブジェクトと共に、日付、時刻、数値、通貨値、テキストの並べ替え順序、大文字小文字の表記規則、および文字列比較の既定の形式を決定します。 カルチャの名前と識別子、インバリアント、ニュートラル、および特定のカルチャの違い、およびカルチャ情報がスレッドとアプリケーションドメインに与える影響については、<xref:System.Globalization.CultureInfo> クラスを参照してください。 スレッドの既定のカルチャがどのように決定されるか、およびユーザーのコンピューターのカルチャ情報を設定する方法については、<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> プロパティを参照してください。  

> [!IMPORTANT]
> 現在のスレッド以外のスレッドで使用する場合、<xref:System.Threading.Thread.CurrentCulture> プロパティは確実に動作しません。 .NET Framework では、プロパティの読み取りは信頼できますが、現在のスレッド以外のスレッドに対して設定することは可能です。 .NET Core では、スレッドが別のスレッドで <xref:System.Threading.Thread.CurrentCulture> プロパティの読み取りまたは書き込みを行おうとすると、<xref:System.InvalidOperationException> がスローされます。
> 現在のカルチャを取得して設定するには、<xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> プロパティを使用することをお勧めします。

 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、<xref:System.Threading.Thread.CurrentCulture%2A> プロパティをニュートラルカルチャに設定できます。 これは、<xref:System.Globalization.CultureInfo> クラスの動作が変更されたためです。ニュートラルカルチャを表す場合、そのプロパティ値 (特に、<xref:System.Globalization.CultureInfo.Calendar%2A>、<xref:System.Globalization.CultureInfo.CompareInfo%2A>、<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>、<xref:System.Globalization.CultureInfo.NumberFormat%2A>、および <xref:System.Globalization.CultureInfo.TextInfo%2A> の各プロパティ) は、ニュートラルカルチャに関連付けられている特定のカルチャを反映するようになりました。 以前のバージョンの .NET Framework では、<xref:System.Threading.Thread.CurrentCulture%2A> プロパティは、ニュートラルカルチャが割り当てられたときに <xref:System.NotSupportedException> 例外をスローしました。  
  
## Examples  
 次の例は、Windows フォームアプリケーションのユーザーインターフェイスを、コントロールパネルで設定されているカルチャで表示できるようにするスレッドステートメントを示しています。 追加のコードが必要です。  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">プロパティが <see langword="null" /> に設定されています。</exception>
        <exception cref="T:System.InvalidOperationException">.NET Core のみ: 別のスレッドからのスレッドのカルチャの読み取りまたは書き込みはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ロールベースのセキュリティに関する、スレッドの現在のプリンシパルを取得または設定します。</summary>
        <value>セキュリティ コンテキストを表す <see cref="T:System.Security.Principal.IPrincipal" /> 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、スレッドのプリンシパルを設定および取得する方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、プリンシパルを設定するために必要なアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行中のスレッドを取得します。</summary>
        <value>現在実行中のスレッドを表す <see cref="T:System.Threading.Thread" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、20個の子タスクを作成するタスクを作成します。 アプリケーション自体と各タスクは、`ShowThreadInformation` メソッドを呼び出します。このメソッドは、<xref:System.Threading.Thread.CurrentThread%2A> プロパティを使用して、実行されているスレッドに関する情報を表示します。  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 各子タスクは、1 ~ 100万の範囲で100万の乱数を生成し、その平均値を返します。 親タスクは、<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> メソッドを呼び出して、各タスクによって返される平均値を表示し、平均値を計算する前に、子タスクが完了したことを確認します。  
  
 アプリケーションがフォアグラウンドスレッドで実行されている間、各タスクはスレッドプールのスレッドで実行されることに注意してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実行時にカルチャ固有のリソースを検索するためにリソース マネージャーで使用される、現在のカルチャを取得または設定します。</summary>
        <value>現在のカルチャを表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 UI カルチャは、ユーザーの入力と出力をサポートするためにアプリケーションが必要とするリソースを指定します。既定では、オペレーティングシステムのカルチャと同じです。 カルチャの名前と識別子、インバリアント、ニュートラル、および特定のカルチャの違い、およびカルチャ情報がスレッドとアプリケーションドメインに与える影響については、<xref:System.Globalization.CultureInfo> クラスを参照してください。 スレッドの既定の UI カルチャがどのように決定されるかについては、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> プロパティを参照してください。  

> [!IMPORTANT]
> 現在のスレッド以外のスレッドで使用する場合、<xref:System.Threading.Thread.CurrentUICulture> プロパティは確実に動作しません。 .NET Framework では、プロパティの読み取りは信頼できますが、現在のスレッド以外のスレッドに対して設定することは可能です。 .NET Core では、スレッドが別のスレッドで <xref:System.Threading.Thread.CurrentUICulture> プロパティの読み取りまたは書き込みを行おうとすると、<xref:System.InvalidOperationException> がスローされます。
> 現在のカルチャを取得して設定するには、<xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> プロパティを使用することをお勧めします。

 このプロパティによって返される <xref:System.Globalization.CultureInfo> は、ニュートラルカルチャにすることができます。 ニュートラルカルチャは、<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>、<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>、<xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>などの書式指定メソッドでは使用しないでください。 <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> メソッドを使用して特定のカルチャを取得するか、<xref:System.Threading.Thread.CurrentCulture%2A> プロパティを使用します。  
  
> [!NOTE]
>  <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> メソッドは、ニュートラルカルチャ "zh-tw-Zh-hant" ("zh-tw") と "zh-tw-Hans" ("zh-tw-CHS") に対して <xref:System.ArgumentException> をスローします。  
  
   
  
## Examples  
 次の例では、現在のスレッドの UI カルチャの言語がフランス語であるかどうかを判断します。 そうでない場合は、現在のスレッドの UI カルチャを英語 (米国) に設定します。  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 次のコード例は、Windows フォームのユーザーインターフェイスをコントロールパネルで設定されているカルチャで表示できるようにするスレッドステートメントを示しています。 追加のコードが必要です。  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">プロパティが <see langword="null" /> に設定されています。</exception>
        <exception cref="T:System.ArgumentException">プロパティが、リソース ファイルの検索に使用できないカルチャ名に設定されています。 リソース ファイル名に使用できるのは、文字、数字、ハイフン、またはアンダースコアのみです。</exception>
        <exception cref="T:System.InvalidOperationException">.NET Core のみ: 別のスレッドからのスレッドのカルチャの読み取りまたは書き込みはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのランタイム呼び出し可能ラッパー (RCW: Runtime Callable Wrapper) の自動クリーンアップをオフにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、共通言語ランタイム (CLR) はランタイム呼び出し可能ラッパーを自動的にクリーンアップします。 CLR はクリーンアップ中にメッセージをポンプするため、次のような通常とは異なる条件を満たす少数のアプリケーションに対して再入の問題が発生する可能性があります。  
  
-   アプリケーションは、独自のメッセージポンプを行います。  
  
-   アプリケーションは、メッセージポンプがいつ発生するかを正確に制御する必要があります。  
  
 このようなアプリケーションでは、<xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> メソッドを使用して、CLR がランタイム呼び出し可能ラッパーを自動再生できないようにすることができます。  
  
 スレッドでこのメソッドが呼び出されると、そのスレッドに対して自動クリーンアップを再び有効にすることはできません。 アプリケーションでランタイム呼び出し可能ラッパーをクリーンアップする準備ができたら、<xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> メソッドを使用して、現在のコンテキストのすべてのランタイム呼び出し可能ラッパーをクリーンアップするようにランタイムに指示します。 メッセージポンプは、メソッドの実行中に発生します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>スレッドの中止または処理されない例外の影響が現在のタスクだけに及ぶコード領域に実行が入ることをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005 などの共通言語ランタイム (CLR) のホストは、コードの重要な領域や重要ではない領域のエラーに対してさまざまなポリシーを確立できます。 クリティカルな領域とは、スレッドの中止またはハンドルされない例外の影響が現在のタスクに限定されない場合があることです。 これに対し、クリティカルでないコード領域の中止または失敗は、エラーが発生したタスクにのみ影響します。  
  
 たとえば、ロックを保持しながらメモリの割り当てを試みるタスクを考えてみます。 メモリ割り当てが失敗した場合は、同じロックを待機している他のタスクがドメイン内に存在する可能性があるため、現在のタスクを中止するだけでは <xref:System.AppDomain>の安定性を確保することはできません。 現在のタスクが終了している場合は、他のタスクがデッドロックしている可能性があります。  
  
 重大なリージョンで障害が発生した場合、ホストは、不安定な状態で実行を継続するリスクを負うのではなく、<xref:System.AppDomain> 全体をアンロードすることになる可能性があります。 コードがクリティカルな領域に入ることをホストに通知するには、<xref:System.Threading.Thread.BeginCriticalRegion%2A>を呼び出します。 実行がコードの重要でない領域に戻るときに <xref:System.Threading.Thread.EndCriticalRegion%2A> を呼び出します。  
  
 SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最高のホスト保護レベルでコードを実行する必要があります。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Thread.BeginCriticalRegion%2A> メソッドと <xref:System.Threading.Thread.EndCriticalRegion%2A> メソッドを使用して、コードのブロックを重要な領域と重要でない領域に分割する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>マネージド コードが現在のオペレーティング システムの物理スレッドの ID に依存する命令の実行を完了したことをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005 などの共通言語ランタイムの一部のホストには、独自のスレッド管理が用意されています。 独自のスレッド管理を提供するホストは、実行中のタスクを1つの物理オペレーティングシステムスレッドから別のシステムスレッドにいつでも移動できます。 ほとんどのタスクはこの切り替えの影響を受けません。 ただし、スレッドアフィニティがあるタスクもあります。つまり、オペレーティングシステムの物理スレッドの id によって異なります。 これらのタスクは、切り替える必要があるコードを実行するときに、ホストに通知する必要があります。  
  
 たとえば、アプリケーションがシステム API を呼び出して、Win32 CRITICAL_SECTION などのスレッドアフィニティを持つオペレーティングシステムロックを取得する場合は、ロックを取得する前に <xref:System.Threading.Thread.BeginThreadAffinity%2A> を呼び出し、ロックを解放した後で <xref:System.Threading.Thread.EndThreadAffinity%2A> する必要があります。  
  
 SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最高のホスト保護レベルでコードを実行する必要があります。  
  
   
  
## Examples  
 次の例は、<xref:System.Threading.Thread.BeginThreadAffinity%2A> および <xref:System.Threading.Thread.EndThreadAffinity%2A> メソッドを使用して、コードのブロックが物理オペレーティングシステムのスレッドの id に依存することをホストに通知する方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドのさまざまなコンテキストに関する情報を格納する <see cref="T:System.Threading.ExecutionContext" /> オブジェクトを取得します。</summary>
        <value>現在のスレッドのコンテキスト情報を統合する <see cref="T:System.Threading.ExecutionContext" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ExecutionContext> クラスは、実行の論理スレッドに関連するすべての情報に対して1つのコンテナーを提供します。 これには、セキュリティコンテキスト、呼び出しコンテキスト、同期コンテキスト、ローカリゼーションコンテキスト、およびトランザクションコンテキストが含まれます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ガベージ コレクターが <see cref="T:System.Threading.Thread" /> オブジェクトを再利用しているときに、リソースが解放され、他のクリーンアップ操作が確実に実行されるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在のオブジェクトを完了する準備が整うと、ガベージコレクターは <xref:System.Threading.Thread.Finalize%2A> を呼び出します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name">解放されるデータ スロットの名前。</param>
        <summary>プロセス内のすべてのスレッドに関して、名前とスロットの関連付けを解除します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッドローカルストレージ (TLS) を使用するための2つのメカニズムが用意されています。スレッド相対静的フィールド (つまり、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールド) とデータスロットです。 スレッド相対静的フィールドは、データスロットよりもはるかに優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。 TLS の使用の詳細については、「[スレッドローカルストレージ: スレッド相対静的フィールドとデータスロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)」を参照してください。  
  
 任意のスレッドが `FreeNamedDataSlot`を呼び出すと、同じ名前の <xref:System.Threading.Thread.GetNamedDataSlot%2A> を呼び出す他のスレッドは、その名前に関連付けられた新しいスロットを割り当てます。 その後、任意のスレッドによって `GetNamedDataSlot` を呼び出すと、新しいスロットが返されます。 ただし、以前の `GetNamedDataSlot` の呼び出しによって返された <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> を持つスレッドは、引き続き古いスロットを使用できます。  
  
 名前に関連付けられているスロットは、`FreeNamedDataSlot` の呼び出しの前に取得されたすべての `LocalDataStoreSlot` が解放され、ガベージコレクトされた場合にのみ解放されます。  
  
 スレッドは、ローカルストアのメモリ機構を使用して、スレッド固有のデータを格納します。 共通言語ランタイムは、作成時に各プロセスに複数スロットのデータストア配列を割り当てます。 スレッドは、データストアにデータスロットを割り当て、スロットにデータ値を格納して取得し、スレッドの有効期限が切れた後で再利用できるようにスロットを解放します。 データスロットはスレッドごとに一意です。 他のスレッド (子スレッドでもありません) は、そのデータを取得できません。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例では、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示します。 2番目の例では、データスロットを使用して同じ処理を行う方法を示します。  
  
 **最初の例**  
  
 次の例は、<xref:System.ThreadStaticAttribute> でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示しています。 この手法は、2番目の例に示す手法よりもパフォーマンスが優れています。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2番目の例**  
  
 次の例は、名前付きデータスロットを使用してスレッド固有の情報を格納する方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アパートメント状態を示す <see cref="T:System.Threading.ApartmentState" /> 値を返します。</summary>
        <returns>マネージド スレッドのアパートメント状態を示す <see cref="T:System.Threading.ApartmentState" /> 値の 1 つ。 既定では、 <see cref="F:System.Threading.ApartmentState.Unknown" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドと共に、<xref:System.Threading.Thread.SetApartmentState%2A> メソッドと <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドを使用して、<xref:System.Threading.Thread.ApartmentState%2A> プロパティを置き換えます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Threading.Thread.GetApartmentState%2A>、<xref:System.Threading.Thread.SetApartmentState%2A>、および <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドを示しています。 このコード例では、スレッドを作成します。 スレッドが開始される前に、<xref:System.Threading.Thread.GetApartmentState%2A> は初期の <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> の状態を表示し、<xref:System.Threading.Thread.SetApartmentState%2A> 状態を <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>に変更します。 <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドは、アパートメント状態が既に設定されているために状態を <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> に変更しようとしたときに `false` を返します。 <xref:System.Threading.Thread.SetApartmentState%2A>で同じ操作が試行された場合、<xref:System.InvalidOperationException> がスローされます。  
  
 スレッドが開始されると、<xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドが再び使用されます。 今回は、スレッドが既に開始されているため <xref:System.Threading.ThreadStateException> をスローします。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのスタックをキャプチャするために使用できる <see cref="T:System.Threading.CompressedStack" /> オブジェクトを返します。</summary>
        <returns>[なし]。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはサポートされなくなりました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">すべての場合。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドが実行されているプロセッサを示すために使用される ID を取得します。</summary>
        <returns>キャッシュされたプロセッサ ID を表す整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

この値はキャッシュされ、定期的に更新されます。 使用された時間によって古くなっている可能性があります。コードを使用する場合、正確性に依存しないようにする必要があります。

値は、0から始まるプロセッサ番号であることは保証されていません。

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="slot">値の取得元の <see cref="T:System.LocalDataStoreSlot" />。</param>
        <summary>現在のスレッドの現在のドメイン内で指定した現在のスレッドのスロットから値を取得します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>取得された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッドローカルストレージ (TLS) を使用するための2つのメカニズムが用意されています。スレッド相対静的フィールド (つまり、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールド) とデータスロットです。 スレッド相対静的フィールドは、データスロットよりもはるかに優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。 TLS の使用の詳細については、「[スレッドローカルストレージ: スレッド相対静的フィールドとデータスロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)」を参照してください。  
  
 スレッドは、ローカルストアのメモリ機構を使用して、スレッド固有のデータを格納します。 共通言語ランタイムは、作成時に各プロセスに複数スロットのデータストア配列を割り当てます。 スレッドは、データストアにデータスロットを割り当て、スロットにデータ値を格納して取得し、スレッドの有効期限が切れた後で再利用できるようにスロットを解放します。 データスロットはスレッドごとに一意です。 他のスレッド (子スレッドでもありません) は、そのデータを取得できません。  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> は、別のスレッドを参照する変数を使用して呼び出した場合でも、常に現在実行中のスレッドに適用される `Shared` メソッドです。 混乱を避けるために、`Shared` メソッドを呼び出すときにクラス名を使用します: `Dim test As Object = Thread.GetData(testSlot)`。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例では、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示します。 2番目の例では、データスロットを使用して同じ処理を行う方法を示します。  
  
 **最初の例**  
  
 次の例は、<xref:System.ThreadStaticAttribute> でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示しています。 この手法は、2番目の例に示す手法よりもパフォーマンスが優れています。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2番目の例**  
  
 次の例は、データスロットを使用してスレッド固有の情報を格納する方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドが実行されている現在のドメインを返します。</summary>
        <returns>実行中のスレッドの現在のアプリケーション ドメインを表す <see cref="T:System.AppDomain" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、スレッドが実行されている `AppDomain` の名前と ID を取得する方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>一意のアプリケーション ドメイン識別子を返します。</summary>
        <returns>アプリケーション ドメインを一意に識別する 32 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、スレッドが実行されている `AppDomain` の名前と ID を取得する方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのハッシュ コードを返します。</summary>
        <returns>整数ハッシュ コード値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハッシュコードが一意であることは保証されていません。 マネージスレッドの一意の識別子が必要な場合は、<xref:System.Threading.Thread.ManagedThreadId%2A> プロパティを使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name">ローカル データ スロットの名前。</param>
        <summary>名前付きデータ スロットを検索します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>このスレッドに割り当てられた <see cref="T:System.LocalDataStoreSlot" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッドローカルストレージ (TLS) を使用するための2つのメカニズムが用意されています。スレッド相対静的フィールド (つまり、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールド) とデータスロットです。 スレッド相対静的フィールドは、データスロットよりもはるかに優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。 TLS の使用の詳細については、「[スレッドローカルストレージ: スレッド相対静的フィールドとデータスロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)」を参照してください。  
  
 スレッドは、ローカルストアのメモリ機構を使用して、スレッド固有のデータを格納します。 共通言語ランタイムは、作成時に各プロセスに複数スロットのデータストア配列を割り当てます。 スレッドは、データストアにデータスロットを割り当て、スロットにデータ値を格納して取得し、スレッドの有効期限が切れた後で再利用できるようにスロットを解放します。 データスロットはスレッドごとに一意です。 他のスレッド (子スレッドでもありません) は、そのデータを取得できません。  
  
 名前付きスロットが存在しない場合は、新しいスロットが割り当てられます。 名前付きデータスロットはパブリックであり、だれでも操作できます。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例では、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示します。 2番目の例では、データスロットを使用して同じ処理を行う方法を示します。  
  
 **最初の例**  
  
 次の例は、<xref:System.ThreadStaticAttribute> でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示しています。 この手法は、2番目の例に示す手法よりもパフォーマンスが優れています。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2番目の例**  
  
 次の例は、名前付きデータスロットを使用してスレッド固有の情報を格納する方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="F:System.Threading.ThreadState.WaitSleepJoin" /> スレッド状態のスレッドを中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このスレッドが現在待機中、スリープ状態、または参加状態でブロックされていない場合は、次にブロックが開始されると中断されます。  
  
 <xref:System.Threading.ThreadInterruptedException> は、中断されたスレッドでスローされますが、スレッドがブロックされるまではスローされません。 スレッドがブロックされない場合、例外はスローされないため、スレッドは中断されることなく完了する可能性があります。  
  
   
  
## Examples  
 次のコード例は、実行中のスレッドが中断され、その後ブロックされた場合の動作を示しています。  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に適切な <see cref="T:System.Security.Permissions.SecurityPermission" /> がありません。</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">スレッドの一時中断および中断</related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドの実行ステータスを示す値を取得します。</summary>
        <value>このスレッドが起動していて、正常終了しておらず中止されてもいない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドがバックグラウンド スレッドであるかどうかを示す値を取得または設定します。</summary>
        <value>このスレッドがバックグラウンド スレッドである場合またはバックグラウンド スレッドになる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドは、バックグラウンドスレッドまたはフォアグラウンドスレッドのいずれかです。 バックグラウンドスレッドは、プロセスが終了しないようにすることを除けば、フォアグラウンドスレッドと同じです。 プロセスに属するすべてのフォアグラウンドスレッドが終了すると、共通言語ランタイムによってプロセスが終了します。 残りのバックグラウンドスレッドは停止され、完了しません。  
  
 既定では、次のスレッドはフォアグラウンドで実行されます (つまり、<xref:System.Threading.Thread.IsBackground%2A> プロパティが `false`を返します)。  
  
-   プライマリスレッド (またはメインアプリケーションスレッド)。  
  
-   <xref:System.Threading.Thread> クラスコンストラクターを呼び出すことによって作成されるすべてのスレッド。  
  
 既定では、次のスレッドがバックグラウンドで実行されます (つまり、<xref:System.Threading.Thread.IsBackground%2A> のプロパティが `true`を返します)。  
  
-   スレッドプールスレッド。ランタイムによって管理されるワーカースレッドのプールです。 スレッドプールを構成し、<xref:System.Threading.ThreadPool> クラスを使用してスレッドプールスレッドの作業をスケジュールすることができます。  
  
    > [!NOTE]
    >  スレッドプールのスレッドでは、タスクベースの非同期操作が自動的に実行されます。  
  
-   アンマネージコードからマネージ実行環境に入るすべてのスレッド。  
  
   
  
## Examples  
 次の例では、フォアグラウンドスレッドとバックグラウンドスレッドの動作を比較しています。 このメソッドは、フォアグラウンドスレッドとバックグラウンドスレッドを作成します。 フォアグラウンドスレッドは、`for` ループを完了して終了するまでプロセスを実行したままにします。 ただし、この例の出力に示されているように、フォアグラウンドスレッドの実行が完了したため、バックグラウンドスレッドの実行が完了する前にプロセスが終了します。  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが動作していません</exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md">フォアグラウンド スレッドとバックグラウンド スレッド</related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドがマネージド スレッド プールに所属しているかどうかを示す値を取得します。</summary>
        <value>このスレッドがマネージド スレッド プールに所属している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細について[は、「マネージスレッドプール](~/docs/standard/threading/the-managed-thread-pool.md)」を参照してください。  
  
   
  
## Examples  
 スレッドがスレッドプールからのものかどうかを確認する方法を次のコード例に示します。  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">マネージド スレッド プール</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスが表すスレッドが終了するまで、呼び出し元のスレッドをブロックします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスが表すスレッドが終了するまで、呼び出し元のスレッドをブロックします。標準 COM および <see langword="SendMessage" /> ポンピングの実行は継続されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A> は、<xref:System.Threading.Thread.Join%2A> メソッドが呼び出されたスレッドが完了するまで、呼び出し元のスレッド (つまり、メソッドを呼び出すスレッド) をブロックする同期メソッドです。 スレッドが終了したことを確認するには、このメソッドを使用します。 スレッドが終了しない場合、呼び出し元は無期限にブロックされます。 次の例では、`Thread1` スレッドが `Thread2`の <xref:System.Threading.Thread.Join> メソッドを呼び出します。これにより、`Thread2` が完了するまで `Thread1` がブロックされます。  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 <xref:System.Threading.Thread.Join%2A> が呼び出されたときにスレッドが既に終了している場合、メソッドはすぐに制御を戻します。  
  
> [!WARNING]
>  現在のスレッドの現在のスレッドを表す <xref:System.Threading.Thread> オブジェクトの <xref:System.Threading.Thread.Join%2A> メソッドを呼び出さないでください。 これにより、現在のスレッドが無期限に待機しているため、アプリが応答しなくなることがあります。  
  
 このメソッドは、呼び出し元のスレッドの状態を変更して <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>を含めます。 <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 状態のスレッドで `Join` を呼び出すことはできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">呼び出し元が、<see cref="F:System.Threading.ThreadState.Unstarted" /> 状態のスレッドを結合しようとしました。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">待機中にスレッドが中断されました。</exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">スレッドが終了するまでの待機時間を表すミリ秒数。</param>
        <summary>このインスタンスが表すスレッドが終了するまで、または指定された時間が経過するまで、呼び出し元のスレッドをブロックします。標準 COM/SendMessage ポンピングの実行は継続されます。</summary>
        <returns>スレッドが終了した場合は <see langword="true" />。<see langword="false" /> パラメーターで指定した時間が経過してもスレッドが終了していない場合は <paramref name="millisecondsTimeout" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29> は、<xref:System.Threading.Thread.Join%2A> メソッドが呼び出されたスレッドが完了するか、タイムアウト間隔が経過するまで、呼び出し元のスレッド (つまり、メソッドを呼び出すスレッド) をブロックする同期メソッドです。 次の例では、`Thread1` スレッドが `Thread2`の <xref:System.Threading.Thread.Join> メソッドを呼び出します。これにより、`Thread2` が完了するか、2秒が経過するまで、`Thread1` がブロックされます。  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 `millisecondsTimeout` パラメーターに <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> が指定されている場合、このメソッドは、戻り値を除き、<xref:System.Threading.Thread.Join> メソッドのオーバーロードと同じように動作します。  
  
 <xref:System.Threading.Thread.Join%2A> が呼び出されたときにスレッドが既に終了している場合、メソッドはすぐに制御を戻します。  
  
 このメソッドは、呼び出し元のスレッドの状態を変更して <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>を含めます。 <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 状態のスレッドで `Join` を呼び出すことはできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> の値が負の値であり、<see cref="F:System.Threading.Timeout.Infinite" /> (ミリ秒単位) と等しくありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドは開始していません。</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <exception cref="T:System.ArgumentException"><paramref name="millisecondsTimeout" /> は -1 未満です (Timeout.Infinite)。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">待機中にスレッドが中断されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="timeout">スレッドが終了するのを待機する時間に設定される <see cref="T:System.TimeSpan" />。</param>
        <summary>このインスタンスが表すスレッドが終了するまで、または指定された時間が経過するまで、呼び出し元のスレッドをブロックします。標準 COM/SendMessage ポンピングの実行は継続されます。</summary>
        <returns>スレッドが終了した場合は <see langword="true" />。<see langword="false" /> パラメーターで指定した時間が経過してもスレッドが終了していない場合は <paramref name="timeout" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29> は、<xref:System.Threading.Thread.Join%2A> メソッドが呼び出されたスレッドが完了するか、タイムアウト間隔が経過するまで、呼び出し元のスレッド (つまり、メソッドを呼び出すスレッド) をブロックする同期メソッドです。 次の例では、`Thread1` スレッドが `Thread2`の <xref:System.Threading.Thread.Join> メソッドを呼び出します。これにより、`Thread2` が完了するか、2秒が経過するまで、`Thread1` がブロックされます。  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 `timeout`に対して <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> が指定されている場合、このメソッドは、戻り値を除き、<xref:System.Threading.Thread.Join> メソッドのオーバーロードと同じように動作します。  
  
 <xref:System.Threading.Thread.Join%2A> が呼び出されたときにスレッドが既に終了している場合、メソッドはすぐに制御を戻します。  
  
 このメソッドは、現在のスレッドの状態を変更して <xref:System.Threading.ThreadState.WaitSleepJoin>を含めます。 <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 状態のスレッドで `Join` を呼び出すことはできません。  
  
   
  
## Examples  
 次のコード例は、`Join` メソッドで `TimeSpan` 値を使用する方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> の値が負の値で、<see cref="F:System.Threading.Timeout.Infinite" /> (ミリ秒単位) と等しくないか、または <see cref="F:System.Int32.MaxValue" /> ミリ秒を超えています。</exception>
        <exception cref="T:System.Threading.ThreadStateException">呼び出し元が、<see cref="F:System.Threading.ThreadState.Unstarted" /> 状態のスレッドを結合しようとしました。</exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のマネージド スレッドの一意の識別子を取得します。</summary>
        <value>このマネージド スレッドの一意の識別子を表す整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドの <xref:System.Threading.Thread.ManagedThreadId%2A> プロパティ値は、プロセス内でそのスレッドを一意に識別するために機能します。  
  
 共通言語ランタイムをホストするアンマネージコードでは、スレッドがファイバーとして実装されている場合でも、<xref:System.Threading.Thread.ManagedThreadId%2A> プロパティの値は時間の経過と共に変化しません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メモリ アクセスを同期します。現在のスレッドを実行中のプロセッサは、<see cref="M:System.Threading.Thread.MemoryBarrier" /> を呼び出す前のメモリ アクセスを <see cref="M:System.Threading.Thread.MemoryBarrier" /> の呼び出し後のメモリ アクセスより後に実行するように命令を並べ替えることはできなくなります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A> は、メモリの順序が脆弱なマルチプロセッサシステム (たとえば、複数の Intel Itanium プロセッサを使用するシステム) にのみ必要です。  
  
 ほとんどの場合、 C# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、または <xref:System.Threading.Monitor> クラスを使用すると、データを簡単に同期できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドの名前を取得または設定します。</summary>
        <value>スレッドの名前を含む文字列。名前が設定されていない場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは1回だけ書き込まれます。 スレッドの <xref:System.Threading.Thread.Name%2A> プロパティの既定値は `null`ので、`null`と比較することによって、既に名前がスレッドに割り当てられているかどうかを確認できます。  
  
 <xref:System.Threading.Thread.Name%2A> プロパティに割り当てられた文字列には、任意の Unicode 文字を含めることができます。  
  
   
  
## Examples  
 次の例は、スレッドに名前を指定する方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">設定操作が要求されましたが、<see langword="Name" /> プロパティは既に設定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドのスケジューリング優先順位を示す値を取得または設定します。</summary>
        <value><see cref="T:System.Threading.ThreadPriority" /> 値のいずれか 1 つです。 既定値は <see cref="F:System.Threading.ThreadPriority.Normal" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドには、次のいずれかの優先順位 <xref:System.Threading.ThreadPriority> 値を割り当てることができます。  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 オペレーティングシステムは、スレッドの優先順位に従う必要はありません。  
  
   
  
## Examples  
 次の例は、スレッドの優先度を変更した結果を示しています。 3つのスレッドが作成され、1つのスレッドの優先度が <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>に設定され、2番目のスレッドの優先度が <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>に設定されます。 各スレッドは、`while` ループ内の変数をインクリメントし、設定された時間に実行します。  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが、<see cref="F:System.Threading.ThreadState.Aborted" /> などの最終状態に達しました。</exception>
        <exception cref="T:System.ArgumentException">セット操作に対して設定された値が有効な <see cref="T:System.Threading.ThreadPriority" /> 値ではありません。</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md">スレッドのスケジューリング</related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドに対して要求された <see cref="M:System.Threading.Thread.Abort(System.Object)" /> をキャンセルします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、適切なアクセス許可を持つコードによってのみ呼び出すことができます。  
  
 スレッドを終了するために `Abort` の呼び出しが行われると、システムによって <xref:System.Threading.ThreadAbortException>がスローされます。 `ThreadAbortException` は、アプリケーションコードでキャッチできる特殊な例外ですが、`ResetAbort` が呼び出されない限り、catch ブロックの最後に再スローされます。 `ResetAbort` は、中止の要求をキャンセルし、`ThreadAbortException` がスレッドを終了できないようにします。  
  
 `ResetAbort` メソッドの呼び出しを示す例については、「<xref:System.Threading.ThreadAbortException>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core のみ: このメンバーはサポートされていません。</exception>
        <exception cref="T:System.Threading.ThreadStateException"><see langword="Abort" /> は現在のスレッドで呼び出されませんでした。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元には、現在のスレッドに対する必要なセキュリティ アクセス許可がありません。</exception>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">スレッドの破棄</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>中断されたスレッドを再開します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Threading.Thread.Suspend%2A> メソッドと <xref:System.Threading.Thread.Resume%2A> メソッドを使用してスレッドの動作を同期しないでください。 スレッドを中断したときに実行されているコードを知ることはできません。 セキュリティアクセス許可の評価中にロックを保持している間にスレッドを中断した場合、<xref:System.AppDomain> 内の他のスレッドがブロックされることがあります。 クラスコンストラクターの実行中にスレッドを中断すると、そのクラスを使用しようとしている <xref:System.AppDomain> 内の他のスレッドがブロックされます。 デッドロックは非常に簡単に発生します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core のみ: このメンバーはサポートされていません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが開始されていないか、実行されていません。または中断状態にはありません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に適切な <see cref="T:System.Security.Permissions.SecurityPermission" /> がありません。</exception>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">スレッドの一時中断および中断</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="state">新しいアパートメント状態。</param>
        <summary>スレッドを開始する前にそのアパートメント状態を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アパートメント状態が開始前に設定されていない場合、新しいスレッドは <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> として初期化されます。 アパートメント状態は、スレッドを開始する前に設定する必要があります。  
  
> [!NOTE]
>  メインアプリケーションスレッドは、既定で <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> に初期化されます。 メインアプリケーションスレッドのアパートメント状態を <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> に設定する唯一の方法は、<xref:System.STAThreadAttribute> 属性をエントリポイントメソッドに適用することです。  
  
 <xref:System.Threading.Thread.SetApartmentState%2A> メソッドと、<xref:System.Threading.Thread.GetApartmentState%2A> メソッドおよび <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドを使用して、<xref:System.Threading.Thread.ApartmentState%2A> プロパティが置き換えられます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Threading.Thread.GetApartmentState%2A>、<xref:System.Threading.Thread.SetApartmentState%2A>、および <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドを示しています。 このコード例では、スレッドを作成します。 スレッドが開始される前に、<xref:System.Threading.Thread.GetApartmentState%2A> は初期の <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> の状態を表示し、<xref:System.Threading.Thread.SetApartmentState%2A> 状態を <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>に変更します。 <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドは、アパートメント状態が既に設定されているために状態を <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> に変更しようとしたときに `false` を返します。 <xref:System.Threading.Thread.SetApartmentState%2A>で同じ操作が試行された場合、<xref:System.InvalidOperationException> がスローされます。  
  
 スレッドが開始されると、<xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドが再び使用されます。 今回は、スレッドが既に開始されているため <xref:System.Threading.ThreadStateException> をスローします。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core のみ: macOS および Linux プラットフォームでは、このメンバーはサポートされていません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="state" /> は有効なアパートメント状態ではありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に開始されています。</exception>
        <exception cref="T:System.InvalidOperationException">アパートメント状態は、すでに初期化されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="stack">現在のスレッドに適用される <see cref="T:System.Threading.CompressedStack" /> オブジェクト。</param>
        <summary>キャプチャした <see cref="T:System.Threading.CompressedStack" /> を現在のスレッドに適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはサポートされなくなりました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">すべての場合。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="slot">値を設定する <see cref="T:System.LocalDataStoreSlot" />。</param>
        <param name="data">設定される値です。</param>
        <summary>現在実行中のスレッド上にある指定されたスロット内のデータを、そのスレッドの現在のドメインに設定します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッドローカルストレージ (TLS) を使用するための2つのメカニズムが用意されています。スレッド相対静的フィールド (つまり、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールド) とデータスロットです。 スレッド相対静的フィールドは、データスロットよりもはるかに優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。 TLS の使用の詳細については、「[スレッドローカルストレージ: スレッド相対静的フィールドとデータスロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)」を参照してください。  
  
 スレッドは、ローカルストアのメモリ機構を使用して、スレッド固有のデータを格納します。 共通言語ランタイムは、作成時に各プロセスに複数スロットのデータストア配列を割り当てます。 スレッドは、データストアにデータスロットを割り当て、スロットにデータ値を格納して取得します。また、スレッドプロシージャが終了し、<xref:System.Threading.Thread> オブジェクトがガベージコレクションによって回収された後で再利用できるようにスロットを解放します。 データスロットはスレッドごとに一意です。 他のスレッド (子スレッドでもありません) は、そのデータを取得できません。  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> は、別のスレッドを参照する変数を使用して呼び出した場合でも、常に現在実行中のスレッドに適用される `Shared` メソッドです。 混乱を避けるために、`Shared` メソッドを呼び出すときにクラス名を使用します: `Thread.SetData(testSlot, "test data")`。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例では、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示します。 2番目の例では、データスロットを使用して同じ処理を行う方法を示します。  
  
 **最初の例**  
  
 次の例は、<xref:System.ThreadStaticAttribute> でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示しています。 この手法は、2番目の例に示す手法よりもパフォーマンスが優れています。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2番目の例**  
  
 次の例は、名前付きデータスロットを使用してスレッド固有の情報を格納する方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した時間の長さにわたって現在のスレッドを中断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">スレッドが中断ブロックされるミリ秒数。 <paramref name="millisecondsTimeout" /> 引数の値が 0 である場合は、スレッドは自らのタイム スライスの残りの部分を放棄し、実行する準備ができている同じ優先順位の他のスレッドに渡します。 優先順位が同じで実行する準備ができている他のスレッドが存在しない場合は、現在のスレッドの実行は中断されません。</param>
        <summary>指定したミリ秒数の間現在のスレッドを中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドは、指定された時間だけオペレーティングシステムによって実行されるようにスケジュールされません。 このメソッドは、<xref:System.Threading.ThreadState.WaitSleepJoin>を含めるようにスレッドの状態を変更します。  
  
 `millisecondsTimeout` パラメーターの <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> を指定して、スレッドを無制限に中断することができます。 ただし、スレッドを同期したりリソースを管理したりするために、<xref:System.Threading.Mutex>、<xref:System.Threading.Monitor>、<xref:System.Threading.EventWaitHandle>、<xref:System.Threading.Semaphore> などの他の <xref:System.Threading?displayProperty=nameWithType> クラスを使用することをお勧めします。  
  
 クロック解像度と呼ばれる特定の速度でのシステムクロックティック。 指定されたタイムアウトはクロックティックと一致するように調整されるので、実際のタイムアウトは指定したタイムアウト値にならない可能性があります。 クロック解像度と待機時間の詳細については、「Windows システム Api の[スリープ機能](/windows/win32/api/synchapi/nf-synchapi-sleep)」を参照してください。  
  
 このメソッドでは、標準の COM および SendMessage ポンプは実行されません。  
  
> [!NOTE]
>  <xref:System.STAThreadAttribute>のあるスレッドでスリープする必要があり、標準の COM および SendMessage ポンプを実行する必要がある場合は、タイムアウト間隔を指定する <xref:System.Threading.Thread.Join%2A> メソッドのオーバーロードの1つを使用することを検討してください。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Thread.Sleep%2A> メソッドを使用して、アプリケーションのメインスレッドをブロックします。  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">タイムアウト値が負の値で、<see cref="F:System.Threading.Timeout.Infinite" /> に等しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">スレッドが中断される時間の長さ。 <paramref name="millisecondsTimeout" /> 引数の値が <see cref="F:System.TimeSpan.Zero" /> である場合は、スレッドは自らのタイム スライスの残りの部分を放棄し、実行する準備ができている同じ優先順位の他のスレッドに渡します。 優先順位が同じで実行する準備ができている他のスレッドが存在しない場合は、現在のスレッドの実行は中断されません。</param>
        <summary>指定した時間の長さにわたって現在のスレッドを中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドは、指定された時間だけオペレーティングシステムによって実行されるようにスケジュールされません。 このメソッドは、<xref:System.Threading.ThreadState.WaitSleepJoin>を含めるようにスレッドの状態を変更します。  
  
 `timeout` パラメーターの <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> を指定して、スレッドを無制限に中断することができます。 ただし、スレッドを同期したりリソースを管理したりするために、<xref:System.Threading.Mutex>、<xref:System.Threading.Monitor>、<xref:System.Threading.EventWaitHandle>、<xref:System.Threading.Semaphore> などの他の <xref:System.Threading?displayProperty=nameWithType> クラスを使用することをお勧めします。  
  
 <xref:System.Threading.Thread.Sleep%2A> のこのオーバーロードは、`timeout`の合計ミリ秒数を使用します。 ミリ秒の小数部は破棄されます。  
  
 このメソッドでは、標準の COM および SendMessage ポンプは実行されません。  
  
> [!NOTE]
>  <xref:System.STAThreadAttribute>のあるスレッドでスリープする必要があり、標準の COM および SendMessage ポンプを実行する必要がある場合は、タイムアウト間隔を指定する <xref:System.Threading.Thread.Join%2A> メソッドのオーバーロードの1つを使用することを検討してください。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> メソッドのオーバーロードを使用して、アプリケーションのメインスレッドを5回 (毎回2秒) ブロックします。  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> の値が負の値で、<see cref="F:System.Threading.Timeout.Infinite" /> (ミリ秒単位) と等しくないか、または <see cref="F:System.Int32.MaxValue" /> ミリ秒を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="iterations">スレッドが待機する時間を定義する 32 ビット符号付き整数。</param>
        <summary>スレッドが、<paramref name="iterations" /> パラメーターで定義される時間だけ待機するようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.SpinWait%2A> メソッドは、ロックを実装する場合に便利です。 <xref:System.Threading.Monitor> や <xref:System.Threading.ReaderWriterLock>などの .NET Framework のクラスは、このメソッドを内部で使用します。 <xref:System.Threading.Thread.SpinWait%2A>、`iterations` パラメーターによって指定されたループカウントを使用して、プロセッサを非常に短いループに配置します。 この待機時間は、プロセッサの速度によって異なります。  
  
 これを <xref:System.Threading.Thread.Sleep%2A> メソッドと比較します。 <xref:System.Threading.Thread.Sleep%2A> を呼び出すスレッドは、指定された間隔が0の場合でも、プロセッサ時間の残りの部分を生成します。 <xref:System.Threading.Thread.Sleep%2A> に0以外の間隔を指定すると、時間間隔が経過するまでスレッドスケジューラによる考慮からスレッドが削除されます。  
  
 通常のアプリケーションでは、<xref:System.Threading.Thread.SpinWait%2A> は一般には便利ではありません。 ほとんどの場合、.NET Framework によって提供される同期クラスを使用する必要があります。たとえば、<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> を呼び出すか、または <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (またはC# Visual Basic の `SyncLock` で`lock`) をラップするステートメントを呼び出します。  
  
> [!CAUTION]
>  状態の変化が近づいていることがわかっている場合などに、コンテキストの切り替えを避けることが有益な場合は、ループ内で <xref:System.Threading.Thread.SpinWait%2A> メソッドを呼び出す必要があります。 実行されるコード <xref:System.Threading.Thread.SpinWait%2A> は、複数のプロセッサを搭載したコンピューターで発生する可能性のある問題を回避するように設計されています。 たとえば、ハイパースレッディングテクノロジを採用している複数の Intel プロセッサを搭載したコンピューターでは、<xref:System.Threading.Thread.SpinWait%2A> によって、特定の状況でプロセッサが枯渇するのを防ぐことができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>スレッドの実行をスケジュールします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オペレーティング システムによって、現在のインスタンスの状態を <see cref="F:System.Threading.ThreadState.Running" /> に変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドが <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> 状態になると、オペレーティングシステムは実行のスケジュールを設定できます。 スレッドは、スレッドコンストラクターに渡された <xref:System.Threading.ThreadStart> または <xref:System.Threading.ParameterizedThreadStart> デリゲートによって表されるメソッドの最初の行で実行を開始します。 <xref:System.Threading.Thread.Start%2A> を呼び出すと、呼び出し元のスレッドがブロックされないことに注意してください。  
  
> [!NOTE]
>  このオーバーロードが <xref:System.Threading.ParameterizedThreadStart> デリゲートを使用して作成されたスレッドで使用されている場合、`null` はスレッドによって実行されるメソッドに渡されます。  
  
 スレッドが終了すると、`Start`の別の呼び出しで再起動することはできません。  
  
   
  
## Examples  
 次の例では、スレッドを作成して開始します。  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に開始されています。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリ不足のため、このスレッドを開始できません。</exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">スレッドを作成し、開始時にデータを渡す</related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="parameter">スレッドが実行するメソッドで使用するデータを格納するオブジェクト。</param>
        <summary>オペレーティング システムによって現在のインスタンスの状態が <see cref="F:System.Threading.ThreadState.Running" /> に変更され、オプションでスレッドが実行するメソッドで使用するデータを格納するオブジェクトが提供されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドが <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> 状態になると、オペレーティングシステムは実行のスケジュールを設定できます。 スレッドは、スレッドコンストラクターに渡された <xref:System.Threading.ThreadStart> または <xref:System.Threading.ParameterizedThreadStart> デリゲートによって表されるメソッドの最初の行で実行を開始します。 <xref:System.Threading.Thread.Start%2A> を呼び出すと、呼び出し元のスレッドがブロックされないことに注意してください。  
  
 スレッドが終了すると、`Start`の別の呼び出しで再起動することはできません。  
  
 このオーバーロードと <xref:System.Threading.ParameterizedThreadStart> デリゲートを使用すると、スレッドプロシージャにデータを簡単に渡すことができますが、どのオブジェクトもこのオーバーロードに渡すことができるため、この手法はタイプセーフではありません。 スレッドプロシージャにデータを渡すより堅牢な方法は、スレッドプロシージャとデータフィールドの両方をワーカーオブジェクトに配置することです。 詳細については、「[開始時にスレッドを作成してデータを渡す](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、静的メソッドとインスタンスメソッドを使用して <xref:System.Threading.ParameterizedThreadStart> デリゲートを作成します。  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に開始されています。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリ不足のため、このスレッドを開始できません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Threading.ThreadStart" /> デリゲートの代わりに <see cref="T:System.Threading.ParameterizedThreadStart" /> デリゲートを使用して、このスレッドは作成されました。</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">スレッドの作成</related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>スレッドを中断します。スレッドが既に中断されている場合は無効です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドが既に中断されている場合、このメソッドによる影響はありません。  
  
> [!CAUTION]
> <xref:System.Threading.Thread.Suspend%2A> メソッドと <xref:System.Threading.Thread.Resume%2A> メソッドを使用してスレッドの動作を同期しないでください。 スレッドを中断したときに実行されているコードを知ることはできません。 セキュリティアクセス許可の評価中にロックを保持している間にスレッドを中断した場合、<xref:System.AppDomain> 内の他のスレッドがブロックされることがあります。 クラスコンストラクターの実行中にスレッドを中断すると、そのクラスを使用しようとしている <xref:System.AppDomain> 内の他のスレッドがブロックされます。 デッドロックは非常に簡単に発生します。

スレッドで `Suspend` メソッドを呼び出すと、スレッドの中断が要求されたことがシステムに示され、スレッドを実際に中断する前にセーフポイントに到達するまでスレッドを実行できます。 スレッドのセーフ ポイントは、ガベージ コレクションを実行できる実行ポイントです。 セーフ ポイントに到達すると、ランタイムにより、中断されたスレッドがマネージド コードで続行されないことが保証されます。 マネージド コードの外部で実行中のスレッドは、通常、ガベージ コレクションでは安全であり、その実行はマネージド コードの実行再開が試行されるまで続行します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core のみ: このメンバーはサポートされていません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが開始していないか、または停止しています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に適切な <see cref="T:System.Security.Permissions.SecurityPermission" /> がありません。</exception>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">スレッドの一時中断および中断</related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">将来利用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。 詳細については、「 [IDispatch:: idispatch.getidsofnames](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインターを取得します。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。 詳細については、「 [IDispatch:: GetTypeInfo](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfo)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。 詳細については、「 [IDispatch:: GetTypeInfoCount](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfocount)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来利用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。 詳細については、「 [IDispatch:: Invoke](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドの状態を示す値を取得します。</summary>
        <value>現在のスレッドの状態を示す <see cref="T:System.Threading.ThreadState" /> 値の 1 つ。 初期値は <see cref="F:System.Threading.ThreadState.Unstarted" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.ThreadState%2A> プロパティは、<xref:System.Threading.Thread.IsAlive%2A> プロパティよりも具体的な情報を提供します。  
  
> [!IMPORTANT]
>  スレッドの状態は、デバッグシナリオでのみ重要です。 スレッドの動作を同期化する目的でコード内でスレッドの状態を使用しないでください。  
  
   
  
## Examples  
 次のコード例は、スレッドの `ThreadState` にアクセスする方法を示しています。  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="state">新しいアパートメント状態。</param>
        <summary>スレッドを開始する前にそのアパートメント状態を設定します。</summary>
        <returns>アパートメント状態が設定されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アパートメント状態が開始前に設定されていない場合、新しいスレッドは <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> として初期化されます。 アパートメント状態は、スレッドを開始する前に設定する必要があります。  
  
> [!NOTE]
>  メインアプリケーションスレッドは、既定で <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> に初期化されます。 メインアプリケーションスレッドのアパートメント状態を <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> に設定する唯一の方法は、<xref:System.STAThreadAttribute> 属性をエントリポイントメソッドに適用することです。  
  
 <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドと、<xref:System.Threading.Thread.GetApartmentState%2A> メソッドおよび <xref:System.Threading.Thread.SetApartmentState%2A> メソッドを使用して、<xref:System.Threading.Thread.ApartmentState%2A> プロパティが置き換えられます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Threading.Thread.GetApartmentState%2A>、<xref:System.Threading.Thread.SetApartmentState%2A>、および <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドを示しています。 このコード例では、スレッドを作成します。 スレッドが開始される前に、<xref:System.Threading.Thread.GetApartmentState%2A> は初期の <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> の状態を表示し、<xref:System.Threading.Thread.SetApartmentState%2A> 状態を <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>に変更します。 <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドは、アパートメント状態が既に設定されているために状態を <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> に変更しようとしたときに `false` を返します。 <xref:System.Threading.Thread.SetApartmentState%2A>で同じ操作が試行された場合、<xref:System.InvalidOperationException> がスローされます。  
  
 スレッドが開始されると、<xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドが再び使用されます。 今回は、スレッドが既に開始されているため <xref:System.Threading.ThreadStateException> をスローします。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core のみ: macOS および Linux プラットフォームでは、このメンバーはサポートされていません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="state" /> は有効なアパートメント状態ではありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが開始され、終了したか、スレッドの実行中にスレッドのコンテキストから呼び出しが行われていません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : byte -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : double -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int16 -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int64 -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : nativeint -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : obj -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : sbyte -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : single -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint16 -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint32 -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint64 -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : unativeint -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : byte * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Byte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : double * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int16 * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Int16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int64 * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : nativeint * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : obj * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : sbyte * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.SByte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : single * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint16 * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UInt16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint32 * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint64 * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : unativeint * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UIntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。 通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。  
  
 マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。 これには、プロセッサキャッシュのフラッシュが必要になる場合があります。  
  
 ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。 そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。  
  
 このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。 フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。  
  
> [!NOTE]
>  でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出し元のスレッドから、現在のプロセッサ上で実行する準備が整っている別のスレッドに実行を切り替えます。 実行の切り替え先のスレッドは、オペレーティング システムによって選択されます。</summary>
        <returns>オペレーティング システムによって実行が別のスレッドに切り替えられた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが成功すると、スレッドの現在のタイムスライスの残りの部分が生成されます。 オペレーティングシステムは、その優先順位と実行可能な他のスレッドの状態に応じて、別のタイムスライスの呼び出し元スレッドをスケジュールします。  
  
 生成は、呼び出し元のスレッドを実行しているプロセッサに限定されます。 オペレーティングシステムは、プロセッサがアイドル状態の場合や、優先順位の低いスレッドが実行されている場合でも、実行を別のプロセッサに切り替えません。 現在のプロセッサで実行する準備ができているスレッドが他にない場合、オペレーティングシステムは実行を生成せず、このメソッドは `false`を返します。  
  
 このメソッドは、プラットフォーム呼び出しを使用してネイティブの Win32 `SwitchToThread` 関数を呼び出すことと同じです。 プラットフォーム呼び出しではなく、ホストが要求したカスタムスレッド動作をバイパスするので、プラットフォーム呼び出しを使用する代わりに、<xref:System.Threading.Thread.Yield%2A> メソッドを呼び出す必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
