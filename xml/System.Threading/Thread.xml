<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="60346ad3a07581a8a491d1886d0f985ef99dacdc" /><Meta Name="ms.sourcegitcommit" Value="f9576bf8c61e3d46834aeeff50f858359f2a99ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="02/09/2020" /><Meta Name="ms.locfileid" Value="77101780" /></Metadata><TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="8d5a0-101">スレッドを作成および制御し、その優先順位の設定およびステータスの取得を実行します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-101">Creates and controls a thread, sets its priority, and gets its status.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-102">プロセスが開始されると、共通言語ランタイムによって、アプリケーションコードを実行するためのフォアグラウンドスレッドが自動的に1つ作成されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-102">When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</span></span> <span data-ttu-id="8d5a0-103">プロセスでは、この主要なフォアグラウンドスレッドと共に、プロセスに関連付けられているプログラムコードの一部を実行するために1つ以上のスレッドを作成できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-103">Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</span></span> <span data-ttu-id="8d5a0-104">これらのスレッドは、フォアグラウンドまたはバックグラウンドで実行できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-104">These threads can execute either in the foreground or in the background.</span></span> <span data-ttu-id="8d5a0-105">さらに、<xref:System.Threading.ThreadPool> クラスを使用して、共通言語ランタイムによって管理されるワーカースレッドでコードを実行できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-105">In addition, you can use the <xref:System.Threading.ThreadPool> class to execute code on worker threads that are managed by the common language runtime.</span></span>  
  
 <span data-ttu-id="8d5a0-106">このセクションの内容</span><span class="sxs-lookup"><span data-stu-id="8d5a0-106">In this section</span></span>  
  
 <span data-ttu-id="8d5a0-107">[スレッド  を開始し](#Starting)ています</span><span class="sxs-lookup"><span data-stu-id="8d5a0-107">[Starting a thread](#Starting) </span></span>  
 <span data-ttu-id="8d5a0-108">[スレッドオブジェクトの取得](#Retrieving) </span><span class="sxs-lookup"><span data-stu-id="8d5a0-108">[Retrieving Thread objects](#Retrieving) </span></span>  
 <span data-ttu-id="8d5a0-109">[フォアグラウンドスレッドとバックグラウンドスレッド](#Foreground) </span><span class="sxs-lookup"><span data-stu-id="8d5a0-109">[Foreground and background threads](#Foreground) </span></span>  
 <span data-ttu-id="8d5a0-110">[カルチャとスレッド](#Culture) </span><span class="sxs-lookup"><span data-stu-id="8d5a0-110">[Culture and threads](#Culture) </span></span>  
 [<span data-ttu-id="8d5a0-111">情報の取得とスレッドの制御</span><span class="sxs-lookup"><span data-stu-id="8d5a0-111">Getting information about and controlling threads</span></span>](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a><span data-ttu-id="8d5a0-112">スレッドの開始</span><span class="sxs-lookup"><span data-stu-id="8d5a0-112">Starting a thread</span></span>  
 <span data-ttu-id="8d5a0-113">スレッドを開始するには、そのクラスコンストラクターでスレッドが実行するメソッドを表すデリゲートを指定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-113">You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</span></span> <span data-ttu-id="8d5a0-114">次に、<xref:System.Threading.Thread.Start%2A> メソッドを呼び出して、実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-114">You then call the <xref:System.Threading.Thread.Start%2A> method to begin execution.</span></span>  
  
 <span data-ttu-id="8d5a0-115">引数を実行するメソッドに渡すことができるかどうかに応じて、<xref:System.Threading.Thread> コンストラクターは、次の2つのデリゲート型のどちらかを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-115">The <xref:System.Threading.Thread> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</span></span>  
  
-   <span data-ttu-id="8d5a0-116">メソッドに引数がない場合は、コンストラクターに <xref:System.Threading.ThreadStart> デリゲートを渡します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-116">If the method has no arguments, you pass a <xref:System.Threading.ThreadStart> delegate to  the constructor.</span></span> <span data-ttu-id="8d5a0-117">署名は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-117">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     <span data-ttu-id="8d5a0-118">次の例では、`ExecuteInForeground` メソッドを実行するスレッドを作成して開始します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-118">The following example creates and starts a thread that executes the `ExecuteInForeground` method.</span></span> <span data-ttu-id="8d5a0-119">メソッドは、一部のスレッドプロパティに関する情報を表示した後、0.5 秒間一時停止するループを実行し、経過秒数を表示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-119">The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</span></span> <span data-ttu-id="8d5a0-120">スレッドが少なくとも5秒間実行されると、ループが終了し、スレッドが実行を終了します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-120">When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</span></span>  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   <span data-ttu-id="8d5a0-121">メソッドに引数がある場合は、コンストラクターに <xref:System.Threading.ParameterizedThreadStart> デリゲートを渡します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-121">If the method has an argument, you pass a <xref:System.Threading.ParameterizedThreadStart> delegate to the constructor.</span></span> <span data-ttu-id="8d5a0-122">署名は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-122">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     <span data-ttu-id="8d5a0-123">その後、デリゲートによって実行されるメソッドC#は、パラメーターを適切な型にキャスト (では) または変換 (Visual Basic) できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-123">The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</span></span>  
  
     <span data-ttu-id="8d5a0-124">次の例は、前の例と同じですが、<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> コンストラクターを呼び出している点が異なります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-124">The following example is identical to the previous one, except that it calls the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor.</span></span> <span data-ttu-id="8d5a0-125">このバージョンの `ExecuteInForeground` メソッドには、ループが実行されるおおよそのミリ秒数を表す1つのパラメーターがあります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-125">This version of the `ExecuteInForeground` method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</span></span>  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 <span data-ttu-id="8d5a0-126">スレッドを開始した後は、<xref:System.Threading.Thread> オブジェクトへの参照を保持する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-126">It is not necessary to retain a reference to a <xref:System.Threading.Thread> object once you have started the thread.</span></span> <span data-ttu-id="8d5a0-127">スレッドは、スレッドプロシージャが完了するまで実行を続けます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-127">The thread continues to execute until the thread procedure is complete.</span></span>  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a><span data-ttu-id="8d5a0-128">スレッドオブジェクトの取得</span><span class="sxs-lookup"><span data-stu-id="8d5a0-128">Retrieving Thread objects</span></span>  
 <span data-ttu-id="8d5a0-129">静的 (Visual Basic の`Shared`) <xref:System.Threading.Thread.CurrentThread%2A> プロパティを使用して、スレッドが実行しているコードから現在実行中のスレッドへの参照を取得できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-129">You can use the static (`Shared` in Visual Basic)  <xref:System.Threading.Thread.CurrentThread%2A> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</span></span> <span data-ttu-id="8d5a0-130">次の例では、<xref:System.Threading.Thread.CurrentThread%2A> プロパティを使用して、メインアプリケーションスレッド、別のフォアグラウンドスレッド、バックグラウンドスレッド、スレッドプールスレッドに関する情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-130">The following example uses the <xref:System.Threading.Thread.CurrentThread%2A> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</span></span>  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a><span data-ttu-id="8d5a0-131">フォアグラウンドスレッドとバックグラウンドスレッド</span><span class="sxs-lookup"><span data-stu-id="8d5a0-131">Foreground and background threads</span></span>  
 <span data-ttu-id="8d5a0-132"><xref:System.Threading.Thread> クラスのインスタンスは、フォアグラウンドスレッドとバックグラウンドスレッドのどちらかを表します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-132">Instances of the <xref:System.Threading.Thread> class represent either foreground threads or background threads.</span></span> <span data-ttu-id="8d5a0-133">バックグラウンドスレッドはフォアグラウンドスレッドと同じですが、例外が1つあります。すべてのフォアグラウンドスレッドが終了した場合、バックグラウンドスレッドはプロセスを実行したままにしません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-133">Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</span></span> <span data-ttu-id="8d5a0-134">すべてのフォアグラウンドスレッドが停止されると、ランタイムはすべてのバックグラウンドスレッドを停止し、シャットダウンします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-134">Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</span></span>  
  
 <span data-ttu-id="8d5a0-135">既定では、次のスレッドがフォアグラウンドで実行されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-135">By default, the following threads execute in the foreground:</span></span>  
  
-   <span data-ttu-id="8d5a0-136">メインアプリケーションスレッド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-136">The main application thread.</span></span>  
  
-   <span data-ttu-id="8d5a0-137"><xref:System.Threading.Thread> クラスコンストラクターを呼び出すことによって作成されるすべてのスレッド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-137">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="8d5a0-138">既定では、次のスレッドがバックグラウンドで実行されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-138">The following threads execute in the background by default:</span></span>  
  
-   <span data-ttu-id="8d5a0-139">スレッドプールスレッド。ランタイムによって管理されるワーカースレッドのプールです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-139">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span>  <span data-ttu-id="8d5a0-140">スレッドプールを構成し、<xref:System.Threading.ThreadPool> クラスを使用してスレッドプールスレッドの作業をスケジュールすることができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-140">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="8d5a0-141">スレッドプールのスレッドでは、タスクベースの非同期操作が自動的に実行されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-141">Task-based asynchronous operations automatically execute on thread pool threads.</span></span> <span data-ttu-id="8d5a0-142">タスクベースの非同期操作では、<xref:System.Threading.Tasks.Task> クラスと <xref:System.Threading.Tasks.Task%601> クラスを使用して、[タスクベースの非同期パターン](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)を実装します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-142">Task-based asynchronous operations use the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes to implement the [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span></span>  
  
-   <span data-ttu-id="8d5a0-143">アンマネージコードからマネージ実行環境に入るすべてのスレッド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-143">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
 <span data-ttu-id="8d5a0-144">バックグラウンドで実行するスレッドを変更するには、<xref:System.Threading.Thread.IsBackground%2A> プロパティをいつでも設定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-144">You can change a thread to execute in the background by setting the <xref:System.Threading.Thread.IsBackground%2A> property at any time.</span></span>  <span data-ttu-id="8d5a0-145">バックグラウンドスレッドは、アプリケーションが実行されている間は続行する必要がありますが、ファイルシステムの変更や着信ソケット接続の監視など、アプリケーションの終了を防ぐ必要がない操作には便利です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-145">Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</span></span>  
  
 <span data-ttu-id="8d5a0-146">次の例は、フォアグラウンドスレッドとバックグラウンドスレッドの違いを示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-146">The following example illustrates the difference between foreground and background threads.</span></span> <span data-ttu-id="8d5a0-147">これは、スレッドを開始する前にバックグラウンドで実行するようにスレッドを設定している点を除いて、[スレッドの開始](#Starting)に関するセクションの最初の例と似ています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-147">It is like the first example in the [Starting a thread](#Starting) section, except that it sets the thread to execute in the background before starting it.</span></span> <span data-ttu-id="8d5a0-148">出力に示されているように、ループは、5秒間実行される前に中断されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-148">As the output shows, the loop is interrupted before it executes for five seconds.</span></span>  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a><span data-ttu-id="8d5a0-149">カルチャとスレッド</span><span class="sxs-lookup"><span data-stu-id="8d5a0-149">Culture and threads</span></span>  
 <span data-ttu-id="8d5a0-150">各スレッドには、<xref:System.Threading.Thread.CurrentCulture%2A> プロパティによって表されるカルチャと、<xref:System.Threading.Thread.CurrentUICulture%2A> プロパティによって表される UI カルチャがあります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-150">Each thread has a culture, represented by the <xref:System.Threading.Thread.CurrentCulture%2A> property, and a UI culture, represented by the <xref:System.Threading.Thread.CurrentUICulture%2A> property.</span></span>  <span data-ttu-id="8d5a0-151">現在のカルチャでは、解析と書式設定、文字列の比較と並べ替えなど、カルチャに依存する操作をサポートしています。また、スレッドで使用される書記体系と暦も制御します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-151">The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</span></span> <span data-ttu-id="8d5a0-152">現在の UI カルチャは、リソースファイル内のリソースのカルチャに依存した取得を提供します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-152">The current UI culture provides for culture-sensitive retrieval of resources in resource files.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="8d5a0-153"><xref:System.Threading.Thread.CurrentCulture> プロパティと <xref:System.Threading.Thread.CurrentUICulture> プロパティは、現在のスレッド以外のスレッドで使用する場合、確実に動作しません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-153">The <xref:System.Threading.Thread.CurrentCulture> and <xref:System.Threading.Thread.CurrentUICulture> properties don't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="8d5a0-154">.NET Framework では、これらのプロパティの読み取りは信頼性がありますが、現在のスレッド以外のスレッドに対してこれらのプロパティを設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-154">In .NET Framework, reading these properties is reliable, although setting these properties for a thread other than the current thread is not.</span></span> <span data-ttu-id="8d5a0-155">.NET Core では、スレッドが別のスレッドでこれらのプロパティの読み取りまたは書き込みを行おうとすると、<xref:System.InvalidOperationException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-155">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write these properties on a different thread.</span></span>
> <span data-ttu-id="8d5a0-156"><xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> と <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> のプロパティを使用して、現在のカルチャを取得して設定することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-156">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> properties to retrieve and set the current culture.</span></span>

 <span data-ttu-id="8d5a0-157">新しいスレッドがインスタンス化されると、そのカルチャと UI カルチャは、現在のシステムカルチャと ui カルチャによって定義され、新しいスレッドの作成元のスレッドのカルチャおよび UI カルチャによっては定義されません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-157">When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</span></span> <span data-ttu-id="8d5a0-158">たとえば、現在のシステムカルチャが英語 (米国) で、プライマリアプリケーションスレッドの現在のカルチャがフランス語 (フランス) の場合、プライマリスレッドからの <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> コンストラクターを呼び出すことによって作成された新しいスレッドのカルチャは、フランス語 (フランス) ではなく英語 (米国) になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-158">This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor from the primary thread is English (United States), and not French (France).</span></span> <span data-ttu-id="8d5a0-159">詳細については、<xref:System.Globalization.CultureInfo> クラスのトピックの「カルチャとスレッド」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-159">For more information, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d5a0-160">これは、[!INCLUDE[net_v46](~/includes/net-v46-md.md)] 以降のバージョンを対象とするアプリに対して非同期操作を実行するスレッドには当てはまりません。この場合、カルチャと UI カルチャは非同期操作のコンテキストの一部になります。非同期操作が既定で実行されるスレッドは、非同期操作の開始元のスレッドのカルチャと UI カルチャを継承します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-160">This is not true of threads that execute asynchronous operations for apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)] and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</span></span> <span data-ttu-id="8d5a0-161">詳細については、<xref:System.Globalization.CultureInfo> クラスのトピックの「カルチャとタスク ベースの非同期の操作」セクションをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-161">For more information, see the "Culture and task-based asynchronous operations" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
 <span data-ttu-id="8d5a0-162">アプリケーションで実行されているすべてのスレッドが同じカルチャと UI カルチャを共有するようにするには、次のいずれかを実行します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-162">You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</span></span>  
  
-   <span data-ttu-id="8d5a0-163">そのカルチャを表す <xref:System.Globalization.CultureInfo> オブジェクトを <xref:System.Threading.ParameterizedThreadStart> デリゲートまたは <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> メソッドに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-163">You can pass a <xref:System.Globalization.CultureInfo> object that represents that culture to the <xref:System.Threading.ParameterizedThreadStart> delegate or the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="8d5a0-164">[!INCLUDE[net_v45](~/includes/net-v45-md.md)] 以降のバージョンで実行されているアプリでは、<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> と <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> プロパティの値を設定することによって、アプリケーションドメインで作成されたすべてのスレッドに割り当てられるカルチャと UI カルチャを定義できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-164">For apps running on the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="8d5a0-165">これはアプリケーションごとのドメイン設定であることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-165">Note that this is a per-application domain setting.</span></span>  

 <span data-ttu-id="8d5a0-166">詳細と例については、<xref:System.Globalization.CultureInfo> クラスのトピックの「カルチャとスレッド」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-166">For more information and examples, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a><span data-ttu-id="8d5a0-167">情報の取得とスレッドの制御</span><span class="sxs-lookup"><span data-stu-id="8d5a0-167">Getting information about and controlling threads</span></span>  
 <span data-ttu-id="8d5a0-168">スレッドに関する情報を提供する多数のプロパティ値を取得できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-168">You can retrieve a number of property values that provide information about a thread.</span></span> <span data-ttu-id="8d5a0-169">場合によっては、これらのプロパティ値を設定して、スレッドの操作を制御することもできます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-169">In some cases, you can also set these property values to control the operation of the thread.</span></span> <span data-ttu-id="8d5a0-170">これらのスレッドプロパティは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-170">These thread properties include:</span></span>  
  
-   <span data-ttu-id="8d5a0-171">名前。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-171">A name.</span></span> <span data-ttu-id="8d5a0-172"><xref:System.Threading.Thread.Name%2A> は、スレッドを識別するために使用できる1回の書き込みプロパティです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-172"><xref:System.Threading.Thread.Name%2A> is a write-once property that you can use to identify a thread.</span></span>  <span data-ttu-id="8d5a0-173">既定値は `null` です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-173">Its default value is `null`.</span></span>  
  
-   <span data-ttu-id="8d5a0-174"><xref:System.Threading.Thread.GetHashCode%2A> メソッドを呼び出すことによって取得できるハッシュコード。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-174">A hash code, which you can retrieve by calling the <xref:System.Threading.Thread.GetHashCode%2A> method.</span></span> <span data-ttu-id="8d5a0-175">ハッシュコードは、スレッドを一意に識別するために使用できます。スレッドの有効期間にわたって、そのハッシュコードは、値の取得元のアプリケーションドメインに関係なく、他のスレッドの値と競合しません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-175">The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</span></span>  
  
-   <span data-ttu-id="8d5a0-176">スレッド ID。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-176">A thread ID.</span></span> <span data-ttu-id="8d5a0-177">読み取り専用の <xref:System.Threading.Thread.ManagedThreadId%2A> プロパティの値は、ランタイムによって割り当てられ、プロセス内のスレッドを一意に識別します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-177">The value of the read-only <xref:System.Threading.Thread.ManagedThreadId%2A> property is assigned by the runtime and uniquely identifies a thread within its process.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="8d5a0-178">オペレーティング システム [ThreadId](/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadid) とマネージド スレッドの間には固定的な関係はありません。これは、アンマネージド ホストがマネージド スレッドとアンマネージド スレッドの間の関係を制御できるためです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-178">An operating-system [ThreadId](/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadid) has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="8d5a0-179">具体的には、高度なホストは[CLR ホスティング API](~/docs/framework/unmanaged-api/hosting/index.md)を使用して、同じオペレーティングシステムスレッドに対して多数のマネージスレッドをスケジュールしたり、異なるオペレーティングシステムスレッド間でマネージスレッドを移動したりできます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-179">Specifically, a sophisticated host can use the [CLR Hosting API](~/docs/framework/unmanaged-api/hosting/index.md) to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</span></span>  
  
-   <span data-ttu-id="8d5a0-180">スレッドの現在の状態。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-180">The thread's current state.</span></span> <span data-ttu-id="8d5a0-181">スレッドは、存在する間は常に、<xref:System.Threading.ThreadState> プロパティによって定義された1つ以上の状態になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-181">For the duration of its existence, a thread is always in one or more of the states defined by the <xref:System.Threading.ThreadState> property.</span></span>  
  
-   <span data-ttu-id="8d5a0-182"><xref:System.Threading.ThreadPriority> プロパティによって定義されるスケジューリング優先度レベル。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-182">A scheduling priority level, which is defined by the <xref:System.Threading.ThreadPriority> property.</span></span> <span data-ttu-id="8d5a0-183">この値は、スレッドの優先順位を要求するように設定できますが、オペレーティングシステムによって受け入れられるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-183">Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</span></span>  
  
-   <span data-ttu-id="8d5a0-184">スレッドがスレッドプールスレッドであるかどうかを示す読み取り専用の <xref:System.Threading.Thread.IsThreadPoolThread%2A> プロパティ。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-184">The read-only <xref:System.Threading.Thread.IsThreadPoolThread%2A> property, which indicates whether a thread is  a thread pool thread.</span></span>  
  
-   <span data-ttu-id="8d5a0-185"><xref:System.Threading.Thread.IsBackground%2A> プロパティ。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-185">The <xref:System.Threading.Thread.IsBackground%2A> property.</span></span> <span data-ttu-id="8d5a0-186">詳細については、「[フォアグラウンドスレッドとバックグラウンドスレッド](#Foreground)」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-186">For more information, see the [Foreground and background threads](#Foreground) section.</span></span>  
  
## Examples  
 <span data-ttu-id="8d5a0-187">次の例は、単純なスレッド機能を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-187">The following example demonstrates simple threading functionality.</span></span>  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 <span data-ttu-id="8d5a0-188">このコードでは、次のような出力が生成されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-188">This code produces output similar to the following:</span></span>  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="8d5a0-189">この型はスレッド セーフです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-189">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="8d5a0-190">スレッドおよびスレッド処理</span><span class="sxs-lookup"><span data-stu-id="8d5a0-190">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="8d5a0-191">スレッドの使用とスレッド処理</span><span class="sxs-lookup"><span data-stu-id="8d5a0-191">Using Threads and Threading</span></span></related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96"><span data-ttu-id="8d5a0-192">Thread クラスの参照ソース</span><span class="sxs-lookup"><span data-stu-id="8d5a0-192">Reference Source for the Thread Class</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d5a0-193"><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-193">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="8d5a0-194">このスレッドが実行を開始するときに呼び出されるメソッドを表すデリゲート。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-194">A delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="8d5a0-195">スレッドの開始時にオブジェクトをスレッドに渡すことを許可するデリゲートを指定して、<see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-195">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-196">スレッドが作成されても、実行は開始されません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-196">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="8d5a0-197">スレッドの実行をスケジュールするには、<xref:System.Threading.Thread.Start%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-197">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span> <span data-ttu-id="8d5a0-198">データオブジェクトをスレッドに渡すには、<xref:System.Threading.Thread.Start%28System.Object%29> メソッドのオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-198">To pass a data object to the thread, use the <xref:System.Threading.Thread.Start%28System.Object%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-199">Visual Basic ユーザーは、スレッドの作成時に <xref:System.Threading.ThreadStart> コンストラクターを省略できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-199">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="8d5a0-200">メソッドを渡すときには `AddressOf` 演算子を使用します。たとえば、`Dim t As New Thread(AddressOf ThreadProc)`のようになります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-200">Use the `AddressOf` operator when passing your method, for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="8d5a0-201">Visual Basic は、<xref:System.Threading.ThreadStart> コンストラクターを自動的に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-201">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-202">次の例は、静的メソッドとインスタンスメソッドを使用して <xref:System.Threading.ParameterizedThreadStart> デリゲートを作成および使用するための構文を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-202">The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d5a0-203"><paramref name="start" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-203"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="8d5a0-204">スレッドの作成</span><span class="sxs-lookup"><span data-stu-id="8d5a0-204">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="8d5a0-205">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ThreadStart" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-205">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="8d5a0-206"><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-206">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-207">スレッドが作成されても、実行は開始されません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-207">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="8d5a0-208">スレッドの実行をスケジュールするには、<xref:System.Threading.Thread.Start%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-208">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-209">Visual Basic ユーザーは、スレッドの作成時に <xref:System.Threading.ThreadStart> コンストラクターを省略できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-209">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="8d5a0-210">例 `Dim t As New Thread(AddressOf ThreadProc)`のようにメソッドを渡すときは、`AddressOf` 演算子を使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-210">Use the `AddressOf` operator when passing your method for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="8d5a0-211">Visual Basic は、<xref:System.Threading.ThreadStart> コンストラクターを自動的に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-211">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-212">次のコード例は、静的メソッドを実行するスレッドを作成する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-212">The following code example shows how to create a thread that executes a static method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 <span data-ttu-id="8d5a0-213">インスタンスメソッドを実行するスレッドを作成する方法を次のコード例に示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-213">The following code example shows how to create a thread that executes an instance method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d5a0-214"><paramref name="start" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-214">The <paramref name="start" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="8d5a0-215">スレッドの作成</span><span class="sxs-lookup"><span data-stu-id="8d5a0-215">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="8d5a0-216">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ParameterizedThreadStart" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-216">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="8d5a0-217">スレッドが使用する最大スタック サイズ (バイト単位)。実行可能ファイルのヘッダーで指定された既定の最大スタック サイズを使用する場合は 0。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-217">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="8d5a0-218">重要: 部分的に信頼されているコードでは、既定のスタック サイズを超える <paramref name="maxStackSize" /> は無視されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-218">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="8d5a0-219">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-219">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="8d5a0-220"><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化して、スレッドの開始時にオブジェクトをスレッドに渡すことを許可するデリゲートとこのスレッドの最大スタック サイズを指定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-220">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-221">このコンストラクターのオーバーロードは使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-221">Avoid using this constructor overload.</span></span> <span data-ttu-id="8d5a0-222"><xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> コンストラクターオーバーロードによって使用される既定のスタックサイズは、スレッドで推奨されるスタックサイズです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-222">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="8d5a0-223">スレッドにメモリの問題がある場合は、無限再帰などのプログラミングエラーが発生する可能性が最も高くなります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-223">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d5a0-224">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、完全に信頼されたコードのみが、`maxStackSize` を既定のスタックサイズ (1 メガバイト) より大きい値に設定できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-224">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="8d5a0-225">部分信頼でコードを実行しているときに `maxStackSize` により大きな値が指定されている場合、`maxStackSize` は無視され、既定のスタックサイズが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-225">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="8d5a0-226">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-226">No exception is thrown.</span></span> <span data-ttu-id="8d5a0-227">任意の信頼レベルのコードでは、`maxStackSize` を既定のスタックサイズよりも小さい値に設定できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-227">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-228">部分的に信頼されるコードによって使用される完全に信頼されたライブラリを開発していて、大きなスタックを必要とするスレッドを開始する必要がある場合は、スレッドを作成する前に完全信頼をアサートする必要があります。または、既定のスタックサイズが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-228">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="8d5a0-229">スレッドで実行されるコードを完全に制御しない限り、この操作は行わないでください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-229">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="8d5a0-230">`maxStackSize` が最小スタックサイズ未満の場合は、最小スタックサイズが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-230">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="8d5a0-231">`maxStackSize` がページサイズの倍数でない場合は、ページサイズの次の大きな倍数に丸められます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-231">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="8d5a0-232">たとえば、Windows Vista で .NET Framework バージョン2.0 を使用している場合は、256 KB (262144 バイト) が最小スタックサイズで、ページサイズは 64 KB (65536 バイト) です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-232">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-233">Windows XP および Windows Server 2003 より前のバージョンの Microsoft Windows では、`maxStackSize` は無視され、実行可能ファイルヘッダーで指定されているスタックサイズが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-233">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="8d5a0-234">非常に小さいスタックサイズを指定する場合は、スタックオーバーフロープローブを無効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-234">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="8d5a0-235">スタックが非常に制限されている場合、プローブによってスタックオーバーフローが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-235">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="8d5a0-236">スタックオーバーフロープローブを無効にするには、アプリケーション構成ファイルに次のを追加します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-236">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d5a0-237"><paramref name="start" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-237"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8d5a0-238"><paramref name="maxStackSize" /> に 0 より小さい値が指定されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-238"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="8d5a0-239">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ThreadStart" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-239">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="8d5a0-240">スレッドが使用する最大スタック サイズ (バイト単位)。実行可能ファイルのヘッダーで指定された既定の最大スタック サイズを使用する場合は 0。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-240">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="8d5a0-241">重要: 部分的に信頼されているコードでは、既定のスタック サイズを超える <paramref name="maxStackSize" /> は無視されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-241">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="8d5a0-242">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-242">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="8d5a0-243"><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化して、スレッドの最大スタック サイズを指定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-243">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-244">このコンストラクターのオーバーロードは使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-244">Avoid using this constructor overload.</span></span> <span data-ttu-id="8d5a0-245"><xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> コンストラクターオーバーロードによって使用される既定のスタックサイズは、スレッドで推奨されるスタックサイズです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-245">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="8d5a0-246">スレッドにメモリの問題がある場合は、無限再帰などのプログラミングエラーが発生する可能性が最も高くなります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-246">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d5a0-247">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、完全に信頼されたコードのみが、`maxStackSize` を既定のスタックサイズ (1 メガバイト) より大きい値に設定できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-247">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="8d5a0-248">部分信頼でコードを実行しているときに `maxStackSize` により大きな値が指定されている場合、`maxStackSize` は無視され、既定のスタックサイズが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-248">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="8d5a0-249">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-249">No exception is thrown.</span></span> <span data-ttu-id="8d5a0-250">任意の信頼レベルのコードでは、`maxStackSize` を既定のスタックサイズよりも小さい値に設定できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-250">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-251">部分的に信頼されるコードによって使用される完全に信頼されたライブラリを開発していて、大きなスタックを必要とするスレッドを開始する必要がある場合は、スレッドを作成する前に完全信頼をアサートする必要があります。または、既定のスタックサイズが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-251">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="8d5a0-252">スレッドで実行されるコードを完全に制御しない限り、この操作は行わないでください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-252">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="8d5a0-253">`maxStackSize` が最小スタックサイズ未満の場合は、最小スタックサイズが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-253">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="8d5a0-254">`maxStackSize` がページサイズの倍数でない場合は、ページサイズの次の大きな倍数に丸められます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-254">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="8d5a0-255">たとえば、Windows Vista で .NET Framework バージョン2.0 を使用している場合は、256 KB (262144 バイト) が最小スタックサイズで、ページサイズは 64 KB (65536 バイト) です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-255">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-256">Windows XP および Windows Server 2003 より前のバージョンの Microsoft Windows では、`maxStackSize` は無視され、実行可能ファイルヘッダーで指定されているスタックサイズが使用されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-256">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="8d5a0-257">非常に小さいスタックサイズを指定する場合は、スタックオーバーフロープローブを無効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-257">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="8d5a0-258">スタックが非常に制限されている場合、プローブによってスタックオーバーフローが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-258">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="8d5a0-259">スタックオーバーフロープローブを無効にするには、アプリケーション構成ファイルに次のを追加します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-259">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d5a0-260"><paramref name="start" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-260"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8d5a0-261"><paramref name="maxStackSize" /> に 0 より小さい値が指定されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-261"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d5a0-262">このメソッドが呼び出された対象のスレッドで、そのスレッドの終了プロセスを開始する <see cref="T:System.Threading.ThreadAbortException" /> を発生させます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-262">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="8d5a0-263">このメソッドを呼び出すと、通常、スレッドが終了します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-263">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> <span data-ttu-id="8d5a0-264">`Thread.Abort` メソッドは注意して使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-264">The `Thread.Abort` method should be used with caution.</span></span> <span data-ttu-id="8d5a0-265">特に、このメソッドを呼び出して、現在のスレッド以外のスレッドを中止すると、<xref:System.Threading.ThreadAbortException> がスローされたときに実行されたコードや実行に失敗したコードがわからなくなります。また、アプリケーションの状態やアプリケーションとユーザーの状態が保持されているかどうかを特定できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-265">Particularly when you call it to abort a thread other than the current thread, you do not know what code has executed or failed to execute when the <xref:System.Threading.ThreadAbortException> is thrown, nor can you be certain of the state of your application or any application and user state that it is responsible for preserving.</span></span> <span data-ttu-id="8d5a0-266">たとえば、`Thread.Abort` を呼び出すと、静的コンストラクターがアンマネージリソースの解放を実行したり、解放したりするのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-266">For example, calling `Thread.Abort` may prevent static constructors from executing or prevent the release of unmanaged resources</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-267">このメソッドが呼び出された対象のスレッドで、そのスレッドの終了プロセスを開始する <see cref="T:System.Threading.ThreadAbortException" /> を発生させます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-267">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="8d5a0-268">このメソッドを呼び出すと、通常、スレッドが終了します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-268">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-269">このメソッドがスレッドで呼び出されると、システムはスレッド内の <xref:System.Threading.ThreadAbortException> をスローして中止します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-269">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="8d5a0-270">`ThreadAbortException` は、アプリケーションコードでキャッチできる特殊な例外ですが、<xref:System.Threading.Thread.ResetAbort%2A> が呼び出されない限り、`catch` ブロックの最後に再スローされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-270">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="8d5a0-271">`ResetAbort` は、中止の要求をキャンセルし、`ThreadAbortException` がスレッドを終了できないようにします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-271">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="8d5a0-272">Unexecuted `finally` ブロックは、スレッドが中止される前に実行されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-272">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-273">スレッドがそれ自体で `Abort` を呼び出すと、その効果は例外をスローするのと似ています。<xref:System.Threading.ThreadAbortException> が直ちに発生し、結果は予測可能です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-273">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="8d5a0-274">ただし、あるスレッドが別のスレッドで `Abort` を呼び出した場合、abort は実行されているすべてのコードを中断します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-274">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="8d5a0-275">また、静的コンストラクターが中断される可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-275">There is also a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="8d5a0-276">まれに、そのクラスのインスタンスがそのアプリケーションドメインで作成されない場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-276">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="8d5a0-277">.NET Framework バージョン1.0 および1.1 では、`finally` ブロックの実行中にスレッドが中止される可能性があります。この場合、`finally` ブロックは中止されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-277">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="8d5a0-278">スレッドはすぐに中止されるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-278">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="8d5a0-279">この状況は、スレッドが中止プロシージャの一部として呼び出された `finally` ブロックで無制限の計算を実行した場合に発生する可能性があります。これにより、中止が無期限に遅延されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-279">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="8d5a0-280">スレッドが中止されるまで待機するには、<xref:System.Threading.Thread.Abort%2A> メソッドを呼び出した後にスレッドで <xref:System.Threading.Thread.Join%2A> メソッドを呼び出すことができますが、待機が終了する保証はありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-280">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-281">中断されているスレッドが、`catch` ブロック、`finally` ブロック、または制約された実行領域などのコードの保護された領域内にある場合、<xref:System.Threading.Thread.Abort%2A> を呼び出すスレッドがブロックする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-281">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="8d5a0-282"><xref:System.Threading.Thread.Abort%2A> を呼び出すスレッドが、中止されたスレッドが必要とするロックを保持している場合、デッドロックが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-282">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="8d5a0-283">開始されていないスレッドで `Abort` が呼び出されると、<xref:System.Threading.Thread.Start%2A> が呼び出されたときにスレッドが中止されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-283">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="8d5a0-284">ブロックされている、またはスリープ状態のスレッドで `Abort` が呼び出された場合、スレッドは中断されてから中止されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-284">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="8d5a0-285">中断されたスレッドで `Abort` が呼び出されると、<xref:System.Threading.Thread.Abort%2A>を呼び出したスレッドで <xref:System.Threading.ThreadStateException> がスローされ、中止されるスレッドの <xref:System.Threading.Thread.ThreadState%2A> プロパティに <xref:System.Threading.ThreadState.AbortRequested> が追加されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-285">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="8d5a0-286"><xref:System.Threading.Thread.Resume%2A> が呼び出されるまで、<xref:System.Threading.ThreadAbortException> は中断されたスレッドでスローされません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-286">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="8d5a0-287">アンマネージコードの実行中にマネージスレッドで `Abort` が呼び出された場合、そのスレッドがマネージコードに戻るまで、`ThreadAbortException` はスローされません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-287">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="8d5a0-288">`Abort` の2回の呼び出しが同時に発生した場合、1回の呼び出しで状態情報を設定し、もう一方の呼び出しで `Abort`を実行することができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-288">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="8d5a0-289">ただし、アプリケーションでこの状況を検出することはできません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-289">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="8d5a0-290">スレッドで `Abort` が呼び出されると、スレッドの状態に <xref:System.Threading.ThreadState.AbortRequested>が含まれます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-290">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="8d5a0-291">`Abort`の呼び出しが成功した結果としてスレッドが終了すると、スレッドの状態が <xref:System.Threading.ThreadState.Stopped>に変更されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-291">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="8d5a0-292">十分な権限を持っている場合、`Abort` のターゲットであるスレッドは、`ResetAbort` メソッドを使用して中止を取り消すことができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-292">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="8d5a0-293">`ResetAbort` メソッドの呼び出しを示す例については、`ThreadAbortException` クラスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-293">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="8d5a0-294">.NET Core のみ: このメンバーはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-294">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8d5a0-295">呼び出し元に、必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-295">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="8d5a0-296">中止しようとしているスレッドが現在中断されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-296">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="8d5a0-297">スレッドに対する高度な操作の場合。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-297">for advanced operations on threads.</span></span> <span data-ttu-id="8d5a0-298"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="8d5a0-298">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="8d5a0-299">スレッドおよびスレッド処理</span><span class="sxs-lookup"><span data-stu-id="8d5a0-299">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="8d5a0-300">スレッドの使用とスレッド処理</span><span class="sxs-lookup"><span data-stu-id="8d5a0-300">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="8d5a0-301">スレッドの破棄</span><span class="sxs-lookup"><span data-stu-id="8d5a0-301">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="stateInfo"><span data-ttu-id="8d5a0-302">中止するスレッドで使用できる、状態などのアプリケーション固有の情報を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-302">An object that contains application-specific information, such as state, which can be used by the thread being aborted.</span></span></param>
        <summary><span data-ttu-id="8d5a0-303">このメソッドが呼び出された対象のスレッドで、スレッドの終了プロセスを開始する <see cref="T:System.Threading.ThreadAbortException" /> を発生させます。またスレッドの終了に関する例外情報も提供します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-303">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</span></span> <span data-ttu-id="8d5a0-304">このメソッドを呼び出すと、通常、スレッドが終了します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-304">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-305">このメソッドがスレッドで呼び出されると、システムはスレッド内の <xref:System.Threading.ThreadAbortException> をスローして中止します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-305">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="8d5a0-306">`ThreadAbortException` は、アプリケーションコードでキャッチできる特殊な例外ですが、<xref:System.Threading.Thread.ResetAbort%2A> が呼び出されない限り、`catch` ブロックの最後に再スローされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-306">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="8d5a0-307">`ResetAbort` は、中止の要求をキャンセルし、`ThreadAbortException` がスレッドを終了できないようにします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-307">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="8d5a0-308">Unexecuted `finally` ブロックは、スレッドが中止される前に実行されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-308">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-309">スレッドがそれ自体で `Abort` を呼び出すと、その効果は例外をスローするのと似ています。<xref:System.Threading.ThreadAbortException> が直ちに発生し、結果は予測可能です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-309">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="8d5a0-310">ただし、あるスレッドが別のスレッドで `Abort` を呼び出した場合、abort は実行されているすべてのコードを中断します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-310">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="8d5a0-311">静的コンストラクターが中断される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-311">There is a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="8d5a0-312">まれに、そのクラスのインスタンスがそのアプリケーションドメインで作成されない場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-312">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="8d5a0-313">.NET Framework バージョン1.0 および1.1 では、`finally` ブロックの実行中にスレッドが中止される可能性があります。この場合、`finally` ブロックは中止されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-313">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="8d5a0-314">スレッドはすぐに中止されるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-314">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="8d5a0-315">この状況は、スレッドが中止プロシージャの一部として呼び出された `finally` ブロックで無制限の計算を実行した場合に発生する可能性があります。これにより、中止が無期限に遅延されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-315">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="8d5a0-316">スレッドが中止されるまで待機するには、<xref:System.Threading.Thread.Abort%2A> メソッドを呼び出した後にスレッドで <xref:System.Threading.Thread.Join%2A> メソッドを呼び出すことができますが、待機が終了する保証はありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-316">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee that the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-317">中断されているスレッドが、`catch` ブロック、`finally` ブロック、または制約された実行領域などのコードの保護された領域内にある場合、<xref:System.Threading.Thread.Abort%2A> を呼び出すスレッドがブロックする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-317">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="8d5a0-318"><xref:System.Threading.Thread.Abort%2A> を呼び出すスレッドが、中止されたスレッドが必要とするロックを保持している場合、デッドロックが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-318">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="8d5a0-319">開始されていないスレッドで `Abort` が呼び出されると、<xref:System.Threading.Thread.Start%2A> が呼び出されたときにスレッドが中止されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-319">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="8d5a0-320">ブロックされている、またはスリープ状態のスレッドで `Abort` が呼び出された場合、スレッドは中断されてから中止されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-320">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="8d5a0-321">中断されたスレッドで `Abort` が呼び出されると、<xref:System.Threading.Thread.Abort%2A>を呼び出したスレッドで <xref:System.Threading.ThreadStateException> がスローされ、中止されるスレッドの <xref:System.Threading.Thread.ThreadState%2A> プロパティに <xref:System.Threading.ThreadState.AbortRequested> が追加されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-321">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="8d5a0-322"><xref:System.Threading.Thread.Resume%2A> が呼び出されるまで、<xref:System.Threading.ThreadAbortException> は中断されたスレッドでスローされません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-322">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="8d5a0-323">アンマネージコードの実行中にマネージスレッドで `Abort` が呼び出された場合、そのスレッドがマネージコードに戻るまで、`ThreadAbortException` はスローされません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-323">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="8d5a0-324">`Abort` の2回の呼び出しが同時に発生した場合、1回の呼び出しで状態情報を設定し、もう一方の呼び出しで `Abort`を実行することができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-324">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="8d5a0-325">ただし、アプリケーションでこの状況を検出することはできません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-325">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="8d5a0-326">スレッドで `Abort` が呼び出されると、スレッドの状態に <xref:System.Threading.ThreadState.AbortRequested>が含まれます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-326">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="8d5a0-327">`Abort`の呼び出しが成功した結果としてスレッドが終了すると、スレッドの状態が <xref:System.Threading.ThreadState.Stopped>に変更されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-327">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="8d5a0-328">十分な権限を持っている場合、`Abort` のターゲットであるスレッドは、`ResetAbort` メソッドを使用して中止を取り消すことができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-328">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="8d5a0-329">`ResetAbort` メソッドの呼び出しを示す例については、`ThreadAbortException` クラスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-329">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-330">次のコード例は、中断されているスレッドに情報を渡す方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-330">The following code example shows how to pass information to a thread that is being aborted.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="8d5a0-331">.NET Core のみ: このメンバーはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-331">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8d5a0-332">呼び出し元に、必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-332">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="8d5a0-333">中止しようとしているスレッドが現在中断されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-333">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="8d5a0-334">スレッドに対する高度な操作の場合。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-334">for advanced operations on threads.</span></span> <span data-ttu-id="8d5a0-335"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="8d5a0-335">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="8d5a0-336">スレッドおよびスレッド処理</span><span class="sxs-lookup"><span data-stu-id="8d5a0-336">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="8d5a0-337">スレッドの使用とスレッド処理</span><span class="sxs-lookup"><span data-stu-id="8d5a0-337">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="8d5a0-338">スレッドの破棄</span><span class="sxs-lookup"><span data-stu-id="8d5a0-338">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-339">無名のデータ スロットをすべてのスレッドに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-339">Allocates an unnamed data slot on all the threads.</span></span> <span data-ttu-id="8d5a0-340">パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-340">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-341">すべてのスレッドに割り当てられた名前付きのデータ スロット。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-341">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d5a0-342">.NET Framework には、スレッドローカルストレージ (TLS) を使用するための2つのメカニズムが用意されています。スレッド相対静的フィールド (つまり、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールド) とデータスロットです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-342">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="8d5a0-343">スレッド相対静的フィールドは、データスロットよりもはるかに優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-343">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="8d5a0-344">TLS の使用の詳細については、「[スレッドローカルストレージ: スレッド相対静的フィールドとデータスロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-344">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="8d5a0-345">スロットはすべてのスレッドに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-345">The slot is allocated on all threads.</span></span>  
  
 <span data-ttu-id="8d5a0-346">スレッドは、ローカルストアのメモリ機構を使用して、スレッド固有のデータを格納します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-346">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="8d5a0-347">共通言語ランタイムは、作成時に各プロセスに複数スロットのデータストア配列を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-347">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="8d5a0-348">スレッドは、データストアにデータスロットを割り当て、スロットにデータ値を格納して取得し、スレッドの有効期限が切れた後で再利用できるようにスロットを解放します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-348">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="8d5a0-349">データスロットはスレッドごとに一意です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-349">Data slots are unique per thread.</span></span> <span data-ttu-id="8d5a0-350">他のスレッド (子スレッドでもありません) は、そのデータを取得できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-350">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-351">このセクションには、2 つのコード例が含まれています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-351">This section contains two code examples.</span></span> <span data-ttu-id="8d5a0-352">最初の例では、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-352">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="8d5a0-353">2番目の例では、データスロットを使用して同じ処理を行う方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-353">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="8d5a0-354">**最初の例**</span><span class="sxs-lookup"><span data-stu-id="8d5a0-354">**First Example**</span></span>  
  
 <span data-ttu-id="8d5a0-355">次の例は、<xref:System.ThreadStaticAttribute> でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-355">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="8d5a0-356">この手法は、2番目の例に示す手法よりもパフォーマンスが優れています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-356">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="8d5a0-357">**2番目の例**</span><span class="sxs-lookup"><span data-stu-id="8d5a0-357">**Second Example**</span></span>  
  
 <span data-ttu-id="8d5a0-358">データスロットを使用してスレッド固有の情報を格納する方法を次のコード例に示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-358">The following code example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="8d5a0-359">スレッドおよびスレッド処理</span><span class="sxs-lookup"><span data-stu-id="8d5a0-359">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="8d5a0-360">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</span><span class="sxs-lookup"><span data-stu-id="8d5a0-360">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8d5a0-361">割り当てられるデータ スロットの名前。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-361">The name of the data slot to be allocated.</span></span></param>
        <summary><span data-ttu-id="8d5a0-362">名前付きのデータ スロットをすべてのスレッドに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-362">Allocates a named data slot on all threads.</span></span> <span data-ttu-id="8d5a0-363">パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-363">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-364">すべてのスレッドに割り当てられた名前付きのデータ スロット。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-364">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d5a0-365">.NET Framework には、スレッドローカルストレージ (TLS) を使用するための2つのメカニズムが用意されています。スレッド相対静的フィールド (つまり、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールド) とデータスロットです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-365">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="8d5a0-366">スレッド相対静的フィールドは、データスロットよりもはるかに優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-366">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="8d5a0-367">TLS の使用の詳細については、「[スレッドローカルストレージ: スレッド相対静的フィールドとデータスロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-367">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="8d5a0-368">スレッドは、ローカルストアのメモリ機構を使用して、スレッド固有のデータを格納します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-368">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="8d5a0-369">共通言語ランタイムは、作成時に各プロセスに複数スロットのデータストア配列を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-369">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="8d5a0-370">スレッドは、データストアにデータスロットを割り当て、スロットにデータ値を格納して取得し、スレッドの有効期限が切れた後で再利用できるようにスロットを解放します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-370">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="8d5a0-371">データスロットはスレッドごとに一意です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-371">Data slots are unique per thread.</span></span> <span data-ttu-id="8d5a0-372">他のスレッド (子スレッドでもありません) は、そのデータを取得できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-372">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="8d5a0-373"><xref:System.Threading.Thread.AllocateNamedDataSlot%2A> メソッドを使用して名前付きデータスロットを割り当てる必要はありません。これは、<xref:System.Threading.Thread.GetNamedDataSlot%2A> メソッドが割り当てられていない場合にスロットが割り当てられるためです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-373">It is not necessary to use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method to allocate a named data slot, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-374"><xref:System.Threading.Thread.AllocateNamedDataSlot%2A> メソッドを使用する場合は、プログラムの起動時にメインスレッドで呼び出す必要があります。これは、指定した名前のスロットが既に割り当てられている場合に例外がスローされるためです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-374">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</span></span> <span data-ttu-id="8d5a0-375">スロットが既に割り当てられているかどうかをテストする方法はありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-375">There is no way to test whether a slot has already been allocated.</span></span>  
  
 <span data-ttu-id="8d5a0-376">このメソッドで割り当てられたスロットは、<xref:System.Threading.Thread.FreeNamedDataSlot%2A>で解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-376">Slots allocated with this method must be freed with <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-377">このセクションには、2 つのコード例が含まれています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-377">This section contains two code examples.</span></span> <span data-ttu-id="8d5a0-378">最初の例では、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-378">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="8d5a0-379">2番目の例では、データスロットを使用して同じ処理を行う方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-379">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="8d5a0-380">**最初の例**</span><span class="sxs-lookup"><span data-stu-id="8d5a0-380">**First Example**</span></span>  
  
 <span data-ttu-id="8d5a0-381">次の例は、<xref:System.ThreadStaticAttribute> でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-381">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="8d5a0-382">この手法は、2番目の例に示す手法よりもパフォーマンスが優れています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-382">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="8d5a0-383">**2番目の例**</span><span class="sxs-lookup"><span data-stu-id="8d5a0-383">**Second Example**</span></span>  
  
 <span data-ttu-id="8d5a0-384">次の例は、名前付きデータスロットを使用してスレッド固有の情報を格納する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-384">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-385">このコード例では、<xref:System.Threading.Thread.GetNamedDataSlot%2A> メソッドがまだ割り当てられていない場合にスロットを割り当てるため、<xref:System.Threading.Thread.AllocateNamedDataSlot%2A> メソッドは使用しません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-385">The example code does not use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span> <span data-ttu-id="8d5a0-386"><xref:System.Threading.Thread.AllocateNamedDataSlot%2A> メソッドを使用する場合は、プログラムの起動時にメインスレッドで呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-386">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d5a0-387">指定された名前の名前付きデータ スロットは、すでに存在します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-387">A named data slot with the specified name already exists.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="8d5a0-388">スレッドおよびスレッド処理</span><span class="sxs-lookup"><span data-stu-id="8d5a0-388">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="8d5a0-389">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</span><span class="sxs-lookup"><span data-stu-id="8d5a0-389">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d5a0-390">このスレッドのアパートメント状態を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-390">Gets or sets the apartment state of this thread.</span></span></summary>
        <value><span data-ttu-id="8d5a0-391"><see cref="T:System.Threading.ApartmentState" /> 値のいずれか 1 つです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-391">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span></span> <span data-ttu-id="8d5a0-392">初期値は <see langword="Unknown" /> です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-392">The initial value is <see langword="Unknown" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-393">**<xref:System.Threading.Thread.ApartmentState%2A> プロパティは互換性のために残されています。**</span><span class="sxs-lookup"><span data-stu-id="8d5a0-393">**The <xref:System.Threading.Thread.ApartmentState%2A> property is obsolete.**</span></span>  <span data-ttu-id="8d5a0-394">旧式ではない代替手段は、アパートメント状態を取得するための <xref:System.Threading.Thread.GetApartmentState%2A> メソッドと、アパートメント状態を設定するための <xref:System.Threading.Thread.SetApartmentState%2A> メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-394">The non-obsolete alternatives are the <xref:System.Threading.Thread.GetApartmentState%2A> method to retrieve the apartment state and the   <xref:System.Threading.Thread.SetApartmentState%2A> method to set the apartment state.</span></span>  
  
 <span data-ttu-id="8d5a0-395">.NET Framework バージョン1.0 および1.1 では、`ApartmentState` プロパティは、スレッドがシングルスレッドまたはマルチスレッドアパートメントで実行されることを示すようにマークします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-395">In the .NET Framework versions 1.0 and 1.1, the `ApartmentState` property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</span></span> <span data-ttu-id="8d5a0-396">このプロパティは、スレッドが `Unstarted` または `Running` スレッド状態のときに設定できます。ただし、スレッドに対して設定できるのは1回だけです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-396">This property can be set when the thread is in the `Unstarted` or `Running` thread state; however, it can be set only once for a thread.</span></span> <span data-ttu-id="8d5a0-397">プロパティが設定されていない場合は、`Unknown`を返します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-397">If the property has not been set, it returns `Unknown`.</span></span>  
  
 <span data-ttu-id="8d5a0-398"><xref:System.Threading.Thread.ApartmentState%2A> プロパティを使用して、アパートメント状態が既に設定されているスレッドのアパートメント状態を設定しようとしましたが、無視されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-398">An attempt to use the <xref:System.Threading.Thread.ApartmentState%2A> property to set the apartment state of a thread whose apartment state has already been set is ignored.</span></span> <span data-ttu-id="8d5a0-399">ただし、この場合は、<xref:System.Threading.Thread.SetApartmentState%2A> メソッドによって <xref:System.InvalidOperationException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-399">However, the <xref:System.Threading.Thread.SetApartmentState%2A> method throws a <xref:System.InvalidOperationException> in this case.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d5a0-400">.NET Framework バージョン2.0 では、開始する前にアパートメント状態が設定されていない場合、新しいスレッドは <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> として初期化されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-400">In the .NET Framework version 2.0, new threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="8d5a0-401">メインアプリケーションスレッドは、既定で <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> に初期化されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-401">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="8d5a0-402">最初のコード行で <xref:System.Threading.ApartmentState?displayProperty=nameWithType> プロパティを設定することにより、メインアプリケーションスレッドを <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> に設定できなくなりました。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-402">You can no longer set the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> by setting the <xref:System.Threading.ApartmentState?displayProperty=nameWithType> property on the first line of code.</span></span> <span data-ttu-id="8d5a0-403">代わりに <xref:System.STAThreadAttribute> を使用してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-403">Use the <xref:System.STAThreadAttribute> instead.</span></span>  
  
 <span data-ttu-id="8d5a0-404">.NET Framework バージョン2.0 では、 [/CLRTHREADATTRIBUTE (CLR スレッド属性の設定)](/cpp/build/reference/clrthreadattribute-set-clr-thread-attribute)リンカー C++オプションを使用して、アプリケーションの COM スレッドモデルを指定できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-404">In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](/cpp/build/reference/clrthreadattribute-set-clr-thread-attribute) linker option.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-405">次のコード例は、スレッドのアパートメント状態を設定する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-405">The following code example demonstrates how to set the apartment state of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d5a0-406">このプロパティを、有効ではないアパートメント状態に設定しようとしました (シングル スレッド アパートメント (<see langword="STA" />) またはマルチ スレッド アパートメント (<see langword="MTA" />) 以外の状態)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-406">An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<see langword="STA" />) or multithreaded apartment (<see langword="MTA" />)).</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-407">スレッドの中止または処理されない例外の影響によりアプリケーション ドメイン内の他のタスクが悪影響を受ける可能性があるコード領域に実行が入ることをホストに通知します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-407">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-408">Microsoft SQL Server 2005 などの共通言語ランタイム (CLR) のホストは、コードの重要な領域や重要ではない領域のエラーに対してさまざまなポリシーを確立できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-408">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="8d5a0-409">クリティカルな領域とは、スレッドの中止またはハンドルされない例外の影響が現在のタスクに限定されない場合があることです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-409">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="8d5a0-410">これに対し、クリティカルでないコード領域の中止または失敗は、エラーが発生したタスクにのみ影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-410">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="8d5a0-411">たとえば、ロックを保持しながらメモリの割り当てを試みるタスクを考えてみます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-411">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="8d5a0-412">メモリ割り当てが失敗した場合は、同じロックを待機している他のタスクがドメイン内に存在する可能性があるため、現在のタスクを中止するだけでは <xref:System.AppDomain>の安定性を確保することはできません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-412">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="8d5a0-413">現在のタスクが終了している場合は、他のタスクがデッドロックしている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-413">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="8d5a0-414">重大なリージョンで障害が発生した場合、ホストは、不安定な状態で実行を継続するリスクを負うのではなく、<xref:System.AppDomain> 全体をアンロードすることになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-414">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="8d5a0-415">コードがクリティカルな領域に入ることをホストに通知するには、<xref:System.Threading.Thread.BeginCriticalRegion%2A>を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-415">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="8d5a0-416">実行がコードの重要でない領域に戻るときに <xref:System.Threading.Thread.EndCriticalRegion%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-416">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="8d5a0-417">SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最高のホスト保護レベルでコードを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-417">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-418">次の例では、<xref:System.Threading.Thread.BeginCriticalRegion%2A> メソッドと <xref:System.Threading.Thread.EndCriticalRegion%2A> メソッドを使用して、コードのブロックを重要な領域と重要でない領域に分割する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-418">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-419">マネージド コードが現在のオペレーティング システムの物理スレッドの ID に依存する命令の実行を開始することをホストに通知します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-419">Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-420">Microsoft SQL Server 2005 などの共通言語ランタイムの一部のホストには、独自のスレッド管理が用意されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-420">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="8d5a0-421">独自のスレッド管理を提供するホストは、実行中のタスクを1つの物理オペレーティングシステムスレッドから別のシステムスレッドにいつでも移動できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-421">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="8d5a0-422">ほとんどのタスクはこの切り替えの影響を受けません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-422">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="8d5a0-423">ただし、スレッドアフィニティがあるタスクもあります。つまり、オペレーティングシステムの物理スレッドの id によって異なります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-423">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="8d5a0-424">これらのタスクは、切り替える必要があるコードを実行するときに、ホストに通知する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-424">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="8d5a0-425">たとえば、アプリケーションがシステム API を呼び出して、Win32 CRITICAL_SECTION などのスレッドアフィニティを持つオペレーティングシステムロックを取得する場合は、ロックを取得する前に <xref:System.Threading.Thread.BeginThreadAffinity%2A> を呼び出し、ロックを解放した後で <xref:System.Threading.Thread.EndThreadAffinity%2A> する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-425">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="8d5a0-426">SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最高のホスト保護レベルでコードを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-426">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-427">次の例は、<xref:System.Threading.Thread.BeginThreadAffinity%2A> および <xref:System.Threading.Thread.EndThreadAffinity%2A> メソッドを使用して、コードのブロックが物理オペレーティングシステムのスレッドの id に依存することをホストに通知する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-427">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8d5a0-428">呼び出し元に、必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-428">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="8d5a0-429">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-429">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="8d5a0-430">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-430">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d5a0-431">スレッドが実行されている現在のコンテキストを取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-431">Gets the current context in which the thread is executing.</span></span></summary>
        <value><span data-ttu-id="8d5a0-432">現在のスレッド コンテキストを表す <see cref="T:System.Runtime.Remoting.Contexts.Context" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-432">A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> representing the current thread context.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8d5a0-433">呼び出し元に、必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-433">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="8d5a0-434">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-434">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="8d5a0-435">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-435">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d5a0-436">現在のスレッドのカルチャを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-436">Gets or sets the culture for the current thread.</span></span></summary>
        <value><span data-ttu-id="8d5a0-437">現在のスレッドでカルチャを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-437">An object that represents the culture for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-438">このプロパティによって返される <xref:System.Globalization.CultureInfo> オブジェクトは、関連付けられたオブジェクトと共に、日付、時刻、数値、通貨値、テキストの並べ替え順序、大文字小文字の表記規則、および文字列比較の既定の形式を決定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-438">The <xref:System.Globalization.CultureInfo> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</span></span> <span data-ttu-id="8d5a0-439">カルチャの名前と識別子、インバリアント、ニュートラル、および特定のカルチャの違い、およびカルチャ情報がスレッドとアプリケーションドメインに与える影響については、<xref:System.Globalization.CultureInfo> クラスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-439">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="8d5a0-440">スレッドの既定のカルチャがどのように決定されるか、およびユーザーのコンピューターのカルチャ情報を設定する方法については、<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> プロパティを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-440">See the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="8d5a0-441">現在のスレッド以外のスレッドで使用する場合、<xref:System.Threading.Thread.CurrentCulture> プロパティは確実に動作しません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-441">The <xref:System.Threading.Thread.CurrentCulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="8d5a0-442">.NET Framework では、プロパティの読み取りは信頼できますが、現在のスレッド以外のスレッドに対して設定することは可能です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-442">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="8d5a0-443">.NET Core では、スレッドが別のスレッドで <xref:System.Threading.Thread.CurrentCulture> プロパティの読み取りまたは書き込みを行おうとすると、<xref:System.InvalidOperationException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-443">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentCulture> property on a different thread.</span></span>
> <span data-ttu-id="8d5a0-444">現在のカルチャを取得して設定するには、<xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> プロパティを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-444">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="8d5a0-445">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、<xref:System.Threading.Thread.CurrentCulture%2A> プロパティをニュートラルカルチャに設定できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-445">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], you can set the <xref:System.Threading.Thread.CurrentCulture%2A> property to a neutral culture.</span></span> <span data-ttu-id="8d5a0-446">これは、<xref:System.Globalization.CultureInfo> クラスの動作が変更されたためです。ニュートラルカルチャを表す場合、そのプロパティ値 (特に、<xref:System.Globalization.CultureInfo.Calendar%2A>、<xref:System.Globalization.CultureInfo.CompareInfo%2A>、<xref:System.Globalization.CultureInfo.DateTimeFormat%2A>、<xref:System.Globalization.CultureInfo.NumberFormat%2A>、および <xref:System.Globalization.CultureInfo.TextInfo%2A> の各プロパティ) は、ニュートラルカルチャに関連付けられている特定のカルチャを反映するようになりました。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-446">This is because the behavior of the <xref:System.Globalization.CultureInfo> class has changed: When it represents a neutral culture, its property values (in particular, the <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, and <xref:System.Globalization.CultureInfo.TextInfo%2A> properties) now reflect the specific culture that is associated with the neutral culture.</span></span> <span data-ttu-id="8d5a0-447">以前のバージョンの .NET Framework では、<xref:System.Threading.Thread.CurrentCulture%2A> プロパティは、ニュートラルカルチャが割り当てられたときに <xref:System.NotSupportedException> 例外をスローしました。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-447">In earlier versions of the .NET Framework, the <xref:System.Threading.Thread.CurrentCulture%2A> property threw a <xref:System.NotSupportedException> exception when a neutral culture was assigned.</span></span>  
  
## Examples  
 <span data-ttu-id="8d5a0-448">次の例は、Windows フォームアプリケーションのユーザーインターフェイスを、コントロールパネルで設定されているカルチャで表示できるようにするスレッドステートメントを示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-448">The following example shows the threading statement that allows the user interface of a Windows Forms application to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="8d5a0-449">追加のコードが必要です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-449">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d5a0-450">プロパティが <see langword="null" /> に設定されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-450">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8d5a0-451">.NET Core のみ: 別のスレッドからのスレッドのカルチャの読み取りまたは書き込みはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-451">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="8d5a0-452">プロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-452">for setting the property.</span></span> <span data-ttu-id="8d5a0-453">関連付けられた列挙型: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="8d5a0-453">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d5a0-454">ロールベースのセキュリティに関する、スレッドの現在のプリンシパルを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-454">Gets or sets the thread's current principal (for role-based security).</span></span></summary>
        <value><span data-ttu-id="8d5a0-455">セキュリティ コンテキストを表す <see cref="T:System.Security.Principal.IPrincipal" /> 値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-455">An <see cref="T:System.Security.Principal.IPrincipal" /> value representing the security context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8d5a0-456">次のコード例は、スレッドのプリンシパルを設定および取得する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-456">The following code example shows how to set and retrieve the principal of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8d5a0-457">呼び出し元に、プリンシパルを設定するために必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-457">The caller does not have the permission required to set the principal.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="8d5a0-458">プリンシパルオブジェクトを操作します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-458">to manipulate the principal object.</span></span> <span data-ttu-id="8d5a0-459"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="8d5a0-459">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d5a0-460">現在実行中のスレッドを取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-460">Gets the currently running thread.</span></span></summary>
        <value><span data-ttu-id="8d5a0-461">現在実行中のスレッドを表す <see cref="T:System.Threading.Thread" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-461">A <see cref="T:System.Threading.Thread" /> that is the representation of the currently running thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8d5a0-462">次の例では、20個の子タスクを作成するタスクを作成します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-462">The following example creates a task that in turn creates 20 child tasks.</span></span> <span data-ttu-id="8d5a0-463">アプリケーション自体と各タスクは、`ShowThreadInformation` メソッドを呼び出します。このメソッドは、<xref:System.Threading.Thread.CurrentThread%2A> プロパティを使用して、実行されているスレッドに関する情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-463">The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the <xref:System.Threading.Thread.CurrentThread%2A> property  to display information about the thread on which it is running.</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 <span data-ttu-id="8d5a0-464">各子タスクは、1 ~ 100万の範囲で100万の乱数を生成し、その平均値を返します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-464">Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</span></span> <span data-ttu-id="8d5a0-465">親タスクは、<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> メソッドを呼び出して、各タスクによって返される平均値を表示し、平均値を計算する前に、子タスクが完了したことを確認します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-465">The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</span></span>  
  
 <span data-ttu-id="8d5a0-466">アプリケーションがフォアグラウンドスレッドで実行されている間、各タスクはスレッドプールのスレッドで実行されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-466">Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d5a0-467">実行時にカルチャ固有のリソースを検索するためにリソース マネージャーで使用される、現在のカルチャを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-467">Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</span></span></summary>
        <value><span data-ttu-id="8d5a0-468">現在のカルチャを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-468">An object that represents the current culture.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-469">UI カルチャは、ユーザーの入力と出力をサポートするためにアプリケーションが必要とするリソースを指定します。既定では、オペレーティングシステムのカルチャと同じです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-469">The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</span></span> <span data-ttu-id="8d5a0-470">カルチャの名前と識別子、インバリアント、ニュートラル、および特定のカルチャの違い、およびカルチャ情報がスレッドとアプリケーションドメインに与える影響については、<xref:System.Globalization.CultureInfo> クラスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-470">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="8d5a0-471">スレッドの既定の UI カルチャがどのように決定されるかについては、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> プロパティを参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-471">See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> property to learn how a thread's default UI culture is determined.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="8d5a0-472">現在のスレッド以外のスレッドで使用する場合、<xref:System.Threading.Thread.CurrentUICulture> プロパティは確実に動作しません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-472">The <xref:System.Threading.Thread.CurrentUICulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="8d5a0-473">.NET Framework では、プロパティの読み取りは信頼できますが、現在のスレッド以外のスレッドに対して設定することは可能です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-473">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="8d5a0-474">.NET Core では、スレッドが別のスレッドで <xref:System.Threading.Thread.CurrentUICulture> プロパティの読み取りまたは書き込みを行おうとすると、<xref:System.InvalidOperationException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-474">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentUICulture> property on a different thread.</span></span>
> <span data-ttu-id="8d5a0-475">現在のカルチャを取得して設定するには、<xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> プロパティを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-475">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="8d5a0-476">このプロパティによって返される <xref:System.Globalization.CultureInfo> は、ニュートラルカルチャにすることができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-476">The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture.</span></span> <span data-ttu-id="8d5a0-477">ニュートラルカルチャは、<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>、<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>、<xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>などの書式指定メソッドでは使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-477">Neutral cultures should not be used with formatting methods such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d5a0-478"><xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> メソッドを使用して特定のカルチャを取得するか、<xref:System.Threading.Thread.CurrentCulture%2A> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-478">Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-479"><xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> メソッドは、ニュートラルカルチャ "zh-tw-Zh-hant" ("zh-tw") と "zh-tw-Hans" ("zh-tw-CHS") に対して <xref:System.ArgumentException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-479">The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method throws <xref:System.ArgumentException> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-480">次の例では、現在のスレッドの UI カルチャの言語がフランス語であるかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-480">The following example determines whether the language of the current thread's UI culture is French.</span></span> <span data-ttu-id="8d5a0-481">そうでない場合は、現在のスレッドの UI カルチャを英語 (米国) に設定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-481">If it is not, it sets the UI culture of the current thread to English (United States).</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 <span data-ttu-id="8d5a0-482">次のコード例は、Windows フォームのユーザーインターフェイスをコントロールパネルで設定されているカルチャで表示できるようにするスレッドステートメントを示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-482">The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="8d5a0-483">追加のコードが必要です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-483">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="8d5a0-484">プロパティが <see langword="null" /> に設定されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-484">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d5a0-485">プロパティが、リソース ファイルの検索に使用できないカルチャ名に設定されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-485">The property is set to a culture name that cannot be used to locate a resource file.</span></span> <span data-ttu-id="8d5a0-486">リソース ファイル名に使用できるのは、文字、数字、ハイフン、またはアンダースコアのみです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-486">Resource filenames must include only letters, numbers, hyphens or underscores.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8d5a0-487">.NET Core のみ: 別のスレッドからのスレッドのカルチャの読み取りまたは書き込みはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-487">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-488">現在のスレッドのランタイム呼び出し可能ラッパー (RCW: Runtime Callable Wrapper) の自動クリーンアップをオフにします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-488">Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-489">既定では、共通言語ランタイム (CLR) はランタイム呼び出し可能ラッパーを自動的にクリーンアップします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-489">By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</span></span> <span data-ttu-id="8d5a0-490">CLR はクリーンアップ中にメッセージをポンプするため、次のような通常とは異なる条件を満たす少数のアプリケーションに対して再入の問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-490">The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</span></span>  
  
-   <span data-ttu-id="8d5a0-491">アプリケーションは、独自のメッセージポンプを行います。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-491">The application does its own message pumping.</span></span>  
  
-   <span data-ttu-id="8d5a0-492">アプリケーションは、メッセージポンプがいつ発生するかを正確に制御する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-492">The application needs to control precisely when message pumping occurs.</span></span>  
  
 <span data-ttu-id="8d5a0-493">このようなアプリケーションでは、<xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> メソッドを使用して、CLR がランタイム呼び出し可能ラッパーを自動再生できないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-493">Such applications can use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</span></span>  
  
 <span data-ttu-id="8d5a0-494">スレッドでこのメソッドが呼び出されると、そのスレッドに対して自動クリーンアップを再び有効にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-494">When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</span></span> <span data-ttu-id="8d5a0-495">アプリケーションでランタイム呼び出し可能ラッパーをクリーンアップする準備ができたら、<xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> メソッドを使用して、現在のコンテキストのすべてのランタイム呼び出し可能ラッパーをクリーンアップするようにランタイムに指示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-495">When your application is ready to clean up runtime callable wrappers, use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</span></span> <span data-ttu-id="8d5a0-496">メッセージポンプは、メソッドの実行中に発生します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-496">Message pumping occurs while the method executes.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="8d5a0-497">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-497">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="8d5a0-498">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-498">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-499">スレッドの中止または処理されない例外の影響が現在のタスクだけに及ぶコード領域に実行が入ることをホストに通知します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-499">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-500">Microsoft SQL Server 2005 などの共通言語ランタイム (CLR) のホストは、コードの重要な領域や重要ではない領域のエラーに対してさまざまなポリシーを確立できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-500">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="8d5a0-501">クリティカルな領域とは、スレッドの中止またはハンドルされない例外の影響が現在のタスクに限定されない場合があることです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-501">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="8d5a0-502">これに対し、クリティカルでないコード領域の中止または失敗は、エラーが発生したタスクにのみ影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-502">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="8d5a0-503">たとえば、ロックを保持しながらメモリの割り当てを試みるタスクを考えてみます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-503">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="8d5a0-504">メモリ割り当てが失敗した場合は、同じロックを待機している他のタスクがドメイン内に存在する可能性があるため、現在のタスクを中止するだけでは <xref:System.AppDomain>の安定性を確保することはできません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-504">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="8d5a0-505">現在のタスクが終了している場合は、他のタスクがデッドロックしている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-505">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="8d5a0-506">重大なリージョンで障害が発生した場合、ホストは、不安定な状態で実行を継続するリスクを負うのではなく、<xref:System.AppDomain> 全体をアンロードすることになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-506">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="8d5a0-507">コードがクリティカルな領域に入ることをホストに通知するには、<xref:System.Threading.Thread.BeginCriticalRegion%2A>を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-507">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="8d5a0-508">実行がコードの重要でない領域に戻るときに <xref:System.Threading.Thread.EndCriticalRegion%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-508">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="8d5a0-509">SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最高のホスト保護レベルでコードを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-509">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-510">次の例では、<xref:System.Threading.Thread.BeginCriticalRegion%2A> メソッドと <xref:System.Threading.Thread.EndCriticalRegion%2A> メソッドを使用して、コードのブロックを重要な領域と重要でない領域に分割する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-510">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-511">マネージド コードが現在のオペレーティング システムの物理スレッドの ID に依存する命令の実行を完了したことをホストに通知します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-511">Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-512">Microsoft SQL Server 2005 などの共通言語ランタイムの一部のホストには、独自のスレッド管理が用意されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-512">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="8d5a0-513">独自のスレッド管理を提供するホストは、実行中のタスクを1つの物理オペレーティングシステムスレッドから別のシステムスレッドにいつでも移動できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-513">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="8d5a0-514">ほとんどのタスクはこの切り替えの影響を受けません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-514">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="8d5a0-515">ただし、スレッドアフィニティがあるタスクもあります。つまり、オペレーティングシステムの物理スレッドの id によって異なります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-515">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="8d5a0-516">これらのタスクは、切り替える必要があるコードを実行するときに、ホストに通知する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-516">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="8d5a0-517">たとえば、アプリケーションがシステム API を呼び出して、Win32 CRITICAL_SECTION などのスレッドアフィニティを持つオペレーティングシステムロックを取得する場合は、ロックを取得する前に <xref:System.Threading.Thread.BeginThreadAffinity%2A> を呼び出し、ロックを解放した後で <xref:System.Threading.Thread.EndThreadAffinity%2A> する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-517">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="8d5a0-518">SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最高のホスト保護レベルでコードを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-518">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-519">次の例は、<xref:System.Threading.Thread.BeginThreadAffinity%2A> および <xref:System.Threading.Thread.EndThreadAffinity%2A> メソッドを使用して、コードのブロックが物理オペレーティングシステムのスレッドの id に依存することをホストに通知する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-519">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8d5a0-520">呼び出し元に、必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-520">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="8d5a0-521">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-521">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="8d5a0-522">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-522">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d5a0-523">現在のスレッドのさまざまなコンテキストに関する情報を格納する <see cref="T:System.Threading.ExecutionContext" /> オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-523">Gets an <see cref="T:System.Threading.ExecutionContext" /> object that contains information about the various contexts of the current thread.</span></span></summary>
        <value><span data-ttu-id="8d5a0-524">現在のスレッドのコンテキスト情報を統合する <see cref="T:System.Threading.ExecutionContext" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-524">An <see cref="T:System.Threading.ExecutionContext" /> object that consolidates context information for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-525"><xref:System.Threading.ExecutionContext> クラスは、実行の論理スレッドに関連するすべての情報に対して1つのコンテナーを提供します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-525">The <xref:System.Threading.ExecutionContext> class provides a single container for all information relevant to a logical thread of execution.</span></span> <span data-ttu-id="8d5a0-526">これには、セキュリティコンテキスト、呼び出しコンテキスト、同期コンテキスト、ローカリゼーションコンテキスト、およびトランザクションコンテキストが含まれます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-526">This includes security context, call context, synchronization context, localization context, and transaction context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-527">ガベージ コレクターが <see cref="T:System.Threading.Thread" /> オブジェクトを再利用しているときに、リソースが解放され、他のクリーンアップ操作が確実に実行されるようにします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-527">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.Thread" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-528">現在のオブジェクトを完了する準備が整うと、ガベージコレクターは <xref:System.Threading.Thread.Finalize%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-528">The garbage collector calls <xref:System.Threading.Thread.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8d5a0-529">解放されるデータ スロットの名前。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-529">The name of the data slot to be freed.</span></span></param>
        <summary><span data-ttu-id="8d5a0-530">プロセス内のすべてのスレッドに関して、名前とスロットの関連付けを解除します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-530">Eliminates the association between a name and a slot, for all threads in the process.</span></span> <span data-ttu-id="8d5a0-531">パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-531">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d5a0-532">.NET Framework には、スレッドローカルストレージ (TLS) を使用するための2つのメカニズムが用意されています。スレッド相対静的フィールド (つまり、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールド) とデータスロットです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-532">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="8d5a0-533">スレッド相対静的フィールドは、データスロットよりもはるかに優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-533">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="8d5a0-534">TLS の使用の詳細については、「[スレッドローカルストレージ: スレッド相対静的フィールドとデータスロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-534">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="8d5a0-535">任意のスレッドが `FreeNamedDataSlot`を呼び出すと、同じ名前の <xref:System.Threading.Thread.GetNamedDataSlot%2A> を呼び出す他のスレッドは、その名前に関連付けられた新しいスロットを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-535">After any thread calls `FreeNamedDataSlot`, any other thread that calls <xref:System.Threading.Thread.GetNamedDataSlot%2A> with the same name will allocate a new slot associated with the name.</span></span> <span data-ttu-id="8d5a0-536">その後、任意のスレッドによって `GetNamedDataSlot` を呼び出すと、新しいスロットが返されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-536">Subsequent calls to `GetNamedDataSlot` by any thread will return the new slot.</span></span> <span data-ttu-id="8d5a0-537">ただし、以前の `GetNamedDataSlot` の呼び出しによって返された <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> を持つスレッドは、引き続き古いスロットを使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-537">However, any thread that still has a <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> returned by an earlier call to `GetNamedDataSlot` can continue to use the old slot.</span></span>  
  
 <span data-ttu-id="8d5a0-538">名前に関連付けられているスロットは、`FreeNamedDataSlot` の呼び出しの前に取得されたすべての `LocalDataStoreSlot` が解放され、ガベージコレクトされた場合にのみ解放されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-538">A slot that has been associated with a name is released only when every `LocalDataStoreSlot` that was obtained prior to the call to `FreeNamedDataSlot` has been released and garbage-collected.</span></span>  
  
 <span data-ttu-id="8d5a0-539">スレッドは、ローカルストアのメモリ機構を使用して、スレッド固有のデータを格納します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-539">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="8d5a0-540">共通言語ランタイムは、作成時に各プロセスに複数スロットのデータストア配列を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-540">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="8d5a0-541">スレッドは、データストアにデータスロットを割り当て、スロットにデータ値を格納して取得し、スレッドの有効期限が切れた後で再利用できるようにスロットを解放します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-541">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="8d5a0-542">データスロットはスレッドごとに一意です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-542">Data slots are unique per thread.</span></span> <span data-ttu-id="8d5a0-543">他のスレッド (子スレッドでもありません) は、そのデータを取得できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-543">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-544">このセクションには、2 つのコード例が含まれています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-544">This section contains two code examples.</span></span> <span data-ttu-id="8d5a0-545">最初の例では、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-545">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="8d5a0-546">2番目の例では、データスロットを使用して同じ処理を行う方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-546">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="8d5a0-547">**最初の例**</span><span class="sxs-lookup"><span data-stu-id="8d5a0-547">**First Example**</span></span>  
  
 <span data-ttu-id="8d5a0-548">次の例は、<xref:System.ThreadStaticAttribute> でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-548">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="8d5a0-549">この手法は、2番目の例に示す手法よりもパフォーマンスが優れています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-549">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="8d5a0-550">**2番目の例**</span><span class="sxs-lookup"><span data-stu-id="8d5a0-550">**Second Example**</span></span>  
  
 <span data-ttu-id="8d5a0-551">次の例は、名前付きデータスロットを使用してスレッド固有の情報を格納する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-551">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="8d5a0-552">スレッドおよびスレッド処理</span><span class="sxs-lookup"><span data-stu-id="8d5a0-552">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="8d5a0-553">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</span><span class="sxs-lookup"><span data-stu-id="8d5a0-553">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-554">アパートメント状態を示す <see cref="T:System.Threading.ApartmentState" /> 値を返します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-554">Returns an <see cref="T:System.Threading.ApartmentState" /> value indicating the apartment state.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-555">マネージド スレッドのアパートメント状態を示す <see cref="T:System.Threading.ApartmentState" /> 値の 1 つ。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-555">One of the <see cref="T:System.Threading.ApartmentState" /> values indicating the apartment state of the managed thread.</span></span> <span data-ttu-id="8d5a0-556">既定では、 <see cref="F:System.Threading.ApartmentState.Unknown" />です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-556">The default is <see cref="F:System.Threading.ApartmentState.Unknown" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-557">このメソッドと共に、<xref:System.Threading.Thread.SetApartmentState%2A> メソッドと <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドを使用して、<xref:System.Threading.Thread.ApartmentState%2A> プロパティを置き換えます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-557">This method, along with the <xref:System.Threading.Thread.SetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-558">次のコード例は、<xref:System.Threading.Thread.GetApartmentState%2A>、<xref:System.Threading.Thread.SetApartmentState%2A>、および <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-558">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="8d5a0-559">このコード例では、スレッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-559">The code example creates a thread.</span></span> <span data-ttu-id="8d5a0-560">スレッドが開始される前に、<xref:System.Threading.Thread.GetApartmentState%2A> は初期の <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> の状態を表示し、<xref:System.Threading.Thread.SetApartmentState%2A> 状態を <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>に変更します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-560">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d5a0-561"><xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドは、アパートメント状態が既に設定されているために状態を <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> に変更しようとしたときに `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-561">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="8d5a0-562"><xref:System.Threading.Thread.SetApartmentState%2A>で同じ操作が試行された場合、<xref:System.InvalidOperationException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-562">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="8d5a0-563">スレッドが開始されると、<xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドが再び使用されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-563">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="8d5a0-564">今回は、スレッドが既に開始されているため <xref:System.Threading.ThreadStateException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-564">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-565">現在のスレッドのスタックをキャプチャするために使用できる <see cref="T:System.Threading.CompressedStack" /> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-565">Returns a <see cref="T:System.Threading.CompressedStack" /> object that can be used to capture the stack for the current thread.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-566">[なし]。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-566">None.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-567">このメソッドはサポートされなくなりました。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-567">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8d5a0-568">すべての場合。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-568">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="8d5a0-569">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-569">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="8d5a0-570">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-570">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-571">現在のスレッドが実行されているプロセッサを示すために使用される ID を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-571">Gets an ID used to indicate on which processor the current thread is executing.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-572">キャッシュされたプロセッサ ID を表す整数。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-572">An integer representing the cached processor ID.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="8d5a0-573">この値はキャッシュされ、定期的に更新されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-573">This value is cached and periodically refreshed.</span></span> <span data-ttu-id="8d5a0-574">使用された時間によって古くなっている可能性があります。コードを使用する場合、正確性に依存しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-574">It may be stale by the time it's used: consuming code must not rely on its accuracy for correctness.</span></span>

<span data-ttu-id="8d5a0-575">値は、0から始まるプロセッサ番号であることは保証されていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-575">The value is not guaranteed to be a zero-based processor number.</span></span>

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="8d5a0-576">値の取得元の <see cref="T:System.LocalDataStoreSlot" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-576">The <see cref="T:System.LocalDataStoreSlot" /> from which to get the value.</span></span></param>
        <summary><span data-ttu-id="8d5a0-577">現在のスレッドの現在のドメイン内で指定した現在のスレッドのスロットから値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-577">Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</span></span> <span data-ttu-id="8d5a0-578">パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-578">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-579">取得された値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-579">The retrieved value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d5a0-580">.NET Framework には、スレッドローカルストレージ (TLS) を使用するための2つのメカニズムが用意されています。スレッド相対静的フィールド (つまり、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールド) とデータスロットです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-580">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="8d5a0-581">スレッド相対静的フィールドは、データスロットよりもはるかに優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-581">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="8d5a0-582">TLS の使用の詳細については、「[スレッドローカルストレージ: スレッド相対静的フィールドとデータスロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-582">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="8d5a0-583">スレッドは、ローカルストアのメモリ機構を使用して、スレッド固有のデータを格納します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-583">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="8d5a0-584">共通言語ランタイムは、作成時に各プロセスに複数スロットのデータストア配列を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-584">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="8d5a0-585">スレッドは、データストアにデータスロットを割り当て、スロットにデータ値を格納して取得し、スレッドの有効期限が切れた後で再利用できるようにスロットを解放します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-585">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="8d5a0-586">データスロットはスレッドごとに一意です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-586">Data slots are unique per thread.</span></span> <span data-ttu-id="8d5a0-587">他のスレッド (子スレッドでもありません) は、そのデータを取得できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-587">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-588"><xref:System.Threading.Thread.GetData%2A> は、別のスレッドを参照する変数を使用して呼び出した場合でも、常に現在実行中のスレッドに適用される `Shared` メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-588"><xref:System.Threading.Thread.GetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="8d5a0-589">混乱を避けるために、`Shared` メソッドを呼び出すときにクラス名を使用します: `Dim test As Object = Thread.GetData(testSlot)`。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-589">To avoid confusion, use the class name when calling `Shared` methods: `Dim test As Object = Thread.GetData(testSlot)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-590">このセクションには、2 つのコード例が含まれています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-590">This section contains two code examples.</span></span> <span data-ttu-id="8d5a0-591">最初の例では、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-591">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="8d5a0-592">2番目の例では、データスロットを使用して同じ処理を行う方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-592">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="8d5a0-593">**最初の例**</span><span class="sxs-lookup"><span data-stu-id="8d5a0-593">**First Example**</span></span>  
  
 <span data-ttu-id="8d5a0-594">次の例は、<xref:System.ThreadStaticAttribute> でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-594">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="8d5a0-595">この手法は、2番目の例に示す手法よりもパフォーマンスが優れています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-595">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="8d5a0-596">**2番目の例**</span><span class="sxs-lookup"><span data-stu-id="8d5a0-596">**Second Example**</span></span>  
  
 <span data-ttu-id="8d5a0-597">次の例は、データスロットを使用してスレッド固有の情報を格納する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-597">The following example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="8d5a0-598">スレッドおよびスレッド処理</span><span class="sxs-lookup"><span data-stu-id="8d5a0-598">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="8d5a0-599">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</span><span class="sxs-lookup"><span data-stu-id="8d5a0-599">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-600">現在のスレッドが実行されている現在のドメインを返します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-600">Returns the current domain in which the current thread is running.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-601">実行中のスレッドの現在のアプリケーション ドメインを表す <see cref="T:System.AppDomain" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-601">An <see cref="T:System.AppDomain" /> representing the current application domain of the running thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8d5a0-602">次のコード例は、スレッドが実行されている `AppDomain` の名前と ID を取得する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-602">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-603">一意のアプリケーション ドメイン識別子を返します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-603">Returns a unique application domain identifier.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-604">アプリケーション ドメインを一意に識別する 32 ビット符号付き整数。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-604">A 32-bit signed integer uniquely identifying the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8d5a0-605">次のコード例は、スレッドが実行されている `AppDomain` の名前と ID を取得する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-605">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-606">現在のスレッドのハッシュ コードを返します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-606">Returns a hash code for the current thread.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-607">整数ハッシュ コード値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-607">An integer hash code value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-608">ハッシュコードが一意であることは保証されていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-608">The hash code is not guaranteed to be unique.</span></span> <span data-ttu-id="8d5a0-609">マネージスレッドの一意の識別子が必要な場合は、<xref:System.Threading.Thread.ManagedThreadId%2A> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-609">Use the <xref:System.Threading.Thread.ManagedThreadId%2A> property if you need a unique identifier for a managed thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="8d5a0-610">ローカル データ スロットの名前。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-610">The name of the local data slot.</span></span></param>
        <summary><span data-ttu-id="8d5a0-611">名前付きデータ スロットを検索します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-611">Looks up a named data slot.</span></span> <span data-ttu-id="8d5a0-612">パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-612">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-613">このスレッドに割り当てられた <see cref="T:System.LocalDataStoreSlot" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-613">A <see cref="T:System.LocalDataStoreSlot" /> allocated for this thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d5a0-614">.NET Framework には、スレッドローカルストレージ (TLS) を使用するための2つのメカニズムが用意されています。スレッド相対静的フィールド (つまり、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールド) とデータスロットです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-614">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="8d5a0-615">スレッド相対静的フィールドは、データスロットよりもはるかに優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-615">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="8d5a0-616">TLS の使用の詳細については、「[スレッドローカルストレージ: スレッド相対静的フィールドとデータスロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-616">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="8d5a0-617">スレッドは、ローカルストアのメモリ機構を使用して、スレッド固有のデータを格納します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-617">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="8d5a0-618">共通言語ランタイムは、作成時に各プロセスに複数スロットのデータストア配列を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-618">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="8d5a0-619">スレッドは、データストアにデータスロットを割り当て、スロットにデータ値を格納して取得し、スレッドの有効期限が切れた後で再利用できるようにスロットを解放します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-619">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="8d5a0-620">データスロットはスレッドごとに一意です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-620">Data slots are unique per thread.</span></span> <span data-ttu-id="8d5a0-621">他のスレッド (子スレッドでもありません) は、そのデータを取得できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-621">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="8d5a0-622">名前付きスロットが存在しない場合は、新しいスロットが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-622">If the named slot does not exist, a new slot is allocated.</span></span> <span data-ttu-id="8d5a0-623">名前付きデータスロットはパブリックであり、だれでも操作できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-623">Named data slots are public and can be manipulated by anyone.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-624">このセクションには、2 つのコード例が含まれています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-624">This section contains two code examples.</span></span> <span data-ttu-id="8d5a0-625">最初の例では、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-625">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="8d5a0-626">2番目の例では、データスロットを使用して同じ処理を行う方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-626">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="8d5a0-627">**最初の例**</span><span class="sxs-lookup"><span data-stu-id="8d5a0-627">**First Example**</span></span>  
  
 <span data-ttu-id="8d5a0-628">次の例は、<xref:System.ThreadStaticAttribute> でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-628">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="8d5a0-629">この手法は、2番目の例に示す手法よりもパフォーマンスが優れています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-629">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="8d5a0-630">**2番目の例**</span><span class="sxs-lookup"><span data-stu-id="8d5a0-630">**Second Example**</span></span>  
  
 <span data-ttu-id="8d5a0-631">次の例は、名前付きデータスロットを使用してスレッド固有の情報を格納する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-631">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="8d5a0-632">スレッドおよびスレッド処理</span><span class="sxs-lookup"><span data-stu-id="8d5a0-632">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="8d5a0-633">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</span><span class="sxs-lookup"><span data-stu-id="8d5a0-633">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-634"><see cref="F:System.Threading.ThreadState.WaitSleepJoin" /> スレッド状態のスレッドを中断します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-634">Interrupts a thread that is in the <see cref="F:System.Threading.ThreadState.WaitSleepJoin" /> thread state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-635">このスレッドが現在待機中、スリープ状態、または参加状態でブロックされていない場合は、次にブロックが開始されると中断されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-635">If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</span></span>  
  
 <span data-ttu-id="8d5a0-636"><xref:System.Threading.ThreadInterruptedException> は、中断されたスレッドでスローされますが、スレッドがブロックされるまではスローされません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-636"><xref:System.Threading.ThreadInterruptedException> is thrown in the interrupted thread, but not until the thread blocks.</span></span> <span data-ttu-id="8d5a0-637">スレッドがブロックされない場合、例外はスローされないため、スレッドは中断されることなく完了する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-637">If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-638">次のコード例は、実行中のスレッドが中断され、その後ブロックされた場合の動作を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-638">The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8d5a0-639">呼び出し元に適切な <see cref="T:System.Security.Permissions.SecurityPermission" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-639">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="8d5a0-640">スレッドに対する高度な操作の場合。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-640">for advanced operations on threads.</span></span> <span data-ttu-id="8d5a0-641"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="8d5a0-641">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="8d5a0-642">スレッドの一時中断および中断</span><span class="sxs-lookup"><span data-stu-id="8d5a0-642">Pausing and interrupting threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d5a0-643">現在のスレッドの実行ステータスを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-643">Gets a value indicating the execution status of the current thread.</span></span></summary>
        <value><span data-ttu-id="8d5a0-644">このスレッドが起動していて、正常終了しておらず中止されてもいない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-644"><see langword="true" /> if this thread has been started and has not terminated normally or aborted; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d5a0-645">スレッドがバックグラウンド スレッドであるかどうかを示す値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-645">Gets or sets a value indicating whether or not a thread is a background thread.</span></span></summary>
        <value><span data-ttu-id="8d5a0-646">このスレッドがバックグラウンド スレッドである場合またはバックグラウンド スレッドになる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-646"><see langword="true" /> if this thread is or is to become a background thread; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-647">スレッドは、バックグラウンドスレッドまたはフォアグラウンドスレッドのいずれかです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-647">A thread is either a background thread or a foreground thread.</span></span> <span data-ttu-id="8d5a0-648">バックグラウンドスレッドは、プロセスが終了しないようにすることを除けば、フォアグラウンドスレッドと同じです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-648">Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</span></span> <span data-ttu-id="8d5a0-649">プロセスに属するすべてのフォアグラウンドスレッドが終了すると、共通言語ランタイムによってプロセスが終了します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-649">Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</span></span> <span data-ttu-id="8d5a0-650">残りのバックグラウンドスレッドは停止され、完了しません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-650">Any remaining background threads are stopped and do not complete.</span></span>  
  
 <span data-ttu-id="8d5a0-651">既定では、次のスレッドはフォアグラウンドで実行されます (つまり、<xref:System.Threading.Thread.IsBackground%2A> プロパティが `false`を返します)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-651">By default, the following threads execute in the foreground (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `false`):</span></span>  
  
-   <span data-ttu-id="8d5a0-652">プライマリスレッド (またはメインアプリケーションスレッド)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-652">The primary thread (or main application thread).</span></span>  
  
-   <span data-ttu-id="8d5a0-653"><xref:System.Threading.Thread> クラスコンストラクターを呼び出すことによって作成されるすべてのスレッド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-653">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="8d5a0-654">既定では、次のスレッドがバックグラウンドで実行されます (つまり、<xref:System.Threading.Thread.IsBackground%2A> のプロパティが `true`を返します)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-654">By default, the following threads execute in the background  (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `true`):</span></span>  
  
-   <span data-ttu-id="8d5a0-655">スレッドプールスレッド。ランタイムによって管理されるワーカースレッドのプールです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-655">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span> <span data-ttu-id="8d5a0-656">スレッドプールを構成し、<xref:System.Threading.ThreadPool> クラスを使用してスレッドプールスレッドの作業をスケジュールすることができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-656">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="8d5a0-657">スレッドプールのスレッドでは、タスクベースの非同期操作が自動的に実行されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-657">Task-based asynchronous operations automatically execute on thread pool threads.</span></span>  
  
-   <span data-ttu-id="8d5a0-658">アンマネージコードからマネージ実行環境に入るすべてのスレッド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-658">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-659">次の例では、フォアグラウンドスレッドとバックグラウンドスレッドの動作を比較しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-659">The following example contrasts the behavior of foreground and background threads.</span></span> <span data-ttu-id="8d5a0-660">このメソッドは、フォアグラウンドスレッドとバックグラウンドスレッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-660">It creates a foreground thread and a background thread.</span></span> <span data-ttu-id="8d5a0-661">フォアグラウンドスレッドは、`for` ループを完了して終了するまでプロセスを実行したままにします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-661">The foreground thread keeps the process running until completes its `for` loop and terminates.</span></span> <span data-ttu-id="8d5a0-662">ただし、この例の出力に示されているように、フォアグラウンドスレッドの実行が完了したため、バックグラウンドスレッドの実行が完了する前にプロセスが終了します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-662">However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="8d5a0-663">スレッドが動作していません</span><span class="sxs-lookup"><span data-stu-id="8d5a0-663">The thread is dead.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md"><span data-ttu-id="8d5a0-664">フォアグラウンド スレッドとバックグラウンド スレッド</span><span class="sxs-lookup"><span data-stu-id="8d5a0-664">Foreground and Background Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d5a0-665">スレッドがマネージド スレッド プールに所属しているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-665">Gets a value indicating whether or not a thread belongs to the managed thread pool.</span></span></summary>
        <value><span data-ttu-id="8d5a0-666">このスレッドがマネージド スレッド プールに所属している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-666"><see langword="true" /> if this thread belongs to the managed thread pool; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-667">詳細について[は、「マネージスレッドプール](~/docs/standard/threading/the-managed-thread-pool.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-667">For more information see [The managed thread pool](~/docs/standard/threading/the-managed-thread-pool.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-668">スレッドがスレッドプールからのものかどうかを確認する方法を次のコード例に示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-668">The following code example shows how to determine whether a thread is from the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="8d5a0-669">マネージド スレッド プール</span><span class="sxs-lookup"><span data-stu-id="8d5a0-669">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d5a0-670">このインスタンスが表すスレッドが終了するまで、呼び出し元のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-670">Blocks the calling thread until the thread represented by this instance terminates.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-671">このインスタンスが表すスレッドが終了するまで、呼び出し元のスレッドをブロックします。標準 COM および <see langword="SendMessage" /> ポンピングの実行は継続されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-671">Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <see langword="SendMessage" /> pumping.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-672"><xref:System.Threading.Thread.Join%2A> は、<xref:System.Threading.Thread.Join%2A> メソッドが呼び出されたスレッドが完了するまで、呼び出し元のスレッド (つまり、メソッドを呼び出すスレッド) をブロックする同期メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-672"><xref:System.Threading.Thread.Join%2A> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed.</span></span> <span data-ttu-id="8d5a0-673">スレッドが終了したことを確認するには、このメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-673">Use this method to ensure that a thread has been terminated.</span></span> <span data-ttu-id="8d5a0-674">スレッドが終了しない場合、呼び出し元は無期限にブロックされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-674">The caller will block indefinitely if the thread does not terminate.</span></span> <span data-ttu-id="8d5a0-675">次の例では、`Thread1` スレッドが `Thread2`の <xref:System.Threading.Thread.Join> メソッドを呼び出します。これにより、`Thread2` が完了するまで `Thread1` がブロックされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-675">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block until `Thread2` has completed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 <span data-ttu-id="8d5a0-676"><xref:System.Threading.Thread.Join%2A> が呼び出されたときにスレッドが既に終了している場合、メソッドはすぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-676">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="8d5a0-677">現在のスレッドの現在のスレッドを表す <xref:System.Threading.Thread> オブジェクトの <xref:System.Threading.Thread.Join%2A> メソッドを呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-677">You should never call the <xref:System.Threading.Thread.Join%2A> method of the <xref:System.Threading.Thread> object that represents the current thread from the current thread.</span></span> <span data-ttu-id="8d5a0-678">これにより、現在のスレッドが無期限に待機しているため、アプリが応答しなくなることがあります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-678">This causes your app to become unresponsive because the current thread waits upon itself indefinitely,</span></span>  
  
 <span data-ttu-id="8d5a0-679">このメソッドは、呼び出し元のスレッドの状態を変更して <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>を含めます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-679">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d5a0-680"><xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 状態のスレッドで `Join` を呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-680">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="8d5a0-681">呼び出し元が、<see cref="F:System.Threading.ThreadState.Unstarted" /> 状態のスレッドを結合しようとしました。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-681">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="8d5a0-682">待機中にスレッドが中断されました。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-682">The thread is interrupted while waiting.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="8d5a0-683">スレッドが終了するまでの待機時間を表すミリ秒数。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-683">The number of milliseconds to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="8d5a0-684">このインスタンスが表すスレッドが終了するまで、または指定された時間が経過するまで、呼び出し元のスレッドをブロックします。標準 COM/SendMessage ポンピングの実行は継続されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-684">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-685">スレッドが終了した場合は <see langword="true" />。<see langword="false" /> パラメーターで指定した時間が経過してもスレッドが終了していない場合は <paramref name="millisecondsTimeout" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-685"><see langword="true" /> if the thread has terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="millisecondsTimeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-686"><xref:System.Threading.Thread.Join%28System.Int32%29> は、<xref:System.Threading.Thread.Join%2A> メソッドが呼び出されたスレッドが完了するか、タイムアウト間隔が経過するまで、呼び出し元のスレッド (つまり、メソッドを呼び出すスレッド) をブロックする同期メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-686"><xref:System.Threading.Thread.Join%28System.Int32%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="8d5a0-687">次の例では、`Thread1` スレッドが `Thread2`の <xref:System.Threading.Thread.Join> メソッドを呼び出します。これにより、`Thread2` が完了するか、2秒が経過するまで、`Thread1` がブロックされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-687">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 <span data-ttu-id="8d5a0-688">`millisecondsTimeout` パラメーターに <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> が指定されている場合、このメソッドは、戻り値を除き、<xref:System.Threading.Thread.Join> メソッドのオーバーロードと同じように動作します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-688">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for the `millisecondsTimeout` parameter, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="8d5a0-689"><xref:System.Threading.Thread.Join%2A> が呼び出されたときにスレッドが既に終了している場合、メソッドはすぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-689">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="8d5a0-690">このメソッドは、呼び出し元のスレッドの状態を変更して <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>を含めます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-690">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d5a0-691"><xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 状態のスレッドで `Join` を呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-691">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8d5a0-692"><paramref name="millisecondsTimeout" /> の値が負の値であり、<see cref="F:System.Threading.Timeout.Infinite" /> (ミリ秒単位) と等しくありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-692">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="8d5a0-693">スレッドは開始していません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-693">The thread has not been started.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d5a0-694"><paramref name="millisecondsTimeout" /> は -1 未満です (Timeout.Infinite)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-694"><paramref name="millisecondsTimeout" /> is less than -1 (Timeout.Infinite).</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="8d5a0-695">待機中にスレッドが中断されました。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-695">The thread was interrupted while waiting.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="8d5a0-696">スレッドが終了するのを待機する時間に設定される <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-696">A <see cref="T:System.TimeSpan" /> set to the amount of time to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="8d5a0-697">このインスタンスが表すスレッドが終了するまで、または指定された時間が経過するまで、呼び出し元のスレッドをブロックします。標準 COM/SendMessage ポンピングの実行は継続されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-697">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-698">スレッドが終了した場合は <see langword="true" />。<see langword="false" /> パラメーターで指定した時間が経過してもスレッドが終了していない場合は <paramref name="timeout" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-698"><see langword="true" /> if the thread terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="timeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-699"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> は、<xref:System.Threading.Thread.Join%2A> メソッドが呼び出されたスレッドが完了するか、タイムアウト間隔が経過するまで、呼び出し元のスレッド (つまり、メソッドを呼び出すスレッド) をブロックする同期メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-699"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="8d5a0-700">次の例では、`Thread1` スレッドが `Thread2`の <xref:System.Threading.Thread.Join> メソッドを呼び出します。これにより、`Thread2` が完了するか、2秒が経過するまで、`Thread1` がブロックされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-700">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 <span data-ttu-id="8d5a0-701">`timeout`に対して <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> が指定されている場合、このメソッドは、戻り値を除き、<xref:System.Threading.Thread.Join> メソッドのオーバーロードと同じように動作します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-701">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for `timeout`, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="8d5a0-702"><xref:System.Threading.Thread.Join%2A> が呼び出されたときにスレッドが既に終了している場合、メソッドはすぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-702">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="8d5a0-703">このメソッドは、現在のスレッドの状態を変更して <xref:System.Threading.ThreadState.WaitSleepJoin>を含めます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-703">This method changes the state of the current thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span> <span data-ttu-id="8d5a0-704"><xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 状態のスレッドで `Join` を呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-704">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-705">次のコード例は、`Join` メソッドで `TimeSpan` 値を使用する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-705">The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8d5a0-706"><paramref name="timeout" /> の値が負の値で、<see cref="F:System.Threading.Timeout.Infinite" /> (ミリ秒単位) と等しくないか、または <see cref="F:System.Int32.MaxValue" /> ミリ秒を超えています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-706">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="8d5a0-707">呼び出し元が、<see cref="F:System.Threading.ThreadState.Unstarted" /> 状態のスレッドを結合しようとしました。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-707">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d5a0-708">現在のマネージド スレッドの一意の識別子を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-708">Gets a unique identifier for the current managed thread.</span></span></summary>
        <value><span data-ttu-id="8d5a0-709">このマネージド スレッドの一意の識別子を表す整数。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-709">An integer that represents a unique identifier for this managed thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-710">スレッドの <xref:System.Threading.Thread.ManagedThreadId%2A> プロパティ値は、プロセス内でそのスレッドを一意に識別するために機能します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-710">A thread's <xref:System.Threading.Thread.ManagedThreadId%2A> property value serves to uniquely identify that thread within its process.</span></span>  
  
 <span data-ttu-id="8d5a0-711">共通言語ランタイムをホストするアンマネージコードでは、スレッドがファイバーとして実装されている場合でも、<xref:System.Threading.Thread.ManagedThreadId%2A> プロパティの値は時間の経過と共に変化しません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-711">The value of the <xref:System.Threading.Thread.ManagedThreadId%2A> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-712">メモリ アクセスを同期します。現在のスレッドを実行中のプロセッサは、<see cref="M:System.Threading.Thread.MemoryBarrier" /> を呼び出す前のメモリ アクセスを <see cref="M:System.Threading.Thread.MemoryBarrier" /> の呼び出し後のメモリ アクセスより後に実行するように命令を並べ替えることはできなくなります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-712">Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <see cref="M:System.Threading.Thread.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-713"><xref:System.Threading.Thread.MemoryBarrier%2A> は、メモリの順序が脆弱なマルチプロセッサシステム (たとえば、複数の Intel Itanium プロセッサを使用するシステム) にのみ必要です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-713"><xref:System.Threading.Thread.MemoryBarrier%2A> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="8d5a0-714">ほとんどの場合、 C# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、または <xref:System.Threading.Monitor> クラスを使用すると、データを簡単に同期できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-714">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d5a0-715">スレッドの名前を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-715">Gets or sets the name of the thread.</span></span></summary>
        <value><span data-ttu-id="8d5a0-716">スレッドの名前を含む文字列。名前が設定されていない場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-716">A string containing the name of the thread, or <see langword="null" /> if no name was set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-717">このプロパティは1回だけ書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-717">This property is write-once.</span></span> <span data-ttu-id="8d5a0-718">スレッドの <xref:System.Threading.Thread.Name%2A> プロパティの既定値は `null`ので、`null`と比較することによって、既に名前がスレッドに割り当てられているかどうかを確認できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-718">Because the default value of a thread's <xref:System.Threading.Thread.Name%2A> property is `null`, you can determine whether a name has already been explicitly assigned to the thread by comparing it with `null`.</span></span>  
  
 <span data-ttu-id="8d5a0-719"><xref:System.Threading.Thread.Name%2A> プロパティに割り当てられた文字列には、任意の Unicode 文字を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-719">The string assigned to the <xref:System.Threading.Thread.Name%2A> property can include any Unicode character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-720">次の例は、スレッドに名前を指定する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-720">The following example shows how to name a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8d5a0-721">設定操作が要求されましたが、<see langword="Name" /> プロパティは既に設定されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-721">A set operation was requested, but the <see langword="Name" /> property has already been set.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d5a0-722">スレッドのスケジューリング優先順位を示す値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-722">Gets or sets a value indicating the scheduling priority of a thread.</span></span></summary>
        <value><span data-ttu-id="8d5a0-723"><see cref="T:System.Threading.ThreadPriority" /> 値のいずれか 1 つです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-723">One of the <see cref="T:System.Threading.ThreadPriority" /> values.</span></span> <span data-ttu-id="8d5a0-724">既定値は <see cref="F:System.Threading.ThreadPriority.Normal" /> です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-724">The default value is <see cref="F:System.Threading.ThreadPriority.Normal" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-725">スレッドには、次のいずれかの優先順位 <xref:System.Threading.ThreadPriority> 値を割り当てることができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-725">A thread can be assigned any one of the following priority <xref:System.Threading.ThreadPriority> values:</span></span>  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 <span data-ttu-id="8d5a0-726">オペレーティングシステムは、スレッドの優先順位に従う必要はありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-726">Operating systems are not required to honor the priority of a thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-727">次の例は、スレッドの優先度を変更した結果を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-727">The following example shows the result of changing the priority of a thread.</span></span> <span data-ttu-id="8d5a0-728">3つのスレッドが作成され、1つのスレッドの優先度が <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>に設定され、2番目のスレッドの優先度が <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>に設定されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-728">Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, and the priority of a second is set to <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d5a0-729">各スレッドは、`while` ループ内の変数をインクリメントし、設定された時間に実行します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-729">Each thread increments a variable in a `while` loop and runs for a set time.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="8d5a0-730">スレッドが、<see cref="F:System.Threading.ThreadState.Aborted" /> などの最終状態に達しました。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-730">The thread has reached a final state, such as <see cref="F:System.Threading.ThreadState.Aborted" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d5a0-731">セット操作に対して設定された値が有効な <see cref="T:System.Threading.ThreadPriority" /> 値ではありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-731">The value specified for a set operation is not a valid <see cref="T:System.Threading.ThreadPriority" /> value.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md"><span data-ttu-id="8d5a0-732">スレッドのスケジューリング</span><span class="sxs-lookup"><span data-stu-id="8d5a0-732">Scheduling threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-733">現在のスレッドに対して要求された <see cref="M:System.Threading.Thread.Abort(System.Object)" /> をキャンセルします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-733">Cancels an <see cref="M:System.Threading.Thread.Abort(System.Object)" /> requested for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-734">このメソッドは、適切なアクセス許可を持つコードによってのみ呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-734">This method can only be called by code with the proper permissions.</span></span>  
  
 <span data-ttu-id="8d5a0-735">スレッドを終了するために `Abort` の呼び出しが行われると、システムによって <xref:System.Threading.ThreadAbortException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-735">When a call is made to `Abort` to terminate a thread, the system throws a <xref:System.Threading.ThreadAbortException>.</span></span> <span data-ttu-id="8d5a0-736">`ThreadAbortException` は、アプリケーションコードでキャッチできる特殊な例外ですが、`ResetAbort` が呼び出されない限り、catch ブロックの最後に再スローされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-736">`ThreadAbortException` is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless `ResetAbort` is called.</span></span> <span data-ttu-id="8d5a0-737">`ResetAbort` は、中止の要求をキャンセルし、`ThreadAbortException` がスレッドを終了できないようにします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-737">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span>  
  
 <span data-ttu-id="8d5a0-738">`ResetAbort` メソッドの呼び出しを示す例については、「<xref:System.Threading.ThreadAbortException>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-738">See <xref:System.Threading.ThreadAbortException> for an example that demonstrates calling the `ResetAbort` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="8d5a0-739">.NET Core のみ: このメンバーはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-739">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="8d5a0-740"><see langword="Abort" /> は現在のスレッドで呼び出されませんでした。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-740"><see langword="Abort" /> was not invoked on the current thread.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8d5a0-741">呼び出し元には、現在のスレッドに対する必要なセキュリティ アクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-741">The caller does not have the required security permission for the current thread.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="8d5a0-742">スレッドに対する高度な操作の場合。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-742">for advanced operations on threads.</span></span> <span data-ttu-id="8d5a0-743"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="8d5a0-743">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="8d5a0-744">スレッドの破棄</span><span class="sxs-lookup"><span data-stu-id="8d5a0-744">Destroying threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-745">中断されたスレッドを再開します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-745">Resumes a thread that has been suspended.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="8d5a0-746"><xref:System.Threading.Thread.Suspend%2A> メソッドと <xref:System.Threading.Thread.Resume%2A> メソッドを使用してスレッドの動作を同期しないでください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-746">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="8d5a0-747">スレッドを中断したときに実行されているコードを知ることはできません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-747">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="8d5a0-748">セキュリティアクセス許可の評価中にロックを保持している間にスレッドを中断した場合、<xref:System.AppDomain> 内の他のスレッドがブロックされることがあります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-748">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="8d5a0-749">クラスコンストラクターの実行中にスレッドを中断すると、そのクラスを使用しようとしている <xref:System.AppDomain> 内の他のスレッドがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-749">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="8d5a0-750">デッドロックは非常に簡単に発生します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-750">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="8d5a0-751">.NET Core のみ: このメンバーはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-751">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="8d5a0-752">スレッドが開始されていないか、実行されていません。または中断状態にはありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-752">The thread has not been started, is dead, or is not in the suspended state.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8d5a0-753">呼び出し元に適切な <see cref="T:System.Security.Permissions.SecurityPermission" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-753">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="8d5a0-754">スレッドに対する高度な操作の場合。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-754">for advanced operations on threads.</span></span> <span data-ttu-id="8d5a0-755">関連付けられた列挙型: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="8d5a0-755">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="8d5a0-756">スレッドの一時中断および中断</span><span class="sxs-lookup"><span data-stu-id="8d5a0-756">Pausing and interrupting threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="8d5a0-757">新しいアパートメント状態。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-757">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="8d5a0-758">スレッドを開始する前にそのアパートメント状態を設定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-758">Sets the apartment state of a thread before it is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-759">アパートメント状態が開始前に設定されていない場合、新しいスレッドは <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> として初期化されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-759">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="8d5a0-760">アパートメント状態は、スレッドを開始する前に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-760">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-761">メインアプリケーションスレッドは、既定で <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> に初期化されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-761">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="8d5a0-762">メインアプリケーションスレッドのアパートメント状態を <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> に設定する唯一の方法は、<xref:System.STAThreadAttribute> 属性をエントリポイントメソッドに適用することです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-762">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="8d5a0-763"><xref:System.Threading.Thread.SetApartmentState%2A> メソッドと、<xref:System.Threading.Thread.GetApartmentState%2A> メソッドおよび <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドを使用して、<xref:System.Threading.Thread.ApartmentState%2A> プロパティが置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-763">The <xref:System.Threading.Thread.SetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-764">次のコード例は、<xref:System.Threading.Thread.GetApartmentState%2A>、<xref:System.Threading.Thread.SetApartmentState%2A>、および <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-764">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="8d5a0-765">このコード例では、スレッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-765">The code example creates a thread.</span></span> <span data-ttu-id="8d5a0-766">スレッドが開始される前に、<xref:System.Threading.Thread.GetApartmentState%2A> は初期の <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> の状態を表示し、<xref:System.Threading.Thread.SetApartmentState%2A> 状態を <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>に変更します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-766">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d5a0-767"><xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドは、アパートメント状態が既に設定されているために状態を <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> に変更しようとしたときに `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-767">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="8d5a0-768"><xref:System.Threading.Thread.SetApartmentState%2A>で同じ操作が試行された場合、<xref:System.InvalidOperationException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-768">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="8d5a0-769">スレッドが開始されると、<xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドが再び使用されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-769">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="8d5a0-770">今回は、スレッドが既に開始されているため <xref:System.Threading.ThreadStateException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-770">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="8d5a0-771">.NET Core のみ: macOS および Linux プラットフォームでは、このメンバーはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-771">.NET Core only: This member is not supported on the macOS and Linux platforms.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d5a0-772"><paramref name="state" /> は有効なアパートメント状態ではありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-772"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="8d5a0-773">スレッドが既に開始されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-773">The thread has already been started.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8d5a0-774">アパートメント状態は、すでに初期化されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-774">The apartment state has already been initialized.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="stack"><span data-ttu-id="8d5a0-775">現在のスレッドに適用される <see cref="T:System.Threading.CompressedStack" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-775">The <see cref="T:System.Threading.CompressedStack" /> object to be applied to the current thread.</span></span></param>
        <summary><span data-ttu-id="8d5a0-776">キャプチャした <see cref="T:System.Threading.CompressedStack" /> を現在のスレッドに適用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-776">Applies a captured <see cref="T:System.Threading.CompressedStack" /> to the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-777">このメソッドはサポートされなくなりました。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-777">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8d5a0-778">すべての場合。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-778">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="8d5a0-779">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-779">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="8d5a0-780">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-780">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="8d5a0-781">値を設定する <see cref="T:System.LocalDataStoreSlot" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-781">The <see cref="T:System.LocalDataStoreSlot" /> in which to set the value.</span></span></param>
        <param name="data"><span data-ttu-id="8d5a0-782">設定される値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-782">The value to be set.</span></span></param>
        <summary><span data-ttu-id="8d5a0-783">現在実行中のスレッド上にある指定されたスロット内のデータを、そのスレッドの現在のドメインに設定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-783">Sets the data in the specified slot on the currently running thread, for that thread's current domain.</span></span> <span data-ttu-id="8d5a0-784">パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-784">For better performance, use fields marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d5a0-785">.NET Framework には、スレッドローカルストレージ (TLS) を使用するための2つのメカニズムが用意されています。スレッド相対静的フィールド (つまり、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールド) とデータスロットです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-785">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="8d5a0-786">スレッド相対静的フィールドは、データスロットよりもはるかに優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-786">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="8d5a0-787">TLS の使用の詳細については、「[スレッドローカルストレージ: スレッド相対静的フィールドとデータスロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-787">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="8d5a0-788">スレッドは、ローカルストアのメモリ機構を使用して、スレッド固有のデータを格納します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-788">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="8d5a0-789">共通言語ランタイムは、作成時に各プロセスに複数スロットのデータストア配列を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-789">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="8d5a0-790">スレッドは、データストアにデータスロットを割り当て、スロットにデータ値を格納して取得します。また、スレッドプロシージャが終了し、<xref:System.Threading.Thread> オブジェクトがガベージコレクションによって回収された後で再利用できるようにスロットを解放します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-790">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <xref:System.Threading.Thread> object has been reclaimed by garbage collection.</span></span> <span data-ttu-id="8d5a0-791">データスロットはスレッドごとに一意です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-791">Data slots are unique per thread.</span></span> <span data-ttu-id="8d5a0-792">他のスレッド (子スレッドでもありません) は、そのデータを取得できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-792">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-793"><xref:System.Threading.Thread.SetData%2A> は、別のスレッドを参照する変数を使用して呼び出した場合でも、常に現在実行中のスレッドに適用される `Shared` メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-793"><xref:System.Threading.Thread.SetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="8d5a0-794">混乱を避けるために、`Shared` メソッドを呼び出すときにクラス名を使用します: `Thread.SetData(testSlot, "test data")`。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-794">To avoid confusion, use the class name when calling `Shared` methods: `Thread.SetData(testSlot, "test data")`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-795">このセクションには、2 つのコード例が含まれています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-795">This section contains two code examples.</span></span> <span data-ttu-id="8d5a0-796">最初の例では、<xref:System.ThreadStaticAttribute> 属性でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-796">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="8d5a0-797">2番目の例では、データスロットを使用して同じ処理を行う方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-797">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="8d5a0-798">**最初の例**</span><span class="sxs-lookup"><span data-stu-id="8d5a0-798">**First Example**</span></span>  
  
 <span data-ttu-id="8d5a0-799">次の例は、<xref:System.ThreadStaticAttribute> でマークされたフィールドを使用して、スレッド固有の情報を保持する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-799">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="8d5a0-800">この手法は、2番目の例に示す手法よりもパフォーマンスが優れています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-800">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="8d5a0-801">**2番目の例**</span><span class="sxs-lookup"><span data-stu-id="8d5a0-801">**Second Example**</span></span>  
  
 <span data-ttu-id="8d5a0-802">次の例は、名前付きデータスロットを使用してスレッド固有の情報を格納する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-802">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="8d5a0-803">スレッドおよびスレッド処理</span><span class="sxs-lookup"><span data-stu-id="8d5a0-803">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="8d5a0-804">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</span><span class="sxs-lookup"><span data-stu-id="8d5a0-804">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d5a0-805">指定した時間の長さにわたって現在のスレッドを中断します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-805">Suspends the current thread for the specified amount of time.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="8d5a0-806">スレッドが中断ブロックされるミリ秒数。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-806">The number of milliseconds for which the thread is suspended.</span></span> <span data-ttu-id="8d5a0-807"><paramref name="millisecondsTimeout" /> 引数の値が 0 である場合は、スレッドは自らのタイム スライスの残りの部分を放棄し、実行する準備ができている同じ優先順位の他のスレッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-807">If the value of the <paramref name="millisecondsTimeout" /> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="8d5a0-808">優先順位が同じで実行する準備ができている他のスレッドが存在しない場合は、現在のスレッドの実行は中断されません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-808">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="8d5a0-809">指定したミリ秒数の間現在のスレッドを中断します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-809">Suspends the current thread for the specified number of milliseconds.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-810">スレッドは、指定された時間だけオペレーティングシステムによって実行されるようにスケジュールされません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-810">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="8d5a0-811">このメソッドは、<xref:System.Threading.ThreadState.WaitSleepJoin>を含めるようにスレッドの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-811">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="8d5a0-812">`millisecondsTimeout` パラメーターの <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> を指定して、スレッドを無制限に中断することができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-812">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the `millisecondsTimeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="8d5a0-813">ただし、スレッドを同期したりリソースを管理したりするために、<xref:System.Threading.Mutex>、<xref:System.Threading.Monitor>、<xref:System.Threading.EventWaitHandle>、<xref:System.Threading.Semaphore> などの他の <xref:System.Threading?displayProperty=nameWithType> クラスを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-813">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to synchronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="8d5a0-814">クロック解像度と呼ばれる特定の速度でのシステムクロックティック。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-814">The system clock ticks at a specific rate called the clock resolution.</span></span> <span data-ttu-id="8d5a0-815">指定されたタイムアウトはクロックティックと一致するように調整されるので、実際のタイムアウトは指定したタイムアウト値にならない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-815">The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</span></span> <span data-ttu-id="8d5a0-816">クロック解像度と待機時間の詳細については、「Windows システム Api の[スリープ機能](/windows/win32/api/synchapi/nf-synchapi-sleep)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-816">For more information on clock resolution and the waiting time, see the [Sleep function](/windows/win32/api/synchapi/nf-synchapi-sleep) from the Windows system APIs.</span></span>  
  
 <span data-ttu-id="8d5a0-817">このメソッドでは、標準の COM および SendMessage ポンプは実行されません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-817">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-818"><xref:System.STAThreadAttribute>のあるスレッドでスリープする必要があり、標準の COM および SendMessage ポンプを実行する必要がある場合は、タイムアウト間隔を指定する <xref:System.Threading.Thread.Join%2A> メソッドのオーバーロードの1つを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-818">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-819">次の例では、<xref:System.Threading.Thread.Sleep%2A> メソッドを使用して、アプリケーションのメインスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-819">The following example uses the <xref:System.Threading.Thread.Sleep%2A> method to block the application's main thread.</span></span>  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8d5a0-820">タイムアウト値が負の値で、<see cref="F:System.Threading.Timeout.Infinite" /> に等しくありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-820">The time-out value is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="8d5a0-821">スレッドが中断される時間の長さ。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-821">The amount of time for which the thread is suspended.</span></span> <span data-ttu-id="8d5a0-822"><paramref name="millisecondsTimeout" /> 引数の値が <see cref="F:System.TimeSpan.Zero" /> である場合は、スレッドは自らのタイム スライスの残りの部分を放棄し、実行する準備ができている同じ優先順位の他のスレッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-822">If the value of the <paramref name="millisecondsTimeout" /> argument is <see cref="F:System.TimeSpan.Zero" />, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="8d5a0-823">優先順位が同じで実行する準備ができている他のスレッドが存在しない場合は、現在のスレッドの実行は中断されません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-823">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="8d5a0-824">指定した時間の長さにわたって現在のスレッドを中断します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-824">Suspends the current thread for the specified amount of time.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-825">スレッドは、指定された時間だけオペレーティングシステムによって実行されるようにスケジュールされません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-825">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="8d5a0-826">このメソッドは、<xref:System.Threading.ThreadState.WaitSleepJoin>を含めるようにスレッドの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-826">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="8d5a0-827">`timeout` パラメーターの <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> を指定して、スレッドを無制限に中断することができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-827">You can specify <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> for the `timeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="8d5a0-828">ただし、スレッドを同期したりリソースを管理したりするために、<xref:System.Threading.Mutex>、<xref:System.Threading.Monitor>、<xref:System.Threading.EventWaitHandle>、<xref:System.Threading.Semaphore> などの他の <xref:System.Threading?displayProperty=nameWithType> クラスを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-828">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to synchronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="8d5a0-829"><xref:System.Threading.Thread.Sleep%2A> のこのオーバーロードは、`timeout`の合計ミリ秒数を使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-829">This overload of <xref:System.Threading.Thread.Sleep%2A> uses the total number of whole milliseconds in `timeout`.</span></span> <span data-ttu-id="8d5a0-830">ミリ秒の小数部は破棄されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-830">Fractional milliseconds are discarded.</span></span>  
  
 <span data-ttu-id="8d5a0-831">このメソッドでは、標準の COM および SendMessage ポンプは実行されません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-831">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-832"><xref:System.STAThreadAttribute>のあるスレッドでスリープする必要があり、標準の COM および SendMessage ポンプを実行する必要がある場合は、タイムアウト間隔を指定する <xref:System.Threading.Thread.Join%2A> メソッドのオーバーロードの1つを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-832">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-833">次の例では、<xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> メソッドのオーバーロードを使用して、アプリケーションのメインスレッドを5回 (毎回2秒) ブロックします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-833">The following example uses the <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> method overload to block the application's main thread five times, for two seconds each time.</span></span>  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="8d5a0-834"><paramref name="timeout" /> の値が負の値で、<see cref="F:System.Threading.Timeout.Infinite" /> (ミリ秒単位) と等しくないか、または <see cref="F:System.Int32.MaxValue" /> ミリ秒を超えています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-834">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="iterations"><span data-ttu-id="8d5a0-835">スレッドが待機する時間を定義する 32 ビット符号付き整数。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-835">A 32-bit signed integer that defines how long a thread is to wait.</span></span></param>
        <summary><span data-ttu-id="8d5a0-836">スレッドが、<paramref name="iterations" /> パラメーターで定義される時間だけ待機するようにします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-836">Causes a thread to wait the number of times defined by the <paramref name="iterations" /> parameter.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-837"><xref:System.Threading.Thread.SpinWait%2A> メソッドは、ロックを実装する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-837">The <xref:System.Threading.Thread.SpinWait%2A> method is useful for implementing locks.</span></span> <span data-ttu-id="8d5a0-838"><xref:System.Threading.Monitor> や <xref:System.Threading.ReaderWriterLock>などの .NET Framework のクラスは、このメソッドを内部で使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-838">Classes in the .NET Framework, such as <xref:System.Threading.Monitor> and <xref:System.Threading.ReaderWriterLock>, use this method internally.</span></span> <span data-ttu-id="8d5a0-839"><xref:System.Threading.Thread.SpinWait%2A>、`iterations` パラメーターによって指定されたループカウントを使用して、プロセッサを非常に短いループに配置します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-839"><xref:System.Threading.Thread.SpinWait%2A> essentially puts the processor into a very tight loop, with the loop count specified by the `iterations` parameter.</span></span> <span data-ttu-id="8d5a0-840">この待機時間は、プロセッサの速度によって異なります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-840">The duration of the wait therefore depends on the speed of the processor.</span></span>  
  
 <span data-ttu-id="8d5a0-841">これを <xref:System.Threading.Thread.Sleep%2A> メソッドと比較します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-841">Contrast this with the <xref:System.Threading.Thread.Sleep%2A> method.</span></span> <span data-ttu-id="8d5a0-842"><xref:System.Threading.Thread.Sleep%2A> を呼び出すスレッドは、指定された間隔が0の場合でも、プロセッサ時間の残りの部分を生成します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-842">A thread that calls <xref:System.Threading.Thread.Sleep%2A> yields the rest of its current slice of processor time, even if the specified interval is zero.</span></span> <span data-ttu-id="8d5a0-843"><xref:System.Threading.Thread.Sleep%2A> に0以外の間隔を指定すると、時間間隔が経過するまでスレッドスケジューラによる考慮からスレッドが削除されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-843">Specifying a non-zero interval for <xref:System.Threading.Thread.Sleep%2A> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</span></span>  
  
 <span data-ttu-id="8d5a0-844">通常のアプリケーションでは、<xref:System.Threading.Thread.SpinWait%2A> は一般には便利ではありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-844"><xref:System.Threading.Thread.SpinWait%2A> is not generally useful for ordinary applications.</span></span> <span data-ttu-id="8d5a0-845">ほとんどの場合、.NET Framework によって提供される同期クラスを使用する必要があります。たとえば、<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> を呼び出すか、または <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (またはC# Visual Basic の `SyncLock` で`lock`) をラップするステートメントを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-845">In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> or a statement that wraps <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in C# or `SyncLock` in Visual Basic).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8d5a0-846">状態の変化が近づいていることがわかっている場合などに、コンテキストの切り替えを避けることが有益な場合は、ループ内で <xref:System.Threading.Thread.SpinWait%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-846">In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <xref:System.Threading.Thread.SpinWait%2A> method in your loop.</span></span> <span data-ttu-id="8d5a0-847">実行されるコード <xref:System.Threading.Thread.SpinWait%2A> は、複数のプロセッサを搭載したコンピューターで発生する可能性のある問題を回避するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-847">The code <xref:System.Threading.Thread.SpinWait%2A> executes is designed to prevent problems that can occur on computers with multiple processors.</span></span> <span data-ttu-id="8d5a0-848">たとえば、ハイパースレッディングテクノロジを採用している複数の Intel プロセッサを搭載したコンピューターでは、<xref:System.Threading.Thread.SpinWait%2A> によって、特定の状況でプロセッサが枯渇するのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-848">For example, on computers with multiple Intel processors employing Hyper-Threading technology, <xref:System.Threading.Thread.SpinWait%2A> prevents processor starvation in certain situations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d5a0-849">スレッドの実行をスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-849">Causes a thread to be scheduled for execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-850">オペレーティング システムによって、現在のインスタンスの状態を <see cref="F:System.Threading.ThreadState.Running" /> に変更します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-850">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-851">スレッドが <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> 状態になると、オペレーティングシステムは実行のスケジュールを設定できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-851">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="8d5a0-852">スレッドは、スレッドコンストラクターに渡された <xref:System.Threading.ThreadStart> または <xref:System.Threading.ParameterizedThreadStart> デリゲートによって表されるメソッドの最初の行で実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-852">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="8d5a0-853"><xref:System.Threading.Thread.Start%2A> を呼び出すと、呼び出し元のスレッドがブロックされないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-853">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-854">このオーバーロードが <xref:System.Threading.ParameterizedThreadStart> デリゲートを使用して作成されたスレッドで使用されている場合、`null` はスレッドによって実行されるメソッドに渡されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-854">If this overload is used with a thread created using a <xref:System.Threading.ParameterizedThreadStart> delegate, `null` is passed to the method executed by the thread.</span></span>  
  
 <span data-ttu-id="8d5a0-855">スレッドが終了すると、`Start`の別の呼び出しで再起動することはできません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-855">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-856">次の例では、スレッドを作成して開始します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-856">The following example creates and starts a thread.</span></span>  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="8d5a0-857">スレッドが既に開始されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-857">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="8d5a0-858">メモリ不足のため、このスレッドを開始できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-858">There is not enough memory available to start this thread.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="8d5a0-859">スレッドおよびスレッド処理</span><span class="sxs-lookup"><span data-stu-id="8d5a0-859">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="8d5a0-860">スレッドを作成し、開始時にデータを渡す</span><span class="sxs-lookup"><span data-stu-id="8d5a0-860">Creating Threads and Passing Data at Start Time</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="parameter"><span data-ttu-id="8d5a0-861">スレッドが実行するメソッドで使用するデータを格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-861">An object that contains data to be used by the method the thread executes.</span></span></param>
        <summary><span data-ttu-id="8d5a0-862">オペレーティング システムによって現在のインスタンスの状態が <see cref="F:System.Threading.ThreadState.Running" /> に変更され、オプションでスレッドが実行するメソッドで使用するデータを格納するオブジェクトが提供されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-862">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />, and optionally supplies an object containing data to be used by the method the thread executes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-863">スレッドが <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> 状態になると、オペレーティングシステムは実行のスケジュールを設定できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-863">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="8d5a0-864">スレッドは、スレッドコンストラクターに渡された <xref:System.Threading.ThreadStart> または <xref:System.Threading.ParameterizedThreadStart> デリゲートによって表されるメソッドの最初の行で実行を開始します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-864">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="8d5a0-865"><xref:System.Threading.Thread.Start%2A> を呼び出すと、呼び出し元のスレッドがブロックされないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-865">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
 <span data-ttu-id="8d5a0-866">スレッドが終了すると、`Start`の別の呼び出しで再起動することはできません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-866">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
 <span data-ttu-id="8d5a0-867">このオーバーロードと <xref:System.Threading.ParameterizedThreadStart> デリゲートを使用すると、スレッドプロシージャにデータを簡単に渡すことができますが、どのオブジェクトもこのオーバーロードに渡すことができるため、この手法はタイプセーフではありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-867">This overload and the <xref:System.Threading.ParameterizedThreadStart> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</span></span> <span data-ttu-id="8d5a0-868">スレッドプロシージャにデータを渡すより堅牢な方法は、スレッドプロシージャとデータフィールドの両方をワーカーオブジェクトに配置することです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-868">A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</span></span> <span data-ttu-id="8d5a0-869">詳細については、「[開始時にスレッドを作成してデータを渡す](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-869">For more information, see [Creating Threads and Passing Data at Start Time](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-870">次の例では、静的メソッドとインスタンスメソッドを使用して <xref:System.Threading.ParameterizedThreadStart> デリゲートを作成します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-870">The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="8d5a0-871">スレッドが既に開始されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-871">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="8d5a0-872">メモリ不足のため、このスレッドを開始できません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-872">There is not enough memory available to start this thread.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="8d5a0-873"><see cref="T:System.Threading.ThreadStart" /> デリゲートの代わりに <see cref="T:System.Threading.ParameterizedThreadStart" /> デリゲートを使用して、このスレッドは作成されました。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-873">This thread was created using a <see cref="T:System.Threading.ThreadStart" /> delegate instead of a <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="8d5a0-874">スレッドの作成</span><span class="sxs-lookup"><span data-stu-id="8d5a0-874">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-875">スレッドを中断します。スレッドが既に中断されている場合は無効です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-875">Either suspends the thread, or if the thread is already suspended, has no effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-876">スレッドが既に中断されている場合、このメソッドによる影響はありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-876">If the thread is already suspended, this method has no effect.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="8d5a0-877"><xref:System.Threading.Thread.Suspend%2A> メソッドと <xref:System.Threading.Thread.Resume%2A> メソッドを使用してスレッドの動作を同期しないでください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-877">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="8d5a0-878">スレッドを中断したときに実行されているコードを知ることはできません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-878">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="8d5a0-879">セキュリティアクセス許可の評価中にロックを保持している間にスレッドを中断した場合、<xref:System.AppDomain> 内の他のスレッドがブロックされることがあります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-879">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="8d5a0-880">クラスコンストラクターの実行中にスレッドを中断すると、そのクラスを使用しようとしている <xref:System.AppDomain> 内の他のスレッドがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-880">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="8d5a0-881">デッドロックは非常に簡単に発生します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-881">Deadlocks can occur very easily.</span></span>

<span data-ttu-id="8d5a0-882">スレッドで `Suspend` メソッドを呼び出すと、スレッドの中断が要求されたことがシステムに示され、スレッドを実際に中断する前にセーフポイントに到達するまでスレッドを実行できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-882">When you call the `Suspend` method on a thread, the system notes that a thread suspension has been requested and allows the thread to execute until it reaches a safe point before actually suspending the thread.</span></span> <span data-ttu-id="8d5a0-883">スレッドのセーフ ポイントは、ガベージ コレクションを実行できる実行ポイントです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-883">A safe point for a thread is a point in its execution at which garbage collection can be performed.</span></span> <span data-ttu-id="8d5a0-884">セーフ ポイントに到達すると、ランタイムにより、中断されたスレッドがマネージド コードで続行されないことが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-884">Once a safe point is reached, the runtime guarantees that the suspended thread will not make any further progress in managed code.</span></span> <span data-ttu-id="8d5a0-885">マネージド コードの外部で実行中のスレッドは、通常、ガベージ コレクションでは安全であり、その実行はマネージド コードの実行再開が試行されるまで続行します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-885">A thread executing outside managed code is always safe for garbage collection, and its execution continues until it attempts to resume execution of managed code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="8d5a0-886">.NET Core のみ: このメンバーはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-886">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="8d5a0-887">スレッドが開始していないか、または停止しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-887">The thread has not been started or is dead.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="8d5a0-888">呼び出し元に適切な <see cref="T:System.Security.Permissions.SecurityPermission" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-888">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="8d5a0-889">スレッドに対する高度な操作の場合。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-889">for advanced operations on threads.</span></span> <span data-ttu-id="8d5a0-890"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="8d5a0-890">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="8d5a0-891">スレッドの一時中断および中断</span><span class="sxs-lookup"><span data-stu-id="8d5a0-891">Pausing and interrupting threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="8d5a0-892">将来利用するために予約されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-892">Reserved for future use.</span></span> <span data-ttu-id="8d5a0-893">IID_NULL にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-893">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="8d5a0-894">マッピング対象として渡される名前の配列。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-894">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="8d5a0-895">マッピングされる名前のカウント。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-895">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="8d5a0-896">名前を解釈するロケール コンテキスト。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-896">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="8d5a0-897">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-897">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="8d5a0-898">一連の名前を対応する一連のディスパッチ識別子に割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-898">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-899">このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-899">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8d5a0-900">詳細については、「 [IDispatch:: idispatch.getidsofnames](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-900">For more information, see [IDispatch::GetIDsOfNames](/windows/win32/api/oaidl/nf-oaidl-idispatch-getidsofnames).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8d5a0-901">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-901">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="8d5a0-902">返される型情報。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-902">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="8d5a0-903">型情報のロケール ID。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-903">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="8d5a0-904">要求された型情報オブジェクトへのポインターを取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-904">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="8d5a0-905">オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-905">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-906">このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-906">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8d5a0-907">詳細については、「 [IDispatch:: GetTypeInfo](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfo)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-907">For more information, see [IDispatch::GetTypeInfo](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfo).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8d5a0-908">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-908">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="8d5a0-909">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-909">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="8d5a0-910">オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-910">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-911">このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-911">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8d5a0-912">詳細については、「 [IDispatch:: GetTypeInfoCount](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfocount)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-912">For more information, see [IDispatch::GetTypeInfoCount](/windows/win32/api/oaidl/nf-oaidl-idispatch-gettypeinfocount).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8d5a0-913">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-913">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="8d5a0-914">メンバーを識別します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-914">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="8d5a0-915">将来利用するために予約されています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-915">Reserved for future use.</span></span> <span data-ttu-id="8d5a0-916">IID_NULL にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-916">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="8d5a0-917">引数を解釈する対象のロケール コンテキスト。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-917">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="8d5a0-918">呼び出しのコンテキストを記述するフラグ。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-918">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="8d5a0-919">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-919">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="8d5a0-920">結果が格納される場所へのポインター。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-920">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="8d5a0-921">例外情報を格納する構造体へのポインター。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-921">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="8d5a0-922">エラーが存在する最初の引数のインデックス。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-922">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="8d5a0-923">オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-923">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-924">このメソッドは、アンマネージコードからマネージクラスにアクセスするためのものであり、マネージコードからは呼び出さないでください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-924">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8d5a0-925">詳細については、「 [IDispatch:: Invoke](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-925">For more information, see [IDispatch::Invoke](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="8d5a0-926">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-926">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="8d5a0-927">現在のスレッドの状態を示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-927">Gets a value containing the states of the current thread.</span></span></summary>
        <value><span data-ttu-id="8d5a0-928">現在のスレッドの状態を示す <see cref="T:System.Threading.ThreadState" /> 値の 1 つ。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-928">One of the <see cref="T:System.Threading.ThreadState" /> values indicating the state of the current thread.</span></span> <span data-ttu-id="8d5a0-929">初期値は <see cref="F:System.Threading.ThreadState.Unstarted" /> です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-929">The initial value is <see cref="F:System.Threading.ThreadState.Unstarted" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-930"><xref:System.Threading.Thread.ThreadState%2A> プロパティは、<xref:System.Threading.Thread.IsAlive%2A> プロパティよりも具体的な情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-930">The <xref:System.Threading.Thread.ThreadState%2A> property provides more specific information than the <xref:System.Threading.Thread.IsAlive%2A> property.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8d5a0-931">スレッドの状態は、デバッグシナリオでのみ重要です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-931">Thread state is only of interest in debugging scenarios.</span></span> <span data-ttu-id="8d5a0-932">スレッドの動作を同期化する目的でコード内でスレッドの状態を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-932">Your code should never use thread state to synchronize the activities of threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-933">次のコード例は、スレッドの `ThreadState` にアクセスする方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-933">The following code example demonstrates accessing the `ThreadState` of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="8d5a0-934">新しいアパートメント状態。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-934">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="8d5a0-935">スレッドを開始する前にそのアパートメント状態を設定します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-935">Sets the apartment state of a thread before it is started.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-936">アパートメント状態が設定されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-936"><see langword="true" /> if the apartment state is set; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-937">アパートメント状態が開始前に設定されていない場合、新しいスレッドは <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> として初期化されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-937">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="8d5a0-938">アパートメント状態は、スレッドを開始する前に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-938">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-939">メインアプリケーションスレッドは、既定で <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> に初期化されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-939">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="8d5a0-940">メインアプリケーションスレッドのアパートメント状態を <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> に設定する唯一の方法は、<xref:System.STAThreadAttribute> 属性をエントリポイントメソッドに適用することです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-940">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="8d5a0-941"><xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドと、<xref:System.Threading.Thread.GetApartmentState%2A> メソッドおよび <xref:System.Threading.Thread.SetApartmentState%2A> メソッドを使用して、<xref:System.Threading.Thread.ApartmentState%2A> プロパティが置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-941">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.SetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8d5a0-942">次のコード例は、<xref:System.Threading.Thread.GetApartmentState%2A>、<xref:System.Threading.Thread.SetApartmentState%2A>、および <xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-942">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="8d5a0-943">このコード例では、スレッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-943">The code example creates a thread.</span></span> <span data-ttu-id="8d5a0-944">スレッドが開始される前に、<xref:System.Threading.Thread.GetApartmentState%2A> は初期の <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> の状態を表示し、<xref:System.Threading.Thread.SetApartmentState%2A> 状態を <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>に変更します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-944">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8d5a0-945"><xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドは、アパートメント状態が既に設定されているために状態を <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> に変更しようとしたときに `false` を返します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-945">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="8d5a0-946"><xref:System.Threading.Thread.SetApartmentState%2A>で同じ操作が試行された場合、<xref:System.InvalidOperationException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-946">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="8d5a0-947">スレッドが開始されると、<xref:System.Threading.Thread.TrySetApartmentState%2A> メソッドが再び使用されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-947">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="8d5a0-948">今回は、スレッドが既に開始されているため <xref:System.Threading.ThreadStateException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-948">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="8d5a0-949">.NET Core のみ: macOS および Linux プラットフォームでは、このメンバーはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-949">.NET Core only: This member is not supported on the macOS and Linux platforms.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="8d5a0-950"><paramref name="state" /> は有効なアパートメント状態ではありません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-950"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="8d5a0-951">スレッドが開始され、終了したか、スレッドの実行中にスレッドのコンテキストから呼び出しが行われていません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-951">The thread was started and has terminated, or the call is not being made from the thread's context while the thread is running.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d5a0-952">フィールドの値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-952">Reads the value of a field.</span></span> <span data-ttu-id="8d5a0-953">この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-953">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : byte -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-954">読み取られるフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-954">The field to be read.</span></span></param>
        <summary><span data-ttu-id="8d5a0-955">フィールドの値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-955">Reads the value of a field.</span></span> <span data-ttu-id="8d5a0-956">この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-956">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-957">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-957">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-958"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-958"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-959">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-959">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-960">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-960">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="8d5a0-961">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-961">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-962">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-962">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-963">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-963">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-964">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-964">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-965">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-965">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-966">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-966">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : double -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-967">読み取られるフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-967">The field to be read.</span></span></param>
        <summary><span data-ttu-id="8d5a0-968">フィールドの値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-968">Reads the value of a field.</span></span> <span data-ttu-id="8d5a0-969">この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-969">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-970">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-970">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-971"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-971"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-972">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-972">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-973">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-973">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="8d5a0-974">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-974">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-975">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-975">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-976">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-976">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-977">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-977">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-978">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-978">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-979">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-979">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int16 -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-980">読み取られるフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-980">The field to be read.</span></span></param>
        <summary><span data-ttu-id="8d5a0-981">フィールドの値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-981">Reads the value of a field.</span></span> <span data-ttu-id="8d5a0-982">この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-982">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-983">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-983">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-984"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-984"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-985">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-985">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-986">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-986">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="8d5a0-987">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-987">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-988">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-988">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-989">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-989">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-990">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-990">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-991">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-991">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-992">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-992">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-993">読み取られるフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-993">The field to be read.</span></span></param>
        <summary><span data-ttu-id="8d5a0-994">フィールドの値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-994">Reads the value of a field.</span></span> <span data-ttu-id="8d5a0-995">この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-995">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-996">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-996">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-997"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-997"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-998">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-998">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-999">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-999">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="8d5a0-1000">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1000">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1001">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1001">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1002">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1002">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1003">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1003">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1004">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1004">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1005">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1005">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int64 -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1006">読み取られるフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1006">The field to be read.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1007">フィールドの値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1007">Reads the value of a field.</span></span> <span data-ttu-id="8d5a0-1008">この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1008">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-1009">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1009">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1010"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1010"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1011">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1011">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1012">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1012">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="8d5a0-1013">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1013">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1014">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1014">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1015">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1015">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1016">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1016">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1017">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1017">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1018">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1018">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : nativeint -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1019">読み取られるフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1019">The field to be read.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1020">フィールドの値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1020">Reads the value of a field.</span></span> <span data-ttu-id="8d5a0-1021">この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1021">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-1022">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1022">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1023"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1023"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1024">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1024">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1025">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1025">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="8d5a0-1026">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1026">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1027">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1027">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1028">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1028">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1029">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1029">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1030">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1030">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1031">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1031">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : obj -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1032">読み取られるフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1032">The field to be read.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1033">フィールドの値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1033">Reads the value of a field.</span></span> <span data-ttu-id="8d5a0-1034">この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1034">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-1035">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1035">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1036"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1036"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1037">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1037">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1038">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1038">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="8d5a0-1039">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1039">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1040">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1040">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1041">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1041">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1042">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1042">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1043">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1043">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1044">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1044">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : sbyte -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1045">読み取られるフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1045">The field to be read.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1046">フィールドの値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1046">Reads the value of a field.</span></span> <span data-ttu-id="8d5a0-1047">この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1047">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-1048">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1048">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1049"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1049"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1050">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1050">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1051">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1051">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="8d5a0-1052">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1052">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1053">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1053">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1054">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1054">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1055">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1055">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1056">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1056">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1057">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1057">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : single -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1058">読み取られるフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1058">The field to be read.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1059">フィールドの値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1059">Reads the value of a field.</span></span> <span data-ttu-id="8d5a0-1060">この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1060">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-1061">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1061">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1062"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1062"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1063">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1063">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1064">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1064">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="8d5a0-1065">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1065">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1066">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1066">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1067">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1067">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1068">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1068">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1069">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1069">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1070">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1070">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint16 -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1071">読み取られるフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1071">The field to be read.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1072">フィールドの値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1072">Reads the value of a field.</span></span> <span data-ttu-id="8d5a0-1073">この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1073">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-1074">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1074">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1075"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1075"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1076">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1076">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1077">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1077">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="8d5a0-1078">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1078">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1079">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1079">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1080">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1080">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1081">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1081">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1082">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1082">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1083">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1083">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint32 -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1084">読み取られるフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1084">The field to be read.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1085">フィールドの値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1085">Reads the value of a field.</span></span> <span data-ttu-id="8d5a0-1086">この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1086">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-1087">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1087">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1088"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1088"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1089">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1089">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1090">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1090">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="8d5a0-1091">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1091">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1092">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1092">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1093">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1093">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1094">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1094">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1095">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1095">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1096">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1096">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint64 -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1097">読み取られるフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1097">The field to be read.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1098">フィールドの値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1098">Reads the value of a field.</span></span> <span data-ttu-id="8d5a0-1099">この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1099">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-1100">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1100">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1101"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1101"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1102">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1102">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1103">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1103">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="8d5a0-1104">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1104">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1105">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1105">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1106">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1106">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1107">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1107">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1108">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1108">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1109">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1109">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : unativeint -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1110">読み取られるフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1110">The field to be read.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1111">フィールドの値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1111">Reads the value of a field.</span></span> <span data-ttu-id="8d5a0-1112">この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1112">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-1113">いずれかのプロセッサによってフィールドに書き込まれた最新の値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1113">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1114"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1114"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1115">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1115">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1116">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileRead%2A> は、任意のプロセッサによってメモリ位置に書き込まれた最新の値を取得します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1116">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="8d5a0-1117">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1117">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1118">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1118">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1119">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1119">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1120">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1120">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1121">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1121">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1122">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1122">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8d5a0-1123">値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1123">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : byte * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Byte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1124">値を書き込むフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1124">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="8d5a0-1125">書き込む値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1125">The value to be written.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1126">値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1126">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1127"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1127"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1128">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1128">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1129">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1129">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="8d5a0-1130">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1130">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1131">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1131">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1132">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1132">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1133">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1133">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1134">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1134">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1135">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1135">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : double * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1136">値を書き込むフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1136">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="8d5a0-1137">書き込む値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1137">The value to be written.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1138">値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1138">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1139"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1139"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1140">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1140">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1141">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1141">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="8d5a0-1142">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1142">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1143">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1143">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1144">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1144">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1145">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1145">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1146">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1146">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1147">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1147">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int16 * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Int16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1148">値を書き込むフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1148">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="8d5a0-1149">書き込む値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1149">The value to be written.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1150">値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1150">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1151"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1151"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1152">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1152">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1153">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1153">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="8d5a0-1154">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1154">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1155">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1155">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1156">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1156">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1157">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1157">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1158">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1158">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1159">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1159">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1160">値を書き込むフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1160">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="8d5a0-1161">書き込む値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1161">The value to be written.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1162">値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1162">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1163"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1163"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1164">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1164">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1165">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1165">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="8d5a0-1166">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1166">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1167">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1167">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1168">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1168">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1169">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1169">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1170">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1170">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1171">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1171">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int64 * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1172">値を書き込むフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1172">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="8d5a0-1173">書き込む値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1173">The value to be written.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1174">値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1174">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1175"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1175"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1176">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1176">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1177">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1177">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="8d5a0-1178">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1178">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1179">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1179">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1180">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1180">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1181">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1181">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1182">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1182">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1183">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1183">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : nativeint * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1184">値を書き込むフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1184">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="8d5a0-1185">書き込む値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1185">The value to be written.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1186">値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1186">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1187"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1187"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1188">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1188">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1189">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1189">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="8d5a0-1190">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1190">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1191">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1191">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1192">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1192">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1193">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1193">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1194">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1194">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1195">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1195">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : obj * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1196">値を書き込むフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1196">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="8d5a0-1197">書き込む値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1197">The value to be written.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1198">値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1198">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1199"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1199"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1200">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1200">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1201">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1201">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="8d5a0-1202">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1202">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1203">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1203">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1204">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1204">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1205">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1205">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1206">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1206">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1207">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1207">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : sbyte * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.SByte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1208">値を書き込むフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1208">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="8d5a0-1209">書き込む値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1209">The value to be written.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1210">値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1210">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1211"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1211"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1212">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1212">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1213">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1213">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="8d5a0-1214">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1214">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1215">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1215">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1216">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1216">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1217">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1217">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1218">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1218">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1219">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1219">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : single * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1220">値を書き込むフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1220">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="8d5a0-1221">書き込む値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1221">The value to be written.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1222">値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1222">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1223"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1223"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1224">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1224">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1225">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1225">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="8d5a0-1226">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1226">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1227">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1227">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1228">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1228">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1229">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1229">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1230">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1230">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1231">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1231">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint16 * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UInt16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1232">値を書き込むフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1232">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="8d5a0-1233">書き込む値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1233">The value to be written.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1234">値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1234">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1235"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1235"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1236">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1236">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1237">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1237">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="8d5a0-1238">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1238">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1239">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1239">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1240">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1240">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1241">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1241">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1242">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1242">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1243">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1243">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint32 * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1244">値を書き込むフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1244">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="8d5a0-1245">書き込む値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1245">The value to be written.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1246">値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1246">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1247"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1247"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1248">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1248">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1249">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1249">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="8d5a0-1250">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1250">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1251">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1251">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1252">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1252">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1253">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1253">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1254">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1254">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1255">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1255">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint64 * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1256">値を書き込むフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1256">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="8d5a0-1257">書き込む値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1257">The value to be written.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1258">値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1258">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1259"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1259"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1260">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1260">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1261">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1261">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="8d5a0-1262">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1262">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1263">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1263">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1264">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1264">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1265">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1265">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1266">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1266">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1267">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1267">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : unativeint * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="value" Type="System.UIntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="8d5a0-1268">値を書き込むフィールド。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1268">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="8d5a0-1269">書き込む値。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1269">The value to be written.</span></span></param>
        <summary><span data-ttu-id="8d5a0-1270">値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1270">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1271"><xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> は、特定の同期の場合に使用します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1271"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="8d5a0-1272">通常の状況ではC# 、`lock` ステートメント、Visual Basic `SyncLock` ステートメント、および <xref:System.Threading.Monitor> クラスを使用すると、簡単に代替できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1272">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="8d5a0-1273">マルチプロセッサシステムでは、<xref:System.Threading.Thread.VolatileWrite%2A> によって、メモリ位置に書き込まれた値がすべてのプロセッサに直ちに表示されるようになります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1273">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="8d5a0-1274">これには、プロセッサキャッシュのフラッシュが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1274">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="8d5a0-1275">ユニプロセッサシステムの場合でも、<xref:System.Threading.Thread.VolatileRead%2A> と <xref:System.Threading.Thread.VolatileWrite%2A> では、メモリに対して値の読み取りまたは書き込みが行われ、キャッシュされません (たとえば、プロセッサレジスタなど)。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1275">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="8d5a0-1276">そのため、別のスレッドまたはハードウェアによって更新できるフィールドへのアクセスを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1276">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="8d5a0-1277">このメソッドを呼び出すと、1つのメモリアクセスだけに影響します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1277">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="8d5a0-1278">フィールドに対して効果的な同期を行うには、フィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1278">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d5a0-1279">でC#は、フィールドに対して `volatile` 修飾子を使用することにより、そのフィールドへのすべてのアクセスで <xref:System.Threading.Thread.VolatileRead%2A> または <xref:System.Threading.Thread.VolatileWrite%2A>が使用されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1279">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8d5a0-1280">呼び出し元のスレッドから、現在のプロセッサ上で実行する準備が整っている別のスレッドに実行を切り替えます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1280">Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</span></span> <span data-ttu-id="8d5a0-1281">実行の切り替え先のスレッドは、オペレーティング システムによって選択されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1281">The operating system selects the thread to yield to.</span></span></summary>
        <returns><span data-ttu-id="8d5a0-1282">オペレーティング システムによって実行が別のスレッドに切り替えられた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1282"><see langword="true" /> if the operating system switched execution to another thread; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8d5a0-1283">このメソッドが成功すると、スレッドの現在のタイムスライスの残りの部分が生成されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1283">If this method succeeds, the rest of the thread's current time slice is yielded.</span></span> <span data-ttu-id="8d5a0-1284">オペレーティングシステムは、その優先順位と実行可能な他のスレッドの状態に応じて、別のタイムスライスの呼び出し元スレッドをスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1284">The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</span></span>  
  
 <span data-ttu-id="8d5a0-1285">生成は、呼び出し元のスレッドを実行しているプロセッサに限定されます。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1285">Yielding is limited to the processor that is executing the calling thread.</span></span> <span data-ttu-id="8d5a0-1286">オペレーティングシステムは、プロセッサがアイドル状態の場合や、優先順位の低いスレッドが実行されている場合でも、実行を別のプロセッサに切り替えません。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1286">The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</span></span> <span data-ttu-id="8d5a0-1287">現在のプロセッサで実行する準備ができているスレッドが他にない場合、オペレーティングシステムは実行を生成せず、このメソッドは `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1287">If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns `false`.</span></span>  
  
 <span data-ttu-id="8d5a0-1288">このメソッドは、プラットフォーム呼び出しを使用してネイティブの Win32 `SwitchToThread` 関数を呼び出すことと同じです。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1288">This method is equivalent to using platform invoke to call the native Win32 `SwitchToThread` function.</span></span> <span data-ttu-id="8d5a0-1289">プラットフォーム呼び出しではなく、ホストが要求したカスタムスレッド動作をバイパスするので、プラットフォーム呼び出しを使用する代わりに、<xref:System.Threading.Thread.Yield%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="8d5a0-1289">You should call the <xref:System.Threading.Thread.Yield%2A> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
