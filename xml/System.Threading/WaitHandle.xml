<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b45f866d911db5b346d0c020668377c6c0462a03" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78780128" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit WaitHandle extends System.Object implements class System.IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Implements IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    interface IDisposable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>共有リソースへの排他アクセスの待機に使用するオペレーティング システム固有のオブジェクトをカプセル化します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle> クラスは、ネイティブオペレーティングシステムの同期ハンドルをカプセル化し、複数の待機操作を可能にするランタイム内のすべての同期オブジェクトを表すために使用されます。 他の同期オブジェクトとの待機ハンドルの比較については、「[同期プリミティブの概要](~/docs/standard/threading/overview-of-synchronization-primitives.md)」を参照してください。  
  
 <xref:System.Threading.WaitHandle> クラス自体は abstract です。 <xref:System.Threading.WaitHandle> から派生したクラスは、共有リソースへのアクセスを取得または解放することを示すシグナリング機構を定義しますが、共有リソースへのアクセスを待機している間、継承された <xref:System.Threading.WaitHandle> メソッドを使用してブロックします。 <xref:System.Threading.WaitHandle> から派生したクラスには次のものがあります。  
  
-   <xref:System.Threading.Mutex> クラス 「 [Mutex](~/docs/standard/threading/mutexes.md)」を参照してください。  
  
-   <xref:System.Threading.EventWaitHandle> クラスとその派生クラス、<xref:System.Threading.AutoResetEvent> および <xref:System.Threading.ManualResetEvent>。  
  
-   <xref:System.Threading.Semaphore> クラス 「[セマフォと SemaphoreSlim」を](~/docs/standard/threading/semaphore-and-semaphoreslim.md)参照してください。  
  
 スレッドは、<xref:System.Threading.WaitHandle>から派生したクラスによって継承されるインスタンスメソッド <xref:System.Threading.WaitHandle.WaitOne%2A>を呼び出すことによって、個々の待機ハンドルでブロックできます。  
  
 <xref:System.Threading.WaitHandle> の派生クラスは、スレッドアフィニティによって異なります。 イベント待機ハンドル (<xref:System.Threading.EventWaitHandle>、<xref:System.Threading.AutoResetEvent>、および <xref:System.Threading.ManualResetEvent>) と、セマフォにはスレッドアフィニティがありません。任意のスレッドは、イベント待機ハンドルまたはセマフォにシグナルを送ることができます。 一方、ミューテックスにはスレッドアフィニティがあります。ミューテックスを所有するスレッドは、ミューテックスを解放する必要があります。スレッドが所有していないミューテックスで <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出した場合、例外がスローされます。  
  
 <xref:System.Threading.WaitHandle> クラスは <xref:System.MarshalByRefObject>から派生するため、これらのクラスを使用して、アプリケーションドメインの境界を越えてスレッドのアクティビティを同期できます。  
  
 <xref:System.Threading.WaitHandle> クラスには、その派生クラスに加えて、1つまたは複数の同期オブジェクトがシグナルを受信するまでスレッドをブロックする静的メソッドが多数あります。 次の設定があります。  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>。スレッドは、1つの待機ハンドルをシグナルし、別の待機ハンドルをすぐに待機できます。  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>。配列内のすべての待機ハンドルがシグナルを受信するまでスレッドが待機できるようにします。  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>、指定された待機ハンドルのセットのいずれかがシグナル状態になるまでスレッドが待機できるようにします。  
  
 これらのメソッドのオーバーロードは、待機を破棄するためのタイムアウト間隔と、待機に入る前に同期コンテキストを終了する機会を提供し、他のスレッドが同期コンテキストを使用できるようにします。  
  
> [!IMPORTANT]
>  この型は <xref:System.IDisposable> インターフェイスを実装します。 型またはその派生型の使用が完了したら、直接または間接的に破棄する必要があります。 直接的に型を破棄するには、`try`/`catch` ブロック内で <xref:System.Threading.WaitHandle.Close%2A> メソッドを呼び出します。 間接的に型を破棄するには、`using` (C# の場合) または `Using` (Visual Basic 言語) などの言語構成要素を使用します。 詳細については、<xref:System.IDisposable> インターフェイスに関するトピック内の「IDisposable を実装するオブジェクトの使用」セクションを参照してください。  
  
 <xref:System.Threading.WaitHandle> は <xref:System.IDisposable.Dispose%2A> パターンを実装します。 「Dispose メソッドの実装」 (~/docs/standard/garbage-collection/implementing-dispose) を参照してください。 <xref:System.Threading.WaitHandle>から派生する場合は、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A> プロパティを使用して、ネイティブオペレーティングシステムハンドルを格納します。 追加のアンマネージリソースを使用しない限り、保護された <xref:System.Threading.WaitHandle.Dispose%2A> メソッドをオーバーライドする必要はありません。  
  
   
  
## Examples  
 次のコード例では、2つのスレッドがバックグラウンドタスクを実行できます。一方、メインスレッドは、<xref:System.Threading.WaitHandle> クラスの静的 <xref:System.Threading.WaitHandle.WaitAny%2A> および <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドを使用してタスクの完了を待機します。  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">スレッド</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">スレッド処理オブジェクトと機能</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">ミューテックス</related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle、AutoResetEvent、および ManualResetEvent</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">集合</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public WaitHandle ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WaitHandle();" FrameworkAlternate="netframework-1.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> によって保持されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Threading.WaitHandle> クラスとその派生クラスの <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> メソッドのパブリック実装です。 このメソッドは、`true` 引数を使用して `Dispose(Boolean)` のオーバーロードを呼び出し、<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> メソッドを呼び出す、標準の実装を提供します。 `WaitHandle` または派生クラスのインスタンスによって保持されているすべてのリソースを解放するには、このメソッドを呼び出します。  
  
 このメソッドが呼び出されると、現在のインスタンスへの参照によって未定義の動作が発生します。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle>への最後の参照を解放する前に、常に <xref:System.Threading.WaitHandle.Close%2A> または <xref:System.Threading.WaitHandle.Dispose> を呼び出してください。 それ以外の場合、使用しているリソースは解放されません。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで割り当てられたリソースを解放するには、<see langword="Dispose(Boolean)" /> メソッドをオーバーライドする必要があります。</para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Dispose メソッドの実装</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Threading.WaitHandle.Close%2A> メソッドに相当します。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle>への最後の参照を解放する前に、常に <xref:System.Threading.WaitHandle.Close%2A> または <xref:System.Threading.WaitHandle.Dispose> を呼び出してください。 それ以外の場合、使用しているリソースは解放されません。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">アンマネージ リソースのクリーンアップ</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>派生クラスでオーバーライドされると、<see cref="T:System.Threading.WaitHandle" /> によって使用されているアンマネージド リソースを解放し、オプションでマネージド リソースも解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Threading.WaitHandle.Close%2A> と、`explicitDisposing` パラメーターを `true`に設定した <xref:System.Threading.WaitHandle.Dispose> メソッドによって呼び出されます。  `explicitDisposing` パラメーターが `true`場合、このメソッドは、この <xref:System.Threading.WaitHandle> オブジェクトが参照するすべてのマネージオブジェクトによって保持されているすべてのリソースを解放します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで割り当てられたリソースを解放するには、<see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> メソッドをオーバーライドする必要があります。  
  
<see cref="M:System.Threading.WaitHandle.Close" /> または <see cref="M:System.Threading.WaitHandle.Dispose" /> メソッドは、他のオブジェクトから複数回呼び出すことができます。 このメソッドをオーバーライドする場合は、<see langword="Dispose" /> または <see langword="Close" />の以前の呼び出しで以前に破棄されたオブジェクトを参照しないように注意してください。</para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Dispose メソッドの実装</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスに保持されているリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> このメンバーは .NET Framework バージョン2.0 以降のバージョンから削除されています。 このトピックは、このトピックの「バージョン情報」に記載されているバージョンにのみ適用されます。


アプリケーションコードはこのメソッドを呼び出しません。ガベージコレクターによる終了処理が無効になっていない限り、ガベージコレクションの実行中に自動的に呼び出されます。 詳細については、次のトピックを参照してください。 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> および <xref:System.Object.Finalize> このメソッドは、<xref:System.Object.Finalize> をオーバーライドします。

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネイティブ オペレーティング システム ハンドルを取得または設定します。</summary>
        <value>ネイティブ オペレーティング システム ハンドルを表す <see langword="IntPtr" />。 既定値は <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> フィールドの値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しい値を <xref:System.Threading.WaitHandle.Handle%2A> プロパティに割り当てると、前のハンドルは閉じられません。 これにより、ハンドルがリークする可能性があります。  
  
 このプロパティは .NET Framework バージョン2.0 以降では使用しないでください。代わりに、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A> プロパティを使用してください。 このプロパティを有効なハンドルに設定すると、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A> プロパティも設定されますが、<xref:System.Threading.WaitHandle.InvalidHandle> に設定すると、ハンドルのリークが発生する可能性があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無効なネイティブ オペレーティング システム ハンドルを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle.Handle%2A> プロパティを初期化する目的で内部的に使用されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>この値を使用して、<see cref="P:System.Threading.WaitHandle.Handle" /> プロパティに有効なネイティブオペレーティングシステムハンドルが含まれているかどうかを判断できます。</para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネイティブ オペレーティング システム ハンドルを取得または設定します。</summary>
        <value>ネイティブ オペレーティング システム ハンドルを表す <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> プロパティに新しい値を割り当てると、前の <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> オブジェクトが収集されたときに、前のハンドルが閉じられます。 ハンドルを手動で閉じないでください。この結果、<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> がハンドルを閉じようとすると <xref:System.ObjectDisposedException> が発生します。  
  
 <xref:System.Threading.WaitHandle> は <xref:System.IDisposable.Dispose%2A> パターンを実装します。 「 [Dispose メソッドの実装」を](~/docs/standard/garbage-collection/implementing-dispose.md)参照してください。 <xref:System.Threading.WaitHandle>から派生する場合は、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A> プロパティを使用して、ネイティブハンドルのオペレーティングシステムハンドルを格納します。 追加のアンマネージリソースを使用しない限り、保護された <xref:System.Threading.WaitHandle.Dispose%2A> メソッドをオーバーライドする必要はありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="toSignal">通知対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">待機対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。</summary>
        <returns>通知と待機の両方が正常に完了した場合は <see langword="true" />。待機が完了しない場合、メソッドから制御は戻りません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この操作はアトミックであるとは限りません。 現在のスレッドが `toSignal` 通知した後、`toWaitOn`で待機する前に、別のプロセッサで実行されているスレッドは `toWaitOn` シグナル状態になるか、待機します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> メソッドのオーバーロードを使用して、メインスレッドがブロックされたスレッドを通知し、スレッドがタスクを完了するまで待機することができます。  
  
 この例では、5つのスレッドを開始し、<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> フラグを使用して作成された <xref:System.Threading.EventWaitHandle> でブロックできるようにします。次に、ユーザーが ENTER キーを押すたびに1つのスレッドを解放します。 この例では、別の5つのスレッドをキューに置いて、<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> フラグを使用して作成された <xref:System.Threading.EventWaitHandle> を使用してすべてを解放します。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" /> が <see langword="null" />です。  
  
- または - 
 <paramref name="toWaitOn" /> が <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="F:System.Threading.ApartmentState.STA" /> 状態のスレッドでメソッドが呼び出されました。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="toSignal" /> はセマフォで、カウントは既に最大値になっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="toSignal">通知対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">待機対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="millisecondsTimeout">待機する間隔を表す整数。 この値が <see cref="F:System.Threading.Timeout.Infinite" />、つまり -1 の場合、待機は無期限となります。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。タイムアウト間隔として 32 ビット符号付き整数を指定し、待機に入る前にコンテキストの同期ドメインを終了するかどうかを指定します。</summary>
        <returns>通知および待機の両方が正常に完了した場合は <see langword="true" />。通知は完了したが、待機がタイムアウトになった場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この操作はアトミックであるとは限りません。 現在のスレッドが `toSignal` 通知した後、`toWaitOn`で待機する前に、別のプロセッサで実行されているスレッドは `toWaitOn` シグナル状態になるか、待機します。  
  
 `millisecondsTimeout` がゼロの場合、メソッドはブロックしません。 `toWaitOn` の状態をテストし、すぐに制御を戻します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了に関する注意事項  
 `exitContext` パラメーターは、<xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。 これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。 <xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。  
  
 コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。 スレッドは、<xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。  
  
 これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>がある場合に便利です。 その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。 メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。 <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" /> が <see langword="null" />です。  
  
- または - 
 <paramref name="toWaitOn" /> が <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">メソッドは <see cref="F:System.Threading.ApartmentState.STA" /> 状態のスレッドで呼び出されます。</exception>
        <exception cref="T:System.InvalidOperationException">カウントの最大値を超えるため、<see cref="T:System.Threading.WaitHandle" /> はシグナル状態にはできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="toSignal">通知対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">待機対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="timeout">待機間隔を表す <see cref="T:System.TimeSpan" />。 この値が -1 の場合、待機は無期限となります。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。タイムアウト間隔として <see cref="T:System.TimeSpan" /> を指定し、待機に入る前にコンテキストの同期ドメインを終了するかどうかを指定します。</summary>
        <returns>通知および待機の両方が正常に完了した場合は <see langword="true" />。通知は完了したが、待機がタイムアウトになった場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この操作はアトミックであるとは限りません。 現在のスレッドが `toSignal` 通知した後、`toWaitOn`で待機する前に、別のプロセッサで実行されているスレッドは `toWaitOn` シグナル状態になるか、待機します。  
  
 `timeout` の最大値は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。  
  
 `timeout` がゼロの場合、メソッドはブロックしません。 `toWaitOn` の状態をテストし、すぐに制御を戻します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了に関する注意事項  
 `exitContext` パラメーターは、<xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。 これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。 <xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。  
  
 コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。 スレッドは、<xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。  
  
 これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>がある場合に便利です。 その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。 メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。 <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" /> が <see langword="null" />です。  
  
- または - 
 <paramref name="toWaitOn" /> が <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="F:System.Threading.ApartmentState.STA" /> 状態のスレッドでメソッドが呼び出されました。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="toSignal" /> はセマフォで、カウントは既に最大値になっています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は、-1 以外の負のミリ秒値となります。  
  
- または - 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberSignature Language="F#" Value="abstract member System.IDisposable.Dispose : unit -&gt; unit&#xA;override this.System.IDisposable.Dispose : unit -&gt; unit" Usage="waitHandle.System.IDisposable.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" /> によって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
`Dispose` を呼び出すと、<xref:System.Threading.WaitHandle> によって使用されるリソースを他の目的で再割り当てできます。 `Dispose`の詳細については、「[アンマネージリソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)」を参照してください。

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</param>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
        <returns><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />。それ以外の場合は、待機を続けます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。 以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドはミューテックスが破棄されたときに `true` を返します。 多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。 システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 すべてのハンドルがシグナル状態になると、<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドはを返します。 64を超えるハンドルが渡されると、<xref:System.NotSupportedException> がスローされます。 配列に重複が含まれている場合、呼び出しは <xref:System.DuplicateWaitObjectException>で失敗します。
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、<xref:System.Threading.ApartmentState.STA> 状態のスレッドではサポートされていません。
  
 このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出し、`exitContext`の `millisecondsTimeout` と `true` の-1 (または <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) を指定することと同じです。  
  
   
  
## Examples  
 次のコード例では、スレッドプールを使用して、ファイルのグループに対して非同期的に作成および書き込みを行う方法を示します。 各書き込み操作は、作業項目としてキューに登録され、完了時に通知されます。 メインスレッドは、すべての項目がシグナル状態になるのを待機してから終了します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。 - または - 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
- または - 
 <paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
- または - 
現在のスレッドの状態が <see cref="F:System.Threading.ApartmentState.STA" /> であり、<paramref name="waitHandles" /> に複数の要素が含まれています。</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照 (重複) を含めることはできません。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary><see cref="T:System.Int32" /> 値を使用して時間間隔を指定し、指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
        <returns><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は<see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `millisecondsTimeout` がゼロの場合、メソッドはブロックしません。 待機ハンドルの状態をテストし、すぐに制御を戻します。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、待機が終了したときにを返します。これは、すべてのハンドルがシグナル状態になったとき、またはタイムアウトが発生したときのいずれかを意味します。 64を超えるハンドルが渡されると、<xref:System.NotSupportedException> がスローされます。 配列に重複がある場合、呼び出しは <xref:System.DuplicateWaitObjectException>で失敗します。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、<xref:System.Threading.ApartmentState.STA> 状態のスレッドではサポートされていません。
  
 このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> のオーバーロードを呼び出し、`exitContext`に `false` を指定することと同じです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
- または - 
 <paramref name="waitHandles" /> は、要素を持たない配列です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
- または - 
現在のスレッドの状態が <see cref="F:System.Threading.ApartmentState.STA" /> であり、<paramref name="waitHandles" /> に複数の要素が含まれています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary><see cref="T:System.TimeSpan" /> 値を使用して時間間隔を指定し、指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
        <returns><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は<see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `timeout` がゼロの場合、メソッドはブロックしません。 待機ハンドルの状態をテストし、すぐに制御を戻します。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、待機が終了したときにを返します。これは、すべてのハンドルがシグナル状態になるか、タイムアウトが発生することを意味します。 64を超えるハンドルが渡されると、<xref:System.NotSupportedException> がスローされます。 配列に重複が含まれている場合、呼び出しは失敗します。
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、<xref:System.Threading.ApartmentState.STA> 状態のスレッドではサポートされていません。
  
 `timeout` の最大値は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。  
  
 このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> のオーバーロードを呼び出し、`exitContext`に `false` を指定することと同じです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
- または - 
 <paramref name="waitHandles" /> は、要素を持たない配列です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
- または - 
現在のスレッドの状態が <see cref="F:System.Threading.ApartmentState.STA" /> であり、<paramref name="waitHandles" /> に複数の要素が含まれています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。 
- または - 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照 (重複) を含めることはできません。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。<see cref="T:System.Int32" /> 値を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は<see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `millisecondsTimeout` がゼロの場合、メソッドはブロックしません。 待機ハンドルの状態をテストし、すぐに制御を戻します。  
  
 <xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。 以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドはミューテックスが破棄されたときに `true` を返します。 多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。 システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、待機が終了したときにを返します。これは、すべてのハンドルがシグナル状態になったとき、またはタイムアウトが発生したときのいずれかを意味します。 64を超えるハンドルが渡されると、<xref:System.NotSupportedException> がスローされます。 配列に重複がある場合、呼び出しは <xref:System.DuplicateWaitObjectException>で失敗します。
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、<xref:System.Threading.ApartmentState.STA> 状態のスレッドではサポートされていません。
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了に関する注意事項  
 `exitContext` パラメーターは、<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。 これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。 <xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。  
  
 コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。 スレッドは、<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。  
  
 これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 属性がある場合に便利です。 その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。 メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。 <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。  
  
   
  
## Examples  
 次のコード例では、スレッドプールを使用して、ファイルのグループに対して非同期的に作成および書き込みを行う方法を示します。 各書き込み操作は、作業項目としてキューに登録され、完了時に通知されます。 メインスレッドは、すべての項目がシグナル状態になるのを待機してから終了します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
- または - 
 <paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
- または - 
現在のスレッドの状態が <see cref="F:System.Threading.ApartmentState.STA" /> であり、<paramref name="waitHandles" /> に複数の要素が含まれています。</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。<see cref="T:System.TimeSpan" /> 値を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `timeout` がゼロの場合、メソッドはブロックしません。 待機ハンドルの状態をテストし、すぐに制御を戻します。  
  
 <xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。 以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドはミューテックスが破棄されたときに `true` を返します。 多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。 システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、待機が終了したときにを返します。これは、すべてのハンドルがシグナル状態になるか、タイムアウトが発生することを意味します。 64を超えるハンドルが渡されると、<xref:System.NotSupportedException> がスローされます。 配列に重複が含まれている場合、呼び出しは失敗します。
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、<xref:System.Threading.ApartmentState.STA> 状態のスレッドではサポートされていません。
  
 `timeout` の最大値は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了に関する注意事項  
 `exitContext` パラメーターは、<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。 これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。 <xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。  
  
 コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。 <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。  
  
 これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>がある場合に便利です。 その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。 メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。 <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。  
  
   
  
## Examples  
 次のコード例では、スレッドプールを使用して、ファイルのグループに対して非同期的に作成および書き込みを行う方法を示します。 各書き込み操作は、作業項目としてキューに登録され、完了時に通知されます。 メインスレッドは、すべての項目がシグナル状態になるのを待機してから終了します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
- または - 
 <paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
- または - 
<see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。 
- または - 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <summary>指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行するオブジェクトの配列インデックス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。 以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、ミューテックスが破棄されたために待機が完了した場合に `true` を返します。 多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。 システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、中断されたミューテックスが原因で待機が完了した場合にのみ、<xref:System.Threading.AbandonedMutexException> をスローします。 解放された mutex が、破棄された mutex よりも小さいインデックス番号で `waitHandles` 含まれる場合、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは正常に完了し、例外はスローされません。  
  
> [!NOTE]
>  バージョン2.0 より前の .NET Framework のバージョンでは、<xref:System.Threading.Mutex>を明示的に解放せずにスレッドが終了または中止し、`Mutex` が別のスレッドの `WaitAny` 配列のインデックス 0 (ゼロ) にある場合、`WaitAny` によって返されるインデックスは、0ではなく128になります。  
  
 ハンドルがシグナル状態になると、このメソッドはを返します。 呼び出し中に複数のオブジェクトがシグナル状態になると、戻り値は、シグナルが発生したすべてのオブジェクトの最小のインデックス値を持つシグナル化されたオブジェクトの配列インデックスになります。

 待機ハンドルの最大数は64、現在のスレッドが <xref:System.Threading.ApartmentState.STA> 状態の場合は63です。

 このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出し、`exitContext`の `millisecondsTimeout` と `true` の-1 (または <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) を指定することと同じです。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドの呼び出しを示しています。  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ApplicationException">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>32 ビット符号付き整数を使用して時間間隔を指定し、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="millisecondsTimeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `millisecondsTimeout` がゼロの場合、メソッドはブロックしません。 待機ハンドルの状態をテストし、すぐに制御を戻します。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、中断されたミューテックスが原因で待機が完了した場合にのみ、<xref:System.Threading.AbandonedMutexException> をスローします。 解放された mutex が、破棄された mutex よりも小さいインデックス番号で `waitHandles` 含まれる場合、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは正常に完了し、例外はスローされません。  
  
 このメソッドは、待機が終了したとき、いずれかのハンドルがシグナル状態になったとき、またはタイムアウトが発生したときに、を返します。 呼び出し中に複数のオブジェクトがシグナル状態になると、戻り値は、シグナルが発生したすべてのオブジェクトの最小のインデックス値を持つシグナル化されたオブジェクトの配列インデックスになります。

 待機ハンドルの最大数は64、現在のスレッドが <xref:System.Threading.ApartmentState.STA> 状態の場合は63です。
  
 このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> のオーバーロードを呼び出し、`exitContext`に `false` を指定することと同じです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" /> は、要素を持たない配列です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary><see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="timeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `timeout` がゼロの場合、メソッドはブロックしません。 待機ハンドルの状態をテストし、すぐに制御を戻します。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、中断されたミューテックスが原因で待機が完了した場合にのみ、<xref:System.Threading.AbandonedMutexException> をスローします。 解放された mutex が、破棄された mutex よりも小さいインデックス番号で `waitHandles` 含まれる場合、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは正常に完了し、例外はスローされません。  
  
 このメソッドは、待機が終了したとき、いずれかのハンドルがシグナル状態になったとき、またはタイムアウトが発生したときに、を返します。 呼び出し中に複数のオブジェクトがシグナル状態になると、戻り値は、シグナルが発生したすべてのオブジェクトの最小のインデックス値を持つシグナル化されたオブジェクトの配列インデックスになります。

 待機ハンドルの最大数は64、現在のスレッドが <xref:System.Threading.ApartmentState.STA> 状態の場合は63です。

 `timeout` の最大値は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。  
  
 このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> のオーバーロードを呼び出し、`exitContext`に `false` を指定することと同じです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。 
- または - 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" /> は、要素を持たない配列です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>32 ビットの符号付き整数を使用して時間間隔を指定し、待機する前に同期ドメインを終了するかどうかを指定して、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="millisecondsTimeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `millisecondsTimeout` がゼロの場合、メソッドはブロックしません。 待機ハンドルの状態をテストし、すぐに制御を戻します。  
  
 <xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。 以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、ミューテックスが破棄されたために待機が完了した場合に `true` を返します。 多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。 システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、中断されたミューテックスが原因で待機が完了した場合にのみ、<xref:System.Threading.AbandonedMutexException> をスローします。 解放された mutex が、破棄された mutex よりも小さいインデックス番号で `waitHandles` 含まれる場合、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは正常に完了し、例外はスローされません。  
  
> [!NOTE]
>  バージョン2.0 より前の .NET Framework のバージョンでは、<xref:System.Threading.Mutex>を明示的に解放せずにスレッドが終了または中止し、`Mutex` が別のスレッドの `WaitAny` 配列のインデックス 0 (ゼロ) にある場合、`WaitAny` によって返されるインデックスは、0ではなく128になります。  
  
 このメソッドは、待機が終了したとき、いずれかのハンドルがシグナル状態になったとき、またはタイムアウトが発生したときに、を返します。 呼び出し中に複数のオブジェクトがシグナル状態になると、戻り値は、シグナルが発生したすべてのオブジェクトの最小のインデックス値を持つシグナル化されたオブジェクトの配列インデックスになります。

 待機ハンドルの最大数は64、現在のスレッドが <xref:System.Threading.ApartmentState.STA> 状態の場合は63です。
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了に関する注意事項  
 `exitContext` パラメーターは、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。 これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。 <xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。  
  
 コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。 スレッドは、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。  
  
 これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>がある場合に便利です。 その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。 メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。 <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。  
  
   
  
## Examples  
 次のコード例は、スレッドプールを使用して複数のディスク上のファイルを同時に検索する方法を示しています。 領域に関する考慮事項については、各ディスクのルートディレクトリのみが検索されます。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ApplicationException">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した配列内のいずれかの要素がシグナルを受信するまで待機します。<see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="timeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `timeout` がゼロの場合、メソッドはブロックしません。 待機ハンドルの状態をテストし、すぐに制御を戻します。  
  
 <xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。 以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、ミューテックスが破棄されたために待機が完了した場合に `true` を返します。 多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。 システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、中断されたミューテックスが原因で待機が完了した場合にのみ、<xref:System.Threading.AbandonedMutexException> をスローします。 解放された mutex が、破棄された mutex よりも小さいインデックス番号で `waitHandles` 含まれる場合、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは正常に完了し、例外はスローされません。  
  
> [!NOTE]
>  バージョン2.0 より前の .NET Framework のバージョンでは、<xref:System.Threading.Mutex>を明示的に解放せずにスレッドが終了または中止し、`Mutex` が別のスレッドの `WaitAny` 配列のインデックス 0 (ゼロ) にある場合、`WaitAny` によって返されるインデックスは、0ではなく128になります。  
  
 このメソッドは、待機が終了したとき、いずれかのハンドルがシグナル状態になったとき、またはタイムアウトが発生したときに、を返します。 呼び出し中に複数のオブジェクトがシグナル状態になると、戻り値は、シグナルが発生したすべてのオブジェクトの最小のインデックス値を持つシグナル化されたオブジェクトの配列インデックスになります。

 待機ハンドルの最大数は64、現在のスレッドが <xref:System.Threading.ApartmentState.STA> 状態の場合は63です。

 `timeout` の最大値は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了に関する注意事項  
 `exitContext` パラメーターは、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。 これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。 <xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。  
  
 コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。 スレッドは、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。  
  
 これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>がある場合に便利です。 その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。 メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。 <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。  
  
   
  
## Examples  
 次のコード例は、スレッドプールを使用して複数のディスク上のファイルを同時に検索する方法を示しています。 領域に関する考慮事項については、各ディスクのルートディレクトリのみが検索されます。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
- または - 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ApplicationException">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。 
- または - 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受け取るまで、現在のスレッドをブロックします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受け取るまで、現在のスレッドをブロックします。</summary>
        <returns>現在のインスタンスがシグナルを受け取った場合は <see langword="true" />。 現在のインスタンスがシグナルを受け取らない場合は、<see cref="M:System.Threading.WaitHandle.WaitOne" /> はシグナルを受け取るまで待機を続けます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。 以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドはミューテックスが破棄されたときに `true` を返します。 多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。 システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 このメソッドの呼び出し元は、現在のインスタンスがシグナルを受信するまで無期限にブロックされます。 <xref:System.Threading.WaitHandle> が別のスレッドからのシグナルを受信するまでブロックするには、このメソッドを使用します (非同期操作の完了時にが生成されるなど)。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出し、最初のパラメーターに-1 または <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> を指定し、2番目のパラメーターに `false` を指定することと同じです。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
   
  
## Examples  
 次のコード例は、待機ハンドルを使用して、バックグラウンドスレッドの実行が完了するのを待機している間にプロセスを終了しないようにする方法を示しています。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>32 ビット符号付き整数を使用して時間間隔をミリ秒単位で指定し、現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受信するまで、現在のスレッドをブロックします。</summary>
        <returns>現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `millisecondsTimeout` がゼロの場合、メソッドはブロックしません。 待機ハンドルの状態をテストし、すぐに制御を戻します。  
  
 このメソッドの呼び出し元は、現在のインスタンスがシグナルを受信するか、タイムアウトが発生するまでブロックします。 <xref:System.Threading.WaitHandle> が別のスレッドからのシグナルを受信するまでブロックするには、このメソッドを使用します (非同期操作の完了時にが生成されるなど)。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
 このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> のオーバーロードを呼び出し、`exitContext`に `false` を指定することと同じです。  
  
   
  
## Examples  
 次のコード例は、待機ハンドルを使用して、バックグラウンドスレッドの実行が完了するのを待機している間にプロセスを終了しないようにする方法を示しています。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary><see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、現在のインスタンスがシグナルを受信するまで現在のスレッドをブロックします。</summary>
        <returns>現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `timeout` がゼロの場合、メソッドはブロックしません。 待機ハンドルの状態をテストし、すぐに制御を戻します。  
  
 このメソッドの呼び出し元は、現在のインスタンスがシグナルを受信するか、タイムアウトが発生するまでブロックします。 <xref:System.Threading.WaitHandle> が別のスレッドからのシグナルを受信するまでブロックするには、このメソッドを使用します (非同期操作の完了時にが生成されるなど)。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
 `timeout` の最大値は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。  
  
 このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> のオーバーロードを呼び出し、`exitContext`に `false` を指定することと同じです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。 
- または - 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受信するまで現在のスレッドをブロックします。時間間隔を指定するために 32 ビット符号付き整数を使用し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `millisecondsTimeout` がゼロの場合、メソッドはブロックしません。 待機ハンドルの状態をテストし、すぐに制御を戻します。  
  
 <xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。 以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドはミューテックスが破棄されたときに `true` を返します。 多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。 システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 このメソッドの呼び出し元は、現在のインスタンスがシグナルを受信するか、タイムアウトが発生するまでブロックします。 <xref:System.Threading.WaitHandle> が別のスレッドからのシグナルを受信するまでブロックするには、このメソッドを使用します (非同期操作の完了時にが生成されるなど)。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了に関する注意事項  
 `exitContext` パラメーターは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。 これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。 <xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。  
  
 コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。 スレッドは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。  
  
 これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>がある場合に便利です。 その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。 メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。 <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。  
  
   
  
## Examples  
 次の例は、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> メソッドのオーバーロードが同期ドメイン内で呼び出された場合の動作を示しています。 まず、スレッドは `exitContext` が `false` に設定された状態で待機し、待機タイムアウトが経過するまでブロックします。 2番目のスレッドは、最初のスレッドが終了した後に実行され、`exitContext` を `true`に設定して待機します。 この2番目のスレッドの待機ハンドルを通知する呼び出しはブロックされず、スレッドは待機タイムアウト前に完了します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>現在のインスタンスがシグナルを受信するまで現在のスレッドをブロックします。<see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `timeout` がゼロの場合、メソッドはブロックしません。 待機ハンドルの状態をテストし、すぐに制御を戻します。  
  
 <xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。 以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドはミューテックスが破棄されたときに `true` を返します。 多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。 システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 このメソッドの呼び出し元は、現在のインスタンスがシグナルを受信するか、タイムアウトが発生するまでブロックします。 <xref:System.Threading.WaitHandle> が別のスレッドからのシグナルを受信するまでブロックするには、このメソッドを使用します (非同期操作の完了時にが生成されるなど)。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
 `timeout` の最大値は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了に関する注意事項  
 `exitContext` パラメーターは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。 これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。 <xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。  
  
 コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。 スレッドは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。  
  
 これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>がある場合に便利です。 その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。 メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。 <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。  
  
   
  
## Examples  
 次のコード例は、待機ハンドルを使用して、バックグラウンドスレッドの実行が完了するのを待機している間にプロセスを終了しないようにする方法を示しています。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。 
- または - 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>待機ハンドルがシグナル状態になる前に <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 操作がタイムアウトになったことを示します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドは、`WaitAny`の可能性のある戻り値の1つです。  
  
   
  
## Examples  
 次のコード例は、スレッドプールを使用して複数のディスク上のファイルを同時に検索する方法を示しています。 領域に関する考慮事項については、各ディスクのルートディレクトリのみが検索されます。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
