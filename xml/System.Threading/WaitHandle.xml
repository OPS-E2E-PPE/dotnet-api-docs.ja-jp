<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="107e6ef6e51385d5827461c353aa32b70f721838" /><Meta Name="ms.sourcegitcommit" Value="1403e40e1f487577d6846a42664d2e74b78a08b7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="01/29/2020" /><Meta Name="ms.locfileid" Value="76824755" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="f6597-101">共有リソースへの排他アクセスの待機に使用するオペレーティング システム固有のオブジェクトをカプセル化します。</span><span class="sxs-lookup"><span data-stu-id="f6597-101">Encapsulates operating system-specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-102"><xref:System.Threading.WaitHandle> クラスは、ネイティブオペレーティングシステムの同期ハンドルをカプセル化し、複数の待機操作を可能にするランタイム内のすべての同期オブジェクトを表すために使用されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="f6597-103">他の同期オブジェクトとの待機ハンドルの比較については、「[同期プリミティブの概要](~/docs/standard/threading/overview-of-synchronization-primitives.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="f6597-104"><xref:System.Threading.WaitHandle> クラス自体は abstract です。</span><span class="sxs-lookup"><span data-stu-id="f6597-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="f6597-105"><xref:System.Threading.WaitHandle> から派生したクラスは、共有リソースへのアクセスを取得または解放することを示すシグナリング機構を定義しますが、共有リソースへのアクセスを待機している間、継承された <xref:System.Threading.WaitHandle> メソッドを使用してブロックします。</span><span class="sxs-lookup"><span data-stu-id="f6597-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="f6597-106"><xref:System.Threading.WaitHandle> から派生したクラスには次のものがあります。</span><span class="sxs-lookup"><span data-stu-id="f6597-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="f6597-107"><xref:System.Threading.Mutex> クラス</span><span class="sxs-lookup"><span data-stu-id="f6597-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="f6597-108">「 [Mutex](~/docs/standard/threading/mutexes.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="f6597-109"><xref:System.Threading.EventWaitHandle> クラスとその派生クラス、<xref:System.Threading.AutoResetEvent> および <xref:System.Threading.ManualResetEvent>。</span><span class="sxs-lookup"><span data-stu-id="f6597-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span>  
  
-   <span data-ttu-id="f6597-110"><xref:System.Threading.Semaphore> クラス</span><span class="sxs-lookup"><span data-stu-id="f6597-110">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="f6597-111">「[セマフォと SemaphoreSlim」を](~/docs/standard/threading/semaphore-and-semaphoreslim.md)参照してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-111">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="f6597-112">スレッドは、<xref:System.Threading.WaitHandle>から派生したクラスによって継承されるインスタンスメソッド <xref:System.Threading.WaitHandle.WaitOne%2A>を呼び出すことによって、個々の待機ハンドルでブロックできます。</span><span class="sxs-lookup"><span data-stu-id="f6597-112">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="f6597-113"><xref:System.Threading.WaitHandle> の派生クラスは、スレッドアフィニティによって異なります。</span><span class="sxs-lookup"><span data-stu-id="f6597-113">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="f6597-114">イベント待機ハンドル (<xref:System.Threading.EventWaitHandle>、<xref:System.Threading.AutoResetEvent>、および <xref:System.Threading.ManualResetEvent>) と、セマフォにはスレッドアフィニティがありません。任意のスレッドは、イベント待機ハンドルまたはセマフォにシグナルを送ることができます。</span><span class="sxs-lookup"><span data-stu-id="f6597-114">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="f6597-115">一方、ミューテックスにはスレッドアフィニティがあります。ミューテックスを所有するスレッドは、ミューテックスを解放する必要があります。スレッドが所有していないミューテックスで <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出した場合、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f6597-115">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="f6597-116"><xref:System.Threading.WaitHandle> クラスは <xref:System.MarshalByRefObject>から派生するため、これらのクラスを使用して、アプリケーションドメインの境界を越えてスレッドのアクティビティを同期できます。</span><span class="sxs-lookup"><span data-stu-id="f6597-116">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="f6597-117"><xref:System.Threading.WaitHandle> クラスには、その派生クラスに加えて、1つまたは複数の同期オブジェクトがシグナルを受信するまでスレッドをブロックする静的メソッドが多数あります。</span><span class="sxs-lookup"><span data-stu-id="f6597-117">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="f6597-118">次の設定があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-118">These include:</span></span>  
  
-   <span data-ttu-id="f6597-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>。スレッドは、1つの待機ハンドルをシグナルし、別の待機ハンドルをすぐに待機できます。</span><span class="sxs-lookup"><span data-stu-id="f6597-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="f6597-120"><xref:System.Threading.WaitHandle.WaitAll%2A>。配列内のすべての待機ハンドルがシグナルを受信するまでスレッドが待機できるようにします。</span><span class="sxs-lookup"><span data-stu-id="f6597-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="f6597-121"><xref:System.Threading.WaitHandle.WaitAny%2A>、指定された待機ハンドルのセットのいずれかがシグナル状態になるまでスレッドが待機できるようにします。</span><span class="sxs-lookup"><span data-stu-id="f6597-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled.</span></span>  
  
 <span data-ttu-id="f6597-122">これらのメソッドのオーバーロードは、待機を破棄するためのタイムアウト間隔と、待機に入る前に同期コンテキストを終了する機会を提供し、他のスレッドが同期コンテキストを使用できるようにします。</span><span class="sxs-lookup"><span data-stu-id="f6597-122">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f6597-123">この型は <xref:System.IDisposable> インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="f6597-123">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="f6597-124">型またはその派生型の使用が完了したら、直接または間接的に破棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-124">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="f6597-125">直接的に型を破棄するには、`try`/`catch` ブロック内で <xref:System.Threading.WaitHandle.Close%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f6597-125">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="f6597-126">間接的に型を破棄するには、`using` (C# の場合) または `Using` (Visual Basic 言語) などの言語構成要素を使用します。</span><span class="sxs-lookup"><span data-stu-id="f6597-126">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="f6597-127">詳細については、<xref:System.IDisposable> インターフェイスに関するトピック内の「IDisposable を実装するオブジェクトの使用」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-127">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="f6597-128"><xref:System.Threading.WaitHandle> は <xref:System.IDisposable.Dispose%2A> パターンを実装します。</span><span class="sxs-lookup"><span data-stu-id="f6597-128"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="f6597-129">「Dispose メソッドの実装」 (~/docs/standard/garbage-collection/implementing-dispose) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-129">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="f6597-130"><xref:System.Threading.WaitHandle>から派生する場合は、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A> プロパティを使用して、ネイティブオペレーティングシステムハンドルを格納します。</span><span class="sxs-lookup"><span data-stu-id="f6597-130">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="f6597-131">追加のアンマネージリソースを使用しない限り、保護された <xref:System.Threading.WaitHandle.Dispose%2A> メソッドをオーバーライドする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="f6597-131">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6597-132">次のコード例では、2つのスレッドがバックグラウンドタスクを実行できます。一方、メインスレッドは、<xref:System.Threading.WaitHandle> クラスの静的 <xref:System.Threading.WaitHandle.WaitAny%2A> および <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドを使用してタスクの完了を待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-132">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="f6597-133">この型はスレッド セーフです。</span><span class="sxs-lookup"><span data-stu-id="f6597-133">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="f6597-134">スレッド</span><span class="sxs-lookup"><span data-stu-id="f6597-134">Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md"><span data-ttu-id="f6597-135">スレッド処理オブジェクトと機能</span><span class="sxs-lookup"><span data-stu-id="f6597-135">Threading Objects and Features</span></span></related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="f6597-136">ミューテックス</span><span class="sxs-lookup"><span data-stu-id="f6597-136">Mutexes</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d"><span data-ttu-id="f6597-137">EventWaitHandle、AutoResetEvent、および ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="f6597-137">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span></span></related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="f6597-138">集合</span><span class="sxs-lookup"><span data-stu-id="f6597-138">Semaphores</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public WaitHandle ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WaitHandle();" FrameworkAlternate="netframework-1.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6597-139"><see cref="T:System.Threading.WaitHandle" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="f6597-139">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6597-140">現在の <see cref="T:System.Threading.WaitHandle" /> によって保持されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="f6597-140">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-141">このメソッドは、<xref:System.Threading.WaitHandle> クラスとその派生クラスの <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> メソッドのパブリック実装です。</span><span class="sxs-lookup"><span data-stu-id="f6597-141">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="f6597-142">このメソッドは、`true` 引数を使用して `Dispose(Boolean)` のオーバーロードを呼び出し、<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> メソッドを呼び出す、標準の実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="f6597-142">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f6597-143">`WaitHandle` または派生クラスのインスタンスによって保持されているすべてのリソースを解放するには、このメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f6597-143">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="f6597-144">このメソッドが呼び出されると、現在のインスタンスへの参照によって未定義の動作が発生します。</span><span class="sxs-lookup"><span data-stu-id="f6597-144">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6597-145"><xref:System.Threading.WaitHandle>への最後の参照を解放する前に、常に <xref:System.Threading.WaitHandle.Close%2A> または <xref:System.Threading.WaitHandle.Dispose> を呼び出してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-145">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="f6597-146">それ以外の場合、使用しているリソースは解放されません。</span><span class="sxs-lookup"><span data-stu-id="f6597-146">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="f6597-147">派生クラスで割り当てられたリソースを解放するには、<see langword="Dispose(Boolean)" /> メソッドをオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-147">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="f6597-148">Dispose メソッドの実装</span><span class="sxs-lookup"><span data-stu-id="f6597-148">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6597-149"><see cref="T:System.Threading.WaitHandle" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="f6597-149">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6597-150"><see cref="T:System.Threading.WaitHandle" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="f6597-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-151">このメソッドは、<xref:System.Threading.WaitHandle.Close%2A> メソッドに相当します。</span><span class="sxs-lookup"><span data-stu-id="f6597-151">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6597-152"><xref:System.Threading.WaitHandle>への最後の参照を解放する前に、常に <xref:System.Threading.WaitHandle.Close%2A> または <xref:System.Threading.WaitHandle.Dispose> を呼び出してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-152">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="f6597-153">それ以外の場合、使用しているリソースは解放されません。</span><span class="sxs-lookup"><span data-stu-id="f6597-153">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md"><span data-ttu-id="f6597-154">アンマネージ リソースのクリーンアップ</span><span class="sxs-lookup"><span data-stu-id="f6597-154">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing"><span data-ttu-id="f6597-155">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-155"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="f6597-156">派生クラスでオーバーライドされると、<see cref="T:System.Threading.WaitHandle" /> によって使用されているアンマネージド リソースを解放し、オプションでマネージド リソースも解放します。</span><span class="sxs-lookup"><span data-stu-id="f6597-156">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-157">このメソッドは、<xref:System.Threading.WaitHandle.Close%2A> と、`explicitDisposing` パラメーターを `true`に設定した <xref:System.Threading.WaitHandle.Dispose> メソッドによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-157">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="f6597-158">`explicitDisposing` パラメーターが `true`場合、このメソッドは、この <xref:System.Threading.WaitHandle> オブジェクトが参照するすべてのマネージオブジェクトによって保持されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="f6597-158">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="f6597-159">派生クラスで割り当てられたリソースを解放するには、<see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> メソッドをオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-159">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
<span data-ttu-id="f6597-160"><see cref="M:System.Threading.WaitHandle.Close" /> または <see cref="M:System.Threading.WaitHandle.Dispose" /> メソッドは、他のオブジェクトから複数回呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="f6597-160">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="f6597-161">このメソッドをオーバーライドする場合は、<see langword="Dispose" /> または <see langword="Close" />の以前の呼び出しで以前に破棄されたオブジェクトを参照しないように注意してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-161">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="f6597-162">Dispose メソッドの実装</span><span class="sxs-lookup"><span data-stu-id="f6597-162">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6597-163">現在のインスタンスに保持されているリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="f6597-163">Releases the resources held by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> <span data-ttu-id="f6597-164">このメンバーは .NET Framework バージョン2.0 以降のバージョンから削除されています。</span><span class="sxs-lookup"><span data-stu-id="f6597-164">This member has been removed from the .NET Framework version 2.0 and subsequent versions.</span></span> <span data-ttu-id="f6597-165">このトピックは、このトピックの「バージョン情報」に記載されているバージョンにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-165">This topic applies only to the versions listed in "Version Information" later in this topic.</span></span>


<span data-ttu-id="f6597-166">アプリケーションコードはこのメソッドを呼び出しません。ガベージコレクターによる終了処理が無効になっていない限り、ガベージコレクションの実行中に自動的に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-166">Application code does not call this method; it is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled.</span></span> <span data-ttu-id="f6597-167">詳細については、次のトピックを参照してください。 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> および <xref:System.Object.Finalize></span><span class="sxs-lookup"><span data-stu-id="f6597-167">For more information, see <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> and <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="f6597-168">このメソッドは、<xref:System.Object.Finalize> をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="f6597-168">This method overrides <xref:System.Object.Finalize>.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6597-169">ネイティブ オペレーティング システム ハンドルを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="f6597-169">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="f6597-170">ネイティブ オペレーティング システム ハンドルを表す <see langword="IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-170">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="f6597-171">既定値は <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> フィールドの値です。</span><span class="sxs-lookup"><span data-stu-id="f6597-171">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-172">新しい値を <xref:System.Threading.WaitHandle.Handle%2A> プロパティに割り当てると、前のハンドルは閉じられません。</span><span class="sxs-lookup"><span data-stu-id="f6597-172">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="f6597-173">これにより、ハンドルがリークする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-173">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="f6597-174">このプロパティは .NET Framework バージョン2.0 以降では使用しないでください。代わりに、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A> プロパティを使用してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-174">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="f6597-175">このプロパティを有効なハンドルに設定すると、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A> プロパティも設定されますが、<xref:System.Threading.WaitHandle.InvalidHandle> に設定すると、ハンドルのリークが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-175">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f6597-176">プロパティ値を設定するには、直接の呼び出し元に対して完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="f6597-176">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="f6597-177">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは設定できません。</span><span class="sxs-lookup"><span data-stu-id="f6597-177">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="f6597-178">派生型には、プロパティ値を設定するための <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> が必要です。</span><span class="sxs-lookup"><span data-stu-id="f6597-178">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6597-179">無効なネイティブ オペレーティング システム ハンドルを表します。</span><span class="sxs-lookup"><span data-stu-id="f6597-179">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="f6597-180">このフィールドは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="f6597-180">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-181"><xref:System.Threading.WaitHandle.Handle%2A> プロパティを初期化する目的で内部的に使用されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-181">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="f6597-182">この値を使用して、<see cref="P:System.Threading.WaitHandle.Handle" /> プロパティに有効なネイティブオペレーティングシステムハンドルが含まれているかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="f6597-182">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6597-183">ネイティブ オペレーティング システム ハンドルを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="f6597-183">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="f6597-184">ネイティブ オペレーティング システム ハンドルを表す <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-184">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-185"><xref:System.Threading.WaitHandle.SafeWaitHandle%2A> プロパティに新しい値を割り当てると、前の <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> オブジェクトが収集されたときに、前のハンドルが閉じられます。</span><span class="sxs-lookup"><span data-stu-id="f6597-185">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="f6597-186">ハンドルを手動で閉じないでください。この結果、<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> がハンドルを閉じようとすると <xref:System.ObjectDisposedException> が発生します。</span><span class="sxs-lookup"><span data-stu-id="f6597-186">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="f6597-187"><xref:System.Threading.WaitHandle> は <xref:System.IDisposable.Dispose%2A> パターンを実装します。</span><span class="sxs-lookup"><span data-stu-id="f6597-187"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="f6597-188">「 [Dispose メソッドの実装」を](~/docs/standard/garbage-collection/implementing-dispose.md)参照してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-188">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span> <span data-ttu-id="f6597-189"><xref:System.Threading.WaitHandle>から派生する場合は、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A> プロパティを使用して、ネイティブハンドルのオペレーティングシステムハンドルを格納します。</span><span class="sxs-lookup"><span data-stu-id="f6597-189">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="f6597-190">追加のアンマネージリソースを使用しない限り、保護された <xref:System.Threading.WaitHandle.Dispose%2A> メソッドをオーバーライドする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="f6597-190">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f6597-191">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="f6597-191">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="f6597-192">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="f6597-192">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="f6597-193">派生型には、このメンバーを呼び出すための <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> が必要です。</span><span class="sxs-lookup"><span data-stu-id="f6597-193">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6597-194">1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-194">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="f6597-195">通知対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-195">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="f6597-196">待機対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-196">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="f6597-197">1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-197">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns><span data-ttu-id="f6597-198">通知と待機の両方が正常に完了した場合は <see langword="true" />。待機が完了しない場合、メソッドから制御は戻りません。</span><span class="sxs-lookup"><span data-stu-id="f6597-198"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-199">この操作はアトミックであるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="f6597-199">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="f6597-200">現在のスレッドが `toSignal` 通知した後、`toWaitOn`で待機する前に、別のプロセッサで実行されているスレッドは `toWaitOn` シグナル状態になるか、待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-200">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6597-201">次のコード例では、<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> メソッドのオーバーロードを使用して、メインスレッドがブロックされたスレッドを通知し、スレッドがタスクを完了するまで待機することができます。</span><span class="sxs-lookup"><span data-stu-id="f6597-201">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="f6597-202">この例では、5つのスレッドを開始し、<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> フラグを使用して作成された <xref:System.Threading.EventWaitHandle> でブロックできるようにします。次に、ユーザーが ENTER キーを押すたびに1つのスレッドを解放します。</span><span class="sxs-lookup"><span data-stu-id="f6597-202">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="f6597-203">この例では、別の5つのスレッドをキューに置いて、<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> フラグを使用して作成された <xref:System.Threading.EventWaitHandle> を使用してすべてを解放します。</span><span class="sxs-lookup"><span data-stu-id="f6597-203">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6597-204"><paramref name="toSignal" /> が <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="f6597-204"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-205">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-205">-or-</span></span> 
 <span data-ttu-id="f6597-206"><paramref name="toWaitOn" /> が <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="f6597-206"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6597-207"><see cref="F:System.Threading.ApartmentState.STA" /> 状態のスレッドでメソッドが呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="f6597-207">The method was called on a thread in <see cref="F:System.Threading.ApartmentState.STA" /> state.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-208"><paramref name="toSignal" /> はセマフォで、カウントは既に最大値になっています。</span><span class="sxs-lookup"><span data-stu-id="f6597-208"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-209">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-209">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-210">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-210">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="f6597-211">通知対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-211">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="f6597-212">待機対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-212">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="f6597-213">待機する間隔を表す整数。</span><span class="sxs-lookup"><span data-stu-id="f6597-213">An integer that represents the interval to wait.</span></span> <span data-ttu-id="f6597-214">この値が <see cref="F:System.Threading.Timeout.Infinite" />、つまり -1 の場合、待機は無期限となります。</span><span class="sxs-lookup"><span data-stu-id="f6597-214">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f6597-215">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-215"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f6597-216">1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。タイムアウト間隔として 32 ビット符号付き整数を指定し、待機に入る前にコンテキストの同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="f6597-216">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="f6597-217">通知および待機の両方が正常に完了した場合は <see langword="true" />。通知は完了したが、待機がタイムアウトになった場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-217"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-218">この操作はアトミックであるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="f6597-218">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="f6597-219">現在のスレッドが `toSignal` 通知した後、`toWaitOn`で待機する前に、別のプロセッサで実行されているスレッドは `toWaitOn` シグナル状態になるか、待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-219">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="f6597-220">`millisecondsTimeout` がゼロの場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="f6597-220">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f6597-221">`toWaitOn` の状態をテストし、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f6597-221">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f6597-222">コンテキストの終了に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="f6597-222">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f6597-223">`exitContext` パラメーターは、<xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。</span><span class="sxs-lookup"><span data-stu-id="f6597-223">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f6597-224">これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-224">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f6597-225"><xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。</span><span class="sxs-lookup"><span data-stu-id="f6597-225">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f6597-226">コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。</span><span class="sxs-lookup"><span data-stu-id="f6597-226">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="f6597-227">スレッドは、<xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。</span><span class="sxs-lookup"><span data-stu-id="f6597-227">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="f6597-228">これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>がある場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="f6597-228">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f6597-229">その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。</span><span class="sxs-lookup"><span data-stu-id="f6597-229">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f6597-230">メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-230">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f6597-231"><xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-231">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6597-232"><paramref name="toSignal" /> が <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="f6597-232"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-233">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-233">-or-</span></span> 
 <span data-ttu-id="f6597-234"><paramref name="toWaitOn" /> が <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="f6597-234"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6597-235">メソッドは <see cref="F:System.Threading.ApartmentState.STA" /> 状態のスレッドで呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-235">The method is called on a thread in <see cref="F:System.Threading.ApartmentState.STA" /> state.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-236">カウントの最大値を超えるため、<see cref="T:System.Threading.WaitHandle" /> はシグナル状態にはできません。</span><span class="sxs-lookup"><span data-stu-id="f6597-236">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6597-237"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="f6597-237"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-238">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-238">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-239">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-239">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="f6597-240">通知対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-240">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="f6597-241">待機対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-241">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="f6597-242">待機間隔を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-242">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="f6597-243">この値が -1 の場合、待機は無期限となります。</span><span class="sxs-lookup"><span data-stu-id="f6597-243">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f6597-244">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-244"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f6597-245">1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。タイムアウト間隔として <see cref="T:System.TimeSpan" /> を指定し、待機に入る前にコンテキストの同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="f6597-245">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="f6597-246">通知および待機の両方が正常に完了した場合は <see langword="true" />。通知は完了したが、待機がタイムアウトになった場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-246"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-247">この操作はアトミックであるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="f6597-247">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="f6597-248">現在のスレッドが `toSignal` 通知した後、`toWaitOn`で待機する前に、別のプロセッサで実行されているスレッドは `toWaitOn` シグナル状態になるか、待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-248">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="f6597-249">`timeout` の最大値は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="f6597-249">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f6597-250">`timeout` がゼロの場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="f6597-250">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f6597-251">`toWaitOn` の状態をテストし、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f6597-251">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f6597-252">コンテキストの終了に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="f6597-252">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f6597-253">`exitContext` パラメーターは、<xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。</span><span class="sxs-lookup"><span data-stu-id="f6597-253">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f6597-254">これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-254">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f6597-255"><xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。</span><span class="sxs-lookup"><span data-stu-id="f6597-255">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f6597-256">コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。</span><span class="sxs-lookup"><span data-stu-id="f6597-256">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="f6597-257">スレッドは、<xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。</span><span class="sxs-lookup"><span data-stu-id="f6597-257">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="f6597-258">これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>がある場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="f6597-258">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f6597-259">その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。</span><span class="sxs-lookup"><span data-stu-id="f6597-259">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f6597-260">メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-260">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f6597-261"><xref:System.Threading.WaitHandle.SignalAndWait%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-261">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6597-262"><paramref name="toSignal" /> が <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="f6597-262"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-263">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-263">-or-</span></span> 
 <span data-ttu-id="f6597-264"><paramref name="toWaitOn" /> が <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="f6597-264"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6597-265"><see cref="F:System.Threading.ApartmentState.STA" /> 状態のスレッドでメソッドが呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="f6597-265">The method was called on a thread in <see cref="F:System.Threading.ApartmentState.STA" /> state.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-266"><paramref name="toSignal" /> はセマフォで、カウントは既に最大値になっています。</span><span class="sxs-lookup"><span data-stu-id="f6597-266"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6597-267"><paramref name="timeout" /> は、-1 以外の負のミリ秒値となります。</span><span class="sxs-lookup"><span data-stu-id="f6597-267"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
<span data-ttu-id="f6597-268">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-268">-or-</span></span> 
 <span data-ttu-id="f6597-269"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="f6597-269"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-270">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-270">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-271">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-271">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6597-272"><see cref="T:System.Threading.WaitHandle" /> によって使用されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="f6597-272">Releases all resources used by the <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="f6597-273">`Dispose` を呼び出すと、<xref:System.Threading.WaitHandle> によって使用されるリソースを他の目的で再割り当てできます。</span><span class="sxs-lookup"><span data-stu-id="f6597-273">Calling `Dispose` allows the resources used by the <xref:System.Threading.WaitHandle> to be reallocated for other purposes.</span></span> <span data-ttu-id="f6597-274">`Dispose`の詳細については、「[アンマネージリソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-274">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6597-275">指定した配列内のすべての要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-275">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f6597-276">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="f6597-276">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="f6597-277">この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="f6597-277">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="f6597-278">指定した配列内のすべての要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-278">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="f6597-279"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />。それ以外の場合は、待機を続けます。</span><span class="sxs-lookup"><span data-stu-id="f6597-279"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-280"><xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。</span><span class="sxs-lookup"><span data-stu-id="f6597-280"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f6597-281">以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドはミューテックスが破棄されたときに `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-281">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f6597-282">多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-282">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f6597-283">システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-283">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f6597-284">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-284">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f6597-285">すべてのハンドルがシグナル状態になると、<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドはを返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-285">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="f6597-286">64を超えるハンドルが渡されると、<xref:System.NotSupportedException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f6597-286">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f6597-287">配列に重複が含まれている場合、呼び出しは <xref:System.DuplicateWaitObjectException>で失敗します。</span><span class="sxs-lookup"><span data-stu-id="f6597-287">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="f6597-288"><xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、<xref:System.Threading.ApartmentState.STA> 状態のスレッドではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="f6597-288">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="f6597-289">このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出し、`exitContext`の `millisecondsTimeout` と `true` の-1 (または <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="f6597-289">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6597-290">次のコード例では、スレッドプールを使用して、ファイルのグループに対して非同期的に作成および書き込みを行う方法を示します。</span><span class="sxs-lookup"><span data-stu-id="f6597-290">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="f6597-291">各書き込み操作は、作業項目としてキューに登録され、完了時に通知されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-291">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="f6597-292">メインスレッドは、すべての項目がシグナル状態になるのを待機してから終了します。</span><span class="sxs-lookup"><span data-stu-id="f6597-292">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6597-293"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-293">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="f6597-294">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-294">-or-</span></span> 
<span data-ttu-id="f6597-295"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-295">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-296">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-296">-or-</span></span> 
 <span data-ttu-id="f6597-297"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</span><span class="sxs-lookup"><span data-stu-id="f6597-297"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="f6597-298"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。</span><span class="sxs-lookup"><span data-stu-id="f6597-298">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="f6597-299"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-299">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6597-300"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="f6597-300">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="f6597-301">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-301">-or-</span></span> 
<span data-ttu-id="f6597-302">現在のスレッドの状態が <see cref="F:System.Threading.ApartmentState.STA" /> であり、<paramref name="waitHandles" /> に複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-302">The current thread is <see cref="F:System.Threading.ApartmentState.STA" /> state, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="f6597-303"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</span><span class="sxs-lookup"><span data-stu-id="f6597-303"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-304">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-304">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-305">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-305">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-306"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f6597-306">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f6597-307">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="f6597-307">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="f6597-308">この配列には、同一オブジェクトに対する複数の参照 (重複) を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="f6597-308">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="f6597-309">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="f6597-309">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f6597-310"><see cref="T:System.Int32" /> 値を使用して時間間隔を指定し、指定した配列内のすべての要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-310">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="f6597-311"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は<see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-311"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-312">`millisecondsTimeout` がゼロの場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="f6597-312">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f6597-313">待機ハンドルの状態をテストし、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f6597-313">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f6597-314"><xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、待機が終了したときにを返します。これは、すべてのハンドルがシグナル状態になったとき、またはタイムアウトが発生したときのいずれかを意味します。</span><span class="sxs-lookup"><span data-stu-id="f6597-314">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="f6597-315">64を超えるハンドルが渡されると、<xref:System.NotSupportedException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f6597-315">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f6597-316">配列に重複がある場合、呼び出しは <xref:System.DuplicateWaitObjectException>で失敗します。</span><span class="sxs-lookup"><span data-stu-id="f6597-316">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6597-317"><xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、<xref:System.Threading.ApartmentState.STA> 状態のスレッドではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="f6597-317">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="f6597-318">このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> のオーバーロードを呼び出し、`exitContext`に `false` を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="f6597-318">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6597-319"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-319">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-320">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-320">-or-</span></span> 
<span data-ttu-id="f6597-321"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-321">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-322">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-322">-or-</span></span> 
 <span data-ttu-id="f6597-323"><paramref name="waitHandles" /> は、要素を持たない配列です。</span><span class="sxs-lookup"><span data-stu-id="f6597-323"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="f6597-324"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。</span><span class="sxs-lookup"><span data-stu-id="f6597-324">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="f6597-325"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-325">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6597-326"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="f6597-326">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="f6597-327">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-327">-or-</span></span> 
<span data-ttu-id="f6597-328">現在のスレッドの状態が <see cref="F:System.Threading.ApartmentState.STA" /> であり、<paramref name="waitHandles" /> に複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-328">The current thread is in <see cref="F:System.Threading.ApartmentState.STA" /> state, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6597-329"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="f6597-329"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-330">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-330">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-331">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-331">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-332"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f6597-332">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f6597-333">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="f6597-333">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="f6597-334">この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="f6597-334">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="f6597-335">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-335">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f6597-336"><see cref="T:System.TimeSpan" /> 値を使用して時間間隔を指定し、指定した配列内のすべての要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-336">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="f6597-337"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は<see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-337"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-338">`timeout` がゼロの場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="f6597-338">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f6597-339">待機ハンドルの状態をテストし、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f6597-339">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f6597-340"><xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、待機が終了したときにを返します。これは、すべてのハンドルがシグナル状態になるか、タイムアウトが発生することを意味します。</span><span class="sxs-lookup"><span data-stu-id="f6597-340">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="f6597-341">64を超えるハンドルが渡されると、<xref:System.NotSupportedException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f6597-341">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f6597-342">配列に重複が含まれている場合、呼び出しは失敗します。</span><span class="sxs-lookup"><span data-stu-id="f6597-342">If the array contains duplicates, the call will fail.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="f6597-343"><xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、<xref:System.Threading.ApartmentState.STA> 状態のスレッドではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="f6597-343">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="f6597-344">`timeout` の最大値は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="f6597-344">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f6597-345">このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> のオーバーロードを呼び出し、`exitContext`に `false` を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="f6597-345">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6597-346"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-346">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-347">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-347">-or-</span></span> 
<span data-ttu-id="f6597-348"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-348">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-349">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-349">-or-</span></span> 
 <span data-ttu-id="f6597-350"><paramref name="waitHandles" /> は、要素を持たない配列です。</span><span class="sxs-lookup"><span data-stu-id="f6597-350"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="f6597-351"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。</span><span class="sxs-lookup"><span data-stu-id="f6597-351">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="f6597-352"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-352">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6597-353"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="f6597-353">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="f6597-354">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-354">-or-</span></span> 
<span data-ttu-id="f6597-355">現在のスレッドの状態が <see cref="F:System.Threading.ApartmentState.STA" /> であり、<paramref name="waitHandles" /> に複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-355">The current thread is in <see cref="F:System.Threading.ApartmentState.STA" /> state, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6597-356"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="f6597-356"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f6597-357">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-357">-or-</span></span> 
 <span data-ttu-id="f6597-358"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="f6597-358"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-359">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-359">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-360">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-360">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-361"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f6597-361">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f6597-362">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="f6597-362">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="f6597-363">この配列には、同一オブジェクトに対する複数の参照 (重複) を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="f6597-363">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="f6597-364">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="f6597-364">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f6597-365">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-365"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f6597-366">指定した配列内のすべての要素がシグナルを受信するまで待機します。<see cref="T:System.Int32" /> 値を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="f6597-366">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="f6597-367"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は<see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-367"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-368">`millisecondsTimeout` がゼロの場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="f6597-368">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f6597-369">待機ハンドルの状態をテストし、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f6597-369">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f6597-370"><xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。</span><span class="sxs-lookup"><span data-stu-id="f6597-370"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f6597-371">以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドはミューテックスが破棄されたときに `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-371">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f6597-372">多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-372">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f6597-373">システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-373">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f6597-374">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-374">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f6597-375"><xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、待機が終了したときにを返します。これは、すべてのハンドルがシグナル状態になったとき、またはタイムアウトが発生したときのいずれかを意味します。</span><span class="sxs-lookup"><span data-stu-id="f6597-375">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="f6597-376">64を超えるハンドルが渡されると、<xref:System.NotSupportedException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f6597-376">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f6597-377">配列に重複がある場合、呼び出しは <xref:System.DuplicateWaitObjectException>で失敗します。</span><span class="sxs-lookup"><span data-stu-id="f6597-377">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="f6597-378"><xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、<xref:System.Threading.ApartmentState.STA> 状態のスレッドではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="f6597-378">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f6597-379">コンテキストの終了に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="f6597-379">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f6597-380">`exitContext` パラメーターは、<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。</span><span class="sxs-lookup"><span data-stu-id="f6597-380">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f6597-381">これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-381">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f6597-382"><xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。</span><span class="sxs-lookup"><span data-stu-id="f6597-382">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f6597-383">コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。</span><span class="sxs-lookup"><span data-stu-id="f6597-383">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="f6597-384">スレッドは、<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。</span><span class="sxs-lookup"><span data-stu-id="f6597-384">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="f6597-385">これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 属性がある場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="f6597-385">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="f6597-386">その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。</span><span class="sxs-lookup"><span data-stu-id="f6597-386">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f6597-387">メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-387">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f6597-388"><xref:System.Threading.WaitHandle.WaitAll%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-388">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6597-389">次のコード例では、スレッドプールを使用して、ファイルのグループに対して非同期的に作成および書き込みを行う方法を示します。</span><span class="sxs-lookup"><span data-stu-id="f6597-389">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="f6597-390">各書き込み操作は、作業項目としてキューに登録され、完了時に通知されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-390">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="f6597-391">メインスレッドは、すべての項目がシグナル状態になるのを待機してから終了します。</span><span class="sxs-lookup"><span data-stu-id="f6597-391">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6597-392"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-392">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-393">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-393">-or-</span></span> 
<span data-ttu-id="f6597-394"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-394">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-395">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-395">-or-</span></span> 
 <span data-ttu-id="f6597-396"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</span><span class="sxs-lookup"><span data-stu-id="f6597-396"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="f6597-397"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-397">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6597-398"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="f6597-398">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="f6597-399">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-399">-or-</span></span> 
<span data-ttu-id="f6597-400">現在のスレッドの状態が <see cref="F:System.Threading.ApartmentState.STA" /> であり、<paramref name="waitHandles" /> に複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-400">The current thread is in <see cref="F:System.Threading.ApartmentState.STA" /> state, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="f6597-401"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</span><span class="sxs-lookup"><span data-stu-id="f6597-401"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6597-402"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="f6597-402"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-403">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-403">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-404">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-404">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-405"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f6597-405">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f6597-406">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="f6597-406">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="f6597-407">この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="f6597-407">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="f6597-408">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-408">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f6597-409">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-409"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f6597-410">指定した配列内のすべての要素がシグナルを受信するまで待機します。<see cref="T:System.TimeSpan" /> 値を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="f6597-410">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="f6597-411"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-411"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-412">`timeout` がゼロの場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="f6597-412">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f6597-413">待機ハンドルの状態をテストし、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f6597-413">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f6597-414"><xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。</span><span class="sxs-lookup"><span data-stu-id="f6597-414"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f6597-415">以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドはミューテックスが破棄されたときに `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-415">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f6597-416">多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-416">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f6597-417">システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-417">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f6597-418">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-418">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f6597-419"><xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、待機が終了したときにを返します。これは、すべてのハンドルがシグナル状態になるか、タイムアウトが発生することを意味します。</span><span class="sxs-lookup"><span data-stu-id="f6597-419">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="f6597-420">64を超えるハンドルが渡されると、<xref:System.NotSupportedException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f6597-420">If more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f6597-421">配列に重複が含まれている場合、呼び出しは失敗します。</span><span class="sxs-lookup"><span data-stu-id="f6597-421">If the array contains duplicates, the call will fail.</span></span>
  
> [!NOTE]
>  <span data-ttu-id="f6597-422"><xref:System.Threading.WaitHandle.WaitAll%2A> メソッドは、<xref:System.Threading.ApartmentState.STA> 状態のスレッドではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="f6597-422">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="f6597-423">`timeout` の最大値は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="f6597-423">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f6597-424">コンテキストの終了に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="f6597-424">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f6597-425">`exitContext` パラメーターは、<xref:System.Threading.WaitHandle.WaitAll%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。</span><span class="sxs-lookup"><span data-stu-id="f6597-425">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f6597-426">これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-426">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f6597-427"><xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。</span><span class="sxs-lookup"><span data-stu-id="f6597-427">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f6597-428">コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。</span><span class="sxs-lookup"><span data-stu-id="f6597-428">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="f6597-429"><xref:System.Threading.WaitHandle.WaitAll%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。</span><span class="sxs-lookup"><span data-stu-id="f6597-429">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="f6597-430">これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>がある場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="f6597-430">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f6597-431">その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。</span><span class="sxs-lookup"><span data-stu-id="f6597-431">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f6597-432">メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.WaitAll%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-432">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f6597-433"><xref:System.Threading.WaitHandle.WaitAll%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-433">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6597-434">次のコード例では、スレッドプールを使用して、ファイルのグループに対して非同期的に作成および書き込みを行う方法を示します。</span><span class="sxs-lookup"><span data-stu-id="f6597-434">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="f6597-435">各書き込み操作は、作業項目としてキューに登録され、完了時に通知されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-435">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="f6597-436">メインスレッドは、すべての項目がシグナル状態になるのを待機してから終了します。</span><span class="sxs-lookup"><span data-stu-id="f6597-436">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6597-437"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-437">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-438">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-438">-or-</span></span> 
<span data-ttu-id="f6597-439"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-439">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-440">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-440">-or-</span></span> 
 <span data-ttu-id="f6597-441"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</span><span class="sxs-lookup"><span data-stu-id="f6597-441"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="f6597-442"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-442">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6597-443"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="f6597-443">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="f6597-444">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-444">-or-</span></span> 
<span data-ttu-id="f6597-445"><see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-445">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="f6597-446"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</span><span class="sxs-lookup"><span data-stu-id="f6597-446"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6597-447"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="f6597-447"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f6597-448">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-448">-or-</span></span> 
 <span data-ttu-id="f6597-449"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="f6597-449"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-450">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-450">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-451">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-451">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-452"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f6597-452">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6597-453">指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-453">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f6597-454">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="f6597-454">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="f6597-455">指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-455">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="f6597-456">待機を実行するオブジェクトの配列インデックス。</span><span class="sxs-lookup"><span data-stu-id="f6597-456">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-457"><xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。</span><span class="sxs-lookup"><span data-stu-id="f6597-457"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f6597-458">以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、ミューテックスが破棄されたために待機が完了した場合に `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-458">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="f6597-459">多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-459">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f6597-460">システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-460">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f6597-461">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-461">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f6597-462"><xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、中断されたミューテックスが原因で待機が完了した場合にのみ、<xref:System.Threading.AbandonedMutexException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="f6597-462">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f6597-463">解放された mutex が、破棄された mutex よりも小さいインデックス番号で `waitHandles` 含まれる場合、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは正常に完了し、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-463">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6597-464">バージョン2.0 より前の .NET Framework のバージョンでは、<xref:System.Threading.Mutex>を明示的に解放せずにスレッドが終了または中止し、`Mutex` が別のスレッドの `WaitAny` 配列のインデックス 0 (ゼロ) にある場合、`WaitAny` によって返されるインデックスは、0ではなく128になります。</span><span class="sxs-lookup"><span data-stu-id="f6597-464">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="f6597-465">ハンドルがシグナル状態になると、このメソッドはを返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-465">This method returns when any handle is signaled.</span></span> <span data-ttu-id="f6597-466">呼び出し中に複数のオブジェクトがシグナル状態になると、戻り値は、シグナルが発生したすべてのオブジェクトの最小のインデックス値を持つシグナル化されたオブジェクトの配列インデックスになります。</span><span class="sxs-lookup"><span data-stu-id="f6597-466">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="f6597-467">待機ハンドルの最大数は64、現在のスレッドが <xref:System.Threading.ApartmentState.STA> 状態の場合は63です。</span><span class="sxs-lookup"><span data-stu-id="f6597-467">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>

 <span data-ttu-id="f6597-468">このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出し、`exitContext`の `millisecondsTimeout` と `true` の-1 (または <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="f6597-468">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6597-469">次のコード例は、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドの呼び出しを示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-469">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6597-470"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-470">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-471">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-471">-or-</span></span> 
<span data-ttu-id="f6597-472"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-472">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6597-473"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="f6597-473">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="f6597-474">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="f6597-474"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-475">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-475">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-476">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-476">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6597-477">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="f6597-477"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-478"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f6597-478">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f6597-479">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="f6597-479">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="f6597-480">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="f6597-480">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f6597-481">32 ビット符号付き整数を使用して時間間隔を指定し、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-481">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="f6597-482">待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="millisecondsTimeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</span><span class="sxs-lookup"><span data-stu-id="f6597-482">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-483">`millisecondsTimeout` がゼロの場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="f6597-483">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f6597-484">待機ハンドルの状態をテストし、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f6597-484">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f6597-485"><xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、中断されたミューテックスが原因で待機が完了した場合にのみ、<xref:System.Threading.AbandonedMutexException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="f6597-485">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f6597-486">解放された mutex が、破棄された mutex よりも小さいインデックス番号で `waitHandles` 含まれる場合、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは正常に完了し、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-486">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="f6597-487">このメソッドは、待機が終了したとき、いずれかのハンドルがシグナル状態になったとき、またはタイムアウトが発生したときに、を返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-487">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="f6597-488">呼び出し中に複数のオブジェクトがシグナル状態になると、戻り値は、シグナルが発生したすべてのオブジェクトの最小のインデックス値を持つシグナル化されたオブジェクトの配列インデックスになります。</span><span class="sxs-lookup"><span data-stu-id="f6597-488">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="f6597-489">待機ハンドルの最大数は64、現在のスレッドが <xref:System.Threading.ApartmentState.STA> 状態の場合は63です。</span><span class="sxs-lookup"><span data-stu-id="f6597-489">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
 <span data-ttu-id="f6597-490">このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> のオーバーロードを呼び出し、`exitContext`に `false` を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="f6597-490">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6597-491"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-491">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-492">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-492">-or-</span></span> 
<span data-ttu-id="f6597-493"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-493">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6597-494"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="f6597-494">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6597-495"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="f6597-495"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-496">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-496">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-497">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-497">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6597-498"><paramref name="waitHandles" /> は、要素を持たない配列です。</span><span class="sxs-lookup"><span data-stu-id="f6597-498"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-499"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f6597-499">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f6597-500">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="f6597-500">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="f6597-501">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-501">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f6597-502"><see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-502">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="f6597-503">待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="timeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</span><span class="sxs-lookup"><span data-stu-id="f6597-503">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-504">`timeout` がゼロの場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="f6597-504">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f6597-505">待機ハンドルの状態をテストし、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f6597-505">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f6597-506"><xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、中断されたミューテックスが原因で待機が完了した場合にのみ、<xref:System.Threading.AbandonedMutexException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="f6597-506">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f6597-507">解放された mutex が、破棄された mutex よりも小さいインデックス番号で `waitHandles` 含まれる場合、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは正常に完了し、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-507">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="f6597-508">このメソッドは、待機が終了したとき、いずれかのハンドルがシグナル状態になったとき、またはタイムアウトが発生したときに、を返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-508">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="f6597-509">呼び出し中に複数のオブジェクトがシグナル状態になると、戻り値は、シグナルが発生したすべてのオブジェクトの最小のインデックス値を持つシグナル化されたオブジェクトの配列インデックスになります。</span><span class="sxs-lookup"><span data-stu-id="f6597-509">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="f6597-510">待機ハンドルの最大数は64、現在のスレッドが <xref:System.Threading.ApartmentState.STA> 状態の場合は63です。</span><span class="sxs-lookup"><span data-stu-id="f6597-510">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>

 <span data-ttu-id="f6597-511">`timeout` の最大値は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="f6597-511">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f6597-512">このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> のオーバーロードを呼び出し、`exitContext`に `false` を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="f6597-512">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6597-513"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-513">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-514">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-514">-or-</span></span> 
<span data-ttu-id="f6597-515"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-515">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6597-516"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="f6597-516">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6597-517"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="f6597-517"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f6597-518">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-518">-or-</span></span> 
 <span data-ttu-id="f6597-519"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="f6597-519"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-520">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-520">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-521">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-521">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6597-522"><paramref name="waitHandles" /> は、要素を持たない配列です。</span><span class="sxs-lookup"><span data-stu-id="f6597-522"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-523"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f6597-523">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f6597-524">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="f6597-524">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="f6597-525">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="f6597-525">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f6597-526">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-526"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f6597-527">32 ビットの符号付き整数を使用して時間間隔を指定し、待機する前に同期ドメインを終了するかどうかを指定して、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-527">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="f6597-528">待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="millisecondsTimeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</span><span class="sxs-lookup"><span data-stu-id="f6597-528">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-529">`millisecondsTimeout` がゼロの場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="f6597-529">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f6597-530">待機ハンドルの状態をテストし、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f6597-530">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f6597-531"><xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。</span><span class="sxs-lookup"><span data-stu-id="f6597-531"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f6597-532">以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、ミューテックスが破棄されたために待機が完了した場合に `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-532">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="f6597-533">多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-533">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f6597-534">システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-534">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f6597-535">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-535">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f6597-536"><xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、中断されたミューテックスが原因で待機が完了した場合にのみ、<xref:System.Threading.AbandonedMutexException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="f6597-536">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f6597-537">解放された mutex が、破棄された mutex よりも小さいインデックス番号で `waitHandles` 含まれる場合、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは正常に完了し、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-537">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6597-538">バージョン2.0 より前の .NET Framework のバージョンでは、<xref:System.Threading.Mutex>を明示的に解放せずにスレッドが終了または中止し、`Mutex` が別のスレッドの `WaitAny` 配列のインデックス 0 (ゼロ) にある場合、`WaitAny` によって返されるインデックスは、0ではなく128になります。</span><span class="sxs-lookup"><span data-stu-id="f6597-538">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="f6597-539">このメソッドは、待機が終了したとき、いずれかのハンドルがシグナル状態になったとき、またはタイムアウトが発生したときに、を返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-539">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="f6597-540">呼び出し中に複数のオブジェクトがシグナル状態になると、戻り値は、シグナルが発生したすべてのオブジェクトの最小のインデックス値を持つシグナル化されたオブジェクトの配列インデックスになります。</span><span class="sxs-lookup"><span data-stu-id="f6597-540">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="f6597-541">待機ハンドルの最大数は64、現在のスレッドが <xref:System.Threading.ApartmentState.STA> 状態の場合は63です。</span><span class="sxs-lookup"><span data-stu-id="f6597-541">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f6597-542">コンテキストの終了に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="f6597-542">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f6597-543">`exitContext` パラメーターは、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。</span><span class="sxs-lookup"><span data-stu-id="f6597-543">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f6597-544">これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-544">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f6597-545"><xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。</span><span class="sxs-lookup"><span data-stu-id="f6597-545">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f6597-546">コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。</span><span class="sxs-lookup"><span data-stu-id="f6597-546">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="f6597-547">スレッドは、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。</span><span class="sxs-lookup"><span data-stu-id="f6597-547">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="f6597-548">これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>がある場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="f6597-548">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f6597-549">その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。</span><span class="sxs-lookup"><span data-stu-id="f6597-549">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f6597-550">メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-550">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f6597-551"><xref:System.Threading.WaitHandle.WaitAny%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-551">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6597-552">次のコード例は、スレッドプールを使用して複数のディスク上のファイルを同時に検索する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-552">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="f6597-553">領域に関する考慮事項については、各ディスクのルートディレクトリのみが検索されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-553">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6597-554"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-554">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-555">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-555">-or-</span></span> 
<span data-ttu-id="f6597-556"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-556">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6597-557"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="f6597-557">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="f6597-558">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="f6597-558"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6597-559"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="f6597-559"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-560">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-560">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-561">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-561">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6597-562">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="f6597-562"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-563"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f6597-563">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="f6597-564">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="f6597-564">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="f6597-565">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-565">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f6597-566">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-566"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f6597-567">指定した配列内のいずれかの要素がシグナルを受信するまで待機します。<see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="f6597-567">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="f6597-568">待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="timeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</span><span class="sxs-lookup"><span data-stu-id="f6597-568">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-569">`timeout` がゼロの場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="f6597-569">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f6597-570">待機ハンドルの状態をテストし、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f6597-570">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f6597-571"><xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。</span><span class="sxs-lookup"><span data-stu-id="f6597-571"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f6597-572">以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、ミューテックスが破棄されたために待機が完了した場合に `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-572">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="f6597-573">多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-573">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f6597-574">システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-574">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f6597-575">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-575">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f6597-576"><xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは、中断されたミューテックスが原因で待機が完了した場合にのみ、<xref:System.Threading.AbandonedMutexException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="f6597-576">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f6597-577">解放された mutex が、破棄された mutex よりも小さいインデックス番号で `waitHandles` 含まれる場合、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドは正常に完了し、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-577">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6597-578">バージョン2.0 より前の .NET Framework のバージョンでは、<xref:System.Threading.Mutex>を明示的に解放せずにスレッドが終了または中止し、`Mutex` が別のスレッドの `WaitAny` 配列のインデックス 0 (ゼロ) にある場合、`WaitAny` によって返されるインデックスは、0ではなく128になります。</span><span class="sxs-lookup"><span data-stu-id="f6597-578">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="f6597-579">このメソッドは、待機が終了したとき、いずれかのハンドルがシグナル状態になったとき、またはタイムアウトが発生したときに、を返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-579">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="f6597-580">呼び出し中に複数のオブジェクトがシグナル状態になると、戻り値は、シグナルが発生したすべてのオブジェクトの最小のインデックス値を持つシグナル化されたオブジェクトの配列インデックスになります。</span><span class="sxs-lookup"><span data-stu-id="f6597-580">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span>

 <span data-ttu-id="f6597-581">待機ハンドルの最大数は64、現在のスレッドが <xref:System.Threading.ApartmentState.STA> 状態の場合は63です。</span><span class="sxs-lookup"><span data-stu-id="f6597-581">The maximum number of the wait handles is 64, and 63 if the current thread is in <xref:System.Threading.ApartmentState.STA> state.</span></span>

 <span data-ttu-id="f6597-582">`timeout` の最大値は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="f6597-582">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f6597-583">コンテキストの終了に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="f6597-583">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f6597-584">`exitContext` パラメーターは、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。</span><span class="sxs-lookup"><span data-stu-id="f6597-584">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f6597-585">これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-585">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f6597-586"><xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。</span><span class="sxs-lookup"><span data-stu-id="f6597-586">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f6597-587">コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。</span><span class="sxs-lookup"><span data-stu-id="f6597-587">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="f6597-588">スレッドは、<xref:System.Threading.WaitHandle.WaitAny%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。</span><span class="sxs-lookup"><span data-stu-id="f6597-588">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="f6597-589">これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>がある場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="f6597-589">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f6597-590">その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。</span><span class="sxs-lookup"><span data-stu-id="f6597-590">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f6597-591">メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.WaitAny%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-591">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f6597-592"><xref:System.Threading.WaitHandle.WaitAny%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-592">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6597-593">次のコード例は、スレッドプールを使用して複数のディスク上のファイルを同時に検索する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-593">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="f6597-594">領域に関する考慮事項については、各ディスクのルートディレクトリのみが検索されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-594">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6597-595"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-595">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6597-596">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-596">-or-</span></span> 
<span data-ttu-id="f6597-597"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="f6597-597">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6597-598"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="f6597-598">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="f6597-599">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="f6597-599"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6597-600"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="f6597-600"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f6597-601">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-601">-or-</span></span> 
 <span data-ttu-id="f6597-602"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="f6597-602"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-603">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-603">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-604">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-604">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6597-605">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="f6597-605"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-606"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f6597-606">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6597-607">現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受け取るまで、現在のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="f6597-607">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6597-608">現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受け取るまで、現在のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="f6597-608">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns><span data-ttu-id="f6597-609">現在のインスタンスがシグナルを受け取った場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-609"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="f6597-610">現在のインスタンスがシグナルを受け取らない場合は、<see cref="M:System.Threading.WaitHandle.WaitOne" /> はシグナルを受け取るまで待機を続けます。</span><span class="sxs-lookup"><span data-stu-id="f6597-610">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-611"><xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。</span><span class="sxs-lookup"><span data-stu-id="f6597-611"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f6597-612">以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドはミューテックスが破棄されたときに `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-612">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f6597-613">多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-613">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f6597-614">システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-614">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f6597-615">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-615">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f6597-616">このメソッドの呼び出し元は、現在のインスタンスがシグナルを受信するまで無期限にブロックされます。</span><span class="sxs-lookup"><span data-stu-id="f6597-616">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="f6597-617"><xref:System.Threading.WaitHandle> が別のスレッドからのシグナルを受信するまでブロックするには、このメソッドを使用します (非同期操作の完了時にが生成されるなど)。</span><span class="sxs-lookup"><span data-stu-id="f6597-617">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f6597-618">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-618">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f6597-619">このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出し、最初のパラメーターに-1 または <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> を指定し、2番目のパラメーターに `false` を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="f6597-619">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="f6597-620">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="f6597-620">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6597-621">次のコード例は、待機ハンドルを使用して、バックグラウンドスレッドの実行が完了するのを待機している間にプロセスを終了しないようにする方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-621">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6597-622">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="f6597-622">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-623">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-623">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-624">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-624">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-625">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="f6597-625">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="f6597-626">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="f6597-626">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f6597-627">32 ビット符号付き整数を使用して時間間隔をミリ秒単位で指定し、現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受信するまで、現在のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="f6597-627">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="f6597-628">現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-628"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-629">`millisecondsTimeout` がゼロの場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="f6597-629">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f6597-630">待機ハンドルの状態をテストし、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f6597-630">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f6597-631">このメソッドの呼び出し元は、現在のインスタンスがシグナルを受信するか、タイムアウトが発生するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="f6597-631">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f6597-632"><xref:System.Threading.WaitHandle> が別のスレッドからのシグナルを受信するまでブロックするには、このメソッドを使用します (非同期操作の完了時にが生成されるなど)。</span><span class="sxs-lookup"><span data-stu-id="f6597-632">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f6597-633">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-633">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f6597-634">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="f6597-634">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="f6597-635">このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> のオーバーロードを呼び出し、`exitContext`に `false` を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="f6597-635">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6597-636">次のコード例は、待機ハンドルを使用して、バックグラウンドスレッドの実行が完了するのを待機している間にプロセスを終了しないようにする方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-636">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6597-637">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="f6597-637">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6597-638"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="f6597-638"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-639">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-639">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-640">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-640">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-641">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="f6597-641">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f6597-642">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-642">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="f6597-643"><see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、現在のインスタンスがシグナルを受信するまで現在のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="f6597-643">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="f6597-644">現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-644"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-645">`timeout` がゼロの場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="f6597-645">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f6597-646">待機ハンドルの状態をテストし、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f6597-646">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f6597-647">このメソッドの呼び出し元は、現在のインスタンスがシグナルを受信するか、タイムアウトが発生するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="f6597-647">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f6597-648"><xref:System.Threading.WaitHandle> が別のスレッドからのシグナルを受信するまでブロックするには、このメソッドを使用します (非同期操作の完了時にが生成されるなど)。</span><span class="sxs-lookup"><span data-stu-id="f6597-648">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f6597-649">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-649">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f6597-650">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="f6597-650">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="f6597-651">`timeout` の最大値は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="f6597-651">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f6597-652">このメソッドのオーバーロードを呼び出すことは、<xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> のオーバーロードを呼び出し、`exitContext`に `false` を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="f6597-652">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6597-653">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="f6597-653">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6597-654"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="f6597-654"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f6597-655">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-655">-or-</span></span> 
 <span data-ttu-id="f6597-656"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="f6597-656"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-657">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-657">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-658">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-658">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-659">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="f6597-659">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="f6597-660">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="f6597-660">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f6597-661">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-661"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f6597-662">現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受信するまで現在のスレッドをブロックします。時間間隔を指定するために 32 ビット符号付き整数を使用し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="f6597-662">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="f6597-663">現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-663"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-664">`millisecondsTimeout` がゼロの場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="f6597-664">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f6597-665">待機ハンドルの状態をテストし、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f6597-665">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f6597-666"><xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。</span><span class="sxs-lookup"><span data-stu-id="f6597-666"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f6597-667">以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドはミューテックスが破棄されたときに `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-667">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f6597-668">多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-668">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f6597-669">システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-669">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f6597-670">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-670">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f6597-671">このメソッドの呼び出し元は、現在のインスタンスがシグナルを受信するか、タイムアウトが発生するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="f6597-671">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f6597-672"><xref:System.Threading.WaitHandle> が別のスレッドからのシグナルを受信するまでブロックするには、このメソッドを使用します (非同期操作の完了時にが生成されるなど)。</span><span class="sxs-lookup"><span data-stu-id="f6597-672">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f6597-673">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-673">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f6597-674">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="f6597-674">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f6597-675">コンテキストの終了に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="f6597-675">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f6597-676">`exitContext` パラメーターは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。</span><span class="sxs-lookup"><span data-stu-id="f6597-676">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f6597-677">これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-677">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f6597-678"><xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。</span><span class="sxs-lookup"><span data-stu-id="f6597-678">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f6597-679">コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。</span><span class="sxs-lookup"><span data-stu-id="f6597-679">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="f6597-680">スレッドは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。</span><span class="sxs-lookup"><span data-stu-id="f6597-680">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="f6597-681">これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>がある場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="f6597-681">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f6597-682">その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。</span><span class="sxs-lookup"><span data-stu-id="f6597-682">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f6597-683">メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-683">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f6597-684"><xref:System.Threading.WaitHandle.WaitOne%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-684">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6597-685">次の例は、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> メソッドのオーバーロードが同期ドメイン内で呼び出された場合の動作を示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-685">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="f6597-686">まず、スレッドは `exitContext` が `false` に設定された状態で待機し、待機タイムアウトが経過するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="f6597-686">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="f6597-687">2番目のスレッドは、最初のスレッドが終了した後に実行され、`exitContext` を `true`に設定して待機します。</span><span class="sxs-lookup"><span data-stu-id="f6597-687">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="f6597-688">この2番目のスレッドの待機ハンドルを通知する呼び出しはブロックされず、スレッドは待機タイムアウト前に完了します。</span><span class="sxs-lookup"><span data-stu-id="f6597-688">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6597-689">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="f6597-689">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6597-690"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="f6597-690"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-691">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-691">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-692">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-692">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-693">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="f6597-693">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f6597-694">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-694">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="f6597-695">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-695"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f6597-696">現在のインスタンスがシグナルを受信するまで現在のスレッドをブロックします。<see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="f6597-696">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="f6597-697">現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f6597-697"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-698">`timeout` がゼロの場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="f6597-698">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f6597-699">待機ハンドルの状態をテストし、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f6597-699">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f6597-700"><xref:System.Threading.AbandonedMutexException> は .NET Framework バージョン2.0 で新しく追加されたものです。</span><span class="sxs-lookup"><span data-stu-id="f6597-700"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f6597-701">以前のバージョンでは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドはミューテックスが破棄されたときに `true` を返します。</span><span class="sxs-lookup"><span data-stu-id="f6597-701">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f6597-702">多くの場合、放棄ミューテックスは深刻なコーディングエラーを示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-702">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f6597-703">システム全体のミューテックスの場合は、アプリケーションが突然 (たとえば、Windows タスクマネージャーを使用して) 終了したことを示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-703">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f6597-704">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f6597-704">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f6597-705">このメソッドの呼び出し元は、現在のインスタンスがシグナルを受信するか、タイムアウトが発生するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="f6597-705">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f6597-706"><xref:System.Threading.WaitHandle> が別のスレッドからのシグナルを受信するまでブロックするには、このメソッドを使用します (非同期操作の完了時にが生成されるなど)。</span><span class="sxs-lookup"><span data-stu-id="f6597-706">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f6597-707">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="f6597-707">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f6597-708">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="f6597-708">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="f6597-709">`timeout` の最大値は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="f6597-709">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f6597-710">コンテキストの終了に関する注意事項</span><span class="sxs-lookup"><span data-stu-id="f6597-710">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f6597-711">`exitContext` パラメーターは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドが既定以外のマネージコンテキストの内部から呼び出されない限り、効果はありません。</span><span class="sxs-lookup"><span data-stu-id="f6597-711">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f6597-712">これは、スレッドが <xref:System.ContextBoundObject>から派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-712">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f6597-713"><xref:System.String>など、<xref:System.ContextBoundObject>から派生していないクラスでメソッドを現在実行している場合でも、現在のアプリケーションドメインのスタックに <xref:System.ContextBoundObject> がある場合は、既定以外のコンテキストにすることができます。</span><span class="sxs-lookup"><span data-stu-id="f6597-713">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f6597-714">コードが既定以外のコンテキストで実行されている場合、`exitContext` に `true` を指定すると、スレッドは <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。</span><span class="sxs-lookup"><span data-stu-id="f6597-714">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="f6597-715">スレッドは、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドの呼び出しが完了した後、元の既定以外のコンテキストに戻ります。</span><span class="sxs-lookup"><span data-stu-id="f6597-715">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="f6597-716">これは、コンテキストバインドクラスに <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>がある場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="f6597-716">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f6597-717">その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。</span><span class="sxs-lookup"><span data-stu-id="f6597-717">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f6597-718">メンバーの呼び出し履歴内のコードが <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを呼び出し、`exitContext`の `true` を指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドが続行されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-718">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f6597-719"><xref:System.Threading.WaitHandle.WaitOne%2A> メソッドから制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f6597-719">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6597-720">次のコード例は、待機ハンドルを使用して、バックグラウンドスレッドの実行が完了するのを待機している間にプロセスを終了しないようにする方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-720">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6597-721">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="f6597-721">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6597-722"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="f6597-722"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="f6597-723">- または -</span><span class="sxs-lookup"><span data-stu-id="f6597-723">-or-</span></span> 
 <span data-ttu-id="f6597-724"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="f6597-724"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="f6597-725">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="f6597-725">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="f6597-726">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="f6597-726">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6597-727">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="f6597-727">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="f6597-728">待機ハンドルがシグナル状態になる前に <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 操作がタイムアウトになったことを示します。</span><span class="sxs-lookup"><span data-stu-id="f6597-728">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="f6597-729">このフィールドは定数です。</span><span class="sxs-lookup"><span data-stu-id="f6597-729">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6597-730">このフィールドは、`WaitAny`の可能性のある戻り値の1つです。</span><span class="sxs-lookup"><span data-stu-id="f6597-730">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6597-731">次のコード例は、スレッドプールを使用して複数のディスク上のファイルを同時に検索する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="f6597-731">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="f6597-732">領域に関する考慮事項については、各ディスクのルートディレクトリのみが検索されます。</span><span class="sxs-lookup"><span data-stu-id="f6597-732">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
