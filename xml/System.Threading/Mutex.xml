<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3aee14deb55430fd5c60ac1edfc35e935b82b582" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75158674" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="ac210-101">同期プリミティブは、プロセス間の同期にも使用できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-101">A synchronization primitive that can also be used for interprocess synchronization.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac210-102">2つ以上のスレッドが共有リソースに同時にアクセスする必要がある場合、システムには、一度に1つのスレッドのみがリソースを使用するように同期機構が必要です。</span><span class="sxs-lookup"><span data-stu-id="ac210-102">When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</span></span> <span data-ttu-id="ac210-103"><xref:System.Threading.Mutex> は、共有リソースへの排他アクセスを1つのスレッドにのみ許可する同期プリミティブです。</span><span class="sxs-lookup"><span data-stu-id="ac210-103"><xref:System.Threading.Mutex> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</span></span> <span data-ttu-id="ac210-104">スレッドがミューテックスを取得した場合、そのミューテックスを取得する2番目のスレッドは、最初のスレッドがミューテックスを解放するまで中断されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-104">If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ac210-105">この型は <xref:System.IDisposable> インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="ac210-105">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="ac210-106">型の使用が完了したら、直接的または間接的に型を破棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-106">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="ac210-107">直接的に型を破棄するには、<xref:System.IDisposable.Dispose%2A>`try`/ ブロック内で `catch` メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="ac210-107">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="ac210-108">間接的に型を破棄するには、`using` (C# の場合) または `Using` (Visual Basic 言語) などの言語構成要素を使用します。</span><span class="sxs-lookup"><span data-stu-id="ac210-108">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="ac210-109">詳細については、<xref:System.IDisposable> インターフェイスに関するトピック内の「IDisposable を実装するオブジェクトの使用」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="ac210-109">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="ac210-110"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> メソッドを使用して、ミューテックスの所有権を要求できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-110">You can use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method to request ownership of a mutex.</span></span> <span data-ttu-id="ac210-111">呼び出し元のスレッドは、次のいずれかが発生するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="ac210-111">The calling thread blocks until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="ac210-112">ミューテックスは、所有されていないことを示すシグナルとして通知されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-112">The mutex is signaled to indicate that it is not owned.</span></span> <span data-ttu-id="ac210-113">この場合、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドは `true`を返し、呼び出し元のスレッドはミューテックスの所有権を前提とし、ミューテックスによって保護されているリソースにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="ac210-113">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true`, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</span></span> <span data-ttu-id="ac210-114">リソースへのアクセスが終了したら、スレッドは <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出して、ミューテックスの所有権を解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-114">When it has finished accessing the resource, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the mutex.</span></span> <span data-ttu-id="ac210-115">例のセクションの最初の例は、このパターンを示しています。</span><span class="sxs-lookup"><span data-stu-id="ac210-115">The first example in the Examples section illustrates this pattern.</span></span>  
  
-   <span data-ttu-id="ac210-116">`millisecondsTimeout` または `timeout` パラメーターを持つ <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドの呼び出しで指定されたタイムアウト期間が経過しました。</span><span class="sxs-lookup"><span data-stu-id="ac210-116">The time-out interval specified in the call to a <xref:System.Threading.WaitHandle.WaitOne%2A> method that has a `millisecondsTimeout` or `timeout` parameter has elapsed.</span></span> <span data-ttu-id="ac210-117">この場合、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドは `false`を返し、呼び出し元のスレッドはミューテックスの所有権を取得しません。</span><span class="sxs-lookup"><span data-stu-id="ac210-117">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `false`, and the calling thread makes no further attempt to acquire ownership of the mutex.</span></span> <span data-ttu-id="ac210-118">この場合は、ミューテックスによって保護されているリソースへのアクセスが呼び出し元のスレッドに対して拒否されるように、コードを構築する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-118">In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</span></span> <span data-ttu-id="ac210-119">スレッドがミューテックスの所有権を取得したことはないため、<xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="ac210-119">Because the thread never acquired ownership of the mutex, it must not call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span> <span data-ttu-id="ac210-120">例のセクションの2番目の例は、このパターンを示しています。</span><span class="sxs-lookup"><span data-stu-id="ac210-120">The second example in the Examples section illustrates this pattern.</span></span>  
  
 <span data-ttu-id="ac210-121"><xref:System.Threading.Mutex> クラスはスレッド id を適用するため、ミューテックスは、それを取得したスレッドだけが解放できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-121">The <xref:System.Threading.Mutex> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</span></span> <span data-ttu-id="ac210-122">これに対し、<xref:System.Threading.Semaphore> クラスでは、スレッド id は適用されません。</span><span class="sxs-lookup"><span data-stu-id="ac210-122">By contrast, the <xref:System.Threading.Semaphore> class does not enforce thread identity.</span></span> <span data-ttu-id="ac210-123">ミューテックスは、アプリケーションドメインの境界を越えて渡すこともできます。</span><span class="sxs-lookup"><span data-stu-id="ac210-123">A mutex can also be passed across application domain boundaries.</span></span>  
  
 <span data-ttu-id="ac210-124">ミューテックスを所有するスレッドは、実行をブロックせずに <xref:System.Threading.WaitHandle.WaitOne%2A> の呼び出しを繰り返すときに同じミューテックスを要求できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-124">The thread that owns a mutex can request the same mutex in repeated calls to <xref:System.Threading.WaitHandle.WaitOne%2A> without blocking its execution.</span></span> <span data-ttu-id="ac210-125">ただし、ミューテックスの所有権を解放するには、スレッドが同じ回数だけ <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-125">However, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="ac210-126"><xref:System.Threading.Mutex> クラスは <xref:System.Threading.WaitHandle>から継承するため、静的 <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> および <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> メソッドを呼び出して、保護されたリソースへのアクセスを同期することもできます。</span><span class="sxs-lookup"><span data-stu-id="ac210-126">Because the <xref:System.Threading.Mutex> class inherits from <xref:System.Threading.WaitHandle>, you can also call the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods to synchronize access to a protected resource.</span></span>  
  
 <span data-ttu-id="ac210-127">ミューテックスを所有している間にスレッドが終了した場合、ミューテックスは破棄されたと言います。</span><span class="sxs-lookup"><span data-stu-id="ac210-127">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="ac210-128">ミューテックスの状態はシグナル状態に設定され、次の待機スレッドは所有権を取得します。</span><span class="sxs-lookup"><span data-stu-id="ac210-128">The state of the mutex is set to signaled, and the next waiting thread gets ownership.</span></span> <span data-ttu-id="ac210-129">.NET Framework のバージョン2.0 以降では、破棄されたミューテックスを取得する次のスレッドで <xref:System.Threading.AbandonedMutexException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="ac210-129">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the abandoned mutex.</span></span> <span data-ttu-id="ac210-130">.NET Framework のバージョン2.0 より前では、例外はスローされませんでした。</span><span class="sxs-lookup"><span data-stu-id="ac210-130">Before version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ac210-131">多くの場合、放棄されたミューテックスは、コードに重大なエラーを示します。</span><span class="sxs-lookup"><span data-stu-id="ac210-131">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="ac210-132">ミューテックスを解放せずにスレッドが終了すると、ミューテックスによって保護されているデータ構造が一貫性のある状態にならない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-132">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="ac210-133">次にミューテックスの所有権を要求するスレッドは、この例外を処理し、データ構造の整合性を検証できる場合は処理を続行できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-133">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="ac210-134">システム全体でミューテックスが有効な場合にミューテックスが破棄されたときは、アプリケーションが強制終了されたことを示している可能性があります (たとえば、Windows タスク マネージャを使用した終了)。</span><span class="sxs-lookup"><span data-stu-id="ac210-134">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
 <span data-ttu-id="ac210-135">ミューテックスは、名前のないローカルミューテックスと名前付きシステムミューテックスの2種類です。</span><span class="sxs-lookup"><span data-stu-id="ac210-135">Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</span></span> <span data-ttu-id="ac210-136">ローカル ミューテックスは、現在のプロセス内にのみ存在します。</span><span class="sxs-lookup"><span data-stu-id="ac210-136">A local mutex exists only within your process.</span></span> <span data-ttu-id="ac210-137">これは、ミューテックスを表す <xref:System.Threading.Mutex> オブジェクトへの参照を持つプロセス内の任意のスレッドで使用できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-137">It can be used by any thread in your process that has a reference to the <xref:System.Threading.Mutex> object that represents the mutex.</span></span> <span data-ttu-id="ac210-138">名前のない各 <xref:System.Threading.Mutex> オブジェクトは、個別のローカルミューテックスを表します。</span><span class="sxs-lookup"><span data-stu-id="ac210-138">Each unnamed <xref:System.Threading.Mutex> object represents a separate local mutex.</span></span>  
  
 <span data-ttu-id="ac210-139">名前付きシステムミューテックスはオペレーティングシステム全体に表示され、プロセスのアクティビティを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-139">Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="ac210-140">名前を受け取るコンストラクターを使用して、名前付きシステムミューテックスを表す <xref:System.Threading.Mutex> オブジェクトを作成できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-140">You can create a <xref:System.Threading.Mutex> object that represents a named system mutex by using a constructor that accepts a name.</span></span> <span data-ttu-id="ac210-141">オペレーティングシステムオブジェクトは、同時に作成することも、<xref:System.Threading.Mutex> オブジェクトを作成する前に存在させることもできます。</span><span class="sxs-lookup"><span data-stu-id="ac210-141">The operating-system object can be created at the same time, or it can exist before the creation of the <xref:System.Threading.Mutex> object.</span></span> <span data-ttu-id="ac210-142">同じ名前付きシステム ミューテックスを表す複数の <xref:System.Threading.Mutex> オブジェクトを作成できます。また、<xref:System.Threading.Mutex.OpenExisting%2A> メソッドを使用して、既存の名前付きシステム ミューテックスを開くことができます。</span><span class="sxs-lookup"><span data-stu-id="ac210-142">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex, and you can use the <xref:System.Threading.Mutex.OpenExisting%2A> method to open an existing named system mutex.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ac210-143">ターミナルサービスを実行しているサーバーでは、名前付きシステムミューテックスに2つのレベルの可視性を持たせることができます。</span><span class="sxs-lookup"><span data-stu-id="ac210-143">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="ac210-144">名前が "Global\\" というプレフィックスで始まる場合、すべてのターミナルサーバーセッションでミューテックスが表示されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-144">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="ac210-145">名前の先頭が "Local\\" で始まる場合、ミューテックスは、そのミューテックスが作成されたターミナルサーバーセッションでのみ表示されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-145">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="ac210-146">この場合、サーバー上の他の各ターミナルサーバーセッションには、同じ名前のミューテックスが個別に存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-146">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="ac210-147">名前付きミューテックスを作成するときにプレフィックスを指定しない場合は、プレフィックス "Local\\" が使用されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-147">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="ac210-148">ターミナルサーバーセッション内では、名前が異なる2つのミューテックスは別々の mutex であり、両方ともターミナルサーバーセッションのすべてのプロセスで表示されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-148">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="ac210-149">つまり、プレフィックス名 "Global\\" と "Local\\" は、ターミナルサーバーセッションに対して相対的な mutex 名のスコープを示します。プロセスに対する相対パスではありません。</span><span class="sxs-lookup"><span data-stu-id="ac210-149">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 <span data-ttu-id="ac210-150">この例では、ローカル <xref:System.Threading.Mutex> オブジェクトを使用して、保護されたリソースへのアクセスを同期する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="ac210-150">This example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="ac210-151">ミューテックスの所有権を取得するまで、呼び出し元のスレッドはブロックされるため、スレッドの所有権を解放するには、<xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-151">Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the thread.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="ac210-152">次の例では、各スレッドが <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> メソッドを呼び出して、ミューテックスを取得します。</span><span class="sxs-lookup"><span data-stu-id="ac210-152">In the following example, each thread calls the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> method to acquire the mutex.</span></span> <span data-ttu-id="ac210-153">タイムアウト間隔が経過すると、メソッドは `false`を返し、スレッドはミューテックスを取得せず、ミューテックスによって保護されるリソースへのアクセスも取得しません。</span><span class="sxs-lookup"><span data-stu-id="ac210-153">If the time-out interval elapses, the method returns `false`, and the thread neither acquires the mutex nor gains access to the resource the mutex protects.</span></span> <span data-ttu-id="ac210-154"><xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドは、ミューテックスを取得するスレッドによってのみ呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-154">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is called only by the thread that acquires the mutex.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="ac210-155">この型はスレッド セーフです。</span><span class="sxs-lookup"><span data-stu-id="ac210-155">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="ac210-156">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="ac210-156">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="ac210-157">ミューテックス</span><span class="sxs-lookup"><span data-stu-id="ac210-157">Mutexes</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ac210-158"><see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="ac210-158">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ac210-159"><see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを、既定のプロパティを使用して初期化します。</span><span class="sxs-lookup"><span data-stu-id="ac210-159">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with default properties.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac210-160">このコンストラクターのオーバーロードを呼び出すことは、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> コンストラクターのオーバーロードを呼び出し、ミューテックスの初期所有権に `false` を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="ac210-160">Calling this constructor overload is the same as calling the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor overload and specifying `false` for initial ownership of the mutex.</span></span> <span data-ttu-id="ac210-161">つまり、呼び出し元のスレッドがミューテックスを所有していません。</span><span class="sxs-lookup"><span data-stu-id="ac210-161">That is, the calling thread does not own the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ac210-162">次のコード例は、ローカル <xref:System.Threading.Mutex> オブジェクトを使用して、保護されたリソースへのアクセスを同期する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="ac210-162">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="ac210-163">ミューテックスを作成するスレッドは、最初にそれを所有していません。</span><span class="sxs-lookup"><span data-stu-id="ac210-163">The thread that creates the mutex does not own it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="ac210-164">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="ac210-164">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="ac210-165">ミューテックス</span><span class="sxs-lookup"><span data-stu-id="ac210-165">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="ac210-166">呼び出し元スレッドにミューテックスの初期所有権を与える場合は<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac210-166"><see langword="true" /> to give the calling thread initial ownership of the mutex; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ac210-167">呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値を使用して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="ac210-167">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ac210-168">次のコード例は、ローカル <xref:System.Threading.Mutex> オブジェクトを使用して、保護されたリソースへのアクセスを同期する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="ac210-168">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="ac210-169"><xref:System.Threading.Mutex> を作成するスレッドは、最初にそれを所有します。</span><span class="sxs-lookup"><span data-stu-id="ac210-169">The thread that creates the <xref:System.Threading.Mutex> owns it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="ac210-170">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="ac210-170">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="ac210-171">ミューテックス</span><span class="sxs-lookup"><span data-stu-id="ac210-171">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="ac210-172">この呼び出しの結果として名前付きシステム ミューテックスが作成された場合に、呼び出し元スレッドに名前付きシステム ミューテックスの初期所有権を付与する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac210-172"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="ac210-173"><see cref="T:System.Threading.Mutex" /> の名前。</span><span class="sxs-lookup"><span data-stu-id="ac210-173">The name of the <see cref="T:System.Threading.Mutex" />.</span></span> <span data-ttu-id="ac210-174">値が <see langword="null" /> の場合、<see cref="T:System.Threading.Mutex" /> は無名になります。</span><span class="sxs-lookup"><span data-stu-id="ac210-174">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <summary><span data-ttu-id="ac210-175">呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値と、ミューテックスの名前を表す文字列を使用して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="ac210-175">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac210-176">`name` が `null` ではなく `initiallyOwned` が `true`場合、呼び出し元のスレッドは、この呼び出しの結果として名前付きシステムミューテックスが作成された場合にのみ、ミューテックスを所有します。</span><span class="sxs-lookup"><span data-stu-id="ac210-176">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</span></span> <span data-ttu-id="ac210-177">名前付きシステムミューテックスが作成されたかどうかを判断するためのメカニズムがないため、このコンストラクターのオーバーロードを呼び出すときに `initiallyOwned` の `false` を指定することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="ac210-177">Since there is no mechanism for determining whether the named system mutex was created, it is better to specify `false` for `initiallyOwned` when calling this constructor overload.</span></span> <span data-ttu-id="ac210-178">初期所有権を確認する必要がある場合は、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> コンストラクターを使用できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-178">You can use the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor if you need to determine initial ownership.</span></span>  
  
 <span data-ttu-id="ac210-179">このコンストラクターは、名前付きシステムミューテックスを表す <xref:System.Threading.Mutex> オブジェクトを初期化します。</span><span class="sxs-lookup"><span data-stu-id="ac210-179">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="ac210-180">同じ名前付きシステムミューテックスを表す複数の <xref:System.Threading.Mutex> オブジェクトを作成できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-180">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="ac210-181">名前付きミューテックスが access control security で既に作成されていて、呼び出し元に <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>がない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="ac210-181">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="ac210-182">スレッドアクティビティの同期に必要なアクセス許可だけを持つ既存の名前付きミューテックスを開くには、<xref:System.Threading.Mutex.OpenExisting%2A> メソッドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="ac210-182">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="ac210-183">`name`に `null` または空の文字列を指定すると、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> コンストラクターを呼び出した場合と同様に、ローカルミューテックスが作成されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-183">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="ac210-184">この場合、`createdNew` は常に `true`です。</span><span class="sxs-lookup"><span data-stu-id="ac210-184">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="ac210-185">これらはシステム全体で使用されるため、名前付きミューテックスを使用して、プロセスの境界を越えてリソースの使用を調整できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-185">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ac210-186">ターミナルサービスを実行しているサーバーでは、名前付きシステムミューテックスに2つのレベルの可視性を持たせることができます。</span><span class="sxs-lookup"><span data-stu-id="ac210-186">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="ac210-187">名前が "Global\\" というプレフィックスで始まる場合、すべてのターミナルサーバーセッションでミューテックスが表示されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-187">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="ac210-188">名前の先頭が "Local\\" で始まる場合、ミューテックスは、そのミューテックスが作成されたターミナルサーバーセッションでのみ表示されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-188">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="ac210-189">この場合、サーバー上の他の各ターミナルサーバーセッションには、同じ名前のミューテックスが個別に存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-189">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="ac210-190">名前付きミューテックスを作成するときにプレフィックスを指定しない場合は、プレフィックス "Local\\" が使用されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-190">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="ac210-191">ターミナルサーバーセッション内では、名前が異なる2つのミューテックスは別々の mutex であり、両方ともターミナルサーバーセッションのすべてのプロセスで表示されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-191">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="ac210-192">つまり、プレフィックス名 "Global\\" と "Local\\" は、ターミナルサーバーセッションに対して相対的な mutex 名のスコープを示します。プロセスに対する相対パスではありません。</span><span class="sxs-lookup"><span data-stu-id="ac210-192">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 <span data-ttu-id="ac210-193">次の例は、名前付きミューテックスを使用して、2つの異なるプロセスで実行されているスレッド間を通知する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="ac210-193">The following example shows how a named mutex is used to signal between threads running in two separate processes.</span></span>  
  
 <span data-ttu-id="ac210-194">このプログラムを2つ以上のコマンドウィンドウから実行します。</span><span class="sxs-lookup"><span data-stu-id="ac210-194">Run this program from two or more command windows.</span></span> <span data-ttu-id="ac210-195">各プロセスは、`MyMutex`名前付きミューテックスを表す <xref:System.Threading.Mutex> オブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="ac210-195">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex `MyMutex`.</span></span> <span data-ttu-id="ac210-196">名前付きミューテックスは、その有効期間がそれを表す <xref:System.Threading.Mutex> オブジェクトの有効期間によって制限されているシステムオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="ac210-196">The named mutex is a system object whose lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="ac210-197">名前付きミューテックスは、最初のプロセスが <xref:System.Threading.Mutex> オブジェクトを作成するときに作成されます。この例では、名前付きミューテックスは、プログラムを実行する最初のプロセスによって所有されています。</span><span class="sxs-lookup"><span data-stu-id="ac210-197">The named mutex is created when the first process creates its <xref:System.Threading.Mutex> object; in this example, the named mutex is owned by the first process that runs the program.</span></span> <span data-ttu-id="ac210-198">名前付きミューテックスは、それを表すすべての <xref:System.Threading.Mutex> オブジェクトが解放されると破棄されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-198">The named mutex is destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span>  
  
 <span data-ttu-id="ac210-199">この例で使用されるコンストラクターのオーバーロードは、名前付きミューテックスの初期所有権が付与されたかどうかを呼び出し元スレッドに通知できません。</span><span class="sxs-lookup"><span data-stu-id="ac210-199">The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted.</span></span> <span data-ttu-id="ac210-200">スレッドが名前付きミューテックスを作成することが確実でない限り、このコンストラクターを使用して初期所有権を要求することはできません。</span><span class="sxs-lookup"><span data-stu-id="ac210-200">You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="ac210-201">名前付きミューテックスが存在し、それにアクセス制御セキュリティがありますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.FullControl" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="ac210-201">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ac210-202">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="ac210-202">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="ac210-203">名前付きミューテックスを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</span><span class="sxs-lookup"><span data-stu-id="ac210-203">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ac210-204"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="ac210-204"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ac210-205">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="ac210-205">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="ac210-206">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="ac210-206">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="ac210-207">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="ac210-207">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="ac210-208">ミューテックス</span><span class="sxs-lookup"><span data-stu-id="ac210-208">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string * bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="ac210-209">この呼び出しの結果として名前付きシステム ミューテックスが作成された場合に、呼び出し元スレッドに名前付きシステム ミューテックスの初期所有権を付与する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac210-209"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="ac210-210"><see cref="T:System.Threading.Mutex" /> の名前。</span><span class="sxs-lookup"><span data-stu-id="ac210-210">The name of the <see cref="T:System.Threading.Mutex" />.</span></span> <span data-ttu-id="ac210-211">値が <see langword="null" /> の場合、<see cref="T:System.Threading.Mutex" /> は無名になります。</span><span class="sxs-lookup"><span data-stu-id="ac210-211">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <param name="createdNew"><span data-ttu-id="ac210-212">このメソッドから制御が戻るとき、ローカル ミューテックスが作成された場合 (つまり <see langword="true" /> が <paramref name="name" /> または空の文字列の場合) または指定した名前付きシステム ミューテックスが作成された場合は、ブール値 <see langword="null" /> が格納されます。指定した名前付きシステム ミューテックスが既に存在する場合は <see langword="false" /> が格納されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-212">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span></span> <span data-ttu-id="ac210-213">このパラメーターは初期化せずに渡されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-213">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="ac210-214">呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値、ミューテックスの名前を表す文字列、およびメソッドから戻るときにミューテックスの初期所有権が呼び出し元のスレッドに付与されたかどうかを示すブール値を指定して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="ac210-214">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac210-215">`name` が `null` ではなく `initiallyOwned` が `true`場合、呼び出し元のスレッドは、呼び出しの後に `createdNew` が `true` されている場合にのみ、名前付きミューテックスを所有します。</span><span class="sxs-lookup"><span data-stu-id="ac210-215">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="ac210-216">それ以外の場合、スレッドは <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを呼び出すことによってミューテックスを要求できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-216">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="ac210-217">このコンストラクターは、名前付きシステムミューテックスを表す <xref:System.Threading.Mutex> オブジェクトを初期化します。</span><span class="sxs-lookup"><span data-stu-id="ac210-217">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="ac210-218">同じ名前付きシステムミューテックスを表す複数の <xref:System.Threading.Mutex> オブジェクトを作成できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-218">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="ac210-219">名前付きミューテックスが access control security で既に作成されていて、呼び出し元に <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> 権限がない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="ac210-219">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> rights, an exception is thrown.</span></span> <span data-ttu-id="ac210-220">スレッドアクティビティの同期に必要なアクセス許可だけを持つ既存の名前付きミューテックスを開くには、<xref:System.Threading.Mutex.OpenExisting%2A> メソッドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="ac210-220">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="ac210-221">`name`に `null` または空の文字列を指定すると、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> コンストラクターを呼び出した場合と同様に、ローカルミューテックスが作成されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-221">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="ac210-222">この場合、`createdNew` は常に `true`です。</span><span class="sxs-lookup"><span data-stu-id="ac210-222">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="ac210-223">これらはシステム全体で使用されるため、名前付きミューテックスを使用して、プロセスの境界を越えてリソースの使用を調整できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-223">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ac210-224">ターミナルサービスを実行しているサーバーでは、名前付きシステムミューテックスに2つのレベルの可視性を持たせることができます。</span><span class="sxs-lookup"><span data-stu-id="ac210-224">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="ac210-225">名前が "Global\\" というプレフィックスで始まる場合、すべてのターミナルサーバーセッションでミューテックスが表示されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-225">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="ac210-226">名前の先頭が "Local\\" で始まる場合、ミューテックスは、そのミューテックスが作成されたターミナルサーバーセッションでのみ表示されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-226">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="ac210-227">この場合、サーバー上の他の各ターミナルサーバーセッションには、同じ名前のミューテックスが個別に存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-227">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="ac210-228">名前付きミューテックスを作成するときにプレフィックスを指定しない場合は、プレフィックス "Local\\" が使用されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-228">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="ac210-229">ターミナルサーバーセッション内では、名前が異なる2つのミューテックスは別々の mutex であり、両方ともターミナルサーバーセッションのすべてのプロセスで表示されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-229">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="ac210-230">つまり、プレフィックス名 "Global\\" と "Local\\" は、ターミナルサーバーセッションに対して相対的な mutex 名のスコープを示します。プロセスに対する相対パスではありません。</span><span class="sxs-lookup"><span data-stu-id="ac210-230">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 <span data-ttu-id="ac210-231">次のコード例は、名前付きミューテックスを使用してプロセスまたはスレッド間のシグナルを通知する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="ac210-231">The following code example shows how a named mutex is used to signal between processes or threads.</span></span> <span data-ttu-id="ac210-232">このプログラムを2つ以上のコマンドウィンドウから実行します。</span><span class="sxs-lookup"><span data-stu-id="ac210-232">Run this program from two or more command windows.</span></span> <span data-ttu-id="ac210-233">各プロセスは、名前付きミューテックス "MyMutex" を表す <xref:System.Threading.Mutex> オブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="ac210-233">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex "MyMutex".</span></span> <span data-ttu-id="ac210-234">名前付きミューテックスはシステムオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="ac210-234">The named mutex is a system object.</span></span> <span data-ttu-id="ac210-235">この例では、有効期間は、それを表す <xref:System.Threading.Mutex> オブジェクトの有効期間によって制限されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-235">In this example, its lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="ac210-236">名前付きミューテックスは、最初のプロセスがローカル <xref:System.Threading.Mutex> オブジェクトを作成するときに作成され、それを表すすべての <xref:System.Threading.Mutex> オブジェクトが解放されると破棄されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-236">The named mutex is created when the first process creates its local <xref:System.Threading.Mutex> object, and destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span> <span data-ttu-id="ac210-237">名前付きミューテックスは最初のプロセスによって最初に所有されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-237">The named mutex is initially owned by the first process.</span></span> <span data-ttu-id="ac210-238">2番目のプロセスとそれ以降のプロセスは、以前のプロセスが名前付きミューテックスを解放するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="ac210-238">The second process and any subsequent processes wait for earlier processes to release the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="ac210-239">名前付きミューテックスが存在し、それにアクセス制御セキュリティがありますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.FullControl" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="ac210-239">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ac210-240">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="ac210-240">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="ac210-241">名前付きミューテックスを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</span><span class="sxs-lookup"><span data-stu-id="ac210-241">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ac210-242"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="ac210-242"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ac210-243">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="ac210-243">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="ac210-244">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="ac210-244">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="ac210-245">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="ac210-245">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="ac210-246">ミューテックス</span><span class="sxs-lookup"><span data-stu-id="ac210-246">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string * bool * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="ac210-247">この呼び出しの結果として名前付きシステム ミューテックスが作成された場合に、呼び出し元スレッドに名前付きシステム ミューテックスの初期所有権を付与する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac210-247"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="ac210-248">システム ミューテックスの名前。</span><span class="sxs-lookup"><span data-stu-id="ac210-248">The name of the system mutex.</span></span> <span data-ttu-id="ac210-249">値が <see langword="null" /> の場合、<see cref="T:System.Threading.Mutex" /> は無名になります。</span><span class="sxs-lookup"><span data-stu-id="ac210-249">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <param name="createdNew"><span data-ttu-id="ac210-250">このメソッドから制御が戻るとき、ローカル ミューテックスが作成された場合 (つまり <see langword="true" /> が <paramref name="name" /> または空の文字列の場合) または指定した名前付きシステム ミューテックスが作成された場合は、ブール値 <see langword="null" /> が格納されます。指定した名前付きシステム ミューテックスが既に存在する場合は <see langword="false" /> が格納されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-250">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span></span> <span data-ttu-id="ac210-251">このパラメーターは初期化せずに渡されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-251">This parameter is passed uninitialized.</span></span></param>
        <param name="mutexSecurity"><span data-ttu-id="ac210-252">名前付きシステム ミューテックスに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="ac210-252">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span></span></param>
        <summary><span data-ttu-id="ac210-253">呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値、ミューテックスの名前を表す文字列、メソッドが戻るときにミューテックスの初期所有権が呼び出し元のスレッドに付与されたかどうかを示すブール値変数、および名前付きミューテックスに適用するアクセス制御セキュリティを指定して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="ac210-253">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac210-254">`name` が `null` ではなく `initiallyOwned` が `true`場合、呼び出し元のスレッドは、呼び出しの後に `createdNew` が `true` されている場合にのみ、名前付きミューテックスを所有します。</span><span class="sxs-lookup"><span data-stu-id="ac210-254">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="ac210-255">それ以外の場合、スレッドは <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを呼び出すことによってミューテックスを要求できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-255">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="ac210-256">このコンストラクターを使用して、名前付きシステムミューテックスの作成時にアクセス制御セキュリティを適用し、他のコードがミューテックスを制御できないようにします。</span><span class="sxs-lookup"><span data-stu-id="ac210-256">Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</span></span>  
  
 <span data-ttu-id="ac210-257">このコンストラクターは、名前付きシステムミューテックスを表す <xref:System.Threading.Mutex> オブジェクトを初期化します。</span><span class="sxs-lookup"><span data-stu-id="ac210-257">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="ac210-258">同じ名前付きシステムミューテックスを表す複数の <xref:System.Threading.Mutex> オブジェクトを作成できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-258">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="ac210-259">名前付きシステムミューテックスが存在しない場合は、指定されたアクセス制御セキュリティを使用して作成されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-259">If the named system mutex does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="ac210-260">名前付きミューテックスが存在する場合、指定されたアクセス制御セキュリティは無視されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-260">If the named mutex exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ac210-261">呼び出し元は、現在のユーザーに対して一部のアクセス権の付与を拒否または失敗した `mutexSecurity` 場合でも、新しく作成された <xref:System.Threading.Mutex> オブジェクトを完全に制御できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-261">The caller has full control over the newly created <xref:System.Threading.Mutex> object even if `mutexSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="ac210-262">ただし、現在のユーザーが、コンストラクターまたは <xref:System.Threading.Mutex.OpenExisting%2A> のいずれかのメソッドを使用して、同じ名前付きミューテックスを表す別の <xref:System.Threading.Mutex> オブジェクトを取得しようとすると、Windows access control セキュリティが適用されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-262">However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="ac210-263">名前付きミューテックスが access control security で既に作成されていて、呼び出し元に <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>がない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="ac210-263">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="ac210-264">スレッドアクティビティの同期に必要なアクセス許可だけを持つ既存の名前付きミューテックスを開くには、<xref:System.Threading.Mutex.OpenExisting%2A> メソッドを参照してください。</span><span class="sxs-lookup"><span data-stu-id="ac210-264">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="ac210-265">`name`に `null` または空の文字列を指定すると、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> コンストラクターを呼び出した場合と同様に、ローカルミューテックスが作成されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-265">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="ac210-266">この場合、`createdNew` は常に `true`です。</span><span class="sxs-lookup"><span data-stu-id="ac210-266">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="ac210-267">これらはシステム全体で使用されるため、名前付きミューテックスを使用して、プロセスの境界を越えてリソースの使用を調整できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-267">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ac210-268">ターミナルサービスを実行しているサーバーでは、名前付きシステムミューテックスに2つのレベルの可視性を持たせることができます。</span><span class="sxs-lookup"><span data-stu-id="ac210-268">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="ac210-269">名前が "Global\\" というプレフィックスで始まる場合、すべてのターミナルサーバーセッションでミューテックスが表示されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-269">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="ac210-270">名前の先頭が "Local\\" で始まる場合、ミューテックスは、そのミューテックスが作成されたターミナルサーバーセッションでのみ表示されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-270">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="ac210-271">この場合、サーバー上の他の各ターミナルサーバーセッションには、同じ名前のミューテックスが個別に存在する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-271">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="ac210-272">名前付きミューテックスを作成するときにプレフィックスを指定しない場合は、プレフィックス "Local\\" が使用されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-272">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="ac210-273">ターミナルサーバーセッション内では、名前が異なる2つのミューテックスは別々の mutex であり、両方ともターミナルサーバーセッションのすべてのプロセスで表示されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-273">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="ac210-274">つまり、プレフィックス名 "Global\\" と "Local\\" は、ターミナルサーバーセッションに対して相対的な mutex 名のスコープを示します。プロセスに対する相対パスではありません。</span><span class="sxs-lookup"><span data-stu-id="ac210-274">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 <span data-ttu-id="ac210-275">次のコード例では、アクセス制御セキュリティを使用した名前付きミューテックスのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="ac210-275">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="ac210-276">この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きミューテックスが存在するかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="ac210-276">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="ac210-277">ミューテックスが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して作成され、現在のユーザーがミューテックスを使用する権限を拒否します。ただし、ミューテックスに対するアクセス許可を読み取り、変更する権限を付与します。</span><span class="sxs-lookup"><span data-stu-id="ac210-277">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="ac210-278">コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.Mutex.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="ac210-278">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="ac210-279">例外がキャッチされ、この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドのオーバーロードを使用して、アクセス許可の読み取りと変更に必要な権限を持つミューテックスを開きます。</span><span class="sxs-lookup"><span data-stu-id="ac210-279">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="ac210-280">アクセス許可が変更されたら、ミューテックスを入力して解放するために必要な権限を使用して、ミューテックスが開かれます。</span><span class="sxs-lookup"><span data-stu-id="ac210-280">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="ac210-281">コンパイルされた例を3番目のコマンドウィンドウから実行すると、新しいアクセス許可を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-281">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ac210-282">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="ac210-282">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="ac210-283">名前付きミューテックスが存在し、それにアクセス制御セキュリティがありますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.FullControl" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="ac210-283">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="ac210-284">名前付きミューテックスを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</span><span class="sxs-lookup"><span data-stu-id="ac210-284">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ac210-285"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="ac210-285"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ac210-286">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="ac210-286">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="ac210-287">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="ac210-287">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ac210-288">名前付きミューテックスのアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="ac210-288">Gets a <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span></span></summary>
        <returns><span data-ttu-id="ac210-289">名前付きミューテックスのアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="ac210-289">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac210-290"><xref:System.Threading.Mutex.GetAccessControl%2A> メソッドは、(ビットごとの OR 演算を使用して組み合わされた) フラグの組み合わせを使用して、アクセス許可 (<xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>、<xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>、および <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>) を検索します。</span><span class="sxs-lookup"><span data-stu-id="ac210-290">The <xref:System.Threading.Mutex.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ac210-291">ユーザーは、このメソッドを呼び出すために <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> を持っている必要があります。また、ミューテックスは <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>で開かれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-291">The user must have <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ac210-292">次のコード例では、アクセス制御セキュリティを使用した名前付きミューテックスのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="ac210-292">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="ac210-293">この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きミューテックスが存在するかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="ac210-293">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="ac210-294">ミューテックスが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して作成され、現在のユーザーがミューテックスを使用する権限を拒否します。ただし、ミューテックスに対するアクセス許可を読み取り、変更する権限を付与します。</span><span class="sxs-lookup"><span data-stu-id="ac210-294">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="ac210-295">コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.Mutex.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="ac210-295">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="ac210-296">例外がキャッチされ、この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドオーバーロードを使用して、<xref:System.Threading.Mutex.GetAccessControl%2A> メソッドと <xref:System.Threading.Mutex.SetAccessControl%2A> メソッドを使用して、アクセス許可の読み取りと変更に必要な権限を持つミューテックスを開きます。</span><span class="sxs-lookup"><span data-stu-id="ac210-296">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="ac210-297">アクセス許可が変更されたら、ミューテックスを入力して解放するために必要な権限を使用して、ミューテックスが開かれます。</span><span class="sxs-lookup"><span data-stu-id="ac210-297">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="ac210-298">コンパイルされた例を3番目のコマンドウィンドウから実行すると、新しいアクセス許可を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-298">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="ac210-299">現在の <see cref="T:System.Threading.Mutex" /> オブジェクトは名前付きシステム ミューテックスを表していますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="ac210-299">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span></span>  
  
<span data-ttu-id="ac210-300">または</span><span class="sxs-lookup"><span data-stu-id="ac210-300">-or-</span></span> 
<span data-ttu-id="ac210-301">現在の <see cref="T:System.Threading.Mutex" /> オブジェクトは名前付きシステム ミューテックスを表しており、<see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /> で開かれませんでした。</span><span class="sxs-lookup"><span data-stu-id="ac210-301">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, and was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ac210-302">Windows 98 または Windows Millennium Edition はサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="ac210-302">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ac210-303">既に存在する場合は、指定した名前付きミューテックスを開きます。</span><span class="sxs-lookup"><span data-stu-id="ac210-303">Opens a specified named mutex, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="ac210-304">開くシステム ミューテックスの名前。</span><span class="sxs-lookup"><span data-stu-id="ac210-304">The name of the system mutex to open.</span></span></param>
        <summary><span data-ttu-id="ac210-305">既に存在する場合は、指定した名前付きミューテックスを開きます。</span><span class="sxs-lookup"><span data-stu-id="ac210-305">Opens the specified named mutex, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="ac210-306">名前付きシステム ミューテックスを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="ac210-306">An object that represents the named system mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac210-307"><xref:System.Threading.Mutex.OpenExisting%2A> メソッドは、指定された名前付きシステムミューテックスを開こうとします。</span><span class="sxs-lookup"><span data-stu-id="ac210-307">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open the specified named system mutex.</span></span> <span data-ttu-id="ac210-308">システムミューテックスが存在しない場合、このメソッドはシステムオブジェクトを作成するのではなく、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="ac210-308">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="ac210-309">システムミューテックスがまだ存在しない場合に作成するには、`name` パラメーターを持つ <xref:System.Threading.Mutex.%23ctor%2A> コンストラクターのいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="ac210-309">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="ac210-310">`name` に同じ値を使用するこのメソッドを複数回呼び出すことは、返されるオブジェクトが同じ名前のシステムミューテックスを表している場合でも、必ずしも同じ <xref:System.Threading.Mutex> オブジェクトを返すとは限りません。</span><span class="sxs-lookup"><span data-stu-id="ac210-310">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="ac210-311">このメソッドオーバーロードは、ビットごとの OR 演算を使用して、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドオーバーロードを呼び出し、<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> および <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 権限を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="ac210-311">This method overload is equivalent to calling the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="ac210-312"><xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> フラグを指定すると、スレッドはミューテックスを待機でき、<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> フラグを指定すると、スレッドは <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="ac210-312">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="ac210-313">このメソッドは、ミューテックスの所有権を要求しません。</span><span class="sxs-lookup"><span data-stu-id="ac210-313">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ac210-314">次のコード例では、アクセス制御セキュリティを使用した名前付きミューテックスのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="ac210-314">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="ac210-315">この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きミューテックスが存在するかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="ac210-315">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="ac210-316">ミューテックスが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して作成され、現在のユーザーがミューテックスを使用する権限を拒否します。ただし、ミューテックスに対するアクセス許可を読み取り、変更する権限を付与します。</span><span class="sxs-lookup"><span data-stu-id="ac210-316">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="ac210-317">コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.Mutex.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="ac210-317">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="ac210-318">例外がキャッチされ、この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドのオーバーロードを使用して、アクセス許可の読み取りと変更に必要な権限を持つミューテックスを開きます。</span><span class="sxs-lookup"><span data-stu-id="ac210-318">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="ac210-319">アクセス許可が変更されたら、ミューテックスを入力して解放するために必要な権限を使用して、ミューテックスが開かれます。</span><span class="sxs-lookup"><span data-stu-id="ac210-319">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="ac210-320">コンパイルされた例を3番目のコマンドウィンドウから実行すると、新しいアクセス許可を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-320">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ac210-321"><paramref name="name" /> が空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="ac210-321"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="ac210-322">または</span><span class="sxs-lookup"><span data-stu-id="ac210-322">-or-</span></span> 
 <span data-ttu-id="ac210-323"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="ac210-323"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ac210-324"><paramref name="name" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="ac210-324"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="ac210-325">名前付きミューテックスが存在しません。</span><span class="sxs-lookup"><span data-stu-id="ac210-325">The named mutex does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ac210-326">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="ac210-326">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="ac210-327">名前付きミューテックスは存在しますが、それを使用するために必要なセキュリティ アクセスがユーザーにありません。</span><span class="sxs-lookup"><span data-stu-id="ac210-327">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ac210-328">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="ac210-328">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="ac210-329">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="ac210-329">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="ac210-330">開くシステム ミューテックスの名前。</span><span class="sxs-lookup"><span data-stu-id="ac210-330">The name of the system mutex to open.</span></span></param>
        <param name="rights"><span data-ttu-id="ac210-331">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="ac210-331">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="ac210-332">既に存在する場合は、必要なセキュリティ アクセスで指定した名前付きミューテックスを開きます。</span><span class="sxs-lookup"><span data-stu-id="ac210-332">Opens the specified named mutex, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="ac210-333">名前付きシステム ミューテックスを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="ac210-333">An object that represents the named system mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac210-334">`rights` パラメーターには、スレッドがミューテックスを待機できるようにするための <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> フラグと、スレッドが <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出せるようにするための <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> フラグを含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-334">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="ac210-335"><xref:System.Threading.Mutex.OpenExisting%2A> メソッドは、既存の名前付きミューテックスを開こうとします。</span><span class="sxs-lookup"><span data-stu-id="ac210-335">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open an existing named mutex.</span></span> <span data-ttu-id="ac210-336">システムミューテックスが存在しない場合、このメソッドはシステムオブジェクトを作成するのではなく、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="ac210-336">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="ac210-337">システムミューテックスがまだ存在しない場合に作成するには、`name` パラメーターを持つ <xref:System.Threading.Mutex.%23ctor%2A> コンストラクターのいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="ac210-337">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="ac210-338">`name` に同じ値を使用するこのメソッドを複数回呼び出すことは、返されるオブジェクトが同じ名前のシステムミューテックスを表している場合でも、必ずしも同じ <xref:System.Threading.Mutex> オブジェクトを返すとは限りません。</span><span class="sxs-lookup"><span data-stu-id="ac210-338">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="ac210-339">このメソッドは、ミューテックスの所有権を要求しません。</span><span class="sxs-lookup"><span data-stu-id="ac210-339">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ac210-340">次のコード例では、アクセス制御セキュリティを使用した名前付きミューテックスのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="ac210-340">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="ac210-341">この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きミューテックスが存在するかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="ac210-341">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="ac210-342">ミューテックスが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して作成され、現在のユーザーがミューテックスを使用する権限を拒否します。ただし、ミューテックスに対するアクセス許可を読み取り、変更する権限を付与します。</span><span class="sxs-lookup"><span data-stu-id="ac210-342">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="ac210-343">コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.Mutex.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="ac210-343">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="ac210-344">例外がキャッチされ、この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドのオーバーロードを使用して、アクセス許可の読み取りと変更に必要な権限を持つミューテックスを開きます。</span><span class="sxs-lookup"><span data-stu-id="ac210-344">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="ac210-345">アクセス許可が変更されたら、ミューテックスを入力して解放するために必要な権限を使用して、ミューテックスが開かれます。</span><span class="sxs-lookup"><span data-stu-id="ac210-345">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="ac210-346">コンパイルされた例を3番目のコマンドウィンドウから実行すると、新しいアクセス許可を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-346">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ac210-347"><paramref name="name" /> が空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="ac210-347"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="ac210-348">または</span><span class="sxs-lookup"><span data-stu-id="ac210-348">-or-</span></span> 
 <span data-ttu-id="ac210-349"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="ac210-349"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ac210-350"><paramref name="name" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="ac210-350"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="ac210-351">名前付きミューテックスが存在しません。</span><span class="sxs-lookup"><span data-stu-id="ac210-351">The named mutex does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ac210-352">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="ac210-352">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="ac210-353">名前付きミューテックスは存在しますが、必要なセキュリティ アクセスがユーザーにありません。</span><span class="sxs-lookup"><span data-stu-id="ac210-353">The named mutex exists, but the user does not have the desired security access.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ac210-354">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="ac210-354">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="ac210-355">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="ac210-355">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ac210-356"><see cref="T:System.Threading.Mutex" /> を一度解放します。</span><span class="sxs-lookup"><span data-stu-id="ac210-356">Releases the <see cref="T:System.Threading.Mutex" /> once.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac210-357">スレッドがミューテックスを取得するたびに (たとえば、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを呼び出すことによって)、ミューテックスの所有権を解放するために <xref:System.Threading.Mutex.ReleaseMutex%2A> を呼び出して、ミューテックスの所有権を取得しようとしている他のスレッドのブロックを解除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-357">Whenever a thread acquires a mutex (for example, by calling its <xref:System.Threading.WaitHandle.WaitOne%2A> method), it must subsequently call <xref:System.Threading.Mutex.ReleaseMutex%2A> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</span></span> <span data-ttu-id="ac210-358">ミューテックスの所有権を取得しようとしたときに (たとえば、`millisecondsTimeout` または `timeout` パラメーターを使用して <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを呼び出すと、要求がタイムアウトしたため `false` が返された場合)、スレッドは <xref:System.Threading.Mutex.ReleaseMutex%2A>を呼び出すことができません。この場合、スレッドはミューテックスによって保護されたリソースにアクセスできなくなります。</span><span class="sxs-lookup"><span data-stu-id="ac210-358">If the attempt to get ownership of the mutex fails (for example, when a call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method with a `millisecondsTimeout` or a `timeout` parameter returns `false` because the request times out), the thread shouldn't call <xref:System.Threading.Mutex.ReleaseMutex%2A>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 <span data-ttu-id="ac210-359">ミューテックスを所有するスレッドは、実行をブロックせずに、繰り返し待機関数呼び出しで同じミューテックスを指定できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-359">A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</span></span> <span data-ttu-id="ac210-360">呼び出しの数は、共通言語ランタイムによって保持されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-360">The number of calls is kept by the common language runtime.</span></span> <span data-ttu-id="ac210-361">スレッドは、ミューテックスの所有権を解放するために、同じ回数 <xref:System.Threading.Mutex.ReleaseMutex%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-361">The thread must call <xref:System.Threading.Mutex.ReleaseMutex%2A> the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="ac210-362">ミューテックスを所有している間にスレッドが終了した場合、ミューテックスは破棄されたと言います。</span><span class="sxs-lookup"><span data-stu-id="ac210-362">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="ac210-363">ミューテックスの状態はシグナル状態に設定され、次の待機スレッドは所有権を取得します。</span><span class="sxs-lookup"><span data-stu-id="ac210-363">The state of the mutex is set to signaled and the next waiting thread gets ownership.</span></span> <span data-ttu-id="ac210-364">ミューテックスを所有している人がいない場合、ミューテックスの状態はシグナル状態になります。</span><span class="sxs-lookup"><span data-stu-id="ac210-364">If no one owns the mutex, the state of the mutex is signaled.</span></span> <span data-ttu-id="ac210-365">.NET Framework のバージョン2.0 以降では、ミューテックスを取得する次のスレッドで <xref:System.Threading.AbandonedMutexException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="ac210-365">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the mutex.</span></span> <span data-ttu-id="ac210-366">.NET Framework のバージョン2.0 より前では、例外はスローされませんでした。</span><span class="sxs-lookup"><span data-stu-id="ac210-366">Prior to version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ac210-367">多くの場合、放棄されたミューテックスは、コードに重大なエラーを示します。</span><span class="sxs-lookup"><span data-stu-id="ac210-367">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="ac210-368">ミューテックスを解放せずにスレッドが終了すると、ミューテックスによって保護されているデータ構造が一貫性のある状態にならない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-368">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="ac210-369">次にミューテックスの所有権を要求するスレッドは、この例外を処理し、データ構造の整合性を検証できる場合は処理を続行できます。</span><span class="sxs-lookup"><span data-stu-id="ac210-369">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="ac210-370">システム全体でミューテックスが有効な場合にミューテックスが破棄されたときは、アプリケーションが強制終了されたことを示している可能性があります (たとえば、Windows タスク マネージャを使用した終了)。</span><span class="sxs-lookup"><span data-stu-id="ac210-370">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ac210-371">次の例は、ローカル <xref:System.Threading.Mutex> オブジェクトを使用して、保護されたリソースへのアクセスを同期する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="ac210-371">The following example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="ac210-372">ミューテックスを作成するスレッドは、最初にそれを所有していません。</span><span class="sxs-lookup"><span data-stu-id="ac210-372">The thread that creates the mutex does not own it initially.</span></span> <span data-ttu-id="ac210-373"><xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドは、不要になったミューテックスを解放するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-373">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is used to release the mutex when it is no longer needed.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="ac210-374">呼び出しスレッドに独自のミューテックスがありません。</span><span class="sxs-lookup"><span data-stu-id="ac210-374">The calling thread does not own the mutex.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="ac210-375">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="ac210-375">The current instance has already been disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="ac210-376">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="ac210-376">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="ac210-377">ミューテックス</span><span class="sxs-lookup"><span data-stu-id="ac210-377">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity"><span data-ttu-id="ac210-378">名前付きシステム ミューテックスに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="ac210-378">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span></span></param>
        <summary><span data-ttu-id="ac210-379">名前付きシステム ミューテックスのアクセス制御セキュリティを設定します。</span><span class="sxs-lookup"><span data-stu-id="ac210-379">Sets the access control security for a named system mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac210-380">ユーザーは、このメソッドを呼び出すための <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> 権限を持っている必要があります。また、ミューテックスは <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>で開かれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-380">The user must have <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ac210-381">次のコード例では、アクセス制御セキュリティを使用した名前付きミューテックスのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="ac210-381">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="ac210-382">この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きミューテックスが存在するかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="ac210-382">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="ac210-383">ミューテックスが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して作成され、現在のユーザーがミューテックスを使用する権限を拒否します。ただし、ミューテックスに対するアクセス許可を読み取り、変更する権限を付与します。</span><span class="sxs-lookup"><span data-stu-id="ac210-383">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="ac210-384">コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.Mutex.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="ac210-384">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="ac210-385">例外がキャッチされ、この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドオーバーロードを使用して、<xref:System.Threading.Mutex.GetAccessControl%2A> メソッドと <xref:System.Threading.Mutex.SetAccessControl%2A> メソッドを使用して、アクセス許可の読み取りと変更に必要な権限を持つミューテックスを開きます。</span><span class="sxs-lookup"><span data-stu-id="ac210-385">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="ac210-386">アクセス許可が変更されたら、ミューテックスを入力して解放するために必要な権限を使用して、ミューテックスが開かれます。</span><span class="sxs-lookup"><span data-stu-id="ac210-386">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="ac210-387">コンパイルされた例を3番目のコマンドウィンドウから実行すると、新しいアクセス許可を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-387">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ac210-388"><paramref name="mutexSecurity" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="ac210-388"><paramref name="mutexSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="ac210-389">ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="ac210-389">The user does not have <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span></span>  
  
<span data-ttu-id="ac210-390">または</span><span class="sxs-lookup"><span data-stu-id="ac210-390">-or-</span></span> 
<span data-ttu-id="ac210-391">ミューテックスは <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> で開かれませんでした。</span><span class="sxs-lookup"><span data-stu-id="ac210-391">The mutex was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="ac210-392">現在の <see cref="T:System.Threading.Mutex" /> オブジェクトは名前付きシステム ミューテックスを表していません。</span><span class="sxs-lookup"><span data-stu-id="ac210-392">The current <see cref="T:System.Threading.Mutex" /> object does not represent a named system mutex.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ac210-393">既に存在する場合は、指定した名前付きミューテックスを開き操作が成功したかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="ac210-393">Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * Mutex -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="ac210-394">開くシステム ミューテックスの名前。</span><span class="sxs-lookup"><span data-stu-id="ac210-394">The name of the system mutex to open.</span></span></param>
        <param name="result"><span data-ttu-id="ac210-395">このメソッドから戻るときに、呼び出しに成功した場合は名前付きミューテックスを表す <see cref="T:System.Threading.Mutex" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-395">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="ac210-396">このパラメーターは未初期化として扱われます。</span><span class="sxs-lookup"><span data-stu-id="ac210-396">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="ac210-397">既に存在する場合は、指定した名前付きミューテックスを開き操作が成功したかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="ac210-397">Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="ac210-398">名前付きミューテックスが正常に開かれた場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac210-398"><see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac210-399">名前付きミューテックスが存在しない場合、このメソッドはそれを作成しません。</span><span class="sxs-lookup"><span data-stu-id="ac210-399">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="ac210-400">システムミューテックスがまだ存在しない場合に作成するには、`name` パラメーターを持つ <xref:System.Threading.Mutex.%23ctor%2A> コンストラクターのいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="ac210-400">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="ac210-401">名前付きミューテックスが存在するかどうかが不明な場合は、<xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドオーバーロードではなく、このメソッドオーバーロードを使用します。これにより、ミューテックスが存在しない場合に例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="ac210-401">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="ac210-402">`name` に同じ値を使用するこのメソッドを複数回呼び出すことは、返されるオブジェクトが同じ名前のシステムミューテックスを表している場合でも、必ずしも同じ <xref:System.Threading.Mutex> オブジェクトを返すとは限りません。</span><span class="sxs-lookup"><span data-stu-id="ac210-402">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="ac210-403">このメソッドオーバーロードは、ビットごとの OR 演算を使用して、<xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> メソッドオーバーロードを呼び出し、<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> および <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 権限を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="ac210-403">This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="ac210-404"><xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> フラグを指定すると、スレッドはミューテックスを待機でき、<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> フラグを指定すると、スレッドは <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="ac210-404">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="ac210-405">このメソッドは、ミューテックスの所有権を要求しません。</span><span class="sxs-lookup"><span data-stu-id="ac210-405">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ac210-406"><paramref name="name" /> が空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="ac210-406"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="ac210-407">または</span><span class="sxs-lookup"><span data-stu-id="ac210-407">-or-</span></span> 
 <span data-ttu-id="ac210-408"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="ac210-408"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ac210-409"><paramref name="name" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="ac210-409"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ac210-410">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="ac210-410">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="ac210-411">名前付きミューテックスは存在しますが、それを使用するために必要なセキュリティ アクセスがユーザーにありません。</span><span class="sxs-lookup"><span data-stu-id="ac210-411">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ac210-412">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="ac210-412">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ac210-413">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="ac210-413">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights * Mutex -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="ac210-414">開くシステム ミューテックスの名前。</span><span class="sxs-lookup"><span data-stu-id="ac210-414">The name of the system mutex to open.</span></span></param>
        <param name="rights"><span data-ttu-id="ac210-415">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="ac210-415">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="ac210-416">このメソッドから戻るときに、呼び出しに成功した場合は名前付きミューテックスを表す <see cref="T:System.Threading.Mutex" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。</span><span class="sxs-lookup"><span data-stu-id="ac210-416">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="ac210-417">このパラメーターは未初期化として扱われます。</span><span class="sxs-lookup"><span data-stu-id="ac210-417">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="ac210-418">既に存在する場合は、必要なセキュリティ アクセスを使用して指定した名前付きミューテックスを開き、操作が成功したかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="ac210-418">Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="ac210-419">名前付きミューテックスが正常に開かれた場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ac210-419"><see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ac210-420">名前付きミューテックスが存在しない場合、このメソッドはそれを作成しません。</span><span class="sxs-lookup"><span data-stu-id="ac210-420">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="ac210-421">システムミューテックスがまだ存在しない場合に作成するには、`name` パラメーターを持つ <xref:System.Threading.Mutex.%23ctor%2A> コンストラクターのいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="ac210-421">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="ac210-422">名前付きミューテックスが存在するかどうかが不明な場合は、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドオーバーロードではなく、このメソッドオーバーロードを使用します。これにより、ミューテックスが存在しない場合に例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="ac210-422">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="ac210-423">`rights` パラメーターには、スレッドがミューテックスを待機できるようにするための <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> フラグと、スレッドが <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出せるようにするための <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> フラグを含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="ac210-423">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="ac210-424">`name` に同じ値を使用するこのメソッドを複数回呼び出すことは、返されるオブジェクトが同じ名前のシステムミューテックスを表している場合でも、必ずしも同じ <xref:System.Threading.Mutex> オブジェクトを返すとは限りません。</span><span class="sxs-lookup"><span data-stu-id="ac210-424">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="ac210-425">このメソッドは、ミューテックスの所有権を要求しません。</span><span class="sxs-lookup"><span data-stu-id="ac210-425">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ac210-426"><paramref name="name" /> が空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="ac210-426"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="ac210-427">または</span><span class="sxs-lookup"><span data-stu-id="ac210-427">-or-</span></span> 
 <span data-ttu-id="ac210-428"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="ac210-428"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ac210-429"><paramref name="name" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="ac210-429"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="ac210-430">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="ac210-430">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="ac210-431">名前付きミューテックスは存在しますが、それを使用するために必要なセキュリティ アクセスがユーザーにありません。</span><span class="sxs-lookup"><span data-stu-id="ac210-431">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ac210-432">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="ac210-432">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ac210-433">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="ac210-433">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>
