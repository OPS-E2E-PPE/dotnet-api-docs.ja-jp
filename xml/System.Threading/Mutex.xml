<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3aee14deb55430fd5c60ac1edfc35e935b82b582" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75158674" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>同期プリミティブは、プロセス間の同期にも使用できます。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 2つ以上のスレッドが共有リソースに同時にアクセスする必要がある場合、システムには、一度に1つのスレッドのみがリソースを使用するように同期機構が必要です。 <xref:System.Threading.Mutex> は、共有リソースへの排他アクセスを1つのスレッドにのみ許可する同期プリミティブです。 スレッドがミューテックスを取得した場合、そのミューテックスを取得する2番目のスレッドは、最初のスレッドがミューテックスを解放するまで中断されます。  
  
> [!IMPORTANT]
>  この型は <xref:System.IDisposable> インターフェイスを実装します。 型の使用が完了したら、直接的または間接的に型を破棄する必要があります。 直接的に型を破棄するには、<xref:System.IDisposable.Dispose%2A>`try`/ ブロック内で `catch` メソッドを呼び出します。 間接的に型を破棄するには、`using` (C# の場合) または `Using` (Visual Basic 言語) などの言語構成要素を使用します。 詳細については、<xref:System.IDisposable> インターフェイスに関するトピック内の「IDisposable を実装するオブジェクトの使用」セクションを参照してください。  
  
 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> メソッドを使用して、ミューテックスの所有権を要求できます。 呼び出し元のスレッドは、次のいずれかが発生するまでブロックします。  
  
-   ミューテックスは、所有されていないことを示すシグナルとして通知されます。 この場合、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドは `true`を返し、呼び出し元のスレッドはミューテックスの所有権を前提とし、ミューテックスによって保護されているリソースにアクセスします。 リソースへのアクセスが終了したら、スレッドは <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出して、ミューテックスの所有権を解放する必要があります。 例のセクションの最初の例は、このパターンを示しています。  
  
-   `millisecondsTimeout` または `timeout` パラメーターを持つ <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドの呼び出しで指定されたタイムアウト期間が経過しました。 この場合、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドは `false`を返し、呼び出し元のスレッドはミューテックスの所有権を取得しません。 この場合は、ミューテックスによって保護されているリソースへのアクセスが呼び出し元のスレッドに対して拒否されるように、コードを構築する必要があります。 スレッドがミューテックスの所有権を取得したことはないため、<xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出すことはできません。 例のセクションの2番目の例は、このパターンを示しています。  
  
 <xref:System.Threading.Mutex> クラスはスレッド id を適用するため、ミューテックスは、それを取得したスレッドだけが解放できます。 これに対し、<xref:System.Threading.Semaphore> クラスでは、スレッド id は適用されません。 ミューテックスは、アプリケーションドメインの境界を越えて渡すこともできます。  
  
 ミューテックスを所有するスレッドは、実行をブロックせずに <xref:System.Threading.WaitHandle.WaitOne%2A> の呼び出しを繰り返すときに同じミューテックスを要求できます。 ただし、ミューテックスの所有権を解放するには、スレッドが同じ回数だけ <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出す必要があります。  
  
 <xref:System.Threading.Mutex> クラスは <xref:System.Threading.WaitHandle>から継承するため、静的 <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> および <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> メソッドを呼び出して、保護されたリソースへのアクセスを同期することもできます。  
  
 ミューテックスを所有している間にスレッドが終了した場合、ミューテックスは破棄されたと言います。 ミューテックスの状態はシグナル状態に設定され、次の待機スレッドは所有権を取得します。 .NET Framework のバージョン2.0 以降では、破棄されたミューテックスを取得する次のスレッドで <xref:System.Threading.AbandonedMutexException> がスローされます。 .NET Framework のバージョン2.0 より前では、例外はスローされませんでした。  
  
> [!CAUTION]
>  多くの場合、放棄されたミューテックスは、コードに重大なエラーを示します。 ミューテックスを解放せずにスレッドが終了すると、ミューテックスによって保護されているデータ構造が一貫性のある状態にならない可能性があります。 次にミューテックスの所有権を要求するスレッドは、この例外を処理し、データ構造の整合性を検証できる場合は処理を続行できます。  
  
 システム全体でミューテックスが有効な場合にミューテックスが破棄されたときは、アプリケーションが強制終了されたことを示している可能性があります (たとえば、Windows タスク マネージャを使用した終了)。  
  
 ミューテックスは、名前のないローカルミューテックスと名前付きシステムミューテックスの2種類です。 ローカル ミューテックスは、現在のプロセス内にのみ存在します。 これは、ミューテックスを表す <xref:System.Threading.Mutex> オブジェクトへの参照を持つプロセス内の任意のスレッドで使用できます。 名前のない各 <xref:System.Threading.Mutex> オブジェクトは、個別のローカルミューテックスを表します。  
  
 名前付きシステムミューテックスはオペレーティングシステム全体に表示され、プロセスのアクティビティを同期するために使用できます。 名前を受け取るコンストラクターを使用して、名前付きシステムミューテックスを表す <xref:System.Threading.Mutex> オブジェクトを作成できます。 オペレーティングシステムオブジェクトは、同時に作成することも、<xref:System.Threading.Mutex> オブジェクトを作成する前に存在させることもできます。 同じ名前付きシステム ミューテックスを表す複数の <xref:System.Threading.Mutex> オブジェクトを作成できます。また、<xref:System.Threading.Mutex.OpenExisting%2A> メソッドを使用して、既存の名前付きシステム ミューテックスを開くことができます。  
  
> [!NOTE]
>  ターミナルサービスを実行しているサーバーでは、名前付きシステムミューテックスに2つのレベルの可視性を持たせることができます。 名前が "Global\\" というプレフィックスで始まる場合、すべてのターミナルサーバーセッションでミューテックスが表示されます。 名前の先頭が "Local\\" で始まる場合、ミューテックスは、そのミューテックスが作成されたターミナルサーバーセッションでのみ表示されます。 この場合、サーバー上の他の各ターミナルサーバーセッションには、同じ名前のミューテックスが個別に存在する可能性があります。 名前付きミューテックスを作成するときにプレフィックスを指定しない場合は、プレフィックス "Local\\" が使用されます。 ターミナルサーバーセッション内では、名前が異なる2つのミューテックスは別々の mutex であり、両方ともターミナルサーバーセッションのすべてのプロセスで表示されます。 つまり、プレフィックス名 "Global\\" と "Local\\" は、ターミナルサーバーセッションに対して相対的な mutex 名のスコープを示します。プロセスに対する相対パスではありません。  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 この例では、ローカル <xref:System.Threading.Mutex> オブジェクトを使用して、保護されたリソースへのアクセスを同期する方法を示します。 ミューテックスの所有権を取得するまで、呼び出し元のスレッドはブロックされるため、スレッドの所有権を解放するには、<xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出す必要があります。  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 次の例では、各スレッドが <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> メソッドを呼び出して、ミューテックスを取得します。 タイムアウト間隔が経過すると、メソッドは `false`を返し、スレッドはミューテックスを取得せず、ミューテックスによって保護されるリソースへのアクセスも取得しません。 <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドは、ミューテックスを取得するスレッドによってのみ呼び出されます。  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">ミューテックス</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを、既定のプロパティを使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンストラクターのオーバーロードを呼び出すことは、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> コンストラクターのオーバーロードを呼び出し、ミューテックスの初期所有権に `false` を指定することと同じです。 つまり、呼び出し元のスレッドがミューテックスを所有していません。  
  
   
  
## Examples  
 次のコード例は、ローカル <xref:System.Threading.Mutex> オブジェクトを使用して、保護されたリソースへのアクセスを同期する方法を示しています。 ミューテックスを作成するスレッドは、最初にそれを所有していません。  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">ミューテックス</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">呼び出し元スレッドにミューテックスの初期所有権を与える場合は<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値を使用して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、ローカル <xref:System.Threading.Mutex> オブジェクトを使用して、保護されたリソースへのアクセスを同期する方法を示しています。 <xref:System.Threading.Mutex> を作成するスレッドは、最初にそれを所有します。  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">ミューテックス</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">この呼び出しの結果として名前付きシステム ミューテックスが作成された場合に、呼び出し元スレッドに名前付きシステム ミューテックスの初期所有権を付与する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="name"><see cref="T:System.Threading.Mutex" /> の名前。 値が <see langword="null" /> の場合、<see cref="T:System.Threading.Mutex" /> は無名になります。</param>
        <summary>呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値と、ミューテックスの名前を表す文字列を使用して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name` が `null` ではなく `initiallyOwned` が `true`場合、呼び出し元のスレッドは、この呼び出しの結果として名前付きシステムミューテックスが作成された場合にのみ、ミューテックスを所有します。 名前付きシステムミューテックスが作成されたかどうかを判断するためのメカニズムがないため、このコンストラクターのオーバーロードを呼び出すときに `initiallyOwned` の `false` を指定することをお勧めします。 初期所有権を確認する必要がある場合は、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> コンストラクターを使用できます。  
  
 このコンストラクターは、名前付きシステムミューテックスを表す <xref:System.Threading.Mutex> オブジェクトを初期化します。 同じ名前付きシステムミューテックスを表す複数の <xref:System.Threading.Mutex> オブジェクトを作成できます。  
  
 名前付きミューテックスが access control security で既に作成されていて、呼び出し元に <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>がない場合は、例外がスローされます。 スレッドアクティビティの同期に必要なアクセス許可だけを持つ既存の名前付きミューテックスを開くには、<xref:System.Threading.Mutex.OpenExisting%2A> メソッドを参照してください。  
  
 `name`に `null` または空の文字列を指定すると、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> コンストラクターを呼び出した場合と同様に、ローカルミューテックスが作成されます。 この場合、`createdNew` は常に `true`です。  
  
 これらはシステム全体で使用されるため、名前付きミューテックスを使用して、プロセスの境界を越えてリソースの使用を調整できます。  
  
> [!NOTE]
>  ターミナルサービスを実行しているサーバーでは、名前付きシステムミューテックスに2つのレベルの可視性を持たせることができます。 名前が "Global\\" というプレフィックスで始まる場合、すべてのターミナルサーバーセッションでミューテックスが表示されます。 名前の先頭が "Local\\" で始まる場合、ミューテックスは、そのミューテックスが作成されたターミナルサーバーセッションでのみ表示されます。 この場合、サーバー上の他の各ターミナルサーバーセッションには、同じ名前のミューテックスが個別に存在する可能性があります。 名前付きミューテックスを作成するときにプレフィックスを指定しない場合は、プレフィックス "Local\\" が使用されます。 ターミナルサーバーセッション内では、名前が異なる2つのミューテックスは別々の mutex であり、両方ともターミナルサーバーセッションのすべてのプロセスで表示されます。 つまり、プレフィックス名 "Global\\" と "Local\\" は、ターミナルサーバーセッションに対して相対的な mutex 名のスコープを示します。プロセスに対する相対パスではありません。  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 次の例は、名前付きミューテックスを使用して、2つの異なるプロセスで実行されているスレッド間を通知する方法を示しています。  
  
 このプログラムを2つ以上のコマンドウィンドウから実行します。 各プロセスは、`MyMutex`名前付きミューテックスを表す <xref:System.Threading.Mutex> オブジェクトを作成します。 名前付きミューテックスは、その有効期間がそれを表す <xref:System.Threading.Mutex> オブジェクトの有効期間によって制限されているシステムオブジェクトです。 名前付きミューテックスは、最初のプロセスが <xref:System.Threading.Mutex> オブジェクトを作成するときに作成されます。この例では、名前付きミューテックスは、プログラムを実行する最初のプロセスによって所有されています。 名前付きミューテックスは、それを表すすべての <xref:System.Threading.Mutex> オブジェクトが解放されると破棄されます。  
  
 この例で使用されるコンストラクターのオーバーロードは、名前付きミューテックスの初期所有権が付与されたかどうかを呼び出し元スレッドに通知できません。 スレッドが名前付きミューテックスを作成することが確実でない限り、このコンストラクターを使用して初期所有権を要求することはできません。  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスが存在し、それにアクセス制御セキュリティがありますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.FullControl" /> がありません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミューテックスを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が 260 文字を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">ミューテックス</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string * bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">この呼び出しの結果として名前付きシステム ミューテックスが作成された場合に、呼び出し元スレッドに名前付きシステム ミューテックスの初期所有権を付与する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="name"><see cref="T:System.Threading.Mutex" /> の名前。 値が <see langword="null" /> の場合、<see cref="T:System.Threading.Mutex" /> は無名になります。</param>
        <param name="createdNew">このメソッドから制御が戻るとき、ローカル ミューテックスが作成された場合 (つまり <see langword="true" /> が <paramref name="name" /> または空の文字列の場合) または指定した名前付きシステム ミューテックスが作成された場合は、ブール値 <see langword="null" /> が格納されます。指定した名前付きシステム ミューテックスが既に存在する場合は <see langword="false" /> が格納されます。 このパラメーターは初期化せずに渡されます。</param>
        <summary>呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値、ミューテックスの名前を表す文字列、およびメソッドから戻るときにミューテックスの初期所有権が呼び出し元のスレッドに付与されたかどうかを示すブール値を指定して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name` が `null` ではなく `initiallyOwned` が `true`場合、呼び出し元のスレッドは、呼び出しの後に `createdNew` が `true` されている場合にのみ、名前付きミューテックスを所有します。 それ以外の場合、スレッドは <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを呼び出すことによってミューテックスを要求できます。  
  
 このコンストラクターは、名前付きシステムミューテックスを表す <xref:System.Threading.Mutex> オブジェクトを初期化します。 同じ名前付きシステムミューテックスを表す複数の <xref:System.Threading.Mutex> オブジェクトを作成できます。  
  
 名前付きミューテックスが access control security で既に作成されていて、呼び出し元に <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> 権限がない場合は、例外がスローされます。 スレッドアクティビティの同期に必要なアクセス許可だけを持つ既存の名前付きミューテックスを開くには、<xref:System.Threading.Mutex.OpenExisting%2A> メソッドを参照してください。  
  
 `name`に `null` または空の文字列を指定すると、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> コンストラクターを呼び出した場合と同様に、ローカルミューテックスが作成されます。 この場合、`createdNew` は常に `true`です。  
  
 これらはシステム全体で使用されるため、名前付きミューテックスを使用して、プロセスの境界を越えてリソースの使用を調整できます。  
  
> [!NOTE]
>  ターミナルサービスを実行しているサーバーでは、名前付きシステムミューテックスに2つのレベルの可視性を持たせることができます。 名前が "Global\\" というプレフィックスで始まる場合、すべてのターミナルサーバーセッションでミューテックスが表示されます。 名前の先頭が "Local\\" で始まる場合、ミューテックスは、そのミューテックスが作成されたターミナルサーバーセッションでのみ表示されます。 この場合、サーバー上の他の各ターミナルサーバーセッションには、同じ名前のミューテックスが個別に存在する可能性があります。 名前付きミューテックスを作成するときにプレフィックスを指定しない場合は、プレフィックス "Local\\" が使用されます。 ターミナルサーバーセッション内では、名前が異なる2つのミューテックスは別々の mutex であり、両方ともターミナルサーバーセッションのすべてのプロセスで表示されます。 つまり、プレフィックス名 "Global\\" と "Local\\" は、ターミナルサーバーセッションに対して相対的な mutex 名のスコープを示します。プロセスに対する相対パスではありません。  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 次のコード例は、名前付きミューテックスを使用してプロセスまたはスレッド間のシグナルを通知する方法を示しています。 このプログラムを2つ以上のコマンドウィンドウから実行します。 各プロセスは、名前付きミューテックス "MyMutex" を表す <xref:System.Threading.Mutex> オブジェクトを作成します。 名前付きミューテックスはシステムオブジェクトです。 この例では、有効期間は、それを表す <xref:System.Threading.Mutex> オブジェクトの有効期間によって制限されます。 名前付きミューテックスは、最初のプロセスがローカル <xref:System.Threading.Mutex> オブジェクトを作成するときに作成され、それを表すすべての <xref:System.Threading.Mutex> オブジェクトが解放されると破棄されます。 名前付きミューテックスは最初のプロセスによって最初に所有されます。 2番目のプロセスとそれ以降のプロセスは、以前のプロセスが名前付きミューテックスを解放するまで待機します。  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスが存在し、それにアクセス制御セキュリティがありますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.FullControl" /> がありません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミューテックスを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が 260 文字を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">ミューテックス</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string * bool * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">この呼び出しの結果として名前付きシステム ミューテックスが作成された場合に、呼び出し元スレッドに名前付きシステム ミューテックスの初期所有権を付与する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="name">システム ミューテックスの名前。 値が <see langword="null" /> の場合、<see cref="T:System.Threading.Mutex" /> は無名になります。</param>
        <param name="createdNew">このメソッドから制御が戻るとき、ローカル ミューテックスが作成された場合 (つまり <see langword="true" /> が <paramref name="name" /> または空の文字列の場合) または指定した名前付きシステム ミューテックスが作成された場合は、ブール値 <see langword="null" /> が格納されます。指定した名前付きシステム ミューテックスが既に存在する場合は <see langword="false" /> が格納されます。 このパラメーターは初期化せずに渡されます。</param>
        <param name="mutexSecurity">名前付きシステム ミューテックスに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクト。</param>
        <summary>呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値、ミューテックスの名前を表す文字列、メソッドが戻るときにミューテックスの初期所有権が呼び出し元のスレッドに付与されたかどうかを示すブール値変数、および名前付きミューテックスに適用するアクセス制御セキュリティを指定して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name` が `null` ではなく `initiallyOwned` が `true`場合、呼び出し元のスレッドは、呼び出しの後に `createdNew` が `true` されている場合にのみ、名前付きミューテックスを所有します。 それ以外の場合、スレッドは <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを呼び出すことによってミューテックスを要求できます。  
  
 このコンストラクターを使用して、名前付きシステムミューテックスの作成時にアクセス制御セキュリティを適用し、他のコードがミューテックスを制御できないようにします。  
  
 このコンストラクターは、名前付きシステムミューテックスを表す <xref:System.Threading.Mutex> オブジェクトを初期化します。 同じ名前付きシステムミューテックスを表す複数の <xref:System.Threading.Mutex> オブジェクトを作成できます。  
  
 名前付きシステムミューテックスが存在しない場合は、指定されたアクセス制御セキュリティを使用して作成されます。 名前付きミューテックスが存在する場合、指定されたアクセス制御セキュリティは無視されます。  
  
> [!NOTE]
>  呼び出し元は、現在のユーザーに対して一部のアクセス権の付与を拒否または失敗した `mutexSecurity` 場合でも、新しく作成された <xref:System.Threading.Mutex> オブジェクトを完全に制御できます。 ただし、現在のユーザーが、コンストラクターまたは <xref:System.Threading.Mutex.OpenExisting%2A> のいずれかのメソッドを使用して、同じ名前付きミューテックスを表す別の <xref:System.Threading.Mutex> オブジェクトを取得しようとすると、Windows access control セキュリティが適用されます。  
  
 名前付きミューテックスが access control security で既に作成されていて、呼び出し元に <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>がない場合は、例外がスローされます。 スレッドアクティビティの同期に必要なアクセス許可だけを持つ既存の名前付きミューテックスを開くには、<xref:System.Threading.Mutex.OpenExisting%2A> メソッドを参照してください。  
  
 `name`に `null` または空の文字列を指定すると、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> コンストラクターを呼び出した場合と同様に、ローカルミューテックスが作成されます。 この場合、`createdNew` は常に `true`です。  
  
 これらはシステム全体で使用されるため、名前付きミューテックスを使用して、プロセスの境界を越えてリソースの使用を調整できます。  
  
> [!NOTE]
>  ターミナルサービスを実行しているサーバーでは、名前付きシステムミューテックスに2つのレベルの可視性を持たせることができます。 名前が "Global\\" というプレフィックスで始まる場合、すべてのターミナルサーバーセッションでミューテックスが表示されます。 名前の先頭が "Local\\" で始まる場合、ミューテックスは、そのミューテックスが作成されたターミナルサーバーセッションでのみ表示されます。 この場合、サーバー上の他の各ターミナルサーバーセッションには、同じ名前のミューテックスが個別に存在する可能性があります。 名前付きミューテックスを作成するときにプレフィックスを指定しない場合は、プレフィックス "Local\\" が使用されます。 ターミナルサーバーセッション内では、名前が異なる2つのミューテックスは別々の mutex であり、両方ともターミナルサーバーセッションのすべてのプロセスで表示されます。 つまり、プレフィックス名 "Global\\" と "Local\\" は、ターミナルサーバーセッションに対して相対的な mutex 名のスコープを示します。プロセスに対する相対パスではありません。  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを使用した名前付きミューテックスのプロセス間の動作を示します。 この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きミューテックスが存在するかどうかをテストします。  
  
 ミューテックスが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して作成され、現在のユーザーがミューテックスを使用する権限を拒否します。ただし、ミューテックスに対するアクセス許可を読み取り、変更する権限を付与します。  
  
 コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.Mutex.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。 例外がキャッチされ、この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドのオーバーロードを使用して、アクセス許可の読み取りと変更に必要な権限を持つミューテックスを開きます。  
  
 アクセス許可が変更されたら、ミューテックスを入力して解放するために必要な権限を使用して、ミューテックスが開かれます。 コンパイルされた例を3番目のコマンドウィンドウから実行すると、新しいアクセス許可を使用して実行されます。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスが存在し、それにアクセス制御セキュリティがありますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.FullControl" /> がありません。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミューテックスを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が 260 文字を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>名前付きミューテックスのアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクトを取得します。</summary>
        <returns>名前付きミューテックスのアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.GetAccessControl%2A> メソッドは、(ビットごとの OR 演算を使用して組み合わされた) フラグの組み合わせを使用して、アクセス許可 (<xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>、<xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>、および <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>) を検索します。  
  
 ユーザーは、このメソッドを呼び出すために <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> を持っている必要があります。また、ミューテックスは <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>で開かれている必要があります。  
  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを使用した名前付きミューテックスのプロセス間の動作を示します。 この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きミューテックスが存在するかどうかをテストします。  
  
 ミューテックスが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して作成され、現在のユーザーがミューテックスを使用する権限を拒否します。ただし、ミューテックスに対するアクセス許可を読み取り、変更する権限を付与します。  
  
 コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.Mutex.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。 例外がキャッチされ、この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドオーバーロードを使用して、<xref:System.Threading.Mutex.GetAccessControl%2A> メソッドと <xref:System.Threading.Mutex.SetAccessControl%2A> メソッドを使用して、アクセス許可の読み取りと変更に必要な権限を持つミューテックスを開きます。  
  
 アクセス許可が変更されたら、ミューテックスを入力して解放するために必要な権限を使用して、ミューテックスが開かれます。 コンパイルされた例を3番目のコマンドウィンドウから実行すると、新しいアクセス許可を使用して実行されます。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">現在の <see cref="T:System.Threading.Mutex" /> オブジェクトは名前付きシステム ミューテックスを表していますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /> がありません。  
  
または 
現在の <see cref="T:System.Threading.Mutex" /> オブジェクトは名前付きシステム ミューテックスを表しており、<see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /> で開かれませんでした。</exception>
        <exception cref="T:System.NotSupportedException">Windows 98 または Windows Millennium Edition はサポートされていません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既に存在する場合は、指定した名前付きミューテックスを開きます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム ミューテックスの名前。</param>
        <summary>既に存在する場合は、指定した名前付きミューテックスを開きます。</summary>
        <returns>名前付きシステム ミューテックスを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.OpenExisting%2A> メソッドは、指定された名前付きシステムミューテックスを開こうとします。 システムミューテックスが存在しない場合、このメソッドはシステムオブジェクトを作成するのではなく、例外をスローします。 システムミューテックスがまだ存在しない場合に作成するには、`name` パラメーターを持つ <xref:System.Threading.Mutex.%23ctor%2A> コンストラクターのいずれかを使用します。  
  
 `name` に同じ値を使用するこのメソッドを複数回呼び出すことは、返されるオブジェクトが同じ名前のシステムミューテックスを表している場合でも、必ずしも同じ <xref:System.Threading.Mutex> オブジェクトを返すとは限りません。  
  
 このメソッドオーバーロードは、ビットごとの OR 演算を使用して、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドオーバーロードを呼び出し、<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> および <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 権限を指定することと同じです。  
  
 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> フラグを指定すると、スレッドはミューテックスを待機でき、<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> フラグを指定すると、スレッドは <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出すことができます。  
  
 このメソッドは、ミューテックスの所有権を要求しません。  
  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを使用した名前付きミューテックスのプロセス間の動作を示します。 この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きミューテックスが存在するかどうかをテストします。  
  
 ミューテックスが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して作成され、現在のユーザーがミューテックスを使用する権限を拒否します。ただし、ミューテックスに対するアクセス許可を読み取り、変更する権限を付与します。  
  
 コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.Mutex.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。 例外がキャッチされ、この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドのオーバーロードを使用して、アクセス許可の読み取りと変更に必要な権限を持つミューテックスを開きます。  
  
 アクセス許可が変更されたら、ミューテックスを入力して解放するために必要な権限を使用して、ミューテックスが開かれます。 コンパイルされた例を3番目のコマンドウィンドウから実行すると、新しいアクセス許可を使用して実行されます。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が空の文字列です。  
  
または 
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミューテックスが存在しません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスは存在しますが、それを使用するために必要なセキュリティ アクセスがユーザーにありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム ミューテックスの名前。</param>
        <param name="rights">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</param>
        <summary>既に存在する場合は、必要なセキュリティ アクセスで指定した名前付きミューテックスを開きます。</summary>
        <returns>名前付きシステム ミューテックスを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights` パラメーターには、スレッドがミューテックスを待機できるようにするための <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> フラグと、スレッドが <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出せるようにするための <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> フラグを含める必要があります。  
  
 <xref:System.Threading.Mutex.OpenExisting%2A> メソッドは、既存の名前付きミューテックスを開こうとします。 システムミューテックスが存在しない場合、このメソッドはシステムオブジェクトを作成するのではなく、例外をスローします。 システムミューテックスがまだ存在しない場合に作成するには、`name` パラメーターを持つ <xref:System.Threading.Mutex.%23ctor%2A> コンストラクターのいずれかを使用します。  
  
 `name` に同じ値を使用するこのメソッドを複数回呼び出すことは、返されるオブジェクトが同じ名前のシステムミューテックスを表している場合でも、必ずしも同じ <xref:System.Threading.Mutex> オブジェクトを返すとは限りません。  
  
 このメソッドは、ミューテックスの所有権を要求しません。  
  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを使用した名前付きミューテックスのプロセス間の動作を示します。 この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きミューテックスが存在するかどうかをテストします。  
  
 ミューテックスが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して作成され、現在のユーザーがミューテックスを使用する権限を拒否します。ただし、ミューテックスに対するアクセス許可を読み取り、変更する権限を付与します。  
  
 コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.Mutex.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。 例外がキャッチされ、この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドのオーバーロードを使用して、アクセス許可の読み取りと変更に必要な権限を持つミューテックスを開きます。  
  
 アクセス許可が変更されたら、ミューテックスを入力して解放するために必要な権限を使用して、ミューテックスが開かれます。 コンパイルされた例を3番目のコマンドウィンドウから実行すると、新しいアクセス許可を使用して実行されます。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が空の文字列です。  
  
または 
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミューテックスが存在しません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスは存在しますが、必要なセキュリティ アクセスがユーザーにありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.Mutex" /> を一度解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドがミューテックスを取得するたびに (たとえば、<xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを呼び出すことによって)、ミューテックスの所有権を解放するために <xref:System.Threading.Mutex.ReleaseMutex%2A> を呼び出して、ミューテックスの所有権を取得しようとしている他のスレッドのブロックを解除する必要があります。 ミューテックスの所有権を取得しようとしたときに (たとえば、`millisecondsTimeout` または `timeout` パラメーターを使用して <xref:System.Threading.WaitHandle.WaitOne%2A> メソッドを呼び出すと、要求がタイムアウトしたため `false` が返された場合)、スレッドは <xref:System.Threading.Mutex.ReleaseMutex%2A>を呼び出すことができません。この場合、スレッドはミューテックスによって保護されたリソースにアクセスできなくなります。  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ミューテックスを所有するスレッドは、実行をブロックせずに、繰り返し待機関数呼び出しで同じミューテックスを指定できます。 呼び出しの数は、共通言語ランタイムによって保持されます。 スレッドは、ミューテックスの所有権を解放するために、同じ回数 <xref:System.Threading.Mutex.ReleaseMutex%2A> を呼び出す必要があります。  
  
 ミューテックスを所有している間にスレッドが終了した場合、ミューテックスは破棄されたと言います。 ミューテックスの状態はシグナル状態に設定され、次の待機スレッドは所有権を取得します。 ミューテックスを所有している人がいない場合、ミューテックスの状態はシグナル状態になります。 .NET Framework のバージョン2.0 以降では、ミューテックスを取得する次のスレッドで <xref:System.Threading.AbandonedMutexException> がスローされます。 .NET Framework のバージョン2.0 より前では、例外はスローされませんでした。  
  
> [!CAUTION]
>  多くの場合、放棄されたミューテックスは、コードに重大なエラーを示します。 ミューテックスを解放せずにスレッドが終了すると、ミューテックスによって保護されているデータ構造が一貫性のある状態にならない可能性があります。 次にミューテックスの所有権を要求するスレッドは、この例外を処理し、データ構造の整合性を検証できる場合は処理を続行できます。  
  
 システム全体でミューテックスが有効な場合にミューテックスが破棄されたときは、アプリケーションが強制終了されたことを示している可能性があります (たとえば、Windows タスク マネージャを使用した終了)。  
  
   
  
## Examples  
 次の例は、ローカル <xref:System.Threading.Mutex> オブジェクトを使用して、保護されたリソースへのアクセスを同期する方法を示しています。 ミューテックスを作成するスレッドは、最初にそれを所有していません。 <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドは、不要になったミューテックスを解放するために使用されます。  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">呼び出しスレッドに独自のミューテックスがありません。</exception>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">ミューテックス</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">名前付きシステム ミューテックスに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクト。</param>
        <summary>名前付きシステム ミューテックスのアクセス制御セキュリティを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーは、このメソッドを呼び出すための <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> 権限を持っている必要があります。また、ミューテックスは <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>で開かれている必要があります。  
  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを使用した名前付きミューテックスのプロセス間の動作を示します。 この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きミューテックスが存在するかどうかをテストします。  
  
 ミューテックスが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して作成され、現在のユーザーがミューテックスを使用する権限を拒否します。ただし、ミューテックスに対するアクセス許可を読み取り、変更する権限を付与します。  
  
 コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.Mutex.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。 例外がキャッチされ、この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドオーバーロードを使用して、<xref:System.Threading.Mutex.GetAccessControl%2A> メソッドと <xref:System.Threading.Mutex.SetAccessControl%2A> メソッドを使用して、アクセス許可の読み取りと変更に必要な権限を持つミューテックスを開きます。  
  
 アクセス許可が変更されたら、ミューテックスを入力して解放するために必要な権限を使用して、ミューテックスが開かれます。 コンパイルされた例を3番目のコマンドウィンドウから実行すると、新しいアクセス許可を使用して実行されます。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mutexSecurity" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.UnauthorizedAccessException">ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> がありません。  
  
または 
ミューテックスは <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> で開かれませんでした。</exception>
        <exception cref="T:System.SystemException">現在の <see cref="T:System.Threading.Mutex" /> オブジェクトは名前付きシステム ミューテックスを表していません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既に存在する場合は、指定した名前付きミューテックスを開き操作が成功したかどうかを示す値を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * Mutex -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム ミューテックスの名前。</param>
        <param name="result">このメソッドから戻るときに、呼び出しに成功した場合は名前付きミューテックスを表す <see cref="T:System.Threading.Mutex" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。 このパラメーターは未初期化として扱われます。</param>
        <summary>既に存在する場合は、指定した名前付きミューテックスを開き操作が成功したかどうかを示す値を返します。</summary>
        <returns>名前付きミューテックスが正常に開かれた場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前付きミューテックスが存在しない場合、このメソッドはそれを作成しません。 システムミューテックスがまだ存在しない場合に作成するには、`name` パラメーターを持つ <xref:System.Threading.Mutex.%23ctor%2A> コンストラクターのいずれかを使用します。  
  
 名前付きミューテックスが存在するかどうかが不明な場合は、<xref:System.Threading.Mutex.OpenExisting%28System.String%29> メソッドオーバーロードではなく、このメソッドオーバーロードを使用します。これにより、ミューテックスが存在しない場合に例外がスローされます。  
  
 `name` に同じ値を使用するこのメソッドを複数回呼び出すことは、返されるオブジェクトが同じ名前のシステムミューテックスを表している場合でも、必ずしも同じ <xref:System.Threading.Mutex> オブジェクトを返すとは限りません。  
  
 このメソッドオーバーロードは、ビットごとの OR 演算を使用して、<xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> メソッドオーバーロードを呼び出し、<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> および <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> 権限を指定することと同じです。 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> フラグを指定すると、スレッドはミューテックスを待機でき、<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> フラグを指定すると、スレッドは <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出すことができます。  
  
 このメソッドは、ミューテックスの所有権を要求しません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が空の文字列です。  
  
または 
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスは存在しますが、それを使用するために必要なセキュリティ アクセスがユーザーにありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights * Mutex -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム ミューテックスの名前。</param>
        <param name="rights">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</param>
        <param name="result">このメソッドから戻るときに、呼び出しに成功した場合は名前付きミューテックスを表す <see cref="T:System.Threading.Mutex" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。 このパラメーターは未初期化として扱われます。</param>
        <summary>既に存在する場合は、必要なセキュリティ アクセスを使用して指定した名前付きミューテックスを開き、操作が成功したかどうかを示す値を返します。</summary>
        <returns>名前付きミューテックスが正常に開かれた場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前付きミューテックスが存在しない場合、このメソッドはそれを作成しません。 システムミューテックスがまだ存在しない場合に作成するには、`name` パラメーターを持つ <xref:System.Threading.Mutex.%23ctor%2A> コンストラクターのいずれかを使用します。  
  
 名前付きミューテックスが存在するかどうかが不明な場合は、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> メソッドオーバーロードではなく、このメソッドオーバーロードを使用します。これにより、ミューテックスが存在しない場合に例外がスローされます。  
  
 `rights` パラメーターには、スレッドがミューテックスを待機できるようにするための <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> フラグと、スレッドが <xref:System.Threading.Mutex.ReleaseMutex%2A> メソッドを呼び出せるようにするための <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> フラグを含める必要があります。  
  
 `name` に同じ値を使用するこのメソッドを複数回呼び出すことは、返されるオブジェクトが同じ名前のシステムミューテックスを表している場合でも、必ずしも同じ <xref:System.Threading.Mutex> オブジェクトを返すとは限りません。  
  
 このメソッドは、ミューテックスの所有権を要求しません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が空の文字列です。  
  
または 
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスは存在しますが、それを使用するために必要なセキュリティ アクセスがユーザーにありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
  </Members>
</Type>
