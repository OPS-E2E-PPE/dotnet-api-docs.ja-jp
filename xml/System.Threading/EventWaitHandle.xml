<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aca10ae288a8c083d01d07db64b553d5a8e78903" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75116502" /></Metadata><TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="17b09-101">スレッドの同期イベントを表します。</span><span class="sxs-lookup"><span data-stu-id="17b09-101">Represents a thread synchronization event.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17b09-102"><xref:System.Threading.EventWaitHandle> クラスを使用すると、スレッドはシグナル化によって相互に通信できます。</span><span class="sxs-lookup"><span data-stu-id="17b09-102">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling.</span></span> <span data-ttu-id="17b09-103">通常、ブロックされていないスレッドが <xref:System.Threading.EventWaitHandle.Set%2A> メソッドを呼び出して、ブロックされているスレッドの1つ以上を解放するまで、<xref:System.Threading.EventWaitHandle> で1つ以上のスレッドがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="17b09-103">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads.</span></span> <span data-ttu-id="17b09-104">スレッドは、`static` (Visual Basic で`Shared`) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> メソッドを呼び出すことによって、<xref:System.Threading.EventWaitHandle> を通知した後、そのスレッドでブロックできます。</span><span class="sxs-lookup"><span data-stu-id="17b09-104">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="17b09-105"><xref:System.Threading.EventWaitHandle> クラスは、名前付きシステム同期イベントへのアクセスを提供します。</span><span class="sxs-lookup"><span data-stu-id="17b09-105">The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.</span></span>  
  
 <span data-ttu-id="17b09-106">シグナル状態になった <xref:System.Threading.EventWaitHandle> の動作は、リセットモードによって異なります。</span><span class="sxs-lookup"><span data-stu-id="17b09-106">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode.</span></span> <span data-ttu-id="17b09-107"><xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> フラグを使用して作成された <xref:System.Threading.EventWaitHandle> は、単一の待機スレッドを解放した後、シグナル状態になると自動的にリセットされます。</span><span class="sxs-lookup"><span data-stu-id="17b09-107">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="17b09-108"><xref:System.Threading.EventWaitHandle> フラグで作成された <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> は、その <xref:System.Threading.EventWaitHandle.Reset%2A> メソッドが呼び出されるまで、シグナル状態のままです。</span><span class="sxs-lookup"><span data-stu-id="17b09-108">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="17b09-109">自動リセットイベントは、リソースへの排他アクセスを提供します。</span><span class="sxs-lookup"><span data-stu-id="17b09-109">Automatic reset events provide exclusive access to a resource.</span></span> <span data-ttu-id="17b09-110">自動リセット イベントが通知を受けたとき、待機中のスレッドがない場合は、スレッドが待機中になるまでシグナル状態のままです。</span><span class="sxs-lookup"><span data-stu-id="17b09-110">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="17b09-111">イベントはスレッドを解放してすぐにリセットされ、以降のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="17b09-111">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
 <span data-ttu-id="17b09-112">手動リセットイベントはゲートに似ています。</span><span class="sxs-lookup"><span data-stu-id="17b09-112">Manual reset events are like gates.</span></span> <span data-ttu-id="17b09-113">イベントが通知されない場合、そのイベントを待機しているスレッドはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="17b09-113">When the event is not signaled, threads that wait on it will block.</span></span> <span data-ttu-id="17b09-114">イベントがシグナル状態になると、待機中のすべてのスレッドが解放され、その <xref:System.Threading.EventWaitHandle.Reset%2A> メソッドが呼び出されるまで、イベントはシグナル状態のままになります (つまり、後続の待機ではブロックされません)。</span><span class="sxs-lookup"><span data-stu-id="17b09-114">When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="17b09-115">手動リセットイベントは、他のスレッドが処理を続行する前に1つのスレッドがアクティビティを完了する必要がある場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="17b09-115">Manual reset events are useful when one thread must complete an activity before other threads can proceed.</span></span>  
  
 <span data-ttu-id="17b09-116"><xref:System.Threading.EventWaitHandle> オブジェクトは、`static`(Visual Basic の`Shared`) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> および <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> メソッドと共に使用できます。</span><span class="sxs-lookup"><span data-stu-id="17b09-116"><xref:System.Threading.EventWaitHandle> objects can be used with the `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="17b09-117">詳細については、「[同期プリミティブの概要](~/docs/standard/threading/overview-of-synchronization-primitives.md)」の「[スレッドの操作」または「シグナル通知](~/docs/standard/threading/overview-of-synchronization-primitives.md#thread-interaction-or-signaling)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="17b09-117">For more information, see the [Thread interaction, or signaling](~/docs/standard/threading/overview-of-synchronization-primitives.md#thread-interaction-or-signaling) section of the [Overview of synchronization primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md) article.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17b09-118">次のコード例では、<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> メソッドのオーバーロードを使用して、メインスレッドがブロックされたスレッドを通知し、スレッドがタスクを完了するまで待機することができます。</span><span class="sxs-lookup"><span data-stu-id="17b09-118">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="17b09-119">この例では、5つのスレッドを開始し、<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> フラグを使用して作成された <xref:System.Threading.EventWaitHandle> でブロックできるようにします。次に、ユーザーが ENTER キーを押すたびに1つのスレッドを解放します。</span><span class="sxs-lookup"><span data-stu-id="17b09-119">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="17b09-120">この例では、別の5つのスレッドをキューに置いて、<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> フラグを使用して作成された <xref:System.Threading.EventWaitHandle> を使用してすべてを解放します。</span><span class="sxs-lookup"><span data-stu-id="17b09-120">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="17b09-121">この型はスレッド セーフです。</span><span class="sxs-lookup"><span data-stu-id="17b09-121">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17b09-122">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="17b09-122">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="17b09-123">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="17b09-123">Overview of synchronization primitives</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="17b09-124"><see cref="T:System.Threading.EventWaitHandle" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="17b09-124">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="17b09-125">初期状態をシグナル状態に設定する場合は <see langword="true" />。非シグナル状態に設定する場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="17b09-125"><see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="17b09-126">イベントが自動的にリセットされるかまたは手動でリセットされるかを指定する <see cref="T:System.Threading.EventResetMode" /> 値の 1 つ。</span><span class="sxs-lookup"><span data-stu-id="17b09-126">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <summary><span data-ttu-id="17b09-127">待機ハンドルの初期状態をシグナル状態に設定するかどうか、および、待機ハンドルが自動的にリセットされるかまたは手動でリセットされるかを指定して、<see cref="T:System.Threading.EventWaitHandle" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="17b09-127">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17b09-128">イベントの初期状態が非シグナルになっている場合、イベントを待機しているスレッドはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="17b09-128">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="17b09-129">初期状態が通知され、`mode`に <xref:System.Threading.EventResetMode.ManualReset> フラグが指定されている場合、イベントを待機しているスレッドはブロックされません。</span><span class="sxs-lookup"><span data-stu-id="17b09-129">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="17b09-130">初期状態が通知され、`mode` が <xref:System.Threading.EventResetMode.AutoReset>場合は、イベントを待機している最初のスレッドが直ちに解放されます。その後、イベントがリセットされ、後続のスレッドがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="17b09-130">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17b09-131">次のコード例では、<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> メソッドのオーバーロードを使用して、メインスレッドがブロックされたスレッドを通知し、スレッドがタスクを完了するまで待機することができます。</span><span class="sxs-lookup"><span data-stu-id="17b09-131">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="17b09-132">この例では、5つのスレッドを開始し、<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> フラグを使用して作成された <xref:System.Threading.EventWaitHandle> でブロックできるようにします。次に、ユーザーが ENTER キーを押すたびに1つのスレッドを解放します。</span><span class="sxs-lookup"><span data-stu-id="17b09-132">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses ENTER key.</span></span> <span data-ttu-id="17b09-133">この例では、別の5つのスレッドをキューに置いて、<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> フラグを使用して作成された <xref:System.Threading.EventWaitHandle> を使用してすべてを解放します。</span><span class="sxs-lookup"><span data-stu-id="17b09-133">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="17b09-134">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="17b09-134">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="17b09-135">名前の付いたイベントがこの呼び出しの結果として作成された場合に、初期状態をシグナル状態に設定するには <see langword="true" />、非シグナル状態に設定するには <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="17b09-135"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="17b09-136">イベントが自動的にリセットされるかまたは手動でリセットされるかを指定する <see cref="T:System.Threading.EventResetMode" /> 値の 1 つ。</span><span class="sxs-lookup"><span data-stu-id="17b09-136">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="17b09-137">システム全体の同期イベントの名前。</span><span class="sxs-lookup"><span data-stu-id="17b09-137">The name of a system-wide synchronization event.</span></span></param>
        <summary><span data-ttu-id="17b09-138">この呼び出しの結果として待機ハンドルが作成された場合に待機ハンドルの初期状態をシグナル状態に設定するかどうか、待機ハンドルが自動的にリセットされるかまたは手動でリセットされるか、およびシステムの同期イベントの名前を指定して、<see cref="T:System.Threading.EventWaitHandle" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="17b09-138">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17b09-139">`name` が `null` または空の文字列の場合は、ローカル <xref:System.Threading.EventWaitHandle> が作成されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-139">If `name` is `null` or an empty string, a local <xref:System.Threading.EventWaitHandle> is created.</span></span>  
  
 <span data-ttu-id="17b09-140">`name` パラメーターに指定された名前のシステムイベントが既に存在する場合、`initialState` パラメーターは無視されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-140">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="17b09-141">名前付きシステムイベントにこのコンストラクターを使用する場合は、`initialState`の `false` を指定します。</span><span class="sxs-lookup"><span data-stu-id="17b09-141">When using this constructor for named system events, specify `false` for `initialState`.</span></span> <span data-ttu-id="17b09-142">このコンストラクターは、名前付きシステムイベントが作成されたかどうかを判断する方法を提供しないため、名前付きイベントの状態に関する想定を行うことはできません。</span><span class="sxs-lookup"><span data-stu-id="17b09-142">This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</span></span> <span data-ttu-id="17b09-143">名前付きイベントが作成されたかどうかを確認するには、<xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> コンストラクターまたは <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> コンストラクターを使用します。</span><span class="sxs-lookup"><span data-stu-id="17b09-143">To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.</span></span>  
  
 <span data-ttu-id="17b09-144">イベントの初期状態が非シグナルになっている場合、イベントを待機しているスレッドはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="17b09-144">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="17b09-145">初期状態が通知され、`mode`に <xref:System.Threading.EventResetMode.ManualReset> フラグが指定されている場合、イベントを待機しているスレッドはブロックされません。</span><span class="sxs-lookup"><span data-stu-id="17b09-145">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="17b09-146">初期状態が通知され、`mode` が <xref:System.Threading.EventResetMode.AutoReset>場合は、イベントを待機している最初のスレッドが直ちに解放されます。その後、イベントがリセットされ、後続のスレッドがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="17b09-146">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17b09-147">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="17b09-147">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="17b09-148">アクセス制御セキュリティを使用した名前付きイベントが存在しますが、ユーザーに <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="17b09-148">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="17b09-149">名前付きイベントを作成できません。別の型の待機ハンドルに同じ名前が付けられていることが原因として考えられます。</span><span class="sxs-lookup"><span data-stu-id="17b09-149">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="17b09-150"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="17b09-150"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="17b09-151">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="17b09-151">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="17b09-152">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="17b09-152">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="17b09-153">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="17b09-153">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string * bool -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="17b09-154">名前の付いたイベントがこの呼び出しの結果として作成された場合に、初期状態をシグナル状態に設定するには <see langword="true" />、非シグナル状態に設定するには <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="17b09-154"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="17b09-155">イベントが自動的にリセットされるかまたは手動でリセットされるかを指定する <see cref="T:System.Threading.EventResetMode" /> 値の 1 つ。</span><span class="sxs-lookup"><span data-stu-id="17b09-155">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="17b09-156">システム全体の同期イベントの名前。</span><span class="sxs-lookup"><span data-stu-id="17b09-156">The name of a system-wide synchronization event.</span></span></param>
        <param name="createdNew"><span data-ttu-id="17b09-157">このメソッドから制御が戻るときに、ローカル イベントが作成された場合 (<see langword="true" /> が <paramref name="name" /> または空の文字列の場合)、または指定した名前付きシステム イベントが作成された場合は <see langword="null" /> が格納されます。指定した名前付きシステム イベントが既に存在する場合は <see langword="false" /> が格納されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-157">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span></span> <span data-ttu-id="17b09-158">このパラメーターは初期化せずに渡されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-158">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="17b09-159"><see cref="T:System.Threading.EventWaitHandle" /> クラスの新しいインスタンスを初期化し、待機ハンドルがこの呼び出しの結果として作成された場合に最初にシグナル状態になるかどうか、リセットは自動または手動か、システムの同期イベントの名前、呼び出しの後の値で名前の付いたシステム イベントが作成されたかどうかを示すブール値変数を指定します。</span><span class="sxs-lookup"><span data-stu-id="17b09-159">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17b09-160">`name` パラメーターに指定された名前のシステムイベントが既に存在する場合、`initialState` パラメーターは無視されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-160">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="17b09-161">このコンストラクターを呼び出した後、`ref` パラメーター (Visual Basic の`ByRef` パラメーター`createdNew`) に指定された変数の値を使用して、名前付きシステムイベントが既に存在していたか、または作成されたかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="17b09-161">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic)`createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="17b09-162">イベントの初期状態が非シグナルになっている場合、イベントを待機しているスレッドはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="17b09-162">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="17b09-163">初期状態が通知され、`mode`に <xref:System.Threading.EventResetMode.ManualReset> フラグが指定されている場合、イベントを待機しているスレッドはブロックされません。</span><span class="sxs-lookup"><span data-stu-id="17b09-163">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="17b09-164">初期状態が通知され、`mode` が <xref:System.Threading.EventResetMode.AutoReset>場合は、イベントを待機している最初のスレッドが直ちに解放されます。その後、イベントがリセットされ、後続のスレッドがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="17b09-164">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17b09-165">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="17b09-165">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="17b09-166">アクセス制御セキュリティを使用した名前付きイベントが存在しますが、ユーザーに <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="17b09-166">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="17b09-167">名前付きイベントを作成できません。別の型の待機ハンドルに同じ名前が付けられていることが原因として考えられます。</span><span class="sxs-lookup"><span data-stu-id="17b09-167">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="17b09-168"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="17b09-168"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="17b09-169">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="17b09-169">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="17b09-170">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="17b09-170">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="17b09-171">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="17b09-171">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string * bool * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialState"><span data-ttu-id="17b09-172">名前の付いたイベントがこの呼び出しの結果として作成された場合に、初期状態をシグナル状態に設定するには <see langword="true" />、非シグナル状態に設定するには <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="17b09-172"><see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span></span></param>
        <param name="mode"><span data-ttu-id="17b09-173">イベントが自動的にリセットされるかまたは手動でリセットされるかを指定する <see cref="T:System.Threading.EventResetMode" /> 値の 1 つ。</span><span class="sxs-lookup"><span data-stu-id="17b09-173">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span></span></param>
        <param name="name"><span data-ttu-id="17b09-174">システム全体の同期イベントの名前。</span><span class="sxs-lookup"><span data-stu-id="17b09-174">The name of a system-wide synchronization event.</span></span></param>
        <param name="createdNew"><span data-ttu-id="17b09-175">このメソッドから制御が戻るときに、ローカル イベントが作成された場合 (<see langword="true" /> が <paramref name="name" /> または空の文字列の場合)、または指定した名前付きシステム イベントが作成された場合は <see langword="null" /> が格納されます。指定した名前付きシステム イベントが既に存在する場合は <see langword="false" /> が格納されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-175">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span></span> <span data-ttu-id="17b09-176">このパラメーターは初期化せずに渡されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-176">This parameter is passed uninitialized.</span></span></param>
        <param name="eventSecurity"><span data-ttu-id="17b09-177">名前付きシステム イベントに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="17b09-177">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span></span></param>
        <summary><span data-ttu-id="17b09-178"><see cref="T:System.Threading.EventWaitHandle" /> クラスの新しいインスタンスを初期化し、待機ハンドルがこの呼び出しの結果として作成された場合に最初にシグナル状態になるかどうか、リセットは自動または手動か、システムの同期イベントの名前、呼び出しの後の値で名前の付いたシステム イベントが作成されたかどうかを示すブール値変数、および名前の付いたシステム イベントが作成された場合は、そのイベントにアクセス制御セキュリティを適用するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="17b09-178">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17b09-179">このコンストラクターを使用して、名前付きシステムイベントの作成時にアクセス制御セキュリティを適用し、他のコードがそのイベントを制御できないようにします。</span><span class="sxs-lookup"><span data-stu-id="17b09-179">Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</span></span>  
  
 <span data-ttu-id="17b09-180">このコンストラクターは、システムイベントを表す <xref:System.Threading.EventWaitHandle> オブジェクトを初期化します。</span><span class="sxs-lookup"><span data-stu-id="17b09-180">This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event.</span></span> <span data-ttu-id="17b09-181">同じシステムイベントを表す複数の <xref:System.Threading.EventWaitHandle> オブジェクトを作成できます。</span><span class="sxs-lookup"><span data-stu-id="17b09-181">You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.</span></span>  
  
 <span data-ttu-id="17b09-182">システムイベントが存在しない場合は、指定されたアクセス制御セキュリティを使用して作成されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-182">If the system event does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="17b09-183">イベントが存在する場合、指定されたアクセス制御セキュリティは無視されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-183">If the event exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="17b09-184">呼び出し元は、現在のユーザーに対して一部のアクセス権の付与を拒否または失敗した `eventSecurity` 場合でも、新しく作成された <xref:System.Threading.EventWaitHandle> オブジェクトを完全に制御できます。</span><span class="sxs-lookup"><span data-stu-id="17b09-184">The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="17b09-185">ただし、現在のユーザーが、コンストラクターまたは <xref:System.Threading.EventWaitHandle.OpenExisting%2A> のいずれかのメソッドを使用して、同じ名前付きイベントを表す別の <xref:System.Threading.EventWaitHandle> オブジェクトを取得しようとすると、Windows アクセス制御セキュリティが適用されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-185">However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="17b09-186">`name` パラメーターに指定された名前のシステムイベントが既に存在する場合、`initialState` パラメーターは無視されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-186">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="17b09-187">このコンストラクターを呼び出した後、`ref` パラメーター (Visual Basic の`ByRef` パラメーター `createdNew`) に指定された変数の値を使用して、名前付きシステムイベントが既に存在していたか、または作成されたかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="17b09-187">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic) `createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="17b09-188">イベントの初期状態が非シグナルになっている場合、イベントを待機しているスレッドはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="17b09-188">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="17b09-189">初期状態が通知され、`mode`に <xref:System.Threading.EventResetMode.ManualReset> フラグが指定されている場合、イベントを待機しているスレッドはブロックされません。</span><span class="sxs-lookup"><span data-stu-id="17b09-189">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="17b09-190">初期状態が通知され、`mode` が <xref:System.Threading.EventResetMode.AutoReset>場合は、イベントを待機している最初のスレッドが直ちに解放されます。その後、イベントがリセットされ、後続のスレッドがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="17b09-190">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17b09-191">次のコード例では、アクセス制御セキュリティを使用した名前付きシステムイベントのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="17b09-191">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="17b09-192">この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きイベントが存在するかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="17b09-192">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="17b09-193">イベントが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して、イベントを使用する権限が現在のユーザーに拒否され、イベントに対する権限の読み取りと変更の権限が付与されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-193">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="17b09-194">コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="17b09-194">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="17b09-195">例外がキャッチされ、この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> メソッドのオーバーロードを使用して、アクセス許可の読み取りと変更に必要な権限を持つイベントを待機します。</span><span class="sxs-lookup"><span data-stu-id="17b09-195">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="17b09-196">アクセス許可が変更されると、イベントは待機して通知するために必要な権限を使用して開かれます。</span><span class="sxs-lookup"><span data-stu-id="17b09-196">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="17b09-197">コンパイルされた例を3番目のコマンドウィンドウから実行した場合、この例は新しいアクセス許可を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-197">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17b09-198">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="17b09-198">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="17b09-199">アクセス制御セキュリティを使用した名前付きイベントが存在しますが、ユーザーに <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="17b09-199">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="17b09-200">名前付きイベントを作成できません。別の型の待機ハンドルに同じ名前が付けられていることが原因として考えられます。</span><span class="sxs-lookup"><span data-stu-id="17b09-200">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="17b09-201"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="17b09-201"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="17b09-202">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="17b09-202">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="17b09-203">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="17b09-203">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="17b09-204">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="17b09-204">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17b09-205">現在の <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> オブジェクトによって表される名前付きシステム イベントのアクセス制御セキュリティを表す <see cref="T:System.Threading.EventWaitHandle" /> オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="17b09-205">Gets an <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event represented by the current <see cref="T:System.Threading.EventWaitHandle" /> object.</span></span></summary>
        <returns><span data-ttu-id="17b09-206">名前付きシステム イベントのアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="17b09-206">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17b09-207"><xref:System.Threading.EventWaitHandle.GetAccessControl%2A> メソッドは、(ビットごとの OR 演算を使用して組み合わされた) フラグの組み合わせを使用して、アクセス許可 (<xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>、<xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>、および <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>) を検索します。</span><span class="sxs-lookup"><span data-stu-id="17b09-207">The <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="17b09-208">このメソッドを呼び出すには、ユーザーが <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> 権限を持っている必要があります。また、イベントが <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> フラグで開かれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="17b09-208">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17b09-209">次のコード例では、アクセス制御セキュリティを使用した名前付きシステムイベントのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="17b09-209">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="17b09-210">この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きイベントが存在するかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="17b09-210">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="17b09-211">イベントが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して、イベントを使用する権限が現在のユーザーに拒否され、イベントに対する権限の読み取りと変更の権限が付与されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-211">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="17b09-212">コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="17b09-212">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="17b09-213">例外がキャッチされ、この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> メソッドのオーバーロードを使用して、アクセス許可の読み取りと変更に必要な権限を持つイベントを待機します。</span><span class="sxs-lookup"><span data-stu-id="17b09-213">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="17b09-214">アクセス許可が読み取られ、<xref:System.Threading.EventWaitHandle.GetAccessControl%2A> メソッドを使用して変更された後、イベントを待機して通知するために必要な権限を使用して、イベントが開かれます。</span><span class="sxs-lookup"><span data-stu-id="17b09-214">After the permissions have been read, using the <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method, and changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="17b09-215">コンパイルされた例を3番目のコマンドウィンドウから実行した場合、この例は新しいアクセス許可を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-215">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="17b09-216">現在の <see cref="T:System.Threading.EventWaitHandle" /> オブジェクトは名前付きシステム イベントを表していますが、ユーザーには <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="17b09-216">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span></span>  
  
<span data-ttu-id="17b09-217">または</span><span class="sxs-lookup"><span data-stu-id="17b09-217">-or-</span></span> 
<span data-ttu-id="17b09-218">現在の <see cref="T:System.Threading.EventWaitHandle" /> オブジェクトは名前付きシステム イベントを表していますが、<see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" /> で開かれませんでした。</span><span class="sxs-lookup"><span data-stu-id="17b09-218">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="17b09-219">Windows 98 または Windows Millennium Edition はサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="17b09-219">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17b09-220">この <see cref="M:System.Threading.WaitHandle.Close" /> で <see cref="T:System.Threading.EventWaitHandle" /> メソッドが既に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="17b09-220">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="17b09-221">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="17b09-221">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="17b09-222">既に存在する場合は、指定した名前付き同期イベントを開きます。</span><span class="sxs-lookup"><span data-stu-id="17b09-222">Opens a specified named synchronization event, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="17b09-223">開くシステム同期イベントの名前。</span><span class="sxs-lookup"><span data-stu-id="17b09-223">The name of the system synchronization event to open.</span></span></param>
        <summary><span data-ttu-id="17b09-224">既に存在する場合は、指定した名前付き同期イベントを開きます。</span><span class="sxs-lookup"><span data-stu-id="17b09-224">Opens the specified named synchronization event, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="17b09-225">名前付きシステム イベントを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="17b09-225">An  object that represents the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17b09-226"><xref:System.Threading.EventWaitHandle.OpenExisting%2A> メソッドは、指定された名前付きシステムイベントを開こうとします。</span><span class="sxs-lookup"><span data-stu-id="17b09-226">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open the specified named system event.</span></span> <span data-ttu-id="17b09-227">システムイベントが存在しない場合、このメソッドは、システムイベントを作成するのではなく、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="17b09-227">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="17b09-228">システムイベントがまだ存在しない場合に作成するには、`name` パラメーターを持つ <xref:System.Threading.EventWaitHandle.%23ctor%2A> コンストラクターのいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="17b09-228">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="17b09-229">`name` に同じ値を使用するこのメソッドを複数回呼び出すことは、返されるオブジェクトが同じ名前付きシステムイベントを表す場合でも、必ずしも同じ <xref:System.Threading.EventWaitHandle> オブジェクトを返すとは限りません。</span><span class="sxs-lookup"><span data-stu-id="17b09-229">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 <span data-ttu-id="17b09-230">このメソッドオーバーロードは、ビットごとの OR 演算を使用して、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> メソッドオーバーロードを呼び出し、<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> および <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> 権限を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="17b09-230">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="17b09-231"><xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> フラグを指定すると、スレッドは名前付きシステムイベントを待機できます。また、<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> フラグを指定すると、スレッドは <xref:System.Threading.EventWaitHandle.Set%2A> および <xref:System.Threading.EventWaitHandle.Reset%2A> メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="17b09-231">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17b09-232">次のコード例では、アクセス制御セキュリティを使用した名前付きシステムイベントのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="17b09-232">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="17b09-233">この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きイベントが存在するかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="17b09-233">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="17b09-234">イベントが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して、イベントを使用する権限が現在のユーザーに拒否され、イベントに対する権限の読み取りと変更の権限が付与されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-234">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="17b09-235">コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="17b09-235">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="17b09-236">例外がキャッチされ、この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> メソッドのオーバーロードを使用して、アクセス許可の読み取りと変更に必要な権限を持つイベントを待機します。</span><span class="sxs-lookup"><span data-stu-id="17b09-236">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="17b09-237">アクセス許可が変更されると、イベントは待機して通知するために必要な権限を使用して開かれます。</span><span class="sxs-lookup"><span data-stu-id="17b09-237">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="17b09-238">コンパイルされた例を3番目のコマンドウィンドウから実行した場合、この例は新しいアクセス許可を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-238">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="17b09-239"><paramref name="name" /> が空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="17b09-239"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="17b09-240">または</span><span class="sxs-lookup"><span data-stu-id="17b09-240">-or-</span></span> 
 <span data-ttu-id="17b09-241"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="17b09-241"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="17b09-242"><paramref name="name" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="17b09-242"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="17b09-243">名前付きシステム イベントが存在しません。</span><span class="sxs-lookup"><span data-stu-id="17b09-243">The named system event does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17b09-244">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="17b09-244">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="17b09-245">名前付きイベントは存在しますが、それを使用するために必要なセキュリティ アクセスがユーザーにありません。</span><span class="sxs-lookup"><span data-stu-id="17b09-245">The named event exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="17b09-246">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="17b09-246">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="17b09-247">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="17b09-247">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="17b09-248">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="17b09-248">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="17b09-249">開くシステム同期イベントの名前。</span><span class="sxs-lookup"><span data-stu-id="17b09-249">The name of the system synchronization event to open.</span></span></param>
        <param name="rights"><span data-ttu-id="17b09-250">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="17b09-250">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="17b09-251">これが既に存在する場合は、必要なセキュリティ アクセスで指定した名前付き同期イベントを開きます。</span><span class="sxs-lookup"><span data-stu-id="17b09-251">Opens the specified named synchronization event, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="17b09-252">名前付きシステム イベントを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="17b09-252">An object that represents the named system event.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17b09-253">`rights` パラメーターには、スレッドがイベントを待機できるようにするための <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> フラグと、スレッドが <xref:System.Threading.EventWaitHandle.Set%2A> および <xref:System.Threading.EventWaitHandle.Reset%2A> メソッドを呼び出せるようにするための <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> フラグを含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="17b09-253">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="17b09-254"><xref:System.Threading.EventWaitHandle.OpenExisting%2A> メソッドは、既存の名前付きシステムイベントを開こうとします。</span><span class="sxs-lookup"><span data-stu-id="17b09-254">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open an existing named system event.</span></span> <span data-ttu-id="17b09-255">システムイベントが存在しない場合、このメソッドは、システムイベントを作成するのではなく、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="17b09-255">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="17b09-256">システムイベントがまだ存在しない場合に作成するには、`name` パラメーターを持つ <xref:System.Threading.EventWaitHandle.%23ctor%2A> コンストラクターのいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="17b09-256">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="17b09-257">`name` に同じ値を使用するこのメソッドを複数回呼び出すことは、返されるオブジェクトが同じ名前付きシステムイベントを表す場合でも、必ずしも同じ <xref:System.Threading.EventWaitHandle> オブジェクトを返すとは限りません。</span><span class="sxs-lookup"><span data-stu-id="17b09-257">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17b09-258">次のコード例では、アクセス制御セキュリティを使用した名前付きシステムイベントのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="17b09-258">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="17b09-259">この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きイベントが存在するかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="17b09-259">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="17b09-260">イベントが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して、イベントを使用する権限が現在のユーザーに拒否され、イベントに対する権限の読み取りと変更の権限が付与されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-260">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="17b09-261">コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="17b09-261">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="17b09-262">例外がキャッチされ、この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> メソッドのオーバーロードを使用して、アクセス許可の読み取りと変更に必要な権限を持つイベントを待機します。</span><span class="sxs-lookup"><span data-stu-id="17b09-262">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="17b09-263">アクセス許可が変更されると、イベントは待機して通知するために必要な権限を使用して開かれます。</span><span class="sxs-lookup"><span data-stu-id="17b09-263">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="17b09-264">コンパイルされた例を3番目のコマンドウィンドウから実行した場合、この例は新しいアクセス許可を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-264">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="17b09-265"><paramref name="name" /> が空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="17b09-265"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="17b09-266">または</span><span class="sxs-lookup"><span data-stu-id="17b09-266">-or-</span></span> 
 <span data-ttu-id="17b09-267"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="17b09-267"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="17b09-268"><paramref name="name" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="17b09-268"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="17b09-269">名前付きシステム イベントが存在しません。</span><span class="sxs-lookup"><span data-stu-id="17b09-269">The named system event does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17b09-270">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="17b09-270">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="17b09-271">名前付きイベントは存在しますが、必要なセキュリティ アクセスがユーザーにありません。</span><span class="sxs-lookup"><span data-stu-id="17b09-271">The named event exists, but the user does not have the desired security access.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="17b09-272">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="17b09-272">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="17b09-273">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="17b09-273">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="17b09-274">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="17b09-274">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17b09-275">イベントの状態を非シグナル状態に設定し、スレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="17b09-275">Sets the state of the event to nonsignaled, causing threads to block.</span></span></summary>
        <returns><span data-ttu-id="17b09-276">正常に操作できた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="17b09-276"><see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17b09-277">この <see cref="M:System.Threading.WaitHandle.Close" /> で <see cref="T:System.Threading.EventWaitHandle" /> メソッドが既に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="17b09-277">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="17b09-278">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="17b09-278">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17b09-279">イベントの状態をシグナル状態に設定し、待機している 1 つ以上のスレッドが進行できるようにします。</span><span class="sxs-lookup"><span data-stu-id="17b09-279">Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</span></span></summary>
        <returns><span data-ttu-id="17b09-280">正常に操作できた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="17b09-280"><see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17b09-281"><xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (<xref:System.Threading.AutoResetEvent>を含む) の <xref:System.Threading.EventWaitHandle> の場合、<xref:System.Threading.EventWaitHandle.Set%2A> メソッドでは1つのスレッドが解放されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-281">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread.</span></span> <span data-ttu-id="17b09-282">待機中のスレッドがない場合、待機ハンドルは、スレッドが待機を試みるか、<xref:System.Threading.EventWaitHandle.Reset%2A> メソッドが呼び出されるまで、シグナル状態のままになります。</span><span class="sxs-lookup"><span data-stu-id="17b09-282">If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="17b09-283"><xref:System.Threading.EventWaitHandle.Set%2A> メソッドを呼び出すたびに、リセットモードが <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>の <xref:System.Threading.EventWaitHandle> からスレッドが解放される保証はありません。</span><span class="sxs-lookup"><span data-stu-id="17b09-283">There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span></span> <span data-ttu-id="17b09-284">2つの呼び出しが近接していて、スレッドが解放される前に2回目の呼び出しが行われる場合、1つのスレッドのみが解放されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-284">If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</span></span> <span data-ttu-id="17b09-285">2番目の呼び出しが行われなかったかのようになります。</span><span class="sxs-lookup"><span data-stu-id="17b09-285">It is as if the second call did not happen.</span></span> <span data-ttu-id="17b09-286">また、待機中のスレッドがなく、<xref:System.Threading.EventWaitHandle> が既にシグナル状態になっているときに <xref:System.Threading.EventWaitHandle.Set%2A> が呼び出された場合、呼び出しは無効になります。</span><span class="sxs-lookup"><span data-stu-id="17b09-286">Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect.</span></span>  
  
 <span data-ttu-id="17b09-287"><xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (<xref:System.Threading.ManualResetEvent>を含む) の <xref:System.Threading.EventWaitHandle> の場合、<xref:System.Threading.EventWaitHandle.Set%2A> メソッドを呼び出すと、その <xref:System.Threading.EventWaitHandle.Reset%2A> メソッドが呼び出されるまで、待機ハンドルはシグナル状態のままになります。</span><span class="sxs-lookup"><span data-stu-id="17b09-287">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (including <xref:System.Threading.ManualResetEvent>), calling the <xref:System.Threading.EventWaitHandle.Set%2A> method leaves the wait handle in a signaled state until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17b09-288">次のコード例では、<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> メソッドのオーバーロードを使用して、メインスレッドがブロックされたスレッドを通知し、スレッドがタスクを完了するまで待機することができます。</span><span class="sxs-lookup"><span data-stu-id="17b09-288">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="17b09-289">この例では、5つのスレッドを開始し、<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> フラグを使用して作成された <xref:System.Threading.EventWaitHandle> でブロックできるようにします。次に、ユーザーが ENTER キーを押すたびに1つのスレッドを解放します。</span><span class="sxs-lookup"><span data-stu-id="17b09-289">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="17b09-290">この例では、別の5つのスレッドをキューに置いて、<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> フラグを使用して作成された <xref:System.Threading.EventWaitHandle> を使用してすべてを解放します。</span><span class="sxs-lookup"><span data-stu-id="17b09-290">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17b09-291">この <see cref="M:System.Threading.WaitHandle.Close" /> で <see cref="T:System.Threading.EventWaitHandle" /> メソッドが既に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="17b09-291">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="17b09-292">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="17b09-292">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="eventSecurity"><span data-ttu-id="17b09-293">名前付きシステム イベントに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="17b09-293">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span></span></param>
        <summary><span data-ttu-id="17b09-294">名前付きシステム イベントのアクセス制御セキュリティを設定します。</span><span class="sxs-lookup"><span data-stu-id="17b09-294">Sets the access control security for a named system event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17b09-295">このメソッドを呼び出すには、ユーザーが <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> 権限を持っている必要があります。また、イベントが <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> フラグで開かれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="17b09-295">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17b09-296">次のコード例では、アクセス制御セキュリティを使用した名前付きシステムイベントのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="17b09-296">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="17b09-297">この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> メソッドオーバーロードを使用して、名前付きイベントが存在するかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="17b09-297">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="17b09-298">イベントが存在しない場合は、初期所有権とアクセス制御セキュリティを使用して、イベントを使用する権限が現在のユーザーに拒否され、イベントに対する権限の読み取りと変更の権限が付与されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-298">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="17b09-299">コンパイルされた例を2つのコマンドウィンドウから実行した場合、2番目のコピーは <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>の呼び出しでアクセス違反例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="17b09-299">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="17b09-300">例外がキャッチされ、この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> メソッドのオーバーロードを使用して、アクセス許可の読み取りと変更に必要な権限を持つイベントを待機します。</span><span class="sxs-lookup"><span data-stu-id="17b09-300">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="17b09-301">アクセス許可が変更された後、<xref:System.Threading.EventWaitHandle.SetAccessControl%2A> メソッドを使用して、イベントを待機して通知するために必要な権限を使用してイベントが開かれます。</span><span class="sxs-lookup"><span data-stu-id="17b09-301">After the permissions are changed, using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="17b09-302">コンパイルされた例を3番目のコマンドウィンドウから実行した場合、この例は新しいアクセス許可を使用して実行されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-302">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="17b09-303"><paramref name="eventSecurity" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="17b09-303"><paramref name="eventSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="17b09-304">ユーザーに <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="17b09-304">The user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span></span>  
  
<span data-ttu-id="17b09-305">または</span><span class="sxs-lookup"><span data-stu-id="17b09-305">-or-</span></span> 
<span data-ttu-id="17b09-306">イベントが <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" /> で開かれませんでした。</span><span class="sxs-lookup"><span data-stu-id="17b09-306">The event was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="17b09-307">現在の <see cref="T:System.Threading.EventWaitHandle" /> オブジェクトは名前付きシステム イベントを表していません。</span><span class="sxs-lookup"><span data-stu-id="17b09-307">The current <see cref="T:System.Threading.EventWaitHandle" /> object does not represent a named system event.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="17b09-308">この <see cref="M:System.Threading.WaitHandle.Close" /> で <see cref="T:System.Threading.EventWaitHandle" /> メソッドが既に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="17b09-308">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="17b09-309">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="17b09-309">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="17b09-310">既に存在する場合は、指定した名前付き同期イベントを開き操作が成功したかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="17b09-310">Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * EventWaitHandle -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="17b09-311">開くシステム同期イベントの名前。</span><span class="sxs-lookup"><span data-stu-id="17b09-311">The name of the system synchronization event to open.</span></span></param>
        <param name="result"><span data-ttu-id="17b09-312">このメソッドから制御が戻るときに、呼び出しに成功した場合は名前付き同期イベントを表す <see cref="T:System.Threading.EventWaitHandle" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-312">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="17b09-313">このパラメーターは初期化前として処理されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-313">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="17b09-314">既に存在する場合は、指定した名前付き同期イベントを開き操作が成功したかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="17b09-314">Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="17b09-315">名前付きの同期イベントが正常に開かれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="17b09-315"><see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17b09-316">名前付き同期イベントが存在しない場合、このメソッドは作成しません。</span><span class="sxs-lookup"><span data-stu-id="17b09-316">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="17b09-317">システムイベントがまだ存在しない場合に作成するには、`name` パラメーターを持つ <xref:System.Threading.EventWaitHandle.%23ctor%2A> コンストラクターのいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="17b09-317">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="17b09-318">名前付き同期イベントが存在するかどうか不明な場合は、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> メソッドオーバーロードではなく、このメソッドオーバーロードを使用します。これにより、同期イベントが存在しない場合に例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="17b09-318">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="17b09-319">このメソッドオーバーロードは、ビットごとの OR 演算を使用して、<xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> メソッドオーバーロードを呼び出し、<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> および <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> 権限を指定することと同じです。</span><span class="sxs-lookup"><span data-stu-id="17b09-319">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="17b09-320"><xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> フラグを指定すると、スレッドは名前付きシステムイベントを待機できます。また、<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> フラグを指定すると、スレッドは <xref:System.Threading.EventWaitHandle.Set%2A> および <xref:System.Threading.EventWaitHandle.Reset%2A> メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="17b09-320">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="17b09-321">`name` に同じ値を使用するこのメソッドを複数回呼び出すことは、返されるオブジェクトが同じ名前付きシステムイベントを表す場合でも、必ずしも同じ <xref:System.Threading.EventWaitHandle> オブジェクトを返すとは限りません。</span><span class="sxs-lookup"><span data-stu-id="17b09-321">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="17b09-322"><paramref name="name" /> が空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="17b09-322"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="17b09-323">または</span><span class="sxs-lookup"><span data-stu-id="17b09-323">-or-</span></span> 
 <span data-ttu-id="17b09-324"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="17b09-324"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="17b09-325"><paramref name="name" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="17b09-325"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17b09-326">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="17b09-326">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="17b09-327">名前付きイベントは存在しますが、必要なセキュリティ アクセスがユーザーにありません。</span><span class="sxs-lookup"><span data-stu-id="17b09-327">The named event exists, but the user does not have the desired security access.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="17b09-328">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="17b09-328">requires full trust for the immediate caller.</span></span> <span data-ttu-id="17b09-329">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="17b09-329">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights * EventWaitHandle -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="17b09-330">開くシステム同期イベントの名前。</span><span class="sxs-lookup"><span data-stu-id="17b09-330">The name of the system synchronization event to open.</span></span></param>
        <param name="rights"><span data-ttu-id="17b09-331">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="17b09-331">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="17b09-332">このメソッドから制御が戻るときに、呼び出しに成功した場合は名前付き同期イベントを表す <see cref="T:System.Threading.EventWaitHandle" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-332">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="17b09-333">このパラメーターは初期化前として処理されます。</span><span class="sxs-lookup"><span data-stu-id="17b09-333">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="17b09-334">既に存在する場合は、必要なセキュリティ アクセスを使って指定した名前付き同期イベントを開き、操作が成功したかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="17b09-334">Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="17b09-335">名前付きの同期イベントが正常に開かれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="17b09-335"><see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17b09-336">名前付き同期イベントが存在しない場合、このメソッドは作成しません。</span><span class="sxs-lookup"><span data-stu-id="17b09-336">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="17b09-337">システムイベントがまだ存在しない場合に作成するには、`name` パラメーターを持つ <xref:System.Threading.EventWaitHandle.%23ctor%2A> コンストラクターのいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="17b09-337">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="17b09-338">名前付き同期イベントが存在するかどうか不明な場合は、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> メソッドオーバーロードではなく、このメソッドオーバーロードを使用します。これにより、同期イベントが存在しない場合に例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="17b09-338">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="17b09-339">`rights` パラメーターには、スレッドがイベントを待機できるようにするための <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> フラグと、スレッドが <xref:System.Threading.EventWaitHandle.Set%2A> および <xref:System.Threading.EventWaitHandle.Reset%2A> メソッドを呼び出せるようにするための <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> フラグを含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="17b09-339">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="17b09-340">`name` に同じ値を使用するこのメソッドを複数回呼び出すことは、返されるオブジェクトが同じ名前付きシステムイベントを表す場合でも、必ずしも同じ <xref:System.Threading.EventWaitHandle> オブジェクトを返すとは限りません。</span><span class="sxs-lookup"><span data-stu-id="17b09-340">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="17b09-341"><paramref name="name" /> が空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="17b09-341"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="17b09-342">または</span><span class="sxs-lookup"><span data-stu-id="17b09-342">-or-</span></span> 
 <span data-ttu-id="17b09-343"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="17b09-343"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="17b09-344"><paramref name="name" /> は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="17b09-344"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="17b09-345">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="17b09-345">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="17b09-346">名前付きイベントは存在しますが、必要なセキュリティ アクセスがユーザーにありません。</span><span class="sxs-lookup"><span data-stu-id="17b09-346">The named event exists, but the user does not have the desired security access.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="17b09-347">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="17b09-347">requires full trust for the immediate caller.</span></span> <span data-ttu-id="17b09-348">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="17b09-348">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>
