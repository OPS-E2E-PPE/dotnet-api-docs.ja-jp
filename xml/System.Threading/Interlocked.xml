<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d6ce8b1f7570e481cceac6397e202ec9df286b51" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73380766" /></Metadata><TypeSignature Language="C#" Value="public static class Interlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class Interlocked" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked abstract sealed" />
  <TypeSignature Language="F#" Value="type Interlocked = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0">
      <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="55d4a-101">複数のスレッドで共有される変数に分割不可能な操作を提供します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-101">Provides atomic operations for variables that are shared by multiple threads.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-102">このクラスのメソッドは、スレッドが他のスレッドからアクセスできる変数を更新しているとき、または別のプロセッサで同時に2つのスレッドが実行されているときに、スケジューラがコンテキストを切り替えるときに発生する可能性のあるエラーから保護するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-102">The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.</span></span> <span data-ttu-id="55d4a-103">このクラスのメンバーは、例外をスローしません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-103">The members of this class do not throw exceptions.</span></span>  
  
 <span data-ttu-id="55d4a-104"><xref:System.Threading.Interlocked.Increment%2A> メソッドと <xref:System.Threading.Interlocked.Decrement%2A> メソッドは変数をインクリメントまたはデクリメントし、結果の値を1回の操作で格納します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-104">The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation.</span></span> <span data-ttu-id="55d4a-105">ほとんどのコンピューターでは、変数のインクリメントはアトミック操作ではないため、次の手順を実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-105">On most computers, incrementing a variable is not an atomic operation, requiring the following steps:</span></span>  
  
1.  <span data-ttu-id="55d4a-106">インスタンス変数からレジスタに値を読み込みます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-106">Load a value from an instance variable into a register.</span></span>  
  
2.  <span data-ttu-id="55d4a-107">値をインクリメントまたはデクリメントします。</span><span class="sxs-lookup"><span data-stu-id="55d4a-107">Increment or decrement the value.</span></span>  
  
3.  <span data-ttu-id="55d4a-108">インスタンス変数に値を格納します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-108">Store the value in the instance variable.</span></span>  
  
 <span data-ttu-id="55d4a-109"><xref:System.Threading.Interlocked.Increment%2A> と <xref:System.Threading.Interlocked.Decrement%2A>を使用しない場合、最初の2つの手順を実行した後にスレッドを割り込ませることができます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-109">If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps.</span></span> <span data-ttu-id="55d4a-110">その後、別のスレッドが3つの手順をすべて実行できます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-110">Another thread can then execute all three steps.</span></span> <span data-ttu-id="55d4a-111">最初のスレッドが実行を再開すると、インスタンス変数の値が上書きされ、2番目のスレッドによって実行されるインクリメントまたはデクリメントの影響は失われます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-111">When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</span></span>  

 <span data-ttu-id="55d4a-112"><xref:System.Threading.Interlocked.Add%2A> メソッドは、整数値をアトミックに整数変数に追加し、変数の新しい値を返します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-112">The <xref:System.Threading.Interlocked.Add%2A> method atomically adds an integer value to an integer variable and returns the new value of the variable.</span></span>  
  
 <span data-ttu-id="55d4a-113"><xref:System.Threading.Interlocked.Exchange%2A> メソッドは、指定された変数の値をアトミックに交換します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-113">The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables.</span></span> <span data-ttu-id="55d4a-114"><xref:System.Threading.Interlocked.CompareExchange%2A> メソッドは、比較の結果に基づいて2つの値を比較し、変数の1つに3番目の値を格納します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-114">The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</span></span> <span data-ttu-id="55d4a-115">比較操作と交換操作は、分割不可能な操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-115">The compare and exchange operations are performed as an atomic operation.</span></span>  

 <span data-ttu-id="55d4a-116">共有変数への書き込みまたは読み取りアクセスがアトミックであることを確認します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-116">Ensure that any write or read access to a shared variable is atomic.</span></span> <span data-ttu-id="55d4a-117">それ以外の場合、データが破損しているか、読み込まれた値が正しくない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-117">Otherwise, the data might be corrupted or the loaded value might be incorrect.</span></span>    
   
  
## Examples  
 <span data-ttu-id="55d4a-118">次のコード例は、スレッドセーフなリソースロック機構を示しています。</span><span class="sxs-lookup"><span data-stu-id="55d4a-118">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="55d4a-119">この型はスレッド セーフです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-119">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-120">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-120">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-121">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-121">Overview of synchronization primitives</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="55d4a-122">分割不可能な操作として、2 つの整数を加算し、最初の整数を合計で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-122">Adds two integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Add(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Add : int * int -&gt; int" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="55d4a-123">加算する最初の値を含む変数。</span><span class="sxs-lookup"><span data-stu-id="55d4a-123">A variable containing the first value to be added.</span></span> <span data-ttu-id="55d4a-124">2 つの値の合計は、<paramref name="location1" /> に格納されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-124">The sum of the two values is stored in <paramref name="location1" />.</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-125"><paramref name="location1" /> にある整数に加算する値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-125">The value to be added to the integer at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="55d4a-126">分割不可能な操作として、2 つの 32 ビット整数を加算し、最初の整数を合計で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-126">Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="55d4a-127"><paramref name="location1" /> に格納された新しい値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-127">The new value stored at <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-128">このメソッドは、をラップすることによってオーバーフロー状態を処理します。 `location1` の値が <xref:System.Int32.MaxValue?displayProperty=nameWithType>、`value` が1の場合、結果は <xref:System.Int32.MinValue?displayProperty=nameWithType>になります。`value` が2の場合、結果は (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1) になります。などなど。</span><span class="sxs-lookup"><span data-stu-id="55d4a-128">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int32.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="55d4a-129">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-129">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-130"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-130">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-131">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-131">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-132">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-132">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Add(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Add : int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="55d4a-133">加算する最初の値を含む変数。</span><span class="sxs-lookup"><span data-stu-id="55d4a-133">A variable containing the first value to be added.</span></span> <span data-ttu-id="55d4a-134">2 つの値の合計は、<paramref name="location1" /> に格納されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-134">The sum of the two values is stored in <paramref name="location1" />.</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-135"><paramref name="location1" /> にある整数に加算する値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-135">The value to be added to the integer at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="55d4a-136">分割不可能な操作として、2 つの 64 ビット整数を加算し、最初の整数を合計で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-136">Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="55d4a-137"><paramref name="location1" /> に格納された新しい値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-137">The new value stored at <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-138">このメソッドは、をラップすることによってオーバーフロー状態を処理します。 `location1` の値が <xref:System.Int64.MaxValue?displayProperty=nameWithType>、`value` が1の場合、結果は <xref:System.Int64.MinValue?displayProperty=nameWithType>になります。`value` が2の場合、結果は (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1) になります。などなど。</span><span class="sxs-lookup"><span data-stu-id="55d4a-138">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int64.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="55d4a-139">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-139">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-140"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-140">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-141">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-141">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-142">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-142">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="55d4a-143">2 つの値が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-143">Compares two values for equality and, if they are equal, replaces the first value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Double, value As Double, comparand As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CompareExchange(double % location1, double value, double comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : double * double * double -&gt; double" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.Double" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="55d4a-144">値を <paramref name="comparand" /> と比較し、場合によっては置き換える比較先。</span><span class="sxs-lookup"><span data-stu-id="55d4a-144">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-145">比較した結果が等しい場合に比較先の値を置き換える値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-145">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="55d4a-146"><paramref name="location1" /> にある値と比較する値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-146">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="55d4a-147">2 つの倍精度浮動小数点数が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-147">Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="55d4a-148"><paramref name="location1" /> の元の値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-148">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-149">`comparand` と `location1` の値が等しい場合、`value` は `location1`に格納されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-149">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="55d4a-150">それ以外の場合は演算が実行されません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-150">Otherwise, no operation is performed.</span></span> <span data-ttu-id="55d4a-151">比較操作と交換操作は、分割不可能な操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-151">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="55d4a-152"><xref:System.Threading.Interlocked.CompareExchange%2A> の戻り値は、交換が行われているかどうかにかかわらず、`location1`の元の値です。</span><span class="sxs-lookup"><span data-stu-id="55d4a-152">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="55d4a-153">次のコード例は、<xref:System.Double> 値の累計を累積したスレッドセーフなメソッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="55d4a-153">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Double> values.</span></span> <span data-ttu-id="55d4a-154">スレッドセーフなメソッドと通常の加算を使用して、2つのスレッドが一連の <xref:System.Double> 値を追加すると、スレッドが完了すると合計が比較されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-154">Two threads add a series of <xref:System.Double> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="55d4a-155">デュアルプロセッサコンピューターでは、合計に大きな違いがあります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-155">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="55d4a-156">スレッドセーフなメソッドでは、実行中の合計の初期値が保存されます。その後、<xref:System.Threading.Interlocked.CompareExchange%2A> メソッドを使用して、新しく計算された合計と古い合計を交換します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-156">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="55d4a-157">戻り値が、実行中の合計の保存値と等しくない場合は、その間に別のスレッドによって合計が更新されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-157">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="55d4a-158">その場合は、実行中の合計を更新しようとする必要があります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-158">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-159"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-159">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-160">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-160">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-161">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-161">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareExchange(int % location1, int value, int comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : int * int * int -&gt; int" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="55d4a-162">値を <paramref name="comparand" /> と比較し、場合によっては置き換える比較先。</span><span class="sxs-lookup"><span data-stu-id="55d4a-162">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-163">比較した結果が等しい場合に比較先の値を置き換える値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-163">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="55d4a-164"><paramref name="location1" /> にある値と比較する値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-164">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="55d4a-165">2 つの 32 ビット符号付き整数が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-165">Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="55d4a-166"><paramref name="location1" /> の元の値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-166">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-167">`comparand` と `location1` の値が等しい場合、`value` は `location1`に格納されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-167">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="55d4a-168">それ以外の場合は演算が実行されません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-168">Otherwise, no operation is performed.</span></span> <span data-ttu-id="55d4a-169">比較操作と交換操作は、分割不可能な操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-169">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="55d4a-170"><xref:System.Threading.Interlocked.CompareExchange%2A> の戻り値は、交換が行われているかどうかにかかわらず、`location1`の元の値です。</span><span class="sxs-lookup"><span data-stu-id="55d4a-170">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="55d4a-171">次のコード例は、実行中の合計を累積したスレッドセーフなメソッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="55d4a-171">The following code example demonstrates a thread-safe method that accumulates a running total.</span></span> <span data-ttu-id="55d4a-172">実行中の合計の初期値が保存されます。その後、<xref:System.Threading.Interlocked.CompareExchange%2A> メソッドを使用して、新しく計算された合計と古い合計を交換します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-172">The initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="55d4a-173">戻り値が、実行中の合計の保存値と等しくない場合は、その間に別のスレッドによって合計が更新されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-173">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="55d4a-174">その場合は、実行中の合計を更新しようとする必要があります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-174">In that case, the attempt to update the running total must be repeated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="55d4a-175">.NET Framework のバージョン2.0 で導入された <xref:System.Threading.Interlocked.Add%2A> メソッドを使用すると、整数のスレッドセーフな実行合計をより簡単に蓄積できます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-175">The <xref:System.Threading.Interlocked.Add%2A> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-176"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-176">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-177">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-177">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-178">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-178">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Long, value As Long, comparand As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CompareExchange(long % location1, long value, long comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : int64 * int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.Int64" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="55d4a-179">値を <paramref name="comparand" /> と比較し、場合によっては置き換える比較先。</span><span class="sxs-lookup"><span data-stu-id="55d4a-179">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-180">比較した結果が等しい場合に比較先の値を置き換える値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-180">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="55d4a-181"><paramref name="location1" /> にある値と比較する値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-181">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="55d4a-182">2 つの 64 ビット符号付き整数が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-182">Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="55d4a-183"><paramref name="location1" /> の元の値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-183">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-184">`comparand` と `location1` の値が等しい場合、`value` は `location1`に格納されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-184">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="55d4a-185">それ以外の場合は演算が実行されません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-185">Otherwise, no operation is performed.</span></span> <span data-ttu-id="55d4a-186">比較操作と交換操作は、分割不可能な操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-186">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="55d4a-187"><xref:System.Threading.Interlocked.CompareExchange%2A> の戻り値は、交換が行われているかどうかにかかわらず、`location1`の元の値です。</span><span class="sxs-lookup"><span data-stu-id="55d4a-187">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-188"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-188">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-189">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-189">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-190">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-190">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CompareExchange(IntPtr % location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : nativeint * nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="System.IntPtr" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="55d4a-191">値を <paramref name="comparand" /> の値と比較し、場合によっては <paramref name="value" /> によって置き換える、比較先の <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="55d4a-191">The destination <see cref="T:System.IntPtr" />, whose value is compared with the value of <paramref name="comparand" /> and possibly replaced by <paramref name="value" />.</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-192">比較した結果が等しい場合に比較先の値を置き換える <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="55d4a-192">The <see cref="T:System.IntPtr" /> that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="55d4a-193"><paramref name="location1" /> にある値と比較する <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="55d4a-193">The <see cref="T:System.IntPtr" /> that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="55d4a-194">2 つのプラットフォーム固有のハンドルまたはポインターが等しいかどうかを比較します。等しい場合は、最初の 1 つを置き換えます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-194">Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</span></span></summary>
        <returns><span data-ttu-id="55d4a-195"><paramref name="location1" /> の元の値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-195">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-196">`comparand` と `location1` の値が等しい場合、`value` は `location1`に格納されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-196">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="55d4a-197">それ以外の場合は演算が実行されません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-197">Otherwise, no operation is performed.</span></span> <span data-ttu-id="55d4a-198">比較操作と交換操作は、分割不可能な操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-198">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="55d4a-199">このメソッドの戻り値は、交換が行われているかどうかにかかわらず、`location1`の元の値です。</span><span class="sxs-lookup"><span data-stu-id="55d4a-199">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="55d4a-200"><xref:System.IntPtr> はプラットフォーム固有の型です。</span><span class="sxs-lookup"><span data-stu-id="55d4a-200"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-201"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-201">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-202">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-202">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-203">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-203">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Object, value As Object, comparand As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CompareExchange(System::Object ^ % location1, System::Object ^ value, System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : obj * obj * obj -&gt; obj" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="55d4a-204">参照によって <paramref name="comparand" /> と比較し、場合によっては置き換える比較先のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="55d4a-204">The destination object that is compared by reference with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-205">参照の比較の結果が等しい場合に比較先のオブジェクトを置き換えるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="55d4a-205">The object that replaces the destination object if the reference comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="55d4a-206"><paramref name="location1" /> にあるオブジェクトと、参照によって比較されるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="55d4a-206">The object that is compared by reference to the object at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="55d4a-207">2 つのオブジェクトの参照が等値であるかどうかを比較します。等しい場合は、最初のオブジェクトを置き換えます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-207">Compares two objects for reference equality and, if they are equal, replaces the first object.</span></span></summary>
        <returns><span data-ttu-id="55d4a-208"><paramref name="location1" /> の元の値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-208">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> <span data-ttu-id="55d4a-209">.NET Framework 2.0 より、<xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> メソッド オーバーロードから参照型に対してタイプ セーフの代替が提供されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-209">Beginning with .NET Framework 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span> <span data-ttu-id="55d4a-210">このオーバーロードの代わりに呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="55d4a-210">We recommend that you call it instead of this overload.</span></span>

<span data-ttu-id="55d4a-211">`comparand` と `location1` 内のオブジェクトが参照によって等しい場合、`value` は `location1`に格納されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-211">If `comparand` and the object in `location1` are equal by reference, then `value` is stored in `location1`.</span></span> <span data-ttu-id="55d4a-212">それ以外の場合は演算が実行されません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-212">Otherwise, no operation is performed.</span></span> <span data-ttu-id="55d4a-213">比較操作と交換操作は、分割不可能な操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-213">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="55d4a-214"><xref:System.Threading.Interlocked.CompareExchange%2A> の戻り値は、交換が行われているかどうかにかかわらず、`location1`の元の値です。</span><span class="sxs-lookup"><span data-stu-id="55d4a-214">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  

> [!NOTE]
>  <span data-ttu-id="55d4a-215">オブジェクトは、値の等価性ではなく、参照の等価性が比較されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-215">The objects are compared for reference equality rather than value equality.</span></span> <span data-ttu-id="55d4a-216">その結果、同じ値の型の2つのボックス化されたインスタンス (たとえば、整数 3) は常に等しくないように見え、操作は実行されません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-216">As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal and no operation is performed.</span></span> <span data-ttu-id="55d4a-217">値型では、このオーバーロードを使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="55d4a-217">Do not use this overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="55d4a-218"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-218">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-219">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-219">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-220">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-220">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Single, value As Single, comparand As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CompareExchange(float % location1, float value, float comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : single * single * single -&gt; single" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="55d4a-221">値を <paramref name="comparand" /> と比較し、場合によっては置き換える比較先。</span><span class="sxs-lookup"><span data-stu-id="55d4a-221">The destination, whose value is compared with <paramref name="comparand" /> and possibly replaced.</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-222">比較した結果が等しい場合に比較先の値を置き換える値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-222">The value that replaces the destination value if the comparison results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="55d4a-223"><paramref name="location1" /> にある値と比較する値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-223">The value that is compared to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="55d4a-224">2 つの単精度浮動小数点数が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-224">Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</span></span></summary>
        <returns><span data-ttu-id="55d4a-225"><paramref name="location1" /> の元の値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-225">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-226">`comparand` と `location1` の値が等しい場合、`value` は `location1`に格納されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-226">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="55d4a-227">それ以外の場合は演算が実行されません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-227">Otherwise, no operation is performed.</span></span> <span data-ttu-id="55d4a-228">比較操作と交換操作は、分割不可能な操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-228">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="55d4a-229"><xref:System.Threading.Interlocked.CompareExchange%2A> の戻り値は、交換が行われているかどうかにかかわらず、`location1`の元の値です。</span><span class="sxs-lookup"><span data-stu-id="55d4a-229">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="55d4a-230">次のコード例は、<xref:System.Single> 値の累計を累積したスレッドセーフなメソッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="55d4a-230">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Single> values.</span></span> <span data-ttu-id="55d4a-231">スレッドセーフなメソッドと通常の加算を使用して、2つのスレッドが一連の <xref:System.Single> 値を追加すると、スレッドが完了すると合計が比較されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-231">Two threads add a series of <xref:System.Single> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="55d4a-232">デュアルプロセッサコンピューターでは、合計に大きな違いがあります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-232">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="55d4a-233">スレッドセーフなメソッドでは、実行中の合計の初期値が保存されます。その後、<xref:System.Threading.Interlocked.CompareExchange%2A> メソッドを使用して、新しく計算された合計と古い合計を交換します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-233">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="55d4a-234">戻り値が、実行中の合計の保存値と等しくない場合は、その間に別のスレッドによって合計が更新されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-234">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="55d4a-235">その場合は、実行中の合計を更新しようとする必要があります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-235">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-236"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-236">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-237">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-237">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-238">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-238">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange(Of T As Class) (ByRef location1 As T, value As T, comparand As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T CompareExchange(T % location1, T value, T comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange : 'T * 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparand" Type="T" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="55d4a-239"><paramref name="location1" />、<paramref name="value" />、および <paramref name="comparand" /> に使用する型。</span><span class="sxs-lookup"><span data-stu-id="55d4a-239">The type to be used for <paramref name="location1" />, <paramref name="value" />, and <paramref name="comparand" />.</span></span> <span data-ttu-id="55d4a-240">この型は、参照型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-240">This type must be a reference type.</span></span></typeparam>
        <param name="location1"><span data-ttu-id="55d4a-241">参照によって値を <paramref name="comparand" /> と比較し、場合によっては置き換える比較先。</span><span class="sxs-lookup"><span data-stu-id="55d4a-241">The destination, whose value is compared by reference with <paramref name="comparand" /> and possibly replaced.</span></span> <span data-ttu-id="55d4a-242">これは参照パラメーターです (C# では <see langword="ref" />、Visual Basic では <see langword="ByRef" />)。</span><span class="sxs-lookup"><span data-stu-id="55d4a-242">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-243">参照によって比較した結果が等しい場合に比較先の値を置き換える値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-243">The value that replaces the destination value if the comparison by reference results in equality.</span></span></param>
        <param name="comparand"><span data-ttu-id="55d4a-244"><paramref name="location1" /> にある値と参照によって比較される値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-244">The value that is compared by reference to the value at <paramref name="location1" />.</span></span></param>
        <summary><span data-ttu-id="55d4a-245">指定した参照型 <paramref name="T" /> の 2 つのインスタンスの参照が等しいかどうかを比較します。等しい場合は、最初の 1 つを置き換えます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-245">Compares two instances of the specified reference type <paramref name="T" /> for reference equality and, if they are equal, replaces the first one.</span></span></summary>
        <returns><span data-ttu-id="55d4a-246"><paramref name="location1" /> の元の値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-246">The original value in <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-247">`comparand` と `location1` の値が参照によって等しい場合、`value` は `location1`に格納されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-247">If `comparand` and the value in `location1` are equal by reference, then `value` is stored in `location1`.</span></span> <span data-ttu-id="55d4a-248">それ以外の場合は演算が実行されません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-248">Otherwise, no operation is performed.</span></span> <span data-ttu-id="55d4a-249">比較と交換は、分割不可能な操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-249">The comparison and the exchange are performed as an atomic operation.</span></span> <span data-ttu-id="55d4a-250">このメソッドの戻り値は、交換が行われているかどうかにかかわらず、`location1`の元の値です。</span><span class="sxs-lookup"><span data-stu-id="55d4a-250">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="55d4a-251">このメソッドは、参照型のみをサポートします。</span><span class="sxs-lookup"><span data-stu-id="55d4a-251">This method only supports reference types.</span></span> <span data-ttu-id="55d4a-252">値型 <xref:System.Int32>、<xref:System.Int64>、<xref:System.IntPtr>、<xref:System.Single>、および <xref:System.Double>の <xref:System.Threading.Interlocked.CompareExchange%2A> メソッドのオーバーロードがありますが、その他の値型はサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-252">There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="55d4a-253">後者では、変換先のオブジェクトに遅延バインディングでアクセスする必要があるため、このメソッドのオーバーロードは <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> メソッドのオーバーロードに適しています。</span><span class="sxs-lookup"><span data-stu-id="55d4a-253">This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-254"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-254">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="55d4a-255">分割不可能な操作として、指定した変数をデクリメントし、結果を格納します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-255">Decrements a specified variable and stores the result, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Decrement(int % location);" />
      <MemberSignature Language="F#" Value="static member Decrement : int -&gt; int" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="55d4a-256">値がデクリメントされる変数。</span><span class="sxs-lookup"><span data-stu-id="55d4a-256">The variable whose value is to be decremented.</span></span></param>
        <summary><span data-ttu-id="55d4a-257">分割不可能な操作として、指定した変数をデクリメントし、結果を格納します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-257">Decrements a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="55d4a-258">デクリメントされた値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-258">The decremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-259">このメソッドは、をラップすることによってオーバーフロー状態を処理します。 `location` = <xref:System.Int32.MinValue?displayProperty=nameWithType>、`location`-1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="55d4a-259">This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="55d4a-260">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-260">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="55d4a-261">次の例では、中間値を使用して1000の乱数を生成するために、0 ~ 1000 の範囲の乱数を指定する必要があるかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-261">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="55d4a-262">中間値の数を追跡するために、変数 `midpointCount`は、ランダム数値ジェネレーターが中間値を返すたびに1000に設定され、デクリメントされます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-262">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value.</span></span> <span data-ttu-id="55d4a-263">3つのスレッドが乱数を生成するため、<xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> メソッドを呼び出して、複数のスレッドが同時に `midpointCount` 更新しないようにします。</span><span class="sxs-lookup"><span data-stu-id="55d4a-263">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="55d4a-264">また、ランダムな数値ジェネレーターを保護するためにロックが使用されています。また、<xref:System.Threading.CountdownEvent> オブジェクトを使用して、`Main` メソッドが3つのスレッドの前に実行を終了しないようにしています。</span><span class="sxs-lookup"><span data-stu-id="55d4a-264">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 <span data-ttu-id="55d4a-265">次の例は前の例と似ていますが、スレッドプロシージャの代わりに <xref:System.Threading.Tasks.Task> クラスを使用して、5万のランダムな中間整数を生成する点が異なります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-265">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="55d4a-266">この例では、ラムダ式によって `GenerateNumbers` のスレッドプロシージャが置き換えられ、<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> メソッドを呼び出すと、<xref:System.Threading.CountdownEvent> オブジェクトが不要になります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-266">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="55d4a-267"><paramref name="location" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-267">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-268">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-268">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-269">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-269">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Decrement(long % location);" />
      <MemberSignature Language="F#" Value="static member Decrement : int64 -&gt; int64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="55d4a-270">値がデクリメントされる変数。</span><span class="sxs-lookup"><span data-stu-id="55d4a-270">The variable whose value is to be decremented.</span></span></param>
        <summary><span data-ttu-id="55d4a-271">分割不可能な操作として、指定した変数をデクリメントしてその結果を格納します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-271">Decrements the specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="55d4a-272">デクリメントされた値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-272">The decremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-273">このメソッドは、をラップすることによってオーバーフロー状態を処理します。 `location` = <xref:System.Int64.MinValue?displayProperty=nameWithType>、`location`-1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="55d4a-273">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="55d4a-274">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-274">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="55d4a-275"><paramref name="location" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-275">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-276">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-276">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-277">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-277">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="55d4a-278">分割不可能な操作として指定した値を変数として設定します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-278">Sets a variable to a specified value as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Double, value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exchange(double % location1, double value);" />
      <MemberSignature Language="F#" Value="static member Exchange : double * double -&gt; double" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="55d4a-279">指定した値に設定する変数。</span><span class="sxs-lookup"><span data-stu-id="55d4a-279">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-280"><paramref name="location1" /> パラメーターに設定される値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-280">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="55d4a-281">分割不可能な操作として、指定した値を倍精度浮動小数点数として設定し、元の値を返します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-281">Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="55d4a-282"><paramref name="location1" /> の元の値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-282">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-283"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-283">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-284">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-284">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-285">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-285">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Exchange(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Exchange : int * int -&gt; int" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="55d4a-286">指定した値に設定する変数。</span><span class="sxs-lookup"><span data-stu-id="55d4a-286">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-287"><paramref name="location1" /> パラメーターに設定される値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-287">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="55d4a-288">分割不可能な操作として、指定した値を 32 ビット符号付き整数として設定し、元の値を返します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-288">Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="55d4a-289"><paramref name="location1" /> の元の値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-289">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="55d4a-290">次のコード例は、スレッドセーフなリソースロック機構を示しています。</span><span class="sxs-lookup"><span data-stu-id="55d4a-290">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="55d4a-291"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-291">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-292">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-292">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-293">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-293">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Exchange(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Exchange : int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="55d4a-294">指定した値に設定する変数。</span><span class="sxs-lookup"><span data-stu-id="55d4a-294">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-295"><paramref name="location1" /> パラメーターに設定される値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-295">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="55d4a-296">分割不可能な操作として、指定した値を 64 ビット符号付き整数として設定し、元の値を返します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-296">Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="55d4a-297"><paramref name="location1" /> の元の値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-297">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-298"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-298">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-299">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-299">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-300">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-300">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As IntPtr, value As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Exchange(IntPtr % location1, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member Exchange : nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="55d4a-301">指定した値に設定する変数。</span><span class="sxs-lookup"><span data-stu-id="55d4a-301">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-302"><paramref name="location1" /> パラメーターに設定される値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-302">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="55d4a-303">分割不可能な操作として、プラットフォーム固有のハンドルまたはポインターに指定した値を設定し、元の値を返します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-303">Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="55d4a-304"><paramref name="location1" /> の元の値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-304">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-305"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-305">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-306">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-306">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-307">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-307">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Object, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Exchange(System::Object ^ % location1, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Exchange : obj * obj -&gt; obj" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="55d4a-308">指定した値に設定する変数。</span><span class="sxs-lookup"><span data-stu-id="55d4a-308">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-309"><paramref name="location1" /> パラメーターに設定される値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-309">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="55d4a-310">分割不可能な操作として、指定した値をオブジェクトとして設定し、元のオブジェクトへの参照を返します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-310">Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="55d4a-311"><paramref name="location1" /> の元の値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-311">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> <span data-ttu-id="55d4a-312">.NET Framework 2.0 より、<xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> メソッド オーバーロードから参照型に対してタイプ セーフの代替が提供されます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-312">Beginning with .NET Framework 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span> <span data-ttu-id="55d4a-313">このオーバーロードの代わりに呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="55d4a-313">We recommend that you call it instead of this overload.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="55d4a-314"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-314">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-315">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-315">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-316">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-316">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Single, value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exchange(float % location1, float value);" />
      <MemberSignature Language="F#" Value="static member Exchange : single * single -&gt; single" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1"><span data-ttu-id="55d4a-317">指定した値に設定する変数。</span><span class="sxs-lookup"><span data-stu-id="55d4a-317">The variable to set to the specified value.</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-318"><paramref name="location1" /> パラメーターに設定される値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-318">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="55d4a-319">分割不可能な操作として、指定した値を単精度浮動小数点数として設定し、元の値を返します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-319">Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="55d4a-320"><paramref name="location1" /> の元の値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-320">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-321"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-321">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-322">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-322">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-323">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-323">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange(Of T As Class) (ByRef location1 As T, value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T Exchange(T % location1, T value);" />
      <MemberSignature Language="F#" Value="static member Exchange : 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="55d4a-324"><paramref name="location1" /> および <paramref name="value" /> に使用する型。</span><span class="sxs-lookup"><span data-stu-id="55d4a-324">The type to be used for <paramref name="location1" /> and <paramref name="value" />.</span></span> <span data-ttu-id="55d4a-325">この型は、参照型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-325">This type must be a reference type.</span></span></typeparam>
        <param name="location1"><span data-ttu-id="55d4a-326">指定した値に設定する変数。</span><span class="sxs-lookup"><span data-stu-id="55d4a-326">The variable to set to the specified value.</span></span> <span data-ttu-id="55d4a-327">これは参照パラメーターです (C# では <see langword="ref" />、Visual Basic では <see langword="ByRef" />)。</span><span class="sxs-lookup"><span data-stu-id="55d4a-327">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span></span></param>
        <param name="value"><span data-ttu-id="55d4a-328"><paramref name="location1" /> パラメーターに設定される値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-328">The value to which the <paramref name="location1" /> parameter is set.</span></span></param>
        <summary><span data-ttu-id="55d4a-329">分割不可能な操作として、指定した型 <paramref name="T" /> の変数に指定した値を設定し、元の値を返します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-329">Sets a variable of the specified type <paramref name="T" /> to a specified value and returns the original value, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="55d4a-330"><paramref name="location1" /> の元の値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-330">The original value of <paramref name="location1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-331">このメソッドは、参照型のみをサポートします。</span><span class="sxs-lookup"><span data-stu-id="55d4a-331">This method only supports reference types.</span></span> <span data-ttu-id="55d4a-332"><xref:System.Int32>、<xref:System.Int64>、<xref:System.IntPtr>、<xref:System.Single>、および <xref:System.Double> 値型の <xref:System.Threading.Interlocked.Exchange%2A> メソッドのオーバーロードがありますが、その他の値型はサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-332">There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="55d4a-333">このメソッドのオーバーロードは、<xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> メソッドのオーバーロードに適しています。後者では、変換先のオブジェクトへの遅延バインディングアクセスが必要になるためです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-333">This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object .</span></span>  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-334"><paramref name="location1" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-334">The address of <paramref name="location1" /> is a null pointer.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="55d4a-335">分割不可能な操作として、指定した変数をインクリメントし、結果を格納します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-335">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Increment(int % location);" />
      <MemberSignature Language="F#" Value="static member Increment : int -&gt; int" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="55d4a-336">値がインクリメントされる変数。</span><span class="sxs-lookup"><span data-stu-id="55d4a-336">The variable whose value is to be incremented.</span></span></param>
        <summary><span data-ttu-id="55d4a-337">分割不可能な操作として、指定した変数をインクリメントし、結果を格納します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-337">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="55d4a-338">インクリメントされた値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-338">The incremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-339">このメソッドは、をラップすることによってオーバーフロー状態を処理します。 `location` = <xref:System.Int32.MaxValue?displayProperty=nameWithType>、`location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="55d4a-339">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="55d4a-340">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-340">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="55d4a-341">次の例では、中間値を使用して1000の乱数を生成するために、0 ~ 1000 の範囲の乱数を指定する必要があるかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-341">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="55d4a-342">中間値の数を追跡するには、変数 `midpointCount`を0に設定し、乱数ジェネレーターが1万に達するまで中間値を返すたびにインクリメントします。</span><span class="sxs-lookup"><span data-stu-id="55d4a-342">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000.</span></span> <span data-ttu-id="55d4a-343">3つのスレッドが乱数を生成するため、<xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> メソッドを呼び出して、複数のスレッドが同時に `midpointCount` 更新しないようにします。</span><span class="sxs-lookup"><span data-stu-id="55d4a-343">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="55d4a-344">また、ランダムな数値ジェネレーターを保護するためにロックが使用されています。また、<xref:System.Threading.CountdownEvent> オブジェクトを使用して、`Main` メソッドが3つのスレッドの前に実行を終了しないようにしています。</span><span class="sxs-lookup"><span data-stu-id="55d4a-344">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 <span data-ttu-id="55d4a-345">次の例は前の例と似ていますが、スレッドプロシージャの代わりに <xref:System.Threading.Tasks.Task> クラスを使用して、5万のランダムな中間整数を生成する点が異なります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-345">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="55d4a-346">この例では、ラムダ式によって `GenerateNumbers` のスレッドプロシージャが置き換えられ、<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> メソッドを呼び出すと、<xref:System.Threading.CountdownEvent> オブジェクトが不要になります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-346">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-347"><paramref name="location" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-347">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-348">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-348">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-349">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-349">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Increment(long % location);" />
      <MemberSignature Language="F#" Value="static member Increment : int64 -&gt; int64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="55d4a-350">値がインクリメントされる変数。</span><span class="sxs-lookup"><span data-stu-id="55d4a-350">The variable whose value is to be incremented.</span></span></param>
        <summary><span data-ttu-id="55d4a-351">分割不可能な操作として、指定した変数をインクリメントし、結果を格納します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-351">Increments a specified variable and stores the result, as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="55d4a-352">インクリメントされた値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-352">The incremented value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-353">このメソッドは、をラップすることによってオーバーフロー状態を処理します。 `location` = <xref:System.Int64.MaxValue?displayProperty=nameWithType>、`location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="55d4a-353">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="55d4a-354">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-354">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="55d4a-355"><paramref name="location" /> のアドレスは null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-355">The address of <paramref name="location" /> is a null pointer.</span></span></exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-356">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-356">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-357">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-357">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="55d4a-358">メモリ アクセスを次のように同期します。現在のスレッドを実行するプロセッサは、<see cref="M:System.Threading.Interlocked.MemoryBarrier" /> を呼び出す前のメモリ アクセスを <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> の呼び出し後のメモリ アクセスより後に実行するように命令を並べ替えることはできません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-358">Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-359">このメソッドは、便宜上、[!INCLUDE[net_v45](~/includes/net-v45-md.md)] の <xref:System.Threading.Interlocked> クラスに追加されました。これは、<xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> メソッドのラッパーです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-359">This method was added to the <xref:System.Threading.Interlocked> class in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] as a convenience; it's a wrapper for the <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="55d4a-360"><xref:System.Threading.Interlocked.MemoryBarrier%2A> は、メモリの順序が脆弱なマルチプロセッサシステム (たとえば、複数の Intel Itanium プロセッサを使用するシステム) でのみ必要です。</span><span class="sxs-lookup"><span data-stu-id="55d4a-360"><xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="55d4a-361">ほとんどの場合、 C# `lock` ステートメント、Visual Basic `SyncLock` ステートメント、または <xref:System.Threading.Monitor> クラスを使用すると、簡単にデータを同期できます。</span><span class="sxs-lookup"><span data-stu-id="55d4a-361">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrierProcessWide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrierProcessWide();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrierProcessWide : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrierProcessWide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="55d4a-362">すべての CPU からの読み取りと書き込みがバリアを超えて移動できるように、プロセス全体のメモリ バリアを提供します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-362">Provides a process-wide memory barrier that ensures that reads and writes from any CPU cannot move across the barrier.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="55d4a-363">`MemoryBarrierProcessWide` メソッドは、次のように "normal" <xref:System.Threading.Interlocked.MemoryBarrier%2A> メソッドとは異なります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-363">The `MemoryBarrierProcessWide` method differs from the "normal" <xref:System.Threading.Interlocked.MemoryBarrier%2A> method as follows:</span></span>

- <span data-ttu-id="55d4a-364">通常のメモリバリアでは、現在の CPU からの読み取りと書き込みがバリアをまたいで移動できないようにします。</span><span class="sxs-lookup"><span data-stu-id="55d4a-364">The normal memory barrier ensures that the reads and writes from the current CPU can't move across the barrier.</span></span> <span data-ttu-id="55d4a-365">プロセス全体のメモリバリアによって、プロセスで使用されている任意の CPU からの読み取りまたは書き込みをバリアで移動できないようにします。</span><span class="sxs-lookup"><span data-stu-id="55d4a-365">The process-wide memory barrier ensures that any read or write from any CPU being used in the process can't move across the barrier.</span></span>

- <span data-ttu-id="55d4a-366">通常のメモリバリアは、データにアクセスする*すべて*のスレッドがバリアを使用する場合に、適切な共有アクセスを可能にします。</span><span class="sxs-lookup"><span data-stu-id="55d4a-366">The normal memory barrier allows reasonable shared access if *every* thread accessing the data uses barriers.</span></span> <span data-ttu-id="55d4a-367">プロセス全体のメモリバリアは、*他の cpu*とプロセスメモリを強制的に同期させます (たとえば、書き込みバッファーをフラッシュし、読み取りバッファーを同期します)。</span><span class="sxs-lookup"><span data-stu-id="55d4a-367">The process-wide memory barrier forces *other CPUs* to synchronize with process memory (for example, to flush write buffers and synchronize read buffers).</span></span> <span data-ttu-id="55d4a-368">これにより、一部のスレッドで非インタロック操作を行うことができ、それでも適切な共有アクセスが可能になります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-368">This allows for non-interlocked operations on some threads and still have reasonable shared access.</span></span> 

- <span data-ttu-id="55d4a-369">通常のメモリバリアではオーバーヘッドがごくわずかです。通常のインタロック操作では、100サイクル未満のコストがかかることがあります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-369">The normal memory barrier imposes very little overhead; normal interlocked operations probably cost fewer than a hundred cycles.</span></span> <span data-ttu-id="55d4a-370">プロセス全体のメモリバリアは、非常にコストが高くなります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-370">The process-wide memory barrier is very expensive.</span></span> <span data-ttu-id="55d4a-371">プロセス内のすべての CPU に対して何かを強制する必要があります。</span><span class="sxs-lookup"><span data-stu-id="55d4a-371">It has to force every CPU in the process do to something, at a probable cost of thousands of cycles.</span></span> 

<span data-ttu-id="55d4a-372">`MemoryBarrierProcessWide` メソッドは、ロックフリープログラミングのすべての微妙な違いにも影響します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-372">The `MemoryBarrierProcessWide` method also suffers from all the subtleties of lock-free programming.</span></span> <span data-ttu-id="55d4a-373">ただし、このメソッドは、実際に呼び出す必要がある場合に非常に便利です。この方法はめったに発生しません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-373">Nevertheless, this method can be extremely useful when you actually need to call it, which should be rare.</span></span>

<span data-ttu-id="55d4a-374">このメソッドは、Windows では[Flushprocesswritebuffers](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers) 、Linux では[sys_membarrier](https://lore.kernel.org/patchwork/patch/188708/)の呼び出しをラップします。</span><span class="sxs-lookup"><span data-stu-id="55d4a-374">This method wraps a call to [FlushProcessWriteBuffers](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-flushprocesswritebuffers) on Windows and [sys_membarrier](https://lore.kernel.org/patchwork/patch/188708/) on Linux.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(long % location);" />
      <MemberSignature Language="F#" Value="static member Read : int64 -&gt; int64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="location"><span data-ttu-id="55d4a-375">読み込む 64 ビット値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-375">The 64-bit value to be loaded.</span></span></param>
        <summary><span data-ttu-id="55d4a-376">分割不可能な操作として 64 ビット値を読み込んで返します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-376">Returns a 64-bit value, loaded as an atomic operation.</span></span></summary>
        <returns><span data-ttu-id="55d4a-377">読み込まれた値。</span><span class="sxs-lookup"><span data-stu-id="55d4a-377">The loaded value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="55d4a-378"><xref:System.Threading.Interlocked.Read%2A> メソッドは、64ビットシステムでは不要です。これは、64ビットの読み取り操作が既にアトミックであるためです。</span><span class="sxs-lookup"><span data-stu-id="55d4a-378">The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.</span></span> <span data-ttu-id="55d4a-379">32ビットシステムでは、<xref:System.Threading.Interlocked.Read%2A>を使用して実行しない限り、64ビットの読み取り操作はアトミックではありません。</span><span class="sxs-lookup"><span data-stu-id="55d4a-379">On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="55d4a-380">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="55d4a-380">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/overview-of-synchronization-primitives.md"><span data-ttu-id="55d4a-381">同期プリミティブの概要</span><span class="sxs-lookup"><span data-stu-id="55d4a-381">Overview of synchronization primitives</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SpeculationBarrier">
      <MemberSignature Language="C#" Value="public static void SpeculationBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpeculationBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.SpeculationBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpeculationBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpeculationBarrier();" />
      <MemberSignature Language="F#" Value="static member SpeculationBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.SpeculationBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="55d4a-382">このポイントを超えた予測実行を保留中の読み取りと書き込みが完了するまでブロックする、メモリ フェンスを定義します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-382">Defines a memory fence that blocks speculative execution past this point until pending reads and writes are complete.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="55d4a-383">`SpeculationBarrier` メソッドは、保留中の読み取りと書き込みが完了するまで、予測実行*をブロックする*メモリフェンス (x86 および amd64 プロセッサでの `mfence` 命令) を定義します。</span><span class="sxs-lookup"><span data-stu-id="55d4a-383">The `SpeculationBarrier` method defines a memory fence (an `mfence` instruction on x86 and amd64 processors) that blocks *speculative* execution past this point until pending reads and writes are complete.</span></span> 

 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
