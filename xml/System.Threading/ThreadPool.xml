<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0f4a1bb9f35be38e9a01180a5f34792030a72e08" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75158570" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="f15f1-101">タスクの実行、作業項目のポスト、非同期 I/O の処理、他のスレッドの代理で行う待機、およびタイマーの処理に使用できるスレッドのプールを提供します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-102">多くのアプリケーションでは、スリープ状態に非常に多くの時間を費やし、イベントが発生するのを待機しているスレッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="f15f1-103">その他のスレッドは、定期的にスリープ状態にならないようにして、変更または更新状態情報をポーリングすることができます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="f15f1-104">スレッドプールを使用すると、システムによって管理されるワーカースレッドのプールをアプリケーションに提供することで、スレッドをより効率的に使用できます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="f15f1-105">スレッドプールのスレッドを使用する操作の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="f15f1-106"><xref:System.Threading.Tasks.Task> または <xref:System.Threading.Tasks.Task%601> オブジェクトを作成してタスクを非同期に実行する場合、既定では、タスクはスレッドプールのスレッドで実行されるようにスケジュールされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="f15f1-107">非同期タイマーは、スレッドプールを使用します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="f15f1-108">スレッドプールスレッドは、<xref:System.Threading.Timer?displayProperty=nameWithType> クラスからコールバックを実行し、<xref:System.Timers.Timer?displayProperty=nameWithType> クラスからイベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="f15f1-109">登録された待機ハンドルを使用すると、システムスレッドは待機ハンドルの状態を監視します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="f15f1-110">待機操作が完了すると、スレッドプールからのワーカースレッドが、対応するコールバック関数を実行します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="f15f1-111"><xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> メソッドを呼び出して、スレッドプールのスレッドで実行するメソッドをキューに入れた場合。</span><span class="sxs-lookup"><span data-stu-id="f15f1-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="f15f1-112">これを行うには、メソッドに <xref:System.Threading.WaitCallback> デリゲートを渡します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="f15f1-113">デリゲートにはシグネチャがあります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="f15f1-114">ここで `state` は、デリゲートによって使用されるデータを格納するオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="f15f1-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="f15f1-115"><xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> メソッドを呼び出すことによって、実際のデータをデリゲートに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f15f1-116">マネージスレッドプール内のスレッドは、バックグラウンドスレッドです。</span><span class="sxs-lookup"><span data-stu-id="f15f1-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="f15f1-117">つまり、<xref:System.Threading.Thread.IsBackground%2A> のプロパティが `true`ます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="f15f1-118">これは、すべてのフォアグラウンドスレッドが終了した後に、<xref:System.Threading.ThreadPool> のスレッドがアプリケーションを実行し続けることがないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f15f1-119">スレッドプールは、スレッドを再利用するときに、スレッドローカルストレージまたは <xref:System.ThreadStaticAttribute> 属性でマークされているフィールドのデータをクリアしません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="f15f1-120">したがって、メソッドがスレッドローカルストレージまたは <xref:System.ThreadStaticAttribute> 属性でマークされたフィールドを検査する場合、その値は、スレッドプールのスレッドを以前に使用した後に残されている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="f15f1-121">また、待機操作に関連付けられていない作業項目をスレッドプールにキューに置いてもかまいません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="f15f1-122">スレッドプール内のスレッドが作業項目を処理するように要求するには、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="f15f1-123">このメソッドは、スレッドプールから選択されたスレッドによって呼び出されるメソッドまたはデリゲートへの参照をパラメーターとして受け取ります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="f15f1-124">キューに登録された後は、作業項目を取り消すことはできません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="f15f1-125">タイマー-キューのタイマーと登録されている待機操作は、スレッドプールも使用します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="f15f1-126">これらのコールバック関数は、スレッドプールのキューに登録されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="f15f1-127">プロセスごとに1つのスレッドプールがあります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-127">There is one thread pool per process.</span></span> <span data-ttu-id="f15f1-128">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 以降では、プロセスのスレッド プールの既定のサイズは、仮想アドレス空間のサイズなど、いくつかの要素によって決まります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="f15f1-129">スレッドの数は、プロセスで <xref:System.Threading.ThreadPool.GetMaxThreads%2A> メソッドを呼び出せば確認できます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="f15f1-130">スレッドプール内のスレッドの数は、<xref:System.Threading.ThreadPool.SetMaxThreads%2A> メソッドを使用して変更できます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="f15f1-131">各スレッドは既定のスタックサイズを使用し、既定の優先順位で実行されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f15f1-132">.NET Framework をホストするアンマネージコードは、mscoree.dll ファイルで定義されている `CorSetMaxThreads` 関数を使用して、スレッドプールのサイズを変更できます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="f15f1-133">スレッドプールは、各カテゴリの最小値に達するまで、新しいワーカースレッドまたは i/o 完了スレッドをオンデマンドで提供します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="f15f1-134">最小値に達すると、スレッドプールはそのカテゴリに追加のスレッドを作成したり、一部のタスクが完了するまで待機したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="f15f1-135">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 以降では、スループットを最適化するために、スレッド プールでワーカー スレッドの作成と破棄が行われます。スループットは、タスクの単位時間あたりの完了数として定義されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="f15f1-136">スレッドが少なすぎると使用可能なリソースが最適に使用されない可能性があり、スレッドが多すぎるとリソースの競合が増える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f15f1-137">要求が少ないときは、スレッド プールの実際のスレッド数が最小値を下回る場合があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="f15f1-138">これらの最小値は、<xref:System.Threading.ThreadPool.GetMinThreads%2A> メソッドを使用して取得できます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f15f1-139"><xref:System.Threading.ThreadPool.SetMinThreads%2A> メソッドを使用して、スレッドの最小数を増やすことができます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="f15f1-140">ただし、これらの値を必要以上に大きくすると、パフォーマンスの問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="f15f1-141">同時に開始するタスクの数が多すぎる場合は、すべてのタスクで処理速度が低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="f15f1-142">ほとんどの場合、スレッドを割り当てるためのスレッド プール独自のアルゴリズムを使用することでスレッド プールのパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f15f1-143">次の例では、メインアプリケーションスレッドが `ThreadProc` という名前のメソッドをキューに入れて、スレッドプールのスレッドで実行し、1秒間スリープしてから終了します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="f15f1-144">`ThreadProc` メソッドは、単にメッセージを表示します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="f15f1-145"><xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> メソッドへの呼び出しをコメントアウトすると、スレッドプールのスレッドでメソッドが実行される前に、メインスレッドが終了します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="f15f1-146">スレッドプールはバックグラウンドスレッドを使用します。これにより、すべてのフォアグラウンドスレッドが終了してもアプリケーションは実行されません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="f15f1-147">(これは競合状態の簡単な例です)。</span><span class="sxs-lookup"><span data-stu-id="f15f1-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="f15f1-148">この型はスレッド セーフです。</span><span class="sxs-lookup"><span data-stu-id="f15f1-148">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="f15f1-149">スレッドおよびスレッド処理</span><span class="sxs-lookup"><span data-stu-id="f15f1-149">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="f15f1-150">マネージスレッドプール</span><span class="sxs-lookup"><span data-stu-id="f15f1-150">The Managed Thread Pooling</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f15f1-151">オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-151">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="f15f1-152">ハンドルを保持する <see cref="T:System.IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-152">An <see cref="T:System.IntPtr" /> that holds the handle.</span></span> <span data-ttu-id="f15f1-153">ハンドルは、アンマネージ側の重複 I/O 用に開かれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-153">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="f15f1-154">オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-154">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="f15f1-155">ハンドルがバインドされている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-155"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f15f1-156">呼び出し元に、必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-156">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f15f1-157">アンマネージコードを呼び出すことができる。</span><span class="sxs-lookup"><span data-stu-id="f15f1-157">for the ability to call unmanaged code.</span></span> <span data-ttu-id="f15f1-158"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="f15f1-158">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="f15f1-159">オペレーティング システム ハンドルを保持する <see cref="T:System.Runtime.InteropServices.SafeHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-159">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span></span> <span data-ttu-id="f15f1-160">ハンドルは、アンマネージ側の重複 I/O 用に開かれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-160">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="f15f1-161">オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-161">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="f15f1-162">ハンドルがバインドされている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-162"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-163">`osHandle` パラメーターは、抽象 <xref:System.Runtime.InteropServices.SafeHandle> クラスから派生する <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>である必要があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-163">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f15f1-164"><paramref name="osHandle" /> が <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-164"><paramref name="osHandle" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f15f1-165">アンマネージコードを呼び出すことができる。</span><span class="sxs-lookup"><span data-stu-id="f15f1-165">for the ability to call unmanaged code.</span></span> <span data-ttu-id="f15f1-166"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="f15f1-166">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CompletedWorkItemCount">
      <MemberSignature Language="C#" Value="public static long CompletedWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 CompletedWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long CompletedWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedWorkItemCount : int64" Usage="System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f15f1-167">これまでに処理された作業項目の数を取得します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-167">Gets the number of work items that have been processed so far.</span></span></summary>
        <value><span data-ttu-id="f15f1-168">これまでに処理された作業項目の数。</span><span class="sxs-lookup"><span data-stu-id="f15f1-168">The number of work items that have been processed so far.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="f15f1-169">スレッドプールの実装に異なる種類の作業項目がある場合、カウントにはすべての型が含まれます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-169">If a thread pool implementation may have different types of work items, the count includes all types.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="f15f1-170">使用できるワーカー スレッドの数。</span><span class="sxs-lookup"><span data-stu-id="f15f1-170">The number of available worker threads.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="f15f1-171">使用できる非同期 I/O スレッドの数。</span><span class="sxs-lookup"><span data-stu-id="f15f1-171">The number of available asynchronous I/O threads.</span></span></param>
        <summary><span data-ttu-id="f15f1-172">スレッド プール スレッドの最大数 (<see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> メソッドから返される) と現在アクティブなスレッドの数との差を取得します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-172">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-173"><xref:System.Threading.ThreadPool.GetAvailableThreads%2A> が返されると、`workerThreads` によって指定された変数には、開始可能な追加のワーカースレッドの数が含まれ、`completionPortThreads` で指定された変数には、開始可能な追加の非同期 i/o スレッドの数が含まれます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-173">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="f15f1-174">使用可能なスレッドがない場合、スレッドプールのスレッドが使用可能になるまで、追加のスレッドプール要求はキューに置かれたままになります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-174">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f15f1-175">次の例では、単純なアプリの起動時に使用可能なワーカースレッドと i/o スレッドの数を表示します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-175">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="f15f1-176">スレッド プール内のワーカー スレッドの最大数。</span><span class="sxs-lookup"><span data-stu-id="f15f1-176">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="f15f1-177">スレッド プール内の非同期 I/O スレッドの最大数。</span><span class="sxs-lookup"><span data-stu-id="f15f1-177">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="f15f1-178">同時にアクティブにできるスレッド プールへの要求の数を取得します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-178">Retrieves the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="f15f1-179">この数を超える要求はすべて、スレッド プール スレッドが使用可能になるまでキューに置かれたままになります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-179">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-180"><xref:System.Threading.ThreadPool.GetMaxThreads%2A> が返されると、`workerThreads` によって指定された変数にはスレッドプールで許可されるワーカースレッドの最大数が含まれ、`completionPortThreads` で指定された変数には、スレッドプールで許可されている非同期 i/o スレッドの最大数が含まれます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-180">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="f15f1-181"><xref:System.Threading.ThreadPool.GetAvailableThreads%2A> メソッドを使用して、いつでもスレッドプール内のスレッドの実際の数を確認できます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-181">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="f15f1-182"><xref:System.Threading.ThreadPool.SetMaxThreads%2A> を使用すると、スレッドプール内のワーカースレッドの最大数と非同期 i/o スレッドの数を設定できます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-182">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="f15f1-183">システムメモリで許可されている数のスレッドプール要求をキューにすることができます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-183">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="f15f1-184">スレッドプールのスレッド数よりも多くの要求がある場合、スレッドプールのスレッドが使用可能になるまで、追加の要求はキューに置かれたままになります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-184">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f15f1-185">スレッドプール内のスレッドの最大数と使用可能な数を取得する方法を次のコード例に示します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-185">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="f15f1-186">`FileStream` を使用して2つのファイルに非同期的に書き込む作業項目がキューに登録されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-186">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="f15f1-187">コールバックメソッドは、重複するように時間が指定されています。</span><span class="sxs-lookup"><span data-stu-id="f15f1-187">The callback methods are timed to overlap.</span></span> <span data-ttu-id="f15f1-188">ワーカースレッドは作業項目を処理し、コンピューターのプロセッサの速度と数に応じて、1つまたは2つの完了ポートスレッドが書き込み操作を処理します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-188">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads : int * int -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="f15f1-189">このメソッドが戻るとき、スレッド プールがオンデマンドで作成するワーカー スレッドの最小数が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f15f1-189">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="f15f1-190">このメソッドが戻るとき、スレッド プールがオンデマンドで作成する非同期 I/O スレッドの最小数が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f15f1-190">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="f15f1-191">スレッドがオンデマンドで (新しい要求の発生ごとに) 作成するスレッド プールの数を取得します。この数を超えると、スレッドの作成と破棄を管理するためのアルゴリズムに切り替わります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-191">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-192">スレッドプールは、各カテゴリの最小値に達するまで、新しいワーカースレッドまたは i/o 完了スレッドをオンデマンドで提供します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-192">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="f15f1-193">既定では、スレッドの最小数はシステム上のプロセッサの数に設定されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-193">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="f15f1-194">最小値に達すると、スレッドプールはそのカテゴリに追加のスレッドを作成したり、一部のタスクが完了するまで待機したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-194">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="f15f1-195">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降では、スレッドプールは、スループットを最適化するためにスレッドを作成して破棄します。スループットは、時間単位で完了するタスクの数として定義されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-195">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="f15f1-196">スレッドが少なすぎると使用可能なリソースが最適に使用されない可能性があり、スレッドが多すぎるとリソースの競合が増える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-196">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f15f1-197">要求が少ないときは、スレッド プールの実際のスレッド数が最小値を下回る場合があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-197">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f15f1-198">次の例では、ワーカースレッドの最小数を4に設定し、元の値を非同期 i/o 完了スレッドの最小数に保持します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-198">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="PendingWorkItemCount">
      <MemberSignature Language="C#" Value="public static long PendingWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 PendingWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PendingWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long PendingWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PendingWorkItemCount : int64" Usage="System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f15f1-199">処理するキューに置かれた現在の作業項目の数を取得します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-199">Gets the number of work items that are currently queued to be processed.</span></span></summary>
        <value><span data-ttu-id="f15f1-200">処理のために現在キューに登録されている作業項目の数。</span><span class="sxs-lookup"><span data-stu-id="f15f1-200">The number of work items that are currently queued to be processed.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="f15f1-201">スレッドプールの実装に異なる種類の作業項目がある場合、カウントには追跡可能なすべての種類が含まれます。これは、タスクを含むユーザーの作業項目である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-201">If a thread pool implementation may have different types of work items, the count includes all types that can be tracked, which may only be the user work items, including tasks.</span></span> <span data-ttu-id="f15f1-202">一部の実装では、キューに入っているタイマーと待機コールバックがカウントされることもあります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-202">Some implementations may also include queued timer and wait callbacks in the count.</span></span> <span data-ttu-id="f15f1-203">Windows では、IO 完了ポートに直接ポストされるため、保留中の IO の完了回数がカウントに含まれることはほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-203">On Windows, the count is unlikely to include the number of pending IO completions, because they are posted directly to an IO completion port.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f15f1-204">メソッドを実行するためのキューに置きます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-204">Queues a method for execution.</span></span> <span data-ttu-id="f15f1-205">メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-205">The method executes when a thread pool thread becomes available.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="f15f1-206">実行するメソッドを表す <see cref="T:System.Threading.WaitCallback" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-206">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span></span></param>
        <summary><span data-ttu-id="f15f1-207">メソッドを実行するためのキューに置きます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-207">Queues a method for execution.</span></span> <span data-ttu-id="f15f1-208">メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-208">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="f15f1-209">メソッドが正常にキューに配置された場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.NotSupportedException" /> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-209"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-210">キューに格納されたメソッドに必要なデータは、メソッドが定義されているクラスのインスタンスフィールドに配置できます。また、必要なデータを格納しているオブジェクトを受け取る <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> オーバーロードを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-210">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f15f1-211">Visual Basic ユーザーは、<xref:System.Threading.WaitCallback> コンストラクターを省略できます。また、コールバックメソッドを <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>に渡すときに `AddressOf` 演算子を使用するだけです。</span><span class="sxs-lookup"><span data-stu-id="f15f1-211">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="f15f1-212">Visual Basic は、正しいデリゲートコンストラクターを自動的に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-212">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="f15f1-213">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="f15f1-213">Version Information</span></span>  
 <span data-ttu-id="f15f1-214">.NET Framework バージョン2.0 では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> プロパティ値は、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> メソッドを使用してキューに置かれたワーカースレッドに反映されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-214">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="f15f1-215">以前のバージョンでは、プリンシパル情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-215">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f15f1-216">次の例では、<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> メソッドオーバーロードを使用して、`ThreadProc` メソッドによって表されるタスクをキューに置いて、スレッドが使用可能になったときに実行します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-216">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="f15f1-217">このオーバーロードでは、タスク情報は提供されません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-217">No task information is supplied with this overload.</span></span> <span data-ttu-id="f15f1-218">したがって、`ThreadProc` メソッドで使用できる情報は、メソッドが属しているオブジェクトに限定されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-218">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f15f1-219"><paramref name="callBack" /> が <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-219"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f15f1-220">共通言語ランタイム (CLR) がホストされており、ホストではこのアクションがサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-220">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="f15f1-221">マネージド スレッド プール</span><span class="sxs-lookup"><span data-stu-id="f15f1-221">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="f15f1-222">実行するメソッドを表す <see cref="T:System.Threading.WaitCallback" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-222">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="f15f1-223">メソッドが使用するデータを格納したオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-223">An object containing data to be used by the method.</span></span></param>
        <summary><span data-ttu-id="f15f1-224">実行するためのキューにメソッドを置き、そのメソッドが使用するデータを含んだオブジェクトを指定します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-224">Queues a method for execution, and specifies an object containing data to be used by the method.</span></span> <span data-ttu-id="f15f1-225">メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-225">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="f15f1-226">メソッドが正常にキューに配置された場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.NotSupportedException" /> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-226"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-227">コールバックメソッドに複雑なデータが必要な場合は、データを格納するクラスを定義できます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-227">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f15f1-228">Visual Basic ユーザーは、<xref:System.Threading.WaitCallback> コンストラクターを省略できます。また、コールバックメソッドを <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>に渡すときに `AddressOf` 演算子を使用するだけです。</span><span class="sxs-lookup"><span data-stu-id="f15f1-228">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="f15f1-229">Visual Basic は、正しいデリゲートコンストラクターを自動的に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-229">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="f15f1-230">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="f15f1-230">Version Information</span></span>  
 <span data-ttu-id="f15f1-231">.NET Framework バージョン2.0 では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> プロパティ値は、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> メソッドを使用してキューに置かれたワーカースレッドに反映されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-231">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="f15f1-232">以前のバージョンでは、プリンシパル情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-232">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f15f1-233">次の例では、.NET スレッドプールを使用して、20 ~ 40 の5つの数値の `Fibonacci` 結果を計算します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-233">The following example uses the .NET thread pool to calculate the `Fibonacci` result for five numbers between 20 and 40.</span></span> <span data-ttu-id="f15f1-234">各 `Fibonacci` の結果は `Fibonacci` クラスによって表され、このクラスには計算を実行する `ThreadPoolCallback` という名前のメソッドがあります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-234">Each `Fibonacci` result is represented by the `Fibonacci` class, which provides a method named `ThreadPoolCallback` that performs the calculation.</span></span> <span data-ttu-id="f15f1-235">`Fibonacci` の各値を表すオブジェクトが作成され、`ThreadPoolCallback` メソッドが <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> に渡されます。このメソッドは、プール内の使用可能なスレッドを割り当てて、渡されたメソッドを実行します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-235">An object that represents each `Fibonacci` value is created, and the `ThreadPoolCallback` method is passed to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, which assigns an available thread in the pool to execute the method.</span></span>  
  
 <span data-ttu-id="f15f1-236">各 `Fibonacci` オブジェクトには計算対象の半ランダムな値が与えられるため、各スレッドはプロセッサ時間に対して競合するので、5つのすべての結果が計算されるまでにかかる時間を事前に知ることはできません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-236">Because each `Fibonacci` object is given a semi-random value to compute, and because each thread will be competing for processor time, you cannot know in advance how long it will take for all five results to be calculated.</span></span> <span data-ttu-id="f15f1-237">そのため、各 `Fibonacci` オブジェクトには構築の間に <xref:System.Threading.ManualResetEvent> クラスのインスタンスを渡されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-237">That is why each `Fibonacci` object is passed an instance of the <xref:System.Threading.ManualResetEvent> class during construction.</span></span> <span data-ttu-id="f15f1-238">各オブジェクトは、その計算が完了したときに、指定されたイベントオブジェクトに通知します。これにより、プライマリスレッドは、5つのすべての `Fibonacci` オブジェクトが結果を計算するまで <xref:System.Threading.WaitHandle.WaitAll%2A> での実行をブロックできます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-238">Each object signals the provided event object when its calculation is complete, which allows the primary thread to block execution with <xref:System.Threading.WaitHandle.WaitAll%2A> until all five `Fibonacci` objects have calculated a result.</span></span> <span data-ttu-id="f15f1-239">その後、`Main` メソッドは各 `Fibonacci` の結果を表示します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-239">The `Main` method then displays each `Fibonacci` result.</span></span>
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f15f1-240">共通言語ランタイム (CLR) がホストされており、ホストではこのアクションがサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-240">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f15f1-241"><paramref name="callBack" /> が <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-241"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="f15f1-242">マネージド スレッド プール</span><span class="sxs-lookup"><span data-stu-id="f15f1-242">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><span data-ttu-id="f15f1-243"><paramref name="state" /> の要素の型。</span><span class="sxs-lookup"><span data-stu-id="f15f1-243">The type of elements of <paramref name="state" />.</span></span></typeparam>
        <param name="callBack"><span data-ttu-id="f15f1-244">実行するメソッドを表す <see cref="T:System.Action`1" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-244">An <see cref="T:System.Action`1" /> representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="f15f1-245">メソッドが使用するデータを格納したオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-245">An object containing data to be used by the method.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="f15f1-246">現在のスレッドに近いキューに作業項目を入れる場合は <see langword="true" />。スレッド プールの共有キューに作業項目を入れる場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-246"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="f15f1-247">実行用に <see cref="T:System.Action`1" /> デリゲートで指定したメソッドをキューに入れ、メソッドで使うデータを指定します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-247">Queues a method specified by an <see cref="T:System.Action`1" /> delegate for execution, and provides data to be used by the method.</span></span> <span data-ttu-id="f15f1-248">メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-248">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="f15f1-249">メソッドが正常にキューに配置された場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.NotSupportedException" /> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-249"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span>
<span data-ttu-id="f15f1-250">.</span><span class="sxs-lookup"><span data-stu-id="f15f1-250">.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f15f1-251"><see cref="T:System.Threading.WaitHandle" /> を待機しているデリゲートを登録します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-251">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="f15f1-252">登録する <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-252">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="f15f1-253"><see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-253">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="f15f1-254"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="f15f1-254">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="f15f1-255">デリゲートに渡されるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-255">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="f15f1-256">ミリ秒単位のタイムアウト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-256">The time-out in milliseconds.</span></span> <span data-ttu-id="f15f1-257"><paramref name="millisecondsTimeOutInterval" /> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-257">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="f15f1-258"><paramref name="millisecondsTimeOutInterval" /> が -1 の場合、関数はタイムアウトしません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-258">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="f15f1-259">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-259"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="f15f1-260">ミリ秒単位のタイムアウトとして 32 ビット符号付き整数を指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-260">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="f15f1-261">ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-261">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-262">このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-262">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="f15f1-263">`executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-263">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="f15f1-264">登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-264">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="f15f1-265"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたデリゲートをスレッドプールにキューに置いています。</span><span class="sxs-lookup"><span data-stu-id="f15f1-265">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="f15f1-266">次のいずれかが発生すると、ワーカースレッドはデリゲートを実行します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-266">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="f15f1-267">指定されたオブジェクトはシグナル状態です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-267">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="f15f1-268">タイムアウト間隔が経過した。</span><span class="sxs-lookup"><span data-stu-id="f15f1-268">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="f15f1-269"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたオブジェクトの <xref:System.Threading.WaitHandle>の現在の状態を確認します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-269">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="f15f1-270">オブジェクトの状態が非シグナルの場合、メソッドは待機操作を登録します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-270">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="f15f1-271">待機操作は、スレッドプールからのスレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-271">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="f15f1-272">デリゲートは、オブジェクトの状態がシグナル状態になるか、タイムアウト間隔が経過すると、ワーカースレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-272">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="f15f1-273">`timeOutInterval` パラメーターが 0 (ゼロ) でなく、`executeOnlyOnce` パラメーターが `false`の場合、イベントが通知されるたびに、またはタイムアウト間隔が経過するたびにタイマーがリセットされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-273">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f15f1-274">`waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-274">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="f15f1-275"><xref:System.Threading.Mutex>の代わりに、最大数が1の <xref:System.Threading.Semaphore> を使用します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-275">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="f15f1-276">待機操作を取り消すには、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-276">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f15f1-277">待機スレッドは、Win32 `WaitForMultipleObjects` 関数を使用して、登録されている待機操作を監視します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-277">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="f15f1-278">したがって、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>の複数の呼び出しで同じネイティブオペレーティングシステムハンドルを使用する必要がある場合は、Win32 `DuplicateHandle` 関数を使用してハンドルを複製する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-278">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="f15f1-279"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>に渡されるイベントオブジェクトはパルスではないことに注意してください。これは、イベントがリセットされる前に、そのイベントがシグナル状態であることを待機スレッドが検出できない可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="f15f1-279">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="f15f1-280">関数は、を返す前に、いくつかの種類の同期オブジェクトの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-280">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="f15f1-281">変更が発生するのは、シグナル状態になった待機条件が満たされたオブジェクトだけです。</span><span class="sxs-lookup"><span data-stu-id="f15f1-281">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="f15f1-282">たとえば、セマフォのカウントは1つ減少します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-282">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="f15f1-283">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="f15f1-283">Version Information</span></span>  
 <span data-ttu-id="f15f1-284">.NET Framework バージョン2.0 以降では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> プロパティ値は、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドを使用してキューに置かれたワーカースレッドに反映されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-284">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="f15f1-285">以前のバージョンでは、プリンシパル情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-285">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f15f1-286"><paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span><span class="sxs-lookup"><span data-stu-id="f15f1-286">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="f15f1-287">マネージド スレッド プール</span><span class="sxs-lookup"><span data-stu-id="f15f1-287">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="f15f1-288">登録する <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-288">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="f15f1-289"><see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-289">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="f15f1-290"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="f15f1-290">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="f15f1-291">デリゲートに渡されたオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-291">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="f15f1-292">ミリ秒単位のタイムアウト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-292">The time-out in milliseconds.</span></span> <span data-ttu-id="f15f1-293"><paramref name="millisecondsTimeOutInterval" /> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-293">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="f15f1-294"><paramref name="millisecondsTimeOutInterval" /> が -1 の場合、関数はタイムアウトしません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-294">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="f15f1-295">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-295"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="f15f1-296">64 ビット符号付き整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-296">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="f15f1-297">ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-297">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-298">このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-298">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="f15f1-299">`executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-299">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="f15f1-300">登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-300">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="f15f1-301"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたデリゲートをスレッドプールにキューに置いています。</span><span class="sxs-lookup"><span data-stu-id="f15f1-301">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="f15f1-302">次のいずれかが発生すると、ワーカースレッドはデリゲートを実行します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-302">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="f15f1-303">指定されたオブジェクトはシグナル状態です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-303">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="f15f1-304">タイムアウト間隔が経過した。</span><span class="sxs-lookup"><span data-stu-id="f15f1-304">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="f15f1-305"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたオブジェクトの <xref:System.Threading.WaitHandle>の現在の状態を確認します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-305">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="f15f1-306">オブジェクトの状態が非シグナルの場合、メソッドは待機操作を登録します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-306">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="f15f1-307">待機操作は、スレッドプールからのスレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-307">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="f15f1-308">デリゲートは、オブジェクトの状態がシグナル状態になるか、タイムアウト間隔が経過すると、ワーカースレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-308">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="f15f1-309">`timeOutInterval` パラメーターが 0 (ゼロ) でなく、`executeOnlyOnce` パラメーターが `false`の場合、イベントが通知されるたびに、またはタイムアウト間隔が経過するたびにタイマーがリセットされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-309">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f15f1-310">`waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-310">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="f15f1-311"><xref:System.Threading.Mutex>の代わりに、最大数が1の <xref:System.Threading.Semaphore> を使用します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-311">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="f15f1-312">待機操作を取り消すには、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-312">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f15f1-313">待機スレッドは、Win32 `WaitForMultipleObjects` 関数を使用して、登録されている待機操作を監視します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-313">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="f15f1-314">したがって、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>の複数の呼び出しで同じネイティブオペレーティングシステムハンドルを使用する必要がある場合は、Win32 `DuplicateHandle` 関数を使用してハンドルを複製する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-314">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="f15f1-315"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>に渡されるイベントオブジェクトはパルスではないことに注意してください。これは、イベントがリセットされる前に、そのイベントがシグナル状態であることを待機スレッドが検出できない可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="f15f1-315">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="f15f1-316">関数は、を返す前に、いくつかの種類の同期オブジェクトの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-316">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="f15f1-317">変更が発生するのは、シグナル状態になった待機条件が満たされたオブジェクトだけです。</span><span class="sxs-lookup"><span data-stu-id="f15f1-317">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="f15f1-318">たとえば、セマフォのカウントは1つ減少します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-318">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="f15f1-319">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="f15f1-319">Version Information</span></span>  
 <span data-ttu-id="f15f1-320">.NET Framework バージョン2.0 以降では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> プロパティ値は、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドを使用してキューに置かれたワーカースレッドに反映されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-320">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="f15f1-321">以前のバージョンでは、プリンシパル情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-321">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f15f1-322"><paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span><span class="sxs-lookup"><span data-stu-id="f15f1-322">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="f15f1-323">マネージド スレッド プール</span><span class="sxs-lookup"><span data-stu-id="f15f1-323">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="f15f1-324">登録する <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-324">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="f15f1-325"><see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-325">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="f15f1-326"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="f15f1-326">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="f15f1-327">デリゲートに渡されたオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-327">The object passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="f15f1-328"><see cref="T:System.TimeSpan" /> で表されるタイムアウト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-328">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="f15f1-329"><paramref name="timeout" /> が 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-329">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="f15f1-330"><paramref name="timeout" /> が -1 の場合、関数はタイムアウトしません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-330">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="f15f1-331">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-331"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="f15f1-332"><see cref="T:System.TimeSpan" /> 値をタイムアウトとして指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-332">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span></span></summary>
        <returns><span data-ttu-id="f15f1-333">ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-333">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-334">このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-334">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="f15f1-335">`executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-335">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="f15f1-336">登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-336">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="f15f1-337"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたデリゲートをスレッドプールにキューに置いています。</span><span class="sxs-lookup"><span data-stu-id="f15f1-337">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="f15f1-338">次のいずれかが発生すると、ワーカースレッドはデリゲートを実行します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-338">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="f15f1-339">指定されたオブジェクトはシグナル状態です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-339">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="f15f1-340">タイムアウト間隔が経過した。</span><span class="sxs-lookup"><span data-stu-id="f15f1-340">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="f15f1-341"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたオブジェクトの <xref:System.Threading.WaitHandle>の現在の状態を確認します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-341">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="f15f1-342">オブジェクトの状態が非シグナルの場合、メソッドは待機操作を登録します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-342">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="f15f1-343">待機操作は、スレッドプールからのスレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-343">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="f15f1-344">デリゲートは、オブジェクトの状態がシグナル状態になるか、タイムアウト間隔が経過すると、ワーカースレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-344">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="f15f1-345">`timeOutInterval` パラメーターが 0 (ゼロ) でなく、`executeOnlyOnce` パラメーターが `false`の場合、イベントが通知されるたびに、またはタイムアウト間隔が経過するたびにタイマーがリセットされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-345">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f15f1-346">`waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-346">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="f15f1-347"><xref:System.Threading.Mutex>の代わりに、最大数が1の <xref:System.Threading.Semaphore> を使用します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-347">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="f15f1-348">待機操作を取り消すには、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-348">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f15f1-349">待機スレッドは、Win32 `WaitForMultipleObjects` 関数を使用して、登録されている待機操作を監視します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-349">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="f15f1-350">したがって、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>の複数の呼び出しで同じネイティブオペレーティングシステムハンドルを使用する必要がある場合は、Win32 `DuplicateHandle` 関数を使用してハンドルを複製する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-350">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="f15f1-351"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>に渡されるイベントオブジェクトはパルスではないことに注意してください。これは、イベントがリセットされる前に、そのイベントがシグナル状態であることを待機スレッドが検出できない可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="f15f1-351">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="f15f1-352">関数は、を返す前に、いくつかの種類の同期オブジェクトの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-352">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="f15f1-353">変更が発生するのは、シグナル状態になった待機条件が満たされたオブジェクトだけです。</span><span class="sxs-lookup"><span data-stu-id="f15f1-353">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="f15f1-354">たとえば、セマフォのカウントは1つ減少します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-354">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="f15f1-355">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="f15f1-355">Version Information</span></span>  
 <span data-ttu-id="f15f1-356">.NET Framework バージョン2.0 以降では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> プロパティ値は、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドを使用してキューに置かれたワーカースレッドに反映されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-356">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="f15f1-357">以前のバージョンでは、プリンシパル情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-357">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f15f1-358"><paramref name="timeout" /> パラメーターが -1 未満。</span><span class="sxs-lookup"><span data-stu-id="f15f1-358">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f15f1-359"><paramref name="timeout" /> パラメーターが <see cref="F:System.Int32.MaxValue" /> より大きい値です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-359">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="f15f1-360">マネージド スレッド プール</span><span class="sxs-lookup"><span data-stu-id="f15f1-360">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="f15f1-361">登録する <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-361">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="f15f1-362"><see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-362">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="f15f1-363"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="f15f1-363">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="f15f1-364">デリゲートに渡されたオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-364">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="f15f1-365">ミリ秒単位のタイムアウト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-365">The time-out in milliseconds.</span></span> <span data-ttu-id="f15f1-366"><paramref name="millisecondsTimeOutInterval" /> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-366">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="f15f1-367"><paramref name="millisecondsTimeOutInterval" /> が -1 の場合、関数はタイムアウトしません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-367">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="f15f1-368">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-368"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="f15f1-369">32 ビット符号なし整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-369">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="f15f1-370">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-370">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-371">このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-371">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="f15f1-372">`executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-372">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="f15f1-373">登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-373">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="f15f1-374"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたデリゲートをスレッドプールにキューに置いています。</span><span class="sxs-lookup"><span data-stu-id="f15f1-374">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="f15f1-375">次のいずれかが発生すると、ワーカースレッドはデリゲートを実行します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-375">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="f15f1-376">指定されたオブジェクトはシグナル状態です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-376">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="f15f1-377">タイムアウト間隔が経過した。</span><span class="sxs-lookup"><span data-stu-id="f15f1-377">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="f15f1-378"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドは、指定されたオブジェクトの <xref:System.Threading.WaitHandle>の現在の状態を確認します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-378">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="f15f1-379">オブジェクトの状態が非シグナルの場合、メソッドは待機操作を登録します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-379">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="f15f1-380">待機操作は、スレッドプールからのスレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-380">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="f15f1-381">デリゲートは、オブジェクトの状態がシグナル状態になるか、タイムアウト間隔が経過すると、ワーカースレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-381">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="f15f1-382">`timeOutInterval` パラメーターが 0 (ゼロ) でなく、`executeOnlyOnce` パラメーターが `false`の場合、イベントが通知されるたびに、またはタイムアウト間隔が経過するたびにタイマーがリセットされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-382">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f15f1-383">`waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-383">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="f15f1-384"><xref:System.Threading.Mutex>の代わりに、最大数が1の <xref:System.Threading.Semaphore> を使用します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-384">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="f15f1-385">待機操作を取り消すには、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-385">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f15f1-386">待機スレッドは、Win32 `WaitForMultipleObjects` 関数を使用して、登録されている待機操作を監視します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-386">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="f15f1-387">したがって、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>の複数の呼び出しで同じネイティブオペレーティングシステムハンドルを使用する必要がある場合は、Win32 `DuplicateHandle` 関数を使用してハンドルを複製する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-387">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="f15f1-388"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>に渡されるイベントオブジェクトはパルスではないことに注意してください。これは、イベントがリセットされる前に、そのイベントがシグナル状態であることを待機スレッドが検出できない可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="f15f1-388">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="f15f1-389">関数は、を返す前に、いくつかの種類の同期オブジェクトの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-389">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="f15f1-390">変更が発生するのは、シグナル状態になった待機条件が満たされたオブジェクトだけです。</span><span class="sxs-lookup"><span data-stu-id="f15f1-390">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="f15f1-391">たとえば、セマフォのカウントは1つ減少します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-391">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="f15f1-392">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="f15f1-392">Version Information</span></span>  
 <span data-ttu-id="f15f1-393">.NET Framework バージョン2.0 以降では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> プロパティ値は、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドを使用してキューに置かれたワーカースレッドに反映されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-393">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="f15f1-394">以前のバージョンでは、プリンシパル情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-394">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f15f1-395">次の例は、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドを使用して、指定された待機ハンドルがシグナル状態になったときに、指定されたコールバックメソッドを実行する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="f15f1-395">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="f15f1-396">この例では、コールバックメソッドが `WaitProc`、待機ハンドルが <xref:System.Threading.AutoResetEvent>です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-396">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="f15f1-397">この例では、実行時にコールバックに渡される情報を保持する `TaskInfo` クラスを定義します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-397">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="f15f1-398">この例では、`TaskInfo` オブジェクトを作成し、いくつかの文字列データを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-398">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="f15f1-399"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドによって返される <xref:System.Threading.RegisteredWaitHandle> は、コールバックメソッドが <xref:System.Threading.RegisteredWaitHandle>にアクセスできるように、`TaskInfo` オブジェクトの `Handle` フィールドに割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-399">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="f15f1-400">コールバックメソッドに渡すオブジェクトとして `TaskInfo` を指定するだけでなく、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドの呼び出しでは、タスクが待機する <xref:System.Threading.AutoResetEvent>、`WaitProc` コールバックメソッドを表す <xref:System.Threading.WaitOrTimerCallback> デリゲート、1秒のタイムアウト時間、および複数のコールバックを指定します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-400">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="f15f1-401">メインスレッドが <xref:System.Threading.EventWaitHandle.Set%2A> メソッドを呼び出すことによって <xref:System.Threading.AutoResetEvent> に通知すると、<xref:System.Threading.WaitOrTimerCallback> デリゲートが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-401">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="f15f1-402">`WaitProc` メソッドは、タイムアウトが発生したかどうかを判断するために <xref:System.Threading.RegisteredWaitHandle> をテストします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-402">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="f15f1-403">待機ハンドルがシグナル状態になったためにコールバックが呼び出された場合、`WaitProc` メソッドは、<xref:System.Threading.RegisteredWaitHandle>の登録を解除し、追加のコールバックを停止します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-403">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="f15f1-404">タイムアウトの場合、タスクは待機を続けます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-404">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="f15f1-405">`WaitProc` メソッドは、メッセージをコンソールに出力することによって終了します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-405">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f15f1-406"><paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span><span class="sxs-lookup"><span data-stu-id="f15f1-406">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="f15f1-407">マネージド スレッド プール</span><span class="sxs-lookup"><span data-stu-id="f15f1-407">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="f15f1-408">スレッド プール内のワーカー スレッドの最大数。</span><span class="sxs-lookup"><span data-stu-id="f15f1-408">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="f15f1-409">スレッド プール内の非同期 I/O スレッドの最大数。</span><span class="sxs-lookup"><span data-stu-id="f15f1-409">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="f15f1-410">同時にアクティブにできるスレッド プールへの要求の数を設定します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-410">Sets the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="f15f1-411">この数を超える要求はすべて、スレッド プール スレッドが使用可能になるまでキューに置かれたままになります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-411">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <returns><span data-ttu-id="f15f1-412">変更が成功した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-412"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-413">ワーカースレッドまたは i/o 完了スレッドの最大数を、コンピューター上のプロセッサ数よりも小さい数に設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-413">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="f15f1-414">存在するプロセッサの数を確認するには、<xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-414">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="f15f1-415">さらに、ワーカースレッドまたは i/o 完了スレッドの最大数を、対応するワーカースレッドまたは i/o 完了スレッドの最小数よりも小さい数に設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-415">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="f15f1-416">最小スレッドプールサイズを確認するには、<xref:System.Threading.ThreadPool.GetMinThreads%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-416">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="f15f1-417">共通言語ランタイムがインターネットインフォメーションサービス (IIS) や SQL Server などでホストされている場合、ホストはスレッドプールサイズの変更を制限したり、禁止したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-417">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="f15f1-418">スレッドプール内のスレッドの最大数を変更するときは注意してください。</span><span class="sxs-lookup"><span data-stu-id="f15f1-418">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="f15f1-419">コードが恩恵を受ける可能性がありますが、変更は使用するコードライブラリに悪影響を及ぼす可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-419">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="f15f1-420">スレッドプールのサイズを大きく設定すると、パフォーマンスの問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-420">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="f15f1-421">同時に実行されているスレッドの数が多すぎると、タスクの切り替えによるオーバーヘッドが大きくなります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-421">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f15f1-422">スレッドを制御する機能。</span><span class="sxs-lookup"><span data-stu-id="f15f1-422">for the ability to control threads.</span></span> <span data-ttu-id="f15f1-423">アクセス許可値: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="f15f1-423">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="f15f1-424">スレッド プールがオンデマンドで作成するワーカー スレッドの最小数。</span><span class="sxs-lookup"><span data-stu-id="f15f1-424">The minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="f15f1-425">スレッド プールがオンデマンドで作成する非同期 I/O スレッドの最小数。</span><span class="sxs-lookup"><span data-stu-id="f15f1-425">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="f15f1-426">スレッドがオンデマンドで (新しい要求の発生ごとに) 作成するスレッド プールの数を設定します。この数を超えると、スレッドの作成と破棄を管理するためのアルゴリズムに切り替わります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-426">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <returns><span data-ttu-id="f15f1-427">変更が成功した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-427"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-428">スレッドプールは、各カテゴリの最小値に達するまで、新しいワーカースレッドまたは i/o 完了スレッドをオンデマンドで提供します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-428">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="f15f1-429">最小値に達すると、スレッドプールはそのカテゴリに追加のスレッドを作成したり、一部のタスクが完了するまで待機したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-429">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="f15f1-430">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]以降では、スレッドプールは、スループットを最適化するためにスレッドを作成して破棄します。スループットは、時間単位で完了するタスクの数として定義されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-430">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="f15f1-431">スレッドが少なすぎると使用可能なリソースが最適に使用されない可能性があり、スレッドが多すぎるとリソースの競合が増える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-431">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="f15f1-432">要求が少ないときは、スレッド プールの実際のスレッド数が最小値を下回る場合があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-432">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="f15f1-433"><xref:System.Threading.ThreadPool.GetMaxThreads%2A>を使用して取得した、アクティブなスレッドプールのスレッドの最大数よりも大きい負の数または数を指定した場合、<xref:System.Threading.ThreadPool.SetMinThreads%2A> は `false` を返し、最小値のいずれかを変更しません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-433">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f15f1-434">既定では、スレッドの最小数はシステム上のプロセッサの数に設定されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-434">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="f15f1-435"><xref:System.Threading.ThreadPool.SetMinThreads%2A> メソッドを使用して、スレッドの最小数を増やすことができます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-435">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="f15f1-436">ただし、これらの値を必要以上に大きくすると、パフォーマンスの問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-436">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="f15f1-437">同時に開始するタスクの数が多すぎる場合は、すべてのタスクで処理速度が低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-437">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="f15f1-438">ほとんどの場合、スレッドプールは、スレッドを割り当てる独自のアルゴリズムによってパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-438">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="f15f1-439">最小値をプロセッサ数未満に減らすと、パフォーマンスが低下する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-439">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f15f1-440">次の例では、ワーカースレッドの最小数を4に設定し、元の値を非同期 i/o 完了スレッドの最小数に保持します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-440">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f15f1-441">スレッドを制御する機能。</span><span class="sxs-lookup"><span data-stu-id="f15f1-441">for the ability to control threads.</span></span> <span data-ttu-id="f15f1-442">アクセス許可値: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="f15f1-442">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="ThreadCount">
      <MemberSignature Language="C#" Value="public static int ThreadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ThreadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.ThreadCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ThreadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ThreadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadCount : int" Usage="System.Threading.ThreadPool.ThreadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f15f1-443">現在存在しているスレッド プールのスレッド数を取得します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-443">Gets the number of thread pool threads that currently exist.</span></span></summary>
        <value><span data-ttu-id="f15f1-444">現在存在しているスレッドプールスレッドの数。</span><span class="sxs-lookup"><span data-stu-id="f15f1-444">The number of thread pool threads that currently exist.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

<span data-ttu-id="f15f1-445">スレッドプールの実装のスレッドの種類が異なる場合、カウントにはすべての型が含まれます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-445">If a thread pool implementation may have different types of threads, the count includes all types.</span></span>

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="overlapped"><span data-ttu-id="f15f1-446">キューに置く <see cref="T:System.Threading.NativeOverlapped" /> 構造体。</span><span class="sxs-lookup"><span data-stu-id="f15f1-446">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span></span></param>
        <summary><span data-ttu-id="f15f1-447">重複した I/O 操作を、実行するためのキューに置きます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-447">Queues an overlapped I/O operation for execution.</span></span></summary>
        <returns><span data-ttu-id="f15f1-448">操作が I/O 完了ポートのキューに正常に置かれた場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-448"><see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-449">ネイティブ Win32 のオーバーラップ i/o の使用の詳細については、Win32 Platform SDK の <xref:System.Threading.Overlapped> クラス、<xref:System.Threading.NativeOverlapped> 構造体、および `OVERLAPPED` 構造体を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f15f1-449">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f15f1-450"><xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> メソッドを使用すると、セキュリティホールが誤って表示される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-450">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="f15f1-451">コードアクセスセキュリティは、スタック上のすべての呼び出し元のアクセス許可に基づいてアクセス許可をチェックします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-451">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="f15f1-452"><xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>を使用してスレッドプールのスレッドで作業がキューに置かれている場合、スレッドプールのスレッドのスタックには実際の呼び出し元のコンテキストがありません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-452">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="f15f1-453">悪意のあるコードがこれを悪用して、アクセス許可のチェックを回避できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-453">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f15f1-454">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-454">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="f15f1-455">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-455">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="f15f1-456">スレッド プールのスレッドが作業項目を選択したときに呼び出される作業項目。</span><span class="sxs-lookup"><span data-stu-id="f15f1-456">The work item to invoke when a thread in the thread pool picks up the work item.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="f15f1-457">現在のスレッドに近いキューに作業項目を入れる場合は <see langword="true" />。スレッド プールの共有キューに作業項目を入れる場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-457"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="f15f1-458">指定された作業項目オブジェクトをスレッド プールのキューに入れます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-458">Queues the specified work item object to the thread pool.</span></span></summary>
        <returns><span data-ttu-id="f15f1-459">メソッドが成功した場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.OutOfMemoryException" /> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-459"><see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f15f1-460">スレッドプールは、作業項目の <xref:System.Threading.IThreadPoolWorkItem.Execute> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-460">The thread pool will invoke the work item's <xref:System.Threading.IThreadPoolWorkItem.Execute> method.</span></span> <span data-ttu-id="f15f1-461">必要に応じて、その作業項目が <xref:System.Threading.ExecutionContext> に反映される役割を担います。スレッドプールはこれを行いません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-461">It is the responsibility of that work item to propagate <xref:System.Threading.ExecutionContext> if it's needed; the thread pool will not do so.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f15f1-462"><paramref name="callback" /> が <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-462"><paramref name="callback" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f15f1-463">作業項目は <see cref="T:System.Threading.Tasks.Task" /> です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-463">The work item is a <see cref="T:System.Threading.Tasks.Task" />.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f15f1-464">作業項目をキューに配置できません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-464">The work item could not be queued.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="f15f1-465">スレッド プール内のスレッドが作業項目をピック アップするときに呼び出すデリゲートを表す <see cref="T:System.Threading.WaitCallback" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-465">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span></span></param>
        <param name="state"><span data-ttu-id="f15f1-466">スレッド プールから処理されるときにデリゲートに渡されるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-466">The object that is passed to the delegate when serviced from the thread pool.</span></span></param>
        <summary><span data-ttu-id="f15f1-467">指定したデリゲートをスレッド プールのキューに置きます。ただし、コール スタックをワーカー スレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-467">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="f15f1-468">メソッドが成功した場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.OutOfMemoryException" /> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-468"><see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-469"><xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> メソッドとは異なり、<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> は呼び出し元のスタックをワーカースレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-469">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="f15f1-470">これにより、コードは呼び出し履歴を失うことがあり、その結果、セキュリティ特権を昇格させることができます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-470">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f15f1-471"><xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> を使用すると、セキュリティホールを誤って開く可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-471">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="f15f1-472">コードアクセスセキュリティは、スタック上のすべての呼び出し元のアクセス許可に基づいてアクセス許可をチェックします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-472">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="f15f1-473"><xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>を使用してスレッドプールのスレッドで作業がキューに置かれている場合、スレッドプールのスレッドのスタックには実際の呼び出し元のコンテキストがありません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-473">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="f15f1-474">悪意のあるコードがこれを悪用して、アクセス許可のチェックを回避できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-474">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f15f1-475">呼び出し元に、必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-475">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="f15f1-476">メモリが不足しています。</span><span class="sxs-lookup"><span data-stu-id="f15f1-476">An out-of-memory condition was encountered.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="f15f1-477">作業項目をキューに配置できません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-477">The work item could not be queued.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f15f1-478"><paramref name="callBack" /> が <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-478"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f15f1-479">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-479">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="f15f1-480">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-480">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="f15f1-481">マネージド スレッド プール</span><span class="sxs-lookup"><span data-stu-id="f15f1-481">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><span data-ttu-id="f15f1-482"><paramref name="state" /> の要素の型。</span><span class="sxs-lookup"><span data-stu-id="f15f1-482">The type of elements of <paramref name="state" />.</span></span></typeparam>
        <param name="callBack"><span data-ttu-id="f15f1-483">実行するメソッドを表すデリゲート。</span><span class="sxs-lookup"><span data-stu-id="f15f1-483">A delegate representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="f15f1-484">メソッドが使用するデータを格納したオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-484">An object containing data to be used by the method.</span></span></param>
        <param name="preferLocal"><span data-ttu-id="f15f1-485">現在のスレッドに近いキューに作業項目を入れる場合は <see langword="true" />。スレッド プールの共有キューに作業項目を入れる場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-485"><see langword="true" /> to prefer queueing the work item in a queue close to the current thread; <see langword="false" /> to prefer queueing the work item to the thread pool's shared queue.</span></span></param>
        <summary><span data-ttu-id="f15f1-486">実行用に <see cref="T:System.Action`1" /> デリゲートで指定したメソッドをキューに入れ、そのメソッドで使用するデータを含んだオブジェクトを指定します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-486">Queues a method specified by an <see cref="T:System.Action`1" /> delegate for execution, and specifies an object containing data to be used by the method.</span></span> <span data-ttu-id="f15f1-487">メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-487">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="f15f1-488">メソッドが正常にキューに配置された場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.NotSupportedException" /> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-488"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f15f1-489"><paramref name="callback" /> が <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-489"><paramref name="callback" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f15f1-490">作業項目をキューに配置できません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-490">The work item could not be queued.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f15f1-491"><see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。ただし、コール スタックをワーカー スレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-491">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="f15f1-492">登録する <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-492">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="f15f1-493"><see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-493">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="f15f1-494"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出すデリゲート。</span><span class="sxs-lookup"><span data-stu-id="f15f1-494">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="f15f1-495">デリゲートに渡されるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-495">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="f15f1-496">ミリ秒単位のタイムアウト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-496">The time-out in milliseconds.</span></span> <span data-ttu-id="f15f1-497"><paramref name="millisecondsTimeOutInterval" /> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-497">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="f15f1-498"><paramref name="millisecondsTimeOutInterval" /> が -1 の場合、関数はタイムアウトしません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-498">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="f15f1-499">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-499"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="f15f1-500">ミリ秒単位のタイムアウトとして 32 ビット符号付き整数を使用して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-500">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="f15f1-501">このメソッドはコール スタックをワーカー スレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-501">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="f15f1-502">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-502">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-503"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドとは異なり、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> は呼び出し元のスタックをワーカースレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-503">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="f15f1-504">これにより、コードは呼び出し履歴を失うことがあり、その結果、セキュリティ特権を昇格させることができます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-504">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f15f1-505"><xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> を使用すると、セキュリティホールを誤って開く可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-505">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="f15f1-506">コードアクセスセキュリティは、スタック上のすべての呼び出し元のアクセス許可に基づいてアクセス許可をチェックします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-506">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="f15f1-507"><xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>を使用してスレッドプールのスレッドで作業がキューに置かれている場合、スレッドプールのスレッドのスタックには実際の呼び出し元のコンテキストがありません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-507">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="f15f1-508">悪意のあるコードがこれを悪用して、アクセス許可のチェックを回避できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-508">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="f15f1-509">`waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-509">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="f15f1-510">このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-510">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="f15f1-511">`executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-511">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="f15f1-512">登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-512">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f15f1-513"><paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span><span class="sxs-lookup"><span data-stu-id="f15f1-513">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f15f1-514">呼び出し元に、必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-514">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f15f1-515">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-515">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="f15f1-516">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-516">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="f15f1-517">マネージド スレッド プール</span><span class="sxs-lookup"><span data-stu-id="f15f1-517">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="f15f1-518">登録する <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-518">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="f15f1-519"><see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-519">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="f15f1-520"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出すデリゲート。</span><span class="sxs-lookup"><span data-stu-id="f15f1-520">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="f15f1-521">デリゲートに渡されるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-521">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="f15f1-522">ミリ秒単位のタイムアウト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-522">The time-out in milliseconds.</span></span> <span data-ttu-id="f15f1-523"><paramref name="millisecondsTimeOutInterval" /> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-523">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="f15f1-524"><paramref name="millisecondsTimeOutInterval" /> が -1 の場合、関数はタイムアウトしません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-524">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="f15f1-525">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-525"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="f15f1-526">64 ビット符号付き整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-526">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="f15f1-527">このメソッドはコール スタックをワーカー スレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-527">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="f15f1-528">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-528">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-529"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドとは異なり、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> は呼び出し元のスタックをワーカースレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-529">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="f15f1-530">これにより、コードは呼び出し履歴を失うことがあり、その結果、セキュリティ特権を昇格させることができます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-530">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f15f1-531"><xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> を使用すると、セキュリティホールを誤って開く可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-531">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="f15f1-532">コードアクセスセキュリティは、スタック上のすべての呼び出し元のアクセス許可に基づいてアクセス許可をチェックします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-532">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="f15f1-533"><xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>を使用してスレッドプールのスレッドで作業がキューに置かれている場合、スレッドプールのスレッドのスタックには実際の呼び出し元のコンテキストがありません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-533">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="f15f1-534">悪意のあるコードがこれを悪用して、アクセス許可のチェックを回避できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-534">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="f15f1-535">`waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-535">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="f15f1-536">このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-536">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="f15f1-537">`executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-537">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="f15f1-538">登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-538">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f15f1-539"><paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span><span class="sxs-lookup"><span data-stu-id="f15f1-539">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f15f1-540">呼び出し元に、必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-540">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f15f1-541">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-541">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="f15f1-542">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-542">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="f15f1-543">マネージド スレッド プール</span><span class="sxs-lookup"><span data-stu-id="f15f1-543">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="f15f1-544">登録する <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-544">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="f15f1-545"><see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-545">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="f15f1-546"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出すデリゲート。</span><span class="sxs-lookup"><span data-stu-id="f15f1-546">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="f15f1-547">デリゲートに渡されるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-547">The object that is passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="f15f1-548"><see cref="T:System.TimeSpan" /> で表されるタイムアウト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-548">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="f15f1-549"><paramref name="timeout" /> が 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-549">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="f15f1-550"><paramref name="timeout" /> が -1 の場合、関数はタイムアウトしません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-550">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="f15f1-551">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-551"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="f15f1-552"><see cref="T:System.TimeSpan" /> 値をタイムアウトとして指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。このメソッドはコール スタックをワーカー スレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-552">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="f15f1-553">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-553">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-554"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドとは異なり、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> は呼び出し元のスタックをワーカースレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-554">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="f15f1-555">これにより、コードは呼び出し履歴を失うことがあり、その結果、セキュリティ特権を昇格させることができます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-555">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f15f1-556"><xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> を使用すると、セキュリティホールを誤って開く可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-556">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="f15f1-557">コードアクセスセキュリティは、スタック上のすべての呼び出し元のアクセス許可に基づいてアクセス許可をチェックします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-557">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="f15f1-558"><xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>を使用してスレッドプールのスレッドで作業がキューに置かれている場合、スレッドプールのスレッドのスタックには実際の呼び出し元のコンテキストがありません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-558">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="f15f1-559">悪意のあるコードがこれを悪用して、アクセス許可のチェックを回避できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-559">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="f15f1-560">`waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-560">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="f15f1-561">このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-561">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="f15f1-562">`executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-562">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="f15f1-563">登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-563">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f15f1-564"><paramref name="timeout" /> パラメーターが -1 未満。</span><span class="sxs-lookup"><span data-stu-id="f15f1-564">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f15f1-565"><paramref name="timeout" /> パラメーターが <see cref="F:System.Int32.MaxValue" /> より大きい値です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-565">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f15f1-566">呼び出し元に、必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-566">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f15f1-567">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-567">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="f15f1-568">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-568">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="f15f1-569">マネージド スレッド プール</span><span class="sxs-lookup"><span data-stu-id="f15f1-569">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="f15f1-570">登録する <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-570">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="f15f1-571"><see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-571">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="f15f1-572"><paramref name="waitObject" /> パラメーターがシグナル通知されたときに呼び出すデリゲート。</span><span class="sxs-lookup"><span data-stu-id="f15f1-572">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="f15f1-573">デリゲートに渡されるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-573">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="f15f1-574">ミリ秒単位のタイムアウト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-574">The time-out in milliseconds.</span></span> <span data-ttu-id="f15f1-575"><paramref name="millisecondsTimeOutInterval" /> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-575">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="f15f1-576"><paramref name="millisecondsTimeOutInterval" /> が -1 の場合、関数はタイムアウトしません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-576">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="f15f1-577">デリゲートの呼び出し後、スレッドが <paramref name="waitObject" /> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="f15f1-577"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="f15f1-578">32 ビット符号なし整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-578">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span> <span data-ttu-id="f15f1-579">このメソッドはコール スタックをワーカー スレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-579">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="f15f1-580">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="f15f1-580">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f15f1-581"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> メソッドとは異なり、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> は呼び出し元のスタックをワーカースレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-581">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="f15f1-582">これにより、コードは呼び出し履歴を失うことがあり、その結果、セキュリティ特権を昇格させることができます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-582">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f15f1-583"><xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> を使用すると、セキュリティホールを誤って開く可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-583">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="f15f1-584">コードアクセスセキュリティは、スタック上のすべての呼び出し元のアクセス許可に基づいてアクセス許可をチェックします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-584">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="f15f1-585"><xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>を使用してスレッドプールのスレッドで作業がキューに置かれている場合、スレッドプールのスレッドのスタックには実際の呼び出し元のコンテキストがありません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-585">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="f15f1-586">悪意のあるコードがこれを悪用して、アクセス許可のチェックを回避できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f15f1-586">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="f15f1-587">`waitObject` に <xref:System.Threading.Mutex> を使用すると、基になる Windows API で既定の `WT_EXECUTEDEFAULT` フラグが使用されるため、コールバックの相互排他が提供されません。そのため、各コールバックは個別のスレッドプールスレッドでディスパッチされます。</span><span class="sxs-lookup"><span data-stu-id="f15f1-587">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Windows API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="f15f1-588">このメソッドによって返される <xref:System.Threading.RegisteredWaitHandle> の使用が終了したら、その <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出して、待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-588">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="f15f1-589">`executeOnlyOnce`に `true` を指定した場合でも、常に <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f15f1-589">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="f15f1-590">登録されている待機ハンドルのファイナライザーに依存するのではなく、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> メソッドを呼び出すと、ガベージコレクションの方が効率的に動作します。</span><span class="sxs-lookup"><span data-stu-id="f15f1-590">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f15f1-591">呼び出し元に、必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-591">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="f15f1-592">直前の呼び出し元に完全信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="f15f1-592">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="f15f1-593">このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="f15f1-593">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="f15f1-594">マネージド スレッド プール</span><span class="sxs-lookup"><span data-stu-id="f15f1-594">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
