<Type Name="EditingCommands" FullName="System.Windows.Documents.EditingCommands">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3952c6422d11625c3e926c21b1f329167434d4b1" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83948583" /></Metadata><TypeSignature Language="C#" Value="public static class EditingCommands" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EditingCommands extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.EditingCommands" />
  <TypeSignature Language="VB.NET" Value="Public Class EditingCommands" />
  <TypeSignature Language="C++ CLI" Value="public ref class EditingCommands abstract sealed" />
  <TypeSignature Language="F#" Value="type EditingCommands = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>一連の標準的な編集関連コマンドを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、編集コマンドと、関連付けられている既定のキージェスチャ (<xref:System.Windows.Input.Key> および <xref:System.Windows.Input.ModifierKeys> 列挙型のキー名を含む) を示します。  
  
|編集コマンド|既定のキージェスチャ|  
|---------------------|-------------------------|  
|<xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>|`Ctrl`+`E`|  
|<xref:System.Windows.Documents.EditingCommands.AlignJustify%2A>|`Ctrl`+`J`|  
|<xref:System.Windows.Documents.EditingCommands.AlignLeft%2A>|`Ctrl`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.AlignRight%2A>|`Ctrl`+`R`|  
|<xref:System.Windows.Documents.EditingCommands.Backspace%2A>|`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A>|既定のキージェスチャはありません|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A>|`Ctrl`+`OemOpenBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>|`Ctrl`+`Shift`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.Delete%2A>|`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A>|`Ctrl`+`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A>|`Ctrl`+`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A>|`Shift`+`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A>|`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A>|既定のキージェスチャはありません|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A>|`Ctrl`+`OemCloseBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>|`Ctrl`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A>|`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A>|`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A>|`Ctrl`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>|`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A>|`Ctrl`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A>|`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A>|`Ctrl`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>|`Ctrl`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>|`Ctrl`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A>|`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A>|`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A>|`Up`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A>|`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A>|`Ctrl`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A>|`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A>|`Shift`+`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A>|`Ctrl`+`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>|`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>|`Ctrl`+`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A>|`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>|`Ctrl`+`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A>|`Ctrl`+`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A>|`Ctrl`+`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A>|`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A>|`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A>|`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A>|`Shift`+`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A>|`Ctrl`+`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.TabBackward%2A>|`Shift`+`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.TabForward%2A>|`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBold%2A>|`Ctrl`+`B`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A>|`Ctrl`+`Shift`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A>|`Insert`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A>|`Ctrl`+`I`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A>|`Ctrl`+`Shift`+`N`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A>|`Ctrl`+`OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A>|`Ctrl`+`Shift+OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A>|`Ctrl`+`U`|  
  
 カーソル移動コマンドと選択範囲の展開コマンドは、既定のキージェスチャの共通セットを共有します。一般的な違いは、選択コマンドをキャレット移動コマンドと区別するために <xref:System.Windows.Input.ModifierKeys.Shift> キーを追加することです。  たとえば、<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A> コマンドは <xref:System.Windows.Input.Key.Left>の既定のキージェスチャを持ち、対応する <xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A> コマンドには <xref:System.Windows.Input.ModifierKeys.Shift>+<xref:System.Windows.Input.Key.Left>の既定のキージェスチャがあります。  
  
 一般に、<xref:System.Windows.Documents.EditingCommands> クラスによって提供されるコマンド定義では、コマンドパラメーター (<xref:System.Windows.Input.ICommand.Execute%2A> メソッドによって予期される `parameter` パラメーター) は使用されません。  
  
 コマンドとコマンドの詳細については、「[入力の概要](/dotnet/framework/wpf/advanced/input-overview)」を参照してください。  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.MediaCommands" />
    <altmember cref="T:System.Windows.Input.ApplicationCommands" />
    <altmember cref="T:System.Windows.Input.ComponentCommands" />
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.CommandManager" />
    <altmember cref="T:System.Windows.Input.NavigationCommands" />
  </Docs>
  <Members>
    <Member MemberName="AlignCenter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignCenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignCenter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignCenter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignCenter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の段落または段落の選択範囲を中央揃えで配置するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.AlignCenter" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="E" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコマンドは、<xref:System.Windows.Documents.Paragraph> レベルで動作します。  段落内のコンテンツを部分的に選択したときにこのコマンドが呼び出された場合 (キャレットが段落内にある場合は空の選択を含む)、要求された効果は段落全体に適用されます。  複数の段落にわたる選択に対してこのコマンドを呼び出すと、選択範囲に含まれる各段落の内容全体に効果が適用されます。  
  
 次の図は、中央のコンテンツの例を示しています。  
  
 ![スクリーンショット: 中央の TextAlign プロパティ値](~/add/media/flowdoc-textalign-center.png "スクリーンショット: 中央の TextAlign プロパティ値")  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_AlignCenter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="AlignCenter"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignJustify">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignJustify { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignJustify" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignJustify As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignJustify { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignJustify : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の段落または段落の選択範囲を両端揃えで配置するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.AlignJustify" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="J" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコマンドは、<xref:System.Windows.Documents.Paragraph> レベルで動作します。  段落内のコンテンツを部分的に選択したときにこのコマンドが呼び出された場合 (キャレットが段落内にある場合は空の選択を含む)、要求された効果は段落全体に適用されます。  複数の段落にまたがる選択範囲でこのコマンドが呼び出された場合、その効果は選択範囲内のすべての段落に適用されます。  
  
 コンテンツが正当化されると、各コンテンツ行の左右の間隔が調整され、両端の幅が等しいか、またはほぼ同じになります。  コンテンツは、通常、コンテンツの両側に滑らかなエッジを作成するために配置されます。  
  
 多くの場合、このコマンドが呼び出されると、段落の最後の行が unjustified のままになる可能性があります。  
  
 次の図は、unjustified (左揃え) コンテンツを示しています。  
  
 ![スクリーンショット: コンテンツは unjustified](~/add/media/content-unjustified.png "スクリーンショット: 内容が揃っていません")  
  
 次の図は、均等になった後の同じコンテンツを示しています。  
  
 ![コンテンツの両端揃えのテキストのスクリーンショット](~/add/media/content-justified.png "内容を再配置したテキストのスクリーンショット")  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_AlignJustify"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="AlignJustify"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignLeft : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コンテンツの選択範囲を左揃えで配置するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.AlignLeft" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="L" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコマンドは、<xref:System.Windows.Documents.Paragraph> レベルで動作します。  段落内のコンテンツを部分的に選択したときにこのコマンドが呼び出された場合 (キャレットが段落内にある場合は空の選択を含む)、要求された効果は段落全体に適用されます。  複数の段落にわたる選択に対してこのコマンドを呼び出すと、選択範囲に含まれる各段落の内容全体に効果が適用されます。  
  
 次の図は、左揃えのコンテンツの例を示しています。  
  
 ![スクリーンショット: Left の TextAlign プロパティ値](~/add/media/flowdoc-textalign-left.png "スクリーンショット: TextAlign プロパティ値が Left の場合")  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_AlignLeft"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="AlignLeft"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignRight : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コンテンツの選択範囲を右揃えで配置するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.AlignRight" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="R" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコマンドは、<xref:System.Windows.Documents.Paragraph> レベルで動作します。  段落内のコンテンツを部分的に選択したときにこのコマンドが呼び出された場合 (キャレットが段落内にある場合は空の選択を含む)、要求された効果は段落全体に適用されます。  複数の段落にわたる選択に対してこのコマンドを呼び出すと、選択範囲に含まれる各段落の内容全体に効果が適用されます。  
  
 次の図は、右上に並べられたコンテンツの例を示しています。  
  
 ![スクリーンショット: 右詰めの値](~/add/media/flowdoc-textalign-right.png "スクリーンショット: 右の TextAlign 値")  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_AlignRight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="AlignRight"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="Backspace">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Backspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Backspace" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Backspace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Backspace As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Backspace { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Backspace : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Backspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>BackSpace を現在の位置または現在の選択範囲に対して入力するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.Backspace" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは、<see langword="Backspace" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 空の選択で呼び出された場合、このコマンドはカレットの直前にある文字または段落の区切り記号を削除します。 空でない選択で呼び出されると、このコマンドによって選択が削除されます。  
  
 このコマンドを実行すると、同じ場所に直ちに挿入されたコンテンツのすべての書式設定が削除されます。  <xref:System.Windows.Documents.EditingCommands.Delete%2A> コマンドとは対照的です。これは以前の書式設定を保持しません。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_Backspace"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="Backspace"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CorrectSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand CorrectSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand CorrectSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CorrectSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ CorrectSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CorrectSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の位置にあるスペル ミスの単語を修正するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドには、既定のキー ジェスチャはありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
<a name="xamlAttributeUsage_CorrectSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="CorrectSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲のフォント サイズを 1 ポイント縮小するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="OemOpenBrackets" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カーソルが単語内にある空の選択に対してこのコマンドが呼び出された場合、その選択は自動的に展開され、単語全体にコマンドが適用されます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_DecreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="DecreaseFontSize"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の段落のインデントを 1 タブ位置分減らすよう要求する <see cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは +<see langword="Shift" />+<see langword="T" /><see langword="Ctrl" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox>でネイティブにサポートされています。  
  
> [!IMPORTANT]
>  このコマンドは、テキスト要素の <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> プロパティが `true`に設定されている場合を除き、テキスト要素には影響しません。  
  
<a name="xamlAttributeUsage_DecreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="DecreaseIndentation"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Delete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Delete" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Delete As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Delete { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Delete : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Delete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲を削除するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.Delete" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは、<see langword="Delete" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコマンドは、削除された選択項目から書式設定を破棄します。  <xref:System.Windows.Documents.EditingCommands.Backspace%2A> コマンドとは対照的に、このコマンドが呼び出された後、同じ場所に直ちに挿入されたコンテンツに対して、削除された選択項目から書式設定を保持します。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_Delete"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="Delete"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteNextWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeleteNextWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeleteNextWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeleteNextWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeleteNextWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeleteNextWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の位置から見て次の単語を削除するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="Delete" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カーソルが単語内にある場合は、現在の位置と単語の末尾との間の単語の残りの部分が削除されます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_DeleteNextWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="DeleteNextWord"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="DeletePreviousWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeletePreviousWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeletePreviousWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeletePreviousWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeletePreviousWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeletePreviousWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の位置から見て前の単語を削除するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="Backspace" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カーソルが単語内にある場合は、現在位置と単語の先頭との間の単語の残りの部分が削除されます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_DeletePreviousWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="DeletePreviousWord"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="EnterLineBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterLineBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterLineBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterLineBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterLineBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterLineBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>改行を現在の位置または現在の選択範囲に対して挿入するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="Enter" />+<see langword="Shift" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.RichTextBox>などのフローコンテンツをサポートするエディターでは、このコマンドによって、<xref:System.Windows.Documents.LineBreak> 要素が現在の位置に挿入されます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_EnterLineBreak"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="EnterLineBreak"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      </Docs>
    </Member>
    <Member MemberName="EnterParagraphBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterParagraphBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterParagraphBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterParagraphBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterParagraphBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterParagraphBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>段落区切りを現在の位置または現在の選択範囲を超えた位置に挿入するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは、<see langword="Enter" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコマンドは、ユーザーが ENTER キーを押すことに相当します。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox> でネイティブにサポートされています (<xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> プロパティが `true`の場合)。  
  
> [!IMPORTANT]
>  このコマンドは、テキスト要素の <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> プロパティが `true`に設定されている場合を除き、テキスト要素には影響しません。  
  
<a name="xamlAttributeUsage_EnterParagraphBreak"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="EnterParagraphBreak"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IgnoreSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IgnoreSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IgnoreSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IgnoreSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の位置または現在の選択範囲内にあるスペル ミスの単語をすべて無視するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドには、既定のキー ジェスチャはありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
<a name="xamlAttributeUsage_IgnoreSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="IgnoreSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲のフォント サイズを 1 ポイント拡大するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="OemCloseBrackets" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カーソルが単語内にある空の選択に対してこのコマンドを呼び出すと、その選択内容が拡張され、単語全体にコマンドが適用されます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_IncreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="IncreaseFontSize"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の段落のインデントを 1 タブ位置分増やすよう要求する <see cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="T" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox>でネイティブにサポートされています。  
  
> [!IMPORTANT]
>  このコマンドは、テキスト要素の <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> プロパティが `true`に設定されている場合を除き、テキスト要素には影響しません。  
  
<a name="xamlAttributeUsage_IncreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="IncreaseIndentation"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャレットを 1 行下に移動するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは、<see langword="Down" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_MoveDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="MoveDownByLine"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャレットを 1 ページ下に移動するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは、<see langword="PageDown" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_MoveDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="MoveDownByPage"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャレットを 1 段落下に移動するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="Down" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコマンドは、次の段落の先頭にカレットを配置します。  
  
 このコマンドは、<xref:System.Windows.Controls.TextBox>で呼び出されたときに <xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A> のように動作します。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_MoveDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="MoveDownByParagraph"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャレットを 1 文字左に移動するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは、<see langword="Left" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_MoveLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="MoveLeftByCharacter"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャレットを 1 語左に移動するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="Left" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カレットが単語内にある場合、このコマンドはカレットをその単語の先頭に移動します。  それ以外の場合、このコマンドはカレットを前の単語の先頭に移動します。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_MoveLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="MoveLeftByWord"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャレットを 1 文字右に移動するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは、<see langword="Right" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_MoveRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="MoveRightByCharacter"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャレットを 1 語右に移動するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="Right" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カレットが単語内にある場合、このコマンドはカレットをその単語の末尾に移動します。  それ以外の場合、このコマンドはカレットを次の単語の先頭に移動します。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_MoveRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="MoveRightByWord"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャレットをコンテンツの末尾に移動するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="End" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *テキストコンテナー*は、手動でコンテンツの最終的な境界線を形成する要素です。  <xref:System.Windows.Controls.TextBlock> と <xref:System.Windows.Documents.FlowDocument> は、テキストコンテナーの例です。  テキストコンテナー内にまとめて含まれるコンテンツは、*ドキュメント*と呼ばれます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_MoveToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="MoveToDocumentEnd"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャレットをコンテンツの先頭に移動するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="Home" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *テキストコンテナー*は、手動でコンテンツの最終的な境界線を形成する要素です。  <xref:System.Windows.Controls.TextBlock> と <xref:System.Windows.Documents.FlowDocument> は、テキストコンテナーの例です。  テキストコンテナー内にまとめて含まれるコンテンツは、*ドキュメント*と呼ばれます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_MoveToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="MoveToDocumentStart"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャレットを現在の行の末尾に移動するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは、<see langword="End" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_MoveToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="MoveToLineEnd"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャレットを現在の行の先頭に移動するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは、<see langword="Home" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_MoveToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="MoveToLineStart"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャレットを 1 行上に移動するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは、<see langword="Up" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_MoveUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="MoveUpByLine"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャレットを 1 ページ上に移動するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは、<see langword="PageUp" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_MoveUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="MoveUpByPage"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キャレットを 1 段落上に移動するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="Up" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコマンドは、次の段落の先頭にカレットを配置します。  
  
 このコマンドは、<xref:System.Windows.Controls.TextBox>で呼び出されたときに <xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A> のように動作します。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_MoveUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="MoveUpByParagraph"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲を 1 行下に拡張するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="Down" />+<see langword="Shift" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_SelectDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="SelectDownByLine"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲を 1 ページ下に拡張するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="PageDown" />+<see langword="Shift" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_SelectDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="SelectDownByPage"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲を 1 段落下に拡張するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは +<see langword="Shift" />+<see langword="Down" /><see langword="Ctrl" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコマンドは、選択範囲を次の段落の先頭まで拡大します。  それ以外の場合、このコマンドは選択範囲を現在の段落の最後まで拡大します。  展開された選択範囲には、段落の末尾を示す段落区切りが含まれます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_SelectDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="SelectDownByParagraph"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲を 1 文字左に拡張するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="Left" />+<see langword="Shift" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_SelectLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="SelectLeftByCharacter"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲を 1 語左に拡張するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは +<see langword="Shift" />+<see langword="Left" /><see langword="Ctrl" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カーソルが単語内にある場合、このコマンドは選択範囲をその単語の先頭まで拡大します。  それ以外の場合、このコマンドは選択範囲を前の単語の先頭まで拡大します。  
  
 展開された選択範囲には、単語区切り記号は含まれません。  <xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>とは対照的に、展開された選択範囲には単語区切り記号が含まれます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_SelectLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="SelectLeftByWord"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲を 1 文字右に拡張するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="Right" />+<see langword="Shift" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_SelectRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="SelectRightByCharacter"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲を 1 語右に拡張するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは +<see langword="Shift" />+<see langword="Right" /><see langword="Ctrl" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カーソルが単語内にある場合、このコマンドは選択範囲をその単語の末尾まで拡張します。  それ以外の場合、このコマンドは選択範囲を次の単語の最後まで拡大します。  
  
 展開された選択範囲には、区切り記号が含まれます。  展開された選択範囲に単語区切り記号が含まれていない <xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A> と比較します。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_SelectRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="SelectRightByWord"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲をコンテンツの末尾まで拡張するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは +<see langword="Shift" />+<see langword="End" /><see langword="Ctrl" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *テキストコンテナー*は、手動でコンテンツの最終的な境界線を形成する要素です。  <xref:System.Windows.Controls.TextBlock> と <xref:System.Windows.Documents.FlowDocument> は、テキストコンテナーの例です。  テキストコンテナー内にまとめて含まれるコンテンツは、*ドキュメント*と呼ばれます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_SelectToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="SelectToDocumentEnd"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲をコンテンツの先頭まで拡張するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは +<see langword="Shift" />+<see langword="Home" /><see langword="Ctrl" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *テキストコンテナー*は、手動でコンテンツの最終的な境界線を形成する要素です。  <xref:System.Windows.Controls.TextBlock> と <xref:System.Windows.Documents.FlowDocument> は、テキストコンテナーの例です。  テキストコンテナー内にまとめて含まれるコンテンツは、*ドキュメント*と呼ばれます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_SelectToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="SelectToDocumentStart"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲を現在の行の末尾まで拡張するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="End" />+<see langword="Shift" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_SelectToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="SelectToLineEnd"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲を現在の行の先頭まで拡張するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="Home" />+<see langword="Shift" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_SelectToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="SelectToLineStart"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲を 1 行上に拡張するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="Up" />+<see langword="Shift" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_SelectUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="SelectUpByLine"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲を 1 ページ上に拡張するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="PageUp" />+<see langword="Shift" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_SelectUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="SelectUpByPage"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲を 1 段落上に拡張するよう要求する <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは +<see langword="Shift" />+<see langword="Up" /><see langword="Ctrl" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カーソルが段落の先頭にある場合、このコマンドは選択範囲を前の段落の先頭まで拡大します。  それ以外の場合、このコマンドは選択範囲を現在の段落の先頭まで拡大します。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_SelectUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="SelectUpByParagraph"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="TabBackward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabBackward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabBackward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabBackward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabBackward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabBackward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.TabBackward" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="Tab" />+<see langword="Shift" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコマンドの動作は、現在選択されている内容によって異なります。 選択範囲が空でない場合、このコマンドは <xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>に相当します。 カーソルが (<xref:System.Windows.Documents.TableCell> 要素によって表される) テーブルセルにある場合、このコマンドはカレットを前のセルに移動します。 それ以外の場合は、現在位置にタブ文字が挿入されます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox> でネイティブにサポートされています (<xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> プロパティが `true`の場合)。  
  
<a name="xamlAttributeUsage_TabBackward"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="TabBackward"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabForward" />
      </Docs>
    </Member>
    <Member MemberName="TabForward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabForward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabForward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabForward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabForward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.TabForward" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは、<see langword="Tab" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコマンドの動作は、現在選択されている内容によって異なります。 選択範囲が空でない場合、または選択範囲が空で、現在のキャレット位置が段落の先頭にある場合、このコマンドは <xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>に相当します。 カーソルが (<xref:System.Windows.Documents.TableCell> 要素によって表される) テーブルセルにある場合、このコマンドはカレットを次のセルに移動します。 カーソルがテーブルの最後のセルにある場合、このコマンドを実行すると新しい行がテーブルに追加され、カレットが新しい行の最初のセルに配置されます。  それ以外の場合は、現在位置にタブ文字が挿入されます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox> と <xref:System.Windows.Controls.TextBox> でネイティブにサポートされています (<xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> プロパティが `true`の場合)。  
  
<a name="xamlAttributeUsage_TabForward"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="TabForward"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabBackward" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBold">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBold { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBold" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBold As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBold { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBold : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲に対して <see cref="P:System.Windows.Documents.EditingCommands.ToggleBold" /> の書式設定を切り替えるよう要求する <see cref="T:System.Windows.Documents.Bold" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="B" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の選択範囲の <xref:System.Windows.FontWeight> が <xref:System.Windows.FontWeights.Thin%2A> から <xref:System.Windows.FontWeights.SemiBold%2A>までの範囲内にある場合、<xref:System.Windows.FontWeights.Bold%2A> が現在の選択項目に適用されます。  それ以外の場合、<xref:System.Windows.FontWeights.Normal%2A> が適用されます。  <xref:System.Windows.FontWeight> 値の比較一覧については、「<xref:System.Windows.FontWeights>」を参照してください。  
  
 選択範囲が空でカレットが単語内にある場合は、単語全体を含むように選択範囲が拡張されます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_ToggleBold"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="ToggleBold"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBullets">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBullets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBullets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBullets As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBullets { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBullets : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲に対して順序の付いていないリスト (箇条書きリスト) の書式設定を切り替えるよう要求する <see cref="P:System.Windows.Documents.EditingCommands.ToggleBullets" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは +<see langword="Shift" />+<see langword="L" /><see langword="Ctrl" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコマンドは、<xref:System.Windows.Documents.Paragraph> レベルで動作します。  段落内のコンテンツを部分的に選択したときにこのコマンドが呼び出された場合 (キャレットが段落内にある場合は空の選択を含む)、要求された効果は段落全体に適用されます。  複数の段落にわたる選択に対してこのコマンドを呼び出すと、選択範囲に含まれる各段落の内容全体に効果が適用されます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_ToggleBullets"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="ToggleBullets"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      </Docs>
    </Member>
    <Member MemberName="ToggleInsert">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleInsert { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleInsert" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleInsert As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleInsert { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleInsert : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>挿入と上書きの入力モードを切り替える <see cref="P:System.Windows.Documents.EditingCommands.ToggleInsert" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキー ジェスチャは、<see langword="Insert" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは、<xref:System.Windows.Controls.RichTextBox>、<xref:System.Windows.Controls.TextBox>、および <xref:System.Windows.Controls.PasswordBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_ToggleInsert"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="ToggleInsert"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalic">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleItalic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleItalic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleItalic As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleItalic { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleItalic : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲に対して <see cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" /> の書式設定を切り替えるよう要求する <see cref="T:System.Windows.Documents.Italic" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="I" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の選択範囲の <xref:System.Windows.FontStyle> が <xref:System.Windows.FontStyles.Normal%2A>場合は、現在の選択項目に <xref:System.Windows.FontStyles.Italic%2A> が適用されます。  それ以外の場合、<xref:System.Windows.FontStyles.Normal%2A> が適用されます。  
  
 選択範囲が空でカレットが単語内にある場合は、単語全体を含むように選択範囲が拡張されます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_ToggleItalic"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="ToggleItalic"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleNumbering">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleNumbering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleNumbering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleNumbering As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleNumbering { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleNumbering : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲に対して順序付きリスト (番号付きリスト) の書式設定を切り替えるよう要求する <see cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは +<see langword="Shift" />+<see langword="N" /><see langword="Ctrl" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコマンドは、<xref:System.Windows.Documents.Paragraph> レベルで動作します。  段落内のコンテンツを部分的に選択したときにこのコマンドが呼び出された場合 (キャレットが段落内にある場合は空の選択を含む)、要求された効果は段落全体に適用されます。  複数の段落にわたる選択に対してこのコマンドを呼び出すと、選択範囲に含まれる各段落の内容全体に効果が適用されます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_ToggleNumbering"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="ToggleNumbering"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSubscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSubscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSubscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSubscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSubscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSubscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲に対して下付き文字の書式設定を切り替えるよう要求する <see cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="OemPlus" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
<a name="xamlAttributeUsage_ToggleSubscript"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="ToggleSubscript"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSuperscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSuperscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSuperscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSuperscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSuperscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSuperscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲に対して上付き文字の書式設定を切り替えるよう要求する <see cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは +<see langword="Shift" />+<see langword="OemPlus" /><see langword="Ctrl" />ます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
<a name="xamlAttributeUsage_ToggleSuperscript"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="ToggleSuperscript"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleUnderline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleUnderline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleUnderline As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleUnderline { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleUnderline : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の選択範囲に対して <see cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" /> の書式設定を切り替えるよう要求する <see cref="T:System.Windows.Documents.Underline" /> コマンドを表します。</summary>
        <value>要求されたコマンド。  このコマンドの既定のキージェスチャは <see langword="U" />+<see langword="Ctrl" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 選択範囲が空でカレットが単語内にある場合は、単語全体を含むように選択範囲が拡張されます。  
  
 特定のオブジェクトでは、このコマンドに応答する実際の実装は必ずしも必要ではありません。多くの場合、コマンドに応答する実装は、アプリケーションライターの役割です。  
  
 このコマンドは <xref:System.Windows.Controls.RichTextBox>でネイティブにサポートされています。  
  
<a name="xamlAttributeUsage_ToggleUnderline"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用  
  
```  
<object property="ToggleUnderline"/>  
```  
  
   
  
## Examples  
 次の例は、コマンドをサポートするオブジェクトで編集コマンドを呼び出す方法を示しています。  
  
 この例では、<xref:System.Windows.Controls.RichTextBox> はコマンドターゲットとして機能します。  <xref:System.Windows.Controls.RichTextBox> は、(<xref:System.Windows.FrameworkElement>から継承された) <xref:System.Windows.IInputElement> インターフェイスを実装し、多くの編集コマンドのネイティブサポートが含まれていることに注意してください。  
  
 <xref:System.Windows.Input.RoutedCommand.Execute%2A> メソッドの最初の引数は、コマンドパラメーターです。  ほとんどの編集コマンドは、コマンドパラメーターを無視します。一般に、このパラメーターは編集コマンドに `null` 必要があります。  
  
 2番目の引数は、コマンドがルーティングされるオブジェクトを指定します。  このオブジェクトは、<xref:System.Windows.IInputElement> インターフェイスを実装する必要があります。また、指定したコマンドのハンドラーを含める必要があります。  通常、コマンドを処理しないオブジェクトで呼び出されると、コマンドは無視されます。  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
  </Members>
</Type>
