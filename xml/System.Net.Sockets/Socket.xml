<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c88112a3343021a4aad0bad923e47c3c5b760806" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75026626" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Berkeley ソケット インターフェイスを実装します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> クラスは、ネットワーク通信用の豊富なメソッドとプロパティのセットを提供します。 <xref:System.Net.Sockets.Socket> クラスを使用すると、<xref:System.Net.Sockets.ProtocolType> 列挙に示されているいずれかの通信プロトコルを使用して、同期データ転送と非同期データ転送の両方を実行できます。  
  
 <xref:System.Net.Sockets.Socket> クラスは、非同期メソッドの .NET Framework の名前付けパターンに従います。 たとえば、同期 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、非同期の <xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドと <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドに対応します。  
  
 アプリケーションで実行中に必要なスレッドが1つだけの場合は、次のメソッドを使用します。これらのメソッドは、同期操作モード用に設計されています。  
  
-   TCP などの接続指向プロトコルを使用している場合、サーバーは <xref:System.Net.Sockets.Socket.Listen%2A> 方法を使用して接続をリッスンできます。 <xref:System.Net.Sockets.Socket.Accept%2A> メソッドは、受信接続要求を処理し、リモートホストとデータを通信するために使用できる <xref:System.Net.Sockets.Socket> を返します。 この返された <xref:System.Net.Sockets.Socket> を使用して、<xref:System.Net.Sockets.Socket.Send%2A> または <xref:System.Net.Sockets.Socket.Receive%2A> メソッドを呼び出します。 ローカル IP アドレスとポート番号を指定する場合は、<xref:System.Net.Sockets.Socket.Listen%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出します。 基になるサービスプロバイダーがフリーポートを割り当てる場合は、ポート番号を0にします。 リッスンしているホストに接続する場合は、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出します。 データを通信するには、<xref:System.Net.Sockets.Socket.Send%2A> または <xref:System.Net.Sockets.Socket.Receive%2A> メソッドを呼び出します。  
  
-   UDP などのコネクションレスプロトコルを使用している場合は、接続をリッスンする必要はありません。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出して、受信データグラムをすべて受け入れます。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用して、リモートホストにデータグラムを送信します。  
  
 実行中に個別のスレッドを使用して通信を処理するには、非同期操作モード用に設計された次のメソッドを使用します。  
  
-   TCP などの接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、および <xref:System.Net.Sockets.Socket.EndConnect%2A> の各方法を使用して、リッスンしているホストに接続します。 <xref:System.Net.Sockets.Socket.BeginSend%2A> および <xref:System.Net.Sockets.Socket.EndSend%2A> または <xref:System.Net.Sockets.Socket.BeginReceive%2A> および <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを使用して、データを非同期に通信します。 着信接続要求は <xref:System.Net.Sockets.Socket.BeginAccept%2A> と <xref:System.Net.Sockets.Socket.EndAccept%2A>を使用して処理できます。  
  
-   UDP などのコネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.BeginSendTo%2A> と <xref:System.Net.Sockets.Socket.EndSendTo%2A> を使用してデータグラムを送信し、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> および <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> を使用してデータグラムを受信することができます。  
  
 1つのソケットに対して複数の非同期操作を実行する場合、それらの操作は、開始された順序で完了するとは限りません。  
  
 データの送受信が終了したら、<xref:System.Net.Sockets.Socket.Shutdown%2A> メソッドを使用して <xref:System.Net.Sockets.Socket>を無効にします。 <xref:System.Net.Sockets.Socket.Shutdown%2A>を呼び出した後、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出して、<xref:System.Net.Sockets.Socket>に関連付けられているすべてのリソースを解放します。  
  
 <xref:System.Net.Sockets.Socket> クラスを使用すると、<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを使用して <xref:System.Net.Sockets.Socket> を構成できます。 <xref:System.Net.Sockets.Socket.GetSocketOption%2A> メソッドを使用して、これらの設定を取得します。  
  
> [!NOTE]
>  比較的単純なアプリケーションを作成し、最大のパフォーマンスを必要としない場合は、<xref:System.Net.Sockets.TcpClient>、<xref:System.Net.Sockets.TcpListener>、および <xref:System.Net.Sockets.UdpClient>の使用を検討してください。 これらのクラスは、<xref:System.Net.Sockets.Socket> 通信のためのより簡単でわかりやすいインターフェイスを提供します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.Socket> クラスを使用して HTTP サーバーにデータを送信し、応答を受信する方法を示します。 この例では、ページ全体が受信されるまでブロックします。  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">発信接続を確立するか、受信要求を受け入れる。</permission>
    <threadsafe>このクラスのインスタンスは、スレッドセーフです。</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">.NET Framework のネットワーク プログラミング</related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">System.Net クラスのベスト プラクティス</related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">ネットワーク アプリケーションのキャッシュ管理</related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">インターネット プロトコル バージョン 6</related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">ネットワーク プログラミングのサンプル</related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">.NET Framework のネットワークのトレース</related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">ネットワーク プログラミングにおけるセキュリティ</related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">バージョン 3.5 のソケット パフォーマンスの強化</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> によって返されるソケット情報。</param>
        <summary><see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> から返された値を指定して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各呼び出しの引数と同じバイト配列を使用して <xref:System.Net.Sockets.Socket.%23ctor%2A> コンストラクターを複数回呼び出す場合は、基になるソケットが同じである複数のマネージ <xref:System.Net.Sockets.Socket>を作成します。 この方法は推奨されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか 1 つ。</param>
        <summary>指定したソケットの種類とプロトコルを使用して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `socketType` パラメーターは <xref:System.Net.Sockets.Socket> クラスの型を指定し、`protocolType` パラメーターは <xref:System.Net.Sockets.Socket>で使用されるプロトコルを指定します。 2つのパラメーターは独立していません。 多くの場合、<xref:System.Net.Sockets.Socket> の型はプロトコルで暗黙の型になります。 <xref:System.Net.Sockets.Socket> 型とプロトコルの種類の組み合わせによって無効な <xref:System.Net.Sockets.Socket>が発生した場合、このコンストラクターは <xref:System.Net.Sockets.SocketException>をスローします。  
  
> [!NOTE]
>  このコンストラクターが <xref:System.Net.Sockets.SocketException>をスローする場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketType" /> と <paramref name="protocolType" /> を組み合わせると、無効なソケットになります。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><see cref="T:System.Net.Sockets.AddressFamily" /> 値のいずれか 1 つ。</param>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか 1 つ。</param>
        <summary>指定したアドレス ファミリ、ソケットの種類、およびプロトコルを使用して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addressFamily` パラメーターは、<xref:System.Net.Sockets.Socket> クラスが使用するアドレス指定スキームを指定します。 `socketType` パラメーターは <xref:System.Net.Sockets.Socket> クラスの型を指定し、`protocolType` パラメーターは <xref:System.Net.Sockets.Socket>によって使用されるプロトコルを指定します。 この3つのパラメーターは独立していません。 アドレスファミリによっては、それらで使用できるプロトコルが制限されている場合があります。また、多くの場合、<xref:System.Net.Sockets.Socket> の種類がプロトコルで暗黙的に使用されます。 アドレスファミリ、<xref:System.Net.Sockets.Socket> の種類、およびプロトコルの種類の組み合わせによって無効な <xref:System.Net.Sockets.Socket>が生成された場合、このコンストラクターは <xref:System.Net.Sockets.SocketException>をスローします。  
  
> [!NOTE]
>  このコンストラクターが <xref:System.Net.Sockets.SocketException>をスローする場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 <xref:System.Net.Sockets.Socket> クラスのインスタンスを作成する方法を次のコード例に示します。  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="addressFamily" />、<paramref name="socketType" />、および <paramref name="protocolType" /> を組み合わせると、無効なソケットになります。</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新しく作成された接続に対して新しい <see cref="T:System.Net.Sockets.Socket" /> を作成します。</summary>
        <returns>新しく作成された接続に対する <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> は、リッスンしているソケットの接続要求キューから、最初の保留中の接続要求を同期的に抽出し、新しい <xref:System.Net.Sockets.Socket>を作成して返します。 この返された <xref:System.Net.Sockets.Socket> を使用して、接続キューからの追加の接続を受け入れることはできません。 ただし、返された <xref:System.Net.Sockets.Socket> の <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> メソッドを呼び出して、リモートホストのネットワークアドレスとポート番号を識別できます。  
  
 ブロックモードでは、<xref:System.Net.Sockets.Socket.Accept%2A> は、受信接続の試行がキューに置かれるまでブロックします。 接続が受け入れられると、元の <xref:System.Net.Sockets.Socket> は、受信した接続要求を閉じるまで引き続きキューに挿入します。  
  
 非ブロッキング <xref:System.Net.Sockets.Socket>を使用してこのメソッドを呼び出し、接続要求がキューに登録されていない場合、<xref:System.Net.Sockets.Socket.Accept%2A> は <xref:System.Net.Sockets.SocketException>をスローします。 <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.Accept%2A> メソッドを呼び出す前に、まず <xref:System.Net.Sockets.Socket.Listen%2A> メソッドを呼び出して、着信接続要求をリッスンしてキューに挿入する必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、単純な <xref:System.Net.Sockets.Socket> 接続を受け入れます。  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.Accept" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>受信接続の試行を受け入れる非同期操作を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルでは、<xref:System.Net.Sockets.Socket.AcceptAsync%2A> メソッドを使用して、着信接続の試行を非同期に処理できます。 接続を非同期に受け入れると、別の実行スレッド内でデータを送受信することができます。 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Listen%2A> メソッドを呼び出して受信接続要求をリッスンし、キューに挿入する必要があります。  
  
 完了を通知するには、EventHandler\<SocketAsyncEventArgs > デリゲートを実装するコールバックメソッドを作成し、それを <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> イベントにフックする必要があります。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、必要に応じて、<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> プロパティで使用する <xref:System.Net.Sockets.Socket> を指定することによって、着信接続に使用する既存の <xref:System.Net.Sockets.Socket> を指定できます。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> プロパティが null の場合、新しい <xref:System.Net.Sockets.Socket> は、現在の <xref:System.Net.Sockets.Socket.ProtocolType%2A> と同じ <xref:System.Net.Sockets.Socket.AddressFamily%2A>、<xref:System.Net.Sockets.Socket.SocketType%2A>、および <xref:System.Net.Sockets.Socket> を使用して構築され、<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> プロパティとして設定されます。  
  
 呼び出し元は、<xref:System.Net.Sockets.Socket.AcceptAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 必要に応じて、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドが成功した後に、ソケットの最初のデータブロックを受け取るバッファーを指定することもできます。 この場合、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> プロパティは、受信するデータを格納するバッファーに設定する必要があります。また、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> プロパティは、バッファー内で受信するデータの最大バイト数に設定する必要があります。 これらのプロパティは、<xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> メソッドを使用して設定できます。 渡されたバッファーの一部は、基になる Winsock AcceptEx 呼び出しで使用するために、内部的に使用されます。 これは、返されるデータの量が、指定された <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> インスタンスの <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> プロパティの値よりも小さいことを意味します。 内部で使用されるバッファーの量は、ソケットのアドレスファミリによって異なります。 必要な最小バッファーサイズは288バイトです。 より大きなバッファーサイズが指定されている場合、<xref:System.Net.Sockets.Socket> は、Winsock AcceptEx 呼び出しによって受信されたアドレスデータ以外の追加データを期待し、この追加データを受信するまで待機します。 タイムアウトが発生した場合、接続はリセットされます。 したがって、余分なデータが特定の量になることが予想される場合は、バッファーサイズを最小バッファーサイズに設定し、この量を加算する必要があります。  
  
 完了コールバックメソッドは、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> プロパティを調べて、<xref:System.Net.Sockets.Socket.AcceptAsync%2A> 操作が成功したかどうかを確認する必要があります。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> イベントは、接続が受け入れられず、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> プロパティが <xref:System.Net.Sockets.SocketError.ConnectionReset>に設定される場合に発生することがあります。 これは、ハーフオープンの SYN タイプスキャンを使用したポートスキャンの結果として発生する可能性があります (SYN > SYN-ACK-> RST シーケンス)。 <xref:System.Net.Sockets.Socket.AcceptAsync%2A> メソッドを使用するアプリケーションは、この条件を処理できるように準備する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 この例外は、提供されたバッファーのサイズが不足している場合に発生します。 バッファーは、2 * (sizeof(SOCKADDR_STORAGE + 16) バイト以上であることが必要です。  
  
この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合にも発生します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">引数が範囲外です。 この例外は、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> が 0 未満の場合に発生します。</exception>
        <exception cref="T:System.InvalidOperationException">無効な操作が要求されました。 この例外は、受け入れ側の <see cref="T:System.Net.Sockets.Socket" /> が接続をリッスンしていない場合、または受け入れられたソケットがバインドされている場合に発生します。  
  
<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> メソッドを呼び出す前に、<see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> メソッドと <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> メソッドを呼び出す必要があります。  
  
この例外は、ソケットが既に接続されている、またはソケット操作が指定された <paramref name="e" /> パラメーターを使用して既に進行中の場合にも発生します。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> のアドレス ファミリを取得します。</summary>
        <value><see cref="T:System.Net.Sockets.AddressFamily" /> 値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily> は、<xref:System.Net.Sockets.Socket> クラスのインスタンスが使用できるアドレス指定スキームを指定します。 このプロパティは読み取り専用であり、<xref:System.Net.Sockets.Socket> が作成されるときに設定されます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.AddressFamily>、<xref:System.Net.Sockets.SocketType>、および <xref:System.Net.Sockets.ProtocolType> をコンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネットワークから受信した、読み取り可能なデータ量を取得します。</summary>
        <value>ネットワークから受信した、読み取り可能なデータのバイト数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非ブロッキング <xref:System.Net.Sockets.Socket>を使用している場合は、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に、データが読み取り用にキューに格納されているかどうかを判断するための適切な方法として <xref:System.Net.Sockets.Socket.Available%2A> を使用します。 使用可能なデータは、読み取り用にネットワークバッファーにキューに格納されているデータの総量です。 データがネットワークバッファーに格納されていない場合、<xref:System.Net.Sockets.Socket.Available%2A> は0を返します。  
  
 リモートホストがシャットダウンまたは接続を閉じると、<xref:System.Net.Sockets.Socket.Available%2A> が <xref:System.Net.Sockets.SocketException>をスローする可能性があります。 <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、Ioonread と使用可能なプロパティを呼び出して、呼び出しの結果を比較しています。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>受信接続の試行を受け入れる非同期操作を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>受信接続の試行を受け入れる非同期操作を開始します。</summary>
        <returns>非同期の <see cref="T:System.Net.Sockets.Socket" /> 作成を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルでは、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを使用して、着信接続の試行を非同期に処理できます。 接続を非同期に受け入れると、別の実行スレッド内でデータを送受信することができます。 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Listen%2A> メソッドを呼び出して受信接続要求をリッスンし、キューに挿入する必要があります。  
  
 <xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに渡す必要があります。 これを行うには、少なくとも、`state` パラメーターを使用して、リッスンしている <xref:System.Net.Sockets.Socket> オブジェクトを <xref:System.Net.Sockets.Socket.BeginAccept%2A> に渡す必要があります。 コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さいクラスを作成できます。 `state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに渡します。  
  
 コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを呼び出す必要があります。 アプリケーションが <xref:System.Net.Sockets.Socket.BeginAccept%2A>を呼び出すと、通常、システムは別のスレッドを使用して、指定されたコールバックメソッドを実行し、保留中の接続が取得されるまで、<xref:System.Net.Sockets.Socket.EndAccept%2A> でブロックします。 <xref:System.Net.Sockets.Socket.EndAccept%2A> は、リモートホストとの間でデータを送受信するために使用できる新しい <xref:System.Net.Sockets.Socket> オブジェクトを返します。 この返された <xref:System.Net.Sockets.Socket> を使用して、接続キューからの追加の接続を受け入れることはできません。 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>を使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの <xref:System.Threading.ManualResetEvent> で Set メソッドを呼び出します。  
  
 また、呼び出し元のスレッドを使用してコールバックメソッドを呼び出すこともできます。 この場合、返された <xref:System.IAsyncResult> の <xref:System.IAsyncResult.CompletedSynchronously%2A> プロパティは、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドが同期的に完了したことを示すように設定されます。  
  
 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドへの保留中の呼び出しを取り消すには、<xref:System.Net.Sockets.Socket>を閉じます。 非同期操作の実行中に <xref:System.Net.Sockets.Socket.Close%2A> メソッドが呼び出されると、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに提供されたコールバックが呼び出されます。  後続の <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドの呼び出しでは、操作が取り消されたことを示す <xref:System.ObjectDisposedException> がスローされます。  
  
> [!NOTE]
>  返された <xref:System.Net.Sockets.Socket> の <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> プロパティを使用して、リモートホストのネットワークアドレスとポート番号を識別できます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、受信接続を非同期的に受信しようとしています。  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。  
  
- または - 
受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="receiveSize">送信元から受け入れるバイト数。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>受信接続の試行を受け入れる非同期操作を開始し、クライアント アプリケーションによって送信されるデータの最初のブロックを受信します。</summary>
        <returns>非同期の <see cref="T:System.Net.Sockets.Socket" /> 作成を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルでは、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを使用して、着信接続の試行を非同期に処理できます。 接続を非同期に受け入れると、別の実行スレッド内でデータを送受信できるようになります。 このオーバーロードでは、`receiveSize` パラメーターの初期転送で許容するバイト数を指定できます。  
  
 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Listen%2A> メソッドを呼び出して受信接続要求をリッスンし、キューに挿入する必要があります。  
  
 <xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに渡す必要があります。 これを行うには、少なくとも、`state` パラメーターを使用して、リッスンしている <xref:System.Net.Sockets.Socket> オブジェクトを <xref:System.Net.Sockets.Socket.BeginAccept%2A> に渡す必要があります。 コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さいクラスを作成できます。 `state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに渡します。  
  
 コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを呼び出す必要があります。 アプリケーションが <xref:System.Net.Sockets.Socket.BeginAccept%2A>を呼び出すと、通常、システムは別のスレッドを使用して、指定されたコールバックメソッドを実行し、保留中の接続が取得されるまで、<xref:System.Net.Sockets.Socket.EndAccept%2A> でブロックします。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> は、リモートホストとの間でデータを送受信するために使用できる新しい <xref:System.Net.Sockets.Socket> を返します。 この返された <xref:System.Net.Sockets.Socket> を使用して、接続キューからの追加の接続を受け入れることはできません。 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>を使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの <xref:System.Threading.ManualResetEvent> で Set メソッドを呼び出します。  
  
 また、呼び出し元のスレッドを使用してコールバックメソッドを呼び出すこともできます。 この場合、返された <xref:System.IAsyncResult> の <xref:System.IAsyncResult.CompletedSynchronously%2A> プロパティは、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドが同期的に完了したことを示すように設定されます。  
  
 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドへの保留中の呼び出しを取り消すには、<xref:System.Net.Sockets.Socket>を閉じます。  非同期操作の実行中に <xref:System.Net.Sockets.Socket.Close%2A> メソッドが呼び出されると、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに提供されたコールバックが呼び出されます。  後続の <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドの呼び出しでは、操作が取り消されたことを示す <xref:System.ObjectDisposedException> がスローされます。  
  
> [!NOTE]
>  を呼び出すと、返された <xref:System.Net.Sockets.Socket> オブジェクトの <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> プロパティを使用して、リモートホストのネットワークアドレスとポート番号を識別できます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、ソケットを開き、非同期接続を受け入れます。 この例では、ソケットは最初の10バイトのデータを受け入れます。 受信したバイト数とデータは、コールバックデリゲートによってコンソールに表示されます。 残りのデータを受信する方法の詳細については、「<xref:System.Net.Sockets.Socket.BeginReceive%2A>」を参照してください。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。  
  
- または - 
受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">受け入れた <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。 この値は <see langword="null" /> の場合もあります。</param>
        <param name="receiveSize">受信する最大バイト数。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>指定したソケットから受信接続の試行を受け入れる非同期操作を開始し、クライアント アプリケーションによって送信されるデータの最初のブロックを受信します。</summary>
        <returns>非同期の <see cref="T:System.Net.Sockets.Socket" /> オブジェクトの作成を参照する <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルでは、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを使用して、着信接続の試行を非同期に処理できます。 接続を非同期に受け入れると、別の実行スレッド内でデータを送受信することができます。 このオーバーロードでは、`acceptSocket` パラメーターで受け入れられたソケットを指定できます。 このパラメーターが `null`場合、受け入れられたソケットは <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドによって作成されます。 `receiveSize` パラメーターで、初期転送時に受け入れるバイト数を指定できます。  
  
 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Listen%2A> メソッドを呼び出して受信接続要求をリッスンし、キューに挿入する必要があります。  
  
 <xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに渡す必要があります。 これを行うには、少なくとも、`state` パラメーターを使用して、リッスンしている <xref:System.Net.Sockets.Socket> オブジェクトを <xref:System.Net.Sockets.Socket.BeginAccept%2A> に渡す必要があります。 コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さいクラスを作成できます。 `state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに渡します。  
  
 コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを呼び出す必要があります。 アプリケーションが <xref:System.Net.Sockets.Socket.BeginAccept%2A>を呼び出すと、通常、システムは別のスレッドを使用して、指定されたコールバックメソッドを実行し、保留中の接続が取得されるまで、<xref:System.Net.Sockets.Socket.EndAccept%2A> でブロックします。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> は、リモートホストとの間でデータを送受信するために使用できる新しい <xref:System.Net.Sockets.Socket> オブジェクトを返します。 この返された <xref:System.Net.Sockets.Socket> を使用して、接続キューからの追加の接続を受け入れることはできません。 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>を使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの <xref:System.Threading.ManualResetEvent> で Set メソッドを呼び出します。  
  
 また、呼び出し元のスレッドを使用してコールバックメソッドを呼び出すこともできます。 この場合、返された <xref:System.IAsyncResult> の <xref:System.IAsyncResult.CompletedSynchronously%2A> プロパティは、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドが同期的に完了したことを示すように設定されます。  
  
 コールバックメソッドの記述の詳細については、「[コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドへの保留中の呼び出しを取り消すには、<xref:System.Net.Sockets.Socket>を閉じます。 非同期操作の実行中に <xref:System.Net.Sockets.Socket.Close%2A> メソッドが呼び出されると、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに提供されたコールバックが呼び出されます。  後続の <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドの呼び出しでは、操作が取り消されたことを示す <xref:System.ObjectDisposedException> がスローされます。  
  
> [!NOTE]
>  返された <xref:System.Net.Sockets.Socket> オブジェクトの <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> プロパティを使用して、リモートホストのネットワークアドレスとポート番号を識別できます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、ソケットを開き、非同期接続を受け入れます。 この例では、ソケットは最初の10バイトのデータを受け入れ、`acceptSocket` パラメーターを `null`ます。これにより、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドによって受け入れられたソケットが強制的に作成されます。 受信したバイト数とデータは、コールバックデリゲートによってコンソールに表示されます。 残りのデータを受信する方法の詳細については、「<xref:System.Net.Sockets.Socket.BeginReceive%2A>」を参照してください。  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。  
  
- または - 
受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホスト接続への非同期要求を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP">リモート ホストを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="end_point">リモート ホストを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドは、`remoteEP` パラメーターへの接続の非同期要求を開始します。 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.BeginConnect%2A> によって既定のリモートホストが確立されます。 既定のリモートホストを非同期的に接続または設定すると、別の実行スレッド内でデータを送受信することができます。  
  
 <xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドに渡すことができます。 少なくとも、`state` パラメーターを使用して <xref:System.Net.Sockets.Socket.BeginConnect%2A> に <xref:System.Net.Sockets.Socket> を渡す必要があります。 コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket>とその他の必要な情報を保持する小さいクラスを作成できます。 `state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドに渡します。  
  
 コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドを呼び出す必要があります。 アプリケーションが <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> が正常に接続されるか例外がスローされるまで、<xref:System.Net.Sockets.Socket.EndConnect%2A> をブロックします。 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A>を使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの <xref:System.Threading.ManualResetEvent> で Set メソッドを呼び出します。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 UDP などのコネクションレスプロトコルを使用している場合は、データを送受信する前に <xref:System.Net.Sockets.Socket.BeginConnect%2A> を呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> と <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> を使用して、リモートホストと通信できます。 <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出すと、指定された既定以外のアドレスから到着したデータグラムはすべて破棄されます。 既定のリモートホストをブロードキャストアドレスに設定する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> を呼び出し、`true`にブロードキャストを設定する必要があります。 できない場合は、<xref:System.Net.Sockets.Socket.BeginConnect%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
 接続指向プロトコルを使用していて、<xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出さない場合は、基になるサービスプロバイダーによって、最も適切なローカルネットワークアドレスとポート番号が割り当てられます。 コネクションレスプロトコルを使用している場合、サービスプロバイダーは、<xref:System.Net.Sockets.Socket.BeginSend%2A> または <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法を呼び出すまで、ローカルネットワークアドレスとポート番号を割り当てません。 既定のリモートホストを変更する場合は、目的のエンドポイントで <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドをもう一度呼び出します。  
  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドへの保留中の呼び出しを取り消すには、<xref:System.Net.Sockets.Socket>を閉じます。 非同期操作の実行中に <xref:System.Net.Sockets.Socket.Close%2A> メソッドが呼び出されると、<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドに提供されたコールバックが呼び出されます。  後続の <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドの呼び出しでは、操作が取り消されたことを示す <xref:System.ObjectDisposedException> がスローされます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このソケットが以前に切断されていた場合は、操作が完了するまで終了しないスレッドで <xref:System.Net.Sockets.Socket.BeginConnect%2A> を呼び出す必要があります。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">リモート ホストの <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="callback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <paramref name="requestCallback" /> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストは <see cref="T:System.Net.IPAddress" /> とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作は、<xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドを呼び出すことによって完了する必要があります。 通常、メソッドは `requestCallback` デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドオーバーロードまたは <xref:System.Net.Sockets.Socket.EndConnect%2A>のいずれかを使用します。  
  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドへの保留中の呼び出しを取り消すには、<xref:System.Net.Sockets.Socket>を閉じます。 非同期操作の実行中に <xref:System.Net.Sockets.Socket.Close%2A> メソッドが呼び出されると、<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドに提供されたコールバックが呼び出されます。  後続の <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドの呼び出しでは、操作が取り消されたことを示す <xref:System.ObjectDisposedException> がスローされます。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このソケットが以前に切断されていた場合は、操作が完了するまで終了しないスレッドで <xref:System.Net.Sockets.Socket.BeginConnect%2A> を呼び出す必要があります。 これは、基になるプロバイダーの制限です。 また、使用する <xref:System.Net.EndPoint> は異なっている必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Net.Sockets.Socket" /> はソケット ファミリに含まれません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">リモート ホストを指定する、少なくとも 1 つの <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="callback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <paramref name="requestCallback" /> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストは、<see cref="T:System.Net.IPAddress" /> 配列とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作は、<xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドを呼び出すことによって完了する必要があります。 通常、メソッドは `requestCallback` デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドオーバーロードのいずれかを使用します。  
  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドへの保留中の呼び出しを取り消すには、<xref:System.Net.Sockets.Socket>を閉じます。 非同期操作の実行中に <xref:System.Net.Sockets.Socket.Close%2A> メソッドが呼び出されると、<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドに提供されたコールバックが呼び出されます。  後続の <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドの呼び出しでは、操作が取り消されたことを示す <xref:System.ObjectDisposedException> がスローされます。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このソケットが以前に切断されていた場合は、操作が完了するまで終了しないスレッドで <xref:System.Net.Sockets.Socket.BeginConnect%2A> を呼び出す必要があります。 これは、基になるプロバイダーの制限です。 また、使用する <xref:System.Net.EndPoint> は異なっている必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> を使用するソケットで有効です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">リモート ホストの名前。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="callback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <paramref name="requestCallback" /> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストはホスト名とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作は、<xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドを呼び出すことによって完了する必要があります。 通常、メソッドは `requestCallback` デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドオーバーロードのいずれかを使用します。  
  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドへの保留中の呼び出しを取り消すには、<xref:System.Net.Sockets.Socket>を閉じます。 非同期操作の実行中に <xref:System.Net.Sockets.Socket.Close%2A> メソッドが呼び出されると、<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドに提供されたコールバックが呼び出されます。  後続の <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドの呼び出しでは、操作が取り消されたことを示す <xref:System.ObjectDisposedException> がスローされます。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このソケットが以前に切断されていた場合は、操作が完了するまで終了しないスレッドで <xref:System.Net.Sockets.Socket.BeginConnect%2A> を呼び出す必要があります。 これは、基になるプロバイダーの制限です。 また、使用する <xref:System.Net.EndPoint> は異なっている必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリ内のソケットに対して正しいものです。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">接続の終了後、このソケットが再利用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>リモート エンドポイントからの切断の非同期要求を開始します。</summary>
        <returns>非同期操作を参照する <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.BeginDisconnect%2A> メソッドを呼び出して、リモートエンドポイントからの切断を要求できます。 `reuseSocket` が `true`場合は、ソケットを再利用できます。  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> メソッドは、個別のスレッドを使用して、指定されたコールバックメソッドを呼び出します。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> メソッドは、保留中の切断が完了するまでブロックします。 コールバックメソッドの記述の詳細については、「[コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException> 例外が発生した場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期通信用のソケットを作成し、いくつかのデータをリモートホストに送信します。 データが送信されると、<xref:System.Net.Sockets.Socket.Shutdown%2A> が呼び出され、送信と受信のアクティビティが停止されます。 次に、<xref:System.Net.Sockets.Socket.BeginDisconnect%2A> が呼び出され、切断要求が開始されます。 要求が完了すると、ソケットが切断されているかどうかをテストするために <xref:System.Net.Sockets.Socket.Connected%2A> プロパティが照会されます。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを呼び出すことによって完了する必要があります。 通常、メソッドは `callback` デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドオーバーロードのいずれかを使用します。  
  
 保留中の <xref:System.Net.Sockets.Socket.BeginReceive%2A>を取り消すには、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出します。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state` は、ユーザー定義のクラスをインスタンス化したものです。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを呼び出すことによって完了する必要があります。 通常、メソッドは `callback` デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドオーバーロードのいずれかを使用します。  
  
 保留中の <xref:System.Net.Sockets.Socket.BeginReceive%2A>を取り消すには、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出します。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state` は、ユーザー定義のクラスをインスタンス化したものです。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信データを格納する、<paramref name="buffer" />パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを呼び出すことによって完了する必要があります。 通常、メソッドは `callback` デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドオーバーロードのいずれかを使用します。  
  
 保留中の <xref:System.Net.Sockets.Socket.BeginReceive%2A>を取り消すには、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出します。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state` は、ユーザー定義のクラスをインスタンス化したものです。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、接続された <xref:System.Net.Sockets.Socket>からのデータの非同期受信を開始します。  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, errorCode, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信データを格納する <paramref name="buffer" />内の場所。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="error">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを呼び出すことによって完了する必要があります。 通常、メソッドは `callback` デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドオーバーロードのいずれかを使用します。  
  
 保留中の <xref:System.Net.Sockets.Socket.BeginReceive%2A>を取り消すには、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出します。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state` は、ユーザー定義のクラスをインスタンス化したものです。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データを格納する、<paramref name="buffer" />パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データのソースを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="remote_end">データのソースを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>指定したネットワーク デバイスから、データの非同期の受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドは、リモートホストからのコネクションレスデータグラムの非同期読み取りを開始します。 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドを呼び出すと、別の実行スレッド内でデータを受け取ることができます。  
  
 <xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドに渡すことができます。 これを行うには、少なくとも、`state` パラメーターに、通信に使用される接続された <xref:System.Net.Sockets.Socket> または既定のが含まれている必要があります。 コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さいクラスを作成できます。 `state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドに渡します。  
  
 コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドを呼び出す必要があります。 アプリケーションが <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> がデータを読み取るか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> でブロックされます。 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>を使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。 コールバックメソッドの記述の詳細については、「[コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して <xref:System.Net.Sockets.Socket> をローカルエンドポイントに明示的にバインドする必要があります。この操作を行わないと、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> は <xref:System.Net.Sockets.SocketException>をスローします。  
  
 このメソッドは、データを `buffer` パラメーターに読み込み、データの送信元のリモートホストエンドポイントをキャプチャします。 このエンドポイントを取得する方法の詳細については、「<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>」を参照してください。 このメソッドは、不明なホストまたは複数のホストからコネクションレスのデータグラムを非同期的に受信する場合に最も役立ちます。 このような場合、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムが `buffer`のサイズより大きい場合、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドは、可能な限り多くのメッセージを `buffer` に入力し、<xref:System.Net.Sockets.SocketException>をスローします。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な大きさのバッファーを使用して <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドを呼び出すことで取得できます。  
  
 リモートホストエンドポイントが常に返されることを保証するには、アプリケーションで <xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して <xref:System.Net.Sockets.Socket> をローカルエンドポイントに明示的にバインドし、`optionLevel` パラメーターを <xref:System.Net.Sockets.SocketOptionLevel.IP> に設定して <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出します。 <xref:System.Net.Sockets.SocketOptionLevel.IPv6> パラメーターを `optionName` に設定し、<xref:System.Net.Sockets.SocketOptionName.PacketInformation>メソッドを呼び出す前にこのオプションを有効にします。`optionValue`<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> そうしないと、受信側が <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドを呼び出した後に、送信者が複数のデータグラムを送信した場合に、リモートホストエンドポイントが返されない可能性があります。  
  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。 これを選択する場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出すか、<xref:System.Net.Sockets.Socket.Accept%2A> または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出して受信接続要求を受け入れることによって、リモートホスト接続を確立する必要があります。 接続を確立または受け入れる前に <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドを呼び出すと、<xref:System.Net.Sockets.SocketException>が表示されます。 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合も、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドは、`remoteEP` パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。  
  
 接続指向のソケットでは、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> は、`size` パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。  
  
 保留中の <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を取り消すには、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、リモートホストからコネクションレスのデータグラムを非同期的に受信します。  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データを格納する、<paramref name="buffer" />パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データのソースを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータの非同期受信を開始して、データ バッファー内の指定した位置に格納します。さらに、エンドポイントとパケット情報を格納します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の受信操作は、<xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> メソッドを呼び出すことによって完了する必要があります。 通常、メソッドは `asyncCallback` デリゲートによって呼び出されます。  
  
 このメソッドは、操作が完了するまでブロックしません。 操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドを使用します。  
  
 保留中の <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>を取り消すには、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出します。  
  
 非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。  
  
 このメソッドは、データを `buffer` パラメーターに読み込み、データの送信元のリモートホストエンドポイント、および受信パケットに関する情報をキャプチャします。 このエンドポイントを取得する方法の詳細については、「<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>」を参照してください。 このメソッドは、不明なホストまたは複数のホストからコネクションレスのデータグラムを非同期的に受信する場合に最も役立ちます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドで確立されたリモートホストへの非同期の送信操作を開始します。 最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出さない場合、<xref:System.Net.Sockets.Socket.BeginSend%2A> は例外をスローします。 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出すと、別の実行スレッド内でデータを送信できるようになります。  
  
 <xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡すことができます。 これを行うには、少なくとも、`state` パラメーターに、通信に使用される接続された <xref:System.Net.Sockets.Socket> または既定のが含まれている必要があります。 コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さなクラスまたは構造体を作成できます。 `state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡します。  
  
 コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndSend%2A> メソッドを呼び出す必要があります。 アプリケーションが <xref:System.Net.Sockets.Socket.BeginSend%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> が要求したバイト数を送信するか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndSend%2A> でブロックします。 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> メソッドを使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 接続指向プロトコルを対象としていますが、最初に <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも <xref:System.Net.Sockets.Socket.BeginSend%2A> 機能します。 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>を使用する必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.BeginSendTo%2A> を使用できます。 また、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A>に別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.BeginSend%2A> を呼び出す前に、既定のリモートホストを変更することもできます。 コネクションレスプロトコルを使用する場合は、バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.BeginSend%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
 <xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state` は、ユーザー定義のクラスをインスタンス化したものです。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドで確立されたリモートホストへの非同期の送信操作を開始します。 最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出さない場合、<xref:System.Net.Sockets.Socket.BeginSend%2A> は例外をスローします。 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出すと、別の実行スレッド内でデータを送信できるようになります。  
  
 <xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡すことができます。 これを行うには、少なくとも、`state` パラメーターに、通信に使用される接続された <xref:System.Net.Sockets.Socket> または既定のが含まれている必要があります。 コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さなクラスまたは構造体を作成できます。 `state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡します。  
  
 コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndSend%2A> メソッドを呼び出す必要があります。 アプリケーションが <xref:System.Net.Sockets.Socket.BeginSend%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> が要求したバイト数を送信するか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndSend%2A> でブロックします。 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> メソッドを使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの <xref:System.Threading.ManualResetEvent> で Set メソッドを呼び出します。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 接続指向プロトコルを対象としていますが、最初に <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも <xref:System.Net.Sockets.Socket.BeginSend%2A> 機能します。 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>を使用する必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.BeginSendTo%2A> を使用できます。 また、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A>に別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.BeginSend%2A> を呼び出す前に、既定のリモートホストを変更することもできます。 コネクションレスプロトコルを使用する場合は、バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.BeginSend%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
 <xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state` は、ユーザー定義のクラスをインスタンス化したものです。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">送信を開始する、<paramref name="buffer" /> パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドで確立されたリモートホストへの非同期の送信操作を開始します。 最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出さない場合、<xref:System.Net.Sockets.Socket.BeginSend%2A> は例外をスローします。 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出すと、別の実行スレッド内でデータを送信できるようになります。  
  
 <xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡すことができます。 これを行うには、少なくとも、`state` パラメーターに、通信に使用される接続された <xref:System.Net.Sockets.Socket> または既定のが含まれている必要があります。 コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さなクラスまたは構造体を作成できます。 `state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡します。  
  
 コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndSend%2A> メソッドを呼び出す必要があります。 アプリケーションが <xref:System.Net.Sockets.Socket.BeginSend%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> が要求したバイト数を送信するか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndSend%2A> でブロックします。 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> メソッドを使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 接続指向プロトコルを対象としていますが、最初に <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも <xref:System.Net.Sockets.Socket.BeginSend%2A> 機能します。 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>を使用する必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.BeginSendTo%2A> を使用できます。 また、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A>に別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.BeginSend%2A> を呼び出す前に、既定のリモートホストを変更することもできます。 コネクションレスプロトコルを使用する場合は、バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.BeginSend%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
 <xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state` は、ユーザー定義のクラスをインスタンス化したものです。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さより小さい値です。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">送信を開始する、<paramref name="buffer" /> パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドで確立されたリモートホストへの非同期の送信操作を開始します。 最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出さない場合、<xref:System.Net.Sockets.Socket.BeginSend%2A> は例外をスローします。 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出すと、別の実行スレッド内でデータを送信できるようになります。  
  
 <xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡すことができます。 これを行うには、少なくとも、`state` パラメーターに、通信に使用される接続された <xref:System.Net.Sockets.Socket> または既定のが含まれている必要があります。 コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さなクラスまたは構造体を作成できます。 `state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡します。  
  
 コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndSend%2A> メソッドを呼び出す必要があります。 アプリケーションが <xref:System.Net.Sockets.Socket.BeginSend%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> が要求したバイト数を送信するか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndSend%2A> でブロックします。 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> メソッドを使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 接続指向プロトコルを対象としていますが、最初に <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも <xref:System.Net.Sockets.Socket.BeginSend%2A> 機能します。 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>を使用する必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.BeginSendTo%2A> を使用できます。 また、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A>に別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.BeginSend%2A> を呼び出す前に、既定のリモートホストを変更することもできます。 コネクションレスプロトコルを使用する場合は、バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.BeginSend%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
 <xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  `state` は、ユーザー定義のクラスをインスタンス化したものです。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、リモートホストへのデータの非同期送信を開始します。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さより小さい値です。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルを非同期的に送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">送信するファイルのパスと名前を格納する文字列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary><see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> フラグを使用して、接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> を送信します。</summary>
        <returns>非同期送信を表す <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、接続されているソケットにファイル `fileName` を送信します。 `fileName` がローカルディレクトリにある場合は、ファイル名だけで識別できます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt ") と UNC 共有名 ("\\\\\\\ 共有ディレクトリ\\\myfile.txt ") はサポートされています。 ファイルが見つからない場合は、例外 <xref:System.IO.FileNotFoundException> がスローされます。  
  
 このメソッドは、Windows Sockets 2 API の `TransmitFile` 関数を使用します。 `TransmitFile` 関数とそのフラグの詳細については、 [Windows Sockets](/windows/desktop/WinSock/)のドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> の各メソッドで確立されたリモートホストへの非同期の送信操作を開始します。 最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出さない場合、<xref:System.Net.Sockets.Socket.BeginSendFile%2A> は例外をスローします。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドを呼び出すと、別の実行スレッド内でファイルを送信できます。  
  
 操作を完了するには、<xref:System.AsyncCallback> delegate パラメーターによって呼び出されるコールバックメソッドを作成します。 これを行うには、少なくとも、`state` パラメーターに、通信に使用される <xref:System.Net.Sockets.Socket> オブジェクトが含まれている必要があります。 コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持するクラスまたは構造体を作成できます。 このカスタムオブジェクトのインスタンスを、`state` パラメーターを使用して <xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドに渡します。  
  
 コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndSendFile%2A> メソッドを呼び出す必要があります。 アプリケーションが <xref:System.Net.Sockets.Socket.BeginSendFile%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> がファイル全体を送信するか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndSendFile%2A> にブロックします。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 接続指向プロトコルを対象としていますが、最初に <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 機能します。 コネクションレスプロトコルを使用する場合は、ファイルのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.BeginSendFile%2A> は <xref:System.Net.Sockets.SocketException> 例外をスローします。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException> 例外が発生した場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、非同期通信用のソケットを作成して接続します。 まず、ファイル ".txt" をリモートホストに非同期的に送信します。 コールバックデリゲートは、転送を完了するために <xref:System.Net.Sockets.Socket.EndSendFile%2A> を呼び出します。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を格納する文字列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="preBuffer">ファイルが送信される前に送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="postBuffer">ファイルが送信された後で送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="flags"><see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">このオプションの完了時に呼び出される <see cref="T:System.AsyncCallback" /> デリゲート。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="state">この要求の状態情報を格納するユーザー定義のオブジェクト。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルとデータのバッファーを非同期的に送信します。</summary>
        <returns>非同期操作を表す <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードには、送信するファイルの名前と <xref:System.Net.Sockets.TransmitFileOptions> 値のビットごとの組み合わせが必要です。 `preBuffer` パラメーターには、ファイルの前に配置するデータが含まれています。 `postBuffer` には、ファイルに従う必要があるデータが含まれています。 `fileName` がローカルディレクトリにある場合は、ファイル名だけで識別できます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt ") と UNC 共有名 ("\\\\\\\ 共有ディレクトリ\\\myfile.txt ") はサポートされています。 ファイルが見つからない場合は、例外 <xref:System.IO.FileNotFoundException> がスローされます。  
  
 `flags` パラメーターは、ファイル転送に関する追加情報を Window Sockets service プロバイダーに提供します。 このパラメーターの使用方法の詳細については、「<xref:System.Net.Sockets.TransmitFileOptions>」を参照してください。  
  
 このメソッドは、Windows Sockets 2 API の `TransmitFile` 関数を使用します。 `TransmitFile` 関数とそのフラグの詳細については、 [Windows Sockets](/windows/desktop/WinSock/)のドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> の各メソッドで確立されたリモートホストへの非同期の送信操作を開始します。 最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出さない場合、<xref:System.Net.Sockets.Socket.BeginSendFile%2A> は例外をスローします。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドを呼び出すと、別の実行スレッド内でファイルを送信できるようになります。  
  
 操作を完了するには、<xref:System.AsyncCallback> delegate パラメーターによって呼び出されるコールバックメソッドを作成します。 これを行うには、少なくとも、`state` パラメーターに、通信に使用される <xref:System.Net.Sockets.Socket> オブジェクトが含まれている必要があります。 コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持するクラスまたは構造体を作成できます。 このカスタムオブジェクトのインスタンスを、`state` パラメーターを使用して <xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドに渡します。  
  
 コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndSendFile%2A> メソッドを呼び出す必要があります。 アプリケーションが <xref:System.Net.Sockets.Socket.BeginSendFile%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> がファイル全体を送信するか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndSendFile%2A> にブロックします。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 接続指向プロトコルを対象としていますが、最初に <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 機能します。 コネクションレスプロトコルを使用する場合は、ファイルのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.BeginSendFile%2A> は <xref:System.Net.Sockets.SocketException> 例外をスローします。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException> 例外が発生した場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、非同期通信用のソケットを作成して接続し、リモートホストへのファイル "test.txt" の非同期送信を開始します。 この例では、`preBuffer` とデータの `postBuffer` を作成してファイルと共に送信し、既定の <xref:System.Net.Sockets.TransmitFileOptions> 値を使用します。 コールバックデリゲートは、転送を完了するために <xref:System.Net.Sockets.Socket.EndSendFile%2A> を呼び出します。  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.NotSupportedException">オペレーティング システムは Windows NT 以降ではありません。  
  
- または -
  
 ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データ送信を開始する、<paramref name="buffer" /> 内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート デバイスを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="remote_end">リモート デバイスを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>特定のリモート ホストにデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドは、`remoteEP` パラメーターで指定されたリモートホストへの非同期の送信操作を開始します。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドを呼び出すと、別の実行スレッド内でデータを送信できるようになります。 コネクションレスプロトコルを対象としていますが、<xref:System.Net.Sockets.Socket.BeginSendTo%2A> はコネクションレスプロトコルと接続指向プロトコルの両方で動作します。  
  
 <xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドに渡すことができます。 これを行うには、少なくとも、`state` パラメーターに、通信に使用される接続された <xref:System.Net.Sockets.Socket> または既定のが含まれている必要があります。 コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket>とその他の必要な情報を保持する小さいクラスを作成できます。 `state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドに渡します。  
  
 コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndSendTo%2A> メソッドを呼び出す必要があります。 アプリケーションが <xref:System.Net.Sockets.Socket.BeginSendTo%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> が要求したバイト数を送信するか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndSendTo%2A> でブロックします。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> メソッドを使用します。 元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。 コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。  
  
 接続指向プロトコルを使用している場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出す必要があります。呼び出さないと、<xref:System.Net.Sockets.Socket.BeginSendTo%2A> がスローされます。<xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.Socket.BeginSendTo%2A> は `remoteEP` パラメーターを無視し、<xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドで設定された <xref:System.Net.EndPoint> にデータを送信します。  
  
 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを使用して既定のリモートホストを確立する必要はありません。 この操作は、<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出す場合にのみ必要です。 <xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出した場合、`remoteEP` パラメーターは、その送信操作に対して指定された既定のリモートホストを上書きします。 <xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要もありません。 この場合、基になるサービスプロバイダーによって、最も適切なローカルネットワークアドレスとポート番号が割り当てられます。 基になるサービスプロバイダーで空きポートを選択する場合は、ポート番号を0にします。 割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は、<xref:System.Net.Sockets.Socket.EndSendTo%2A> メソッドが正常に完了した後に、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティを使用できます。  
  
 ブロードキャストアドレスにデータを送信する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。 -バッファーのサイズが、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.EndSendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
 <xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。 特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、指定したリモートホストにデータを非同期的に送信します。  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><see cref="T:System.Net.Sockets.Socket" /> に関連付けるローカル <see cref="T:System.Net.EndPoint" />。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> をローカル エンドポイントと関連付けます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のローカルエンドポイントを使用する必要がある場合は、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用します。 <xref:System.Net.Sockets.Socket.Listen%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Bind%2A> を呼び出す必要があります。 特定のローカルエンドポイントを使用する必要がない限り、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを使用する前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.Bind%2A> メソッドは、コネクションレスプロトコルと接続指向プロトコルの両方で使用できます。  
  
 <xref:System.Net.Sockets.Socket.Bind%2A>を呼び出す前に、まずデータを通信するローカル <xref:System.Net.IPEndPoint> を作成する必要があります。 どのローカルアドレスが割り当てられているか気にしない場合は、address パラメーターとして <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> を使用して <xref:System.Net.IPEndPoint> を作成することができ、基になるサービスプロバイダーによって最も適切なネットワークアドレスが割り当てられます。 これは、複数のネットワークインターフェイスがある場合に、アプリケーションの簡素化に役立つ可能性があります。 使用されるローカルポートを気にしない場合は、ポート番号に0を使用して <xref:System.Net.IPEndPoint> を作成できます。 この場合、サービスプロバイダーは1024と5000の間の使用可能なポート番号を割り当てます。  
  
 上記の方法を使用すると、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>を呼び出すことによって、どのローカルネットワークアドレスとポート番号が割り当てられているかを調べることができます。 接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドを呼び出した後に、ローカルに割り当てられたネットワークアドレスを返しません。 コネクションレスプロトコルを使用している場合は、送信または受信が完了するまで、この情報にアクセスすることはできません。  
  
 UDP ソケットが受信パケットのインターフェイス情報を受け取る必要がある場合は、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出した直後に socket オプションを <xref:System.Net.Sockets.SocketOptionName.PacketInformation> に設定して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを明示的に呼び出す必要があります。  
  
> [!NOTE]
>  マルチキャストデータグラムを受信する場合は、マルチキャストポート番号を指定して <xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要があります。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用して、コネクションレスのデータグラムを受信する場合は、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要があります。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出すときに <xref:System.Net.Sockets.SocketException> を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、指定されたローカルエンドポイントを使用して <xref:System.Net.Sockets.Socket> をバインドします。  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission"><paramref name="localEP" />によって定義されたホストからの接続を受け入れる場合。 関連付けられた列挙型: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> がブロッキング モードかどうかを示す値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> がブロックする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティは、<xref:System.Net.Sockets.Socket> がブロッキングモードであるかどうかを示します。  
  
 ブロックモードで、すぐには完了しないメソッド呼び出しを行う場合、要求された操作が完了するまで、アプリケーションは実行をブロックします。 要求された操作が完了していなくても実行を続行する場合は、[<xref:System.Net.Sockets.Socket.Blocking%2A>] プロパティを `false`に変更します。 <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティは、非同期メソッドには影響しません。 非同期的にデータを送受信し、実行をブロックする場合は、<xref:System.Threading.ManualResetEvent> クラスを使用します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> メソッドの 1 つを呼び出してリモート ホストへの接続を要求するために使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート ホスト接続への非同期要求を取り消します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> メソッドは、リモートホスト接続の非同期要求をキャンセルします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、関連付けられたすべてのリソースを解放します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、関連付けられたすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A> メソッドは、リモートホスト接続を閉じ、<xref:System.Net.Sockets.Socket>に関連付けられているすべてのマネージリソースとアンマネージリソースを解放します。 終了時に、<xref:System.Net.Sockets.Socket.Connected%2A> プロパティが `false`に設定されます。  
  
 接続指向プロトコルの場合、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Shutdown%2A> を呼び出すことをお勧めします。 これにより、接続されたソケットが閉じられる前に、すべてのデータが送信され、受信されます。  
  
 最初に <xref:System.Net.Sockets.Socket.Shutdown%2A>を呼び出さずに <xref:System.Net.Sockets.Socket.Close%2A> を呼び出す必要がある場合は、<xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> オプションを `false` に設定し、ゼロ以外のタイムアウト期間を指定することにより、送信転送のためにキューに格納されたデータが送信されるようにすることができます。 <xref:System.Net.Sockets.Socket.Close%2A> は、このデータが送信されるか、指定されたタイムアウトが経過するまでブロックされます。 <xref:System.Net.Sockets.SocketOptionName.DontLinger> を `false` に設定し、タイムアウト間隔をゼロに指定した場合、<xref:System.Net.Sockets.Socket.Close%2A> は接続を解放し、発信キューに格納されたデータを自動的に破棄します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket オプションを `false`に設定するには、<xref:System.Net.Sockets.LingerOption>を作成し、enabled プロパティを `true`に設定して、<xref:System.Net.Sockets.LingerOption.LingerTime%2A> プロパティを目的のタイムアウト期間に設定します。 この <xref:System.Net.Sockets.LingerOption> を <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket オプションと共に使用して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.Socket>を閉じます。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout">最大 <paramref name="timeout" /> 秒まで待ってから残りのデータを送信し、ソケットを閉じます。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、すべての関連付けられているリソースを指定したタイムアウトで解放して、キューに置かれたデータの送信を許可します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A> メソッドは、リモートホスト接続を閉じ、<xref:System.Net.Sockets.Socket>に関連付けられているすべてのマネージリソースとアンマネージリソースを解放します。 終了時に、<xref:System.Net.Sockets.Socket.Connected%2A> プロパティが `false`に設定されます。  
  
 接続指向プロトコルの場合、<xref:System.Net.Sockets.Socket.Close%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Shutdown%2A> を呼び出すことをお勧めします。 これにより、接続されたソケットが閉じられる前に、すべてのデータが送信され、受信されます。  
  
 最初に <xref:System.Net.Sockets.Socket.Shutdown%2A>を呼び出さずに <xref:System.Net.Sockets.Socket.Close%2A> を呼び出す必要がある場合は、<xref:System.Net.Sockets.SocketOptionName.DontLinger> オプションを `false` に設定し、ゼロ以外のタイムアウト期間を指定することによって、送信転送用のキューに置かれたデータが送信されるようにすることができます。 <xref:System.Net.Sockets.Socket.Close%2A> は、このデータが送信されるか、指定されたタイムアウトが経過するまでブロックされます。 <xref:System.Net.Sockets.SocketOptionName.DontLinger> を `false` に設定し、タイムアウト間隔をゼロに指定した場合、<xref:System.Net.Sockets.Socket.Close%2A> は接続を解放し、発信キューに格納されたデータを自動的に破棄します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket オプションを `false`に設定するには、<xref:System.Net.Sockets.LingerOption>を作成し、enabled プロパティを `true`に設定して、<xref:System.Net.Sockets.LingerOption.LingerTime%2A> プロパティを目的のタイムアウト期間に設定します。 この <xref:System.Net.Sockets.LingerOption> を <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket オプションと共に使用して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Net.Sockets.Socket>を閉じる方法を示しています。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホストへの接続を確立します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP">リモート デバイスを表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>リモート ホストへの接続を確立します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドは、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> と指定されたリモートエンドポイント間のネットワーク接続を同期的に確立します。 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> によって既定のリモートホストが確立されます。 <xref:System.Net.Sockets.Socket.Connect%2A>を呼び出した後、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを使用してリモートデバイスにデータを送信したり、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドを使用してリモートデバイスからデータを受信したりすることができます。  
  
 UDP などのコネクションレスプロトコルを使用している場合は、データを送受信する前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.SendTo%2A> と <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用して、リモートホストと同期的に通信できます。 <xref:System.Net.Sockets.Socket.Connect%2A>を呼び出すと、指定された既定以外のアドレスから到着したデータグラムはすべて破棄されます。 既定のリモートホストをブロードキャストアドレスに設定する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。指定しないと、<xref:System.Net.Sockets.Socket.Connect%2A> は <xref:System.Net.Sockets.SocketException>をスローします。 <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティを `false` に明示的に設定しない限り、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドはブロックされます。 TCP のような接続指向プロトコルを使用していて、ブロックを無効にすると、<xref:System.Net.Sockets.Socket.Connect%2A> は接続に時間がかかるため、<xref:System.Net.Sockets.SocketException> をスローします。 コネクションレスプロトコルは、既定のリモートホストを確立するだけなので、例外をスローしません。 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> を使用すると、特定のエラーコードを取得できます。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。 エラーによって WSAEWOULDBLOCK が返された場合、リモートホスト接続は接続指向 <xref:System.Net.Sockets.Socket>によって開始されていますが、まだ正常に完了していません。 <xref:System.Net.Sockets.Socket.Poll%2A> メソッドを使用して、<xref:System.Net.Sockets.Socket> の接続がいつ終了するかを判断します。  
  
> [!NOTE]
>  接続指向プロトコルを使用していて、<xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出さなかった場合は、基になるサービスプロバイダーによってローカルネットワークアドレスとポート番号が割り当てられます。 コネクションレスプロトコルを使用している場合、送信または受信操作が完了するまで、サービスプロバイダーはローカルネットワークアドレスとポート番号を割り当てません。 既定のリモートホストを変更する場合は、目的のエンドポイントで <xref:System.Net.Sockets.Socket.Connect%2A> をもう一度呼び出します。  
  
> [!NOTE]
>  ソケットが既に切断されている場合は、この方法を使用して接続を復元することはできません。 非同期の <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドのいずれかを使用して再接続します。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートエンドポイントに接続し、接続を確認します。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
        <permission cref="T:System.Net.SocketPermission">リモートホストに接続するために使用します。 関連付けられた列挙型: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">リモート ホストの IP アドレス。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストは、IP アドレスとポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドは、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> と指定されたリモートエンドポイント間のネットワーク接続を同期的に確立します。 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> によって既定のリモートホストが確立されます。 を呼び出した後、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを使用してリモートデバイスにデータを送信したり、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドを使用してリモートデバイスからデータを受信したりすることができ <xref:System.Net.Sockets.Socket.Connect%2A> ます。  
  
 UDP などのコネクションレスプロトコルを使用している場合は、データを送受信する前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.SendTo%2A> と <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用して、リモートホストと同期的に通信できます。 を呼び出すと <xref:System.Net.Sockets.Socket.Connect%2A> 指定した既定値以外のアドレスから到達したデータグラムは破棄されます。 既定のリモートホストをブロードキャストアドレスに設定する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。指定しないと、<xref:System.Net.Sockets.Socket.Connect%2A> は <xref:System.Net.Sockets.SocketException>をスローします。 <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティを `false` に明示的に設定しない限り、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドはブロックします。 TCP のような接続指向プロトコルを使用していて、ブロックを無効にすると、<xref:System.Net.Sockets.Socket.Connect%2A> は接続に時間がかかるため、<xref:System.Net.Sockets.SocketException> をスローします。 コネクションレスプロトコルは、既定のリモートホストを確立するだけなので、例外をスローしません。 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> を使用すると、特定のエラーコードを取得できます。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。 エラーによって WSAEWOULDBLOCK が返された場合、リモートホスト接続は接続指向 <xref:System.Net.Sockets.Socket>によって開始されていますが、まだ正常に完了していません。 <xref:System.Net.Sockets.Socket.Poll%2A> メソッドを使用して、<xref:System.Net.Sockets.Socket> の接続がいつ終了するかを判断します。  
  
> [!NOTE]
>  接続指向プロトコルを使用していて、<xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出さなかった場合は、基になるサービスプロバイダーによってローカルネットワークアドレスとポート番号が割り当てられます。 コネクションレスプロトコルを使用している場合、送信または受信操作が完了するまで、サービスプロバイダーはローカルネットワークアドレスとポート番号を割り当てません。 既定のリモートホストを変更する場合は、目的のエンドポイントで <xref:System.Net.Sockets.Socket.Connect%2A> をもう一度呼び出します。  
  
> [!NOTE]
>  ソケットが既に切断されている場合は、この方法を使用して接続を復元することはできません。 非同期の <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドのいずれかを使用して再接続します。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートエンドポイントに接続し、接続を確認します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">リモート ホストの IP アドレス。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストは、IP アドレスの配列とポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、通常、1つのホストに対して複数の IP アドレスを返すことができる <xref:System.Net.Dns.GetHostAddresses%2A>の呼び出しの直後に使用されます。 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドは、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> と指定されたリモートエンドポイント間のネットワーク接続を同期的に確立します。 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> によって既定のリモートホストが確立されます。 を呼び出した後、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを使用してリモートデバイスにデータを送信したり、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドを使用してリモートデバイスからデータを受信したりすることができ <xref:System.Net.Sockets.Socket.Connect%2A> ます。  
  
 UDP などのコネクションレスプロトコルを使用している場合は、データを送受信する前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.SendTo%2A> と <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用して、リモートホストと同期的に通信できます。 を呼び出すと <xref:System.Net.Sockets.Socket.Connect%2A> 指定した既定値以外のアドレスから到達したデータグラムは破棄されます。 既定のリモートホストをブロードキャストアドレスに設定する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。指定しないと、<xref:System.Net.Sockets.Socket.Connect%2A> は <xref:System.Net.Sockets.SocketException>をスローします。 <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティを `false` に明示的に設定しない限り、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドはブロックします。 TCP のような接続指向プロトコルを使用していて、ブロックを無効にすると、<xref:System.Net.Sockets.Socket.Connect%2A> は接続に時間がかかるため、<xref:System.Net.Sockets.SocketException> をスローします。 コネクションレスプロトコルは、既定のリモートホストを確立するだけなので、例外をスローしません。 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> を使用すると、特定のエラーコードを取得できます。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。 エラーによって WSAEWOULDBLOCK が返された場合、リモートホスト接続は接続指向 <xref:System.Net.Sockets.Socket>によって開始されていますが、まだ正常に完了していません。 <xref:System.Net.Sockets.Socket.Poll%2A> メソッドを使用して、<xref:System.Net.Sockets.Socket> の接続がいつ終了するかを判断します。  
  
> [!NOTE]
>  接続指向プロトコルを使用していて、<xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出さなかった場合は、基になるサービスプロバイダーによってローカルネットワークアドレスとポート番号が割り当てられます。 コネクションレスプロトコルを使用している場合、送信または受信操作が完了するまで、サービスプロバイダーはローカルネットワークアドレスとポート番号を割り当てません。 既定のリモートホストを変更する場合は、目的のエンドポイントで <xref:System.Net.Sockets.Socket.Connect%2A> をもう一度呼び出します。  
  
> [!NOTE]
>  ソケットが既に切断されている場合は、この方法を使用して接続を復元することはできません。 非同期の <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドのいずれかを使用して再接続します。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートエンドポイントに接続し、接続を確認します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">リモート ホストの名前。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストはホスト名とポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> 方法では、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> と指定したリモートホストの間のネットワーク接続を同期的に確立します。 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> によって既定のリモートホストが確立されます。 を呼び出した後、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを使用してリモートデバイスにデータを送信したり、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドを使用してリモートデバイスからデータを受信したりすることができ <xref:System.Net.Sockets.Socket.Connect%2A> ます。  
  
 UDP などのコネクションレスプロトコルを使用している場合は、データを送受信する前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.SendTo%2A> と <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用して、リモートホストと同期的に通信できます。 を呼び出すと <xref:System.Net.Sockets.Socket.Connect%2A> 指定した既定値以外のアドレスから到達したデータグラムは破棄されます。 既定のリモートホストをブロードキャストアドレスに設定する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。指定しないと、<xref:System.Net.Sockets.Socket.Connect%2A> は <xref:System.Net.Sockets.SocketException>をスローします。 <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティを `false` に明示的に設定しない限り、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドはブロックします。 TCP のような接続指向プロトコルを使用していて、ブロックを無効にすると、<xref:System.Net.Sockets.Socket.Connect%2A> は接続に時間がかかるため、<xref:System.Net.Sockets.SocketException> をスローします。 コネクションレスプロトコルは、既定のリモートホストを確立するだけなので、例外をスローしません。 <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> を使用すると、特定のエラーコードを取得できます。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。 エラーによって WSAEWOULDBLOCK が返された場合、リモートホスト接続は接続指向 <xref:System.Net.Sockets.Socket>によって開始されていますが、まだ正常に完了していません。 <xref:System.Net.Sockets.Socket.Poll%2A> メソッドを使用して、<xref:System.Net.Sockets.Socket> の接続がいつ終了するかを判断します。  
  
 Ipv6 が有効になっていて、<xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> メソッドを呼び出して、IPv6 と IPv4 の両方のアドレスに解決されるホストに接続する場合、IPv4 アドレスの前に IPv6 アドレスへの接続が最初に試行されます。 ホストが IPv6 アドレスでリッスンしていない場合、接続の確立に時間がかかることがあります。  
  
> [!NOTE]
>  接続指向プロトコルを使用していて、<xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出さなかった場合は、基になるサービスプロバイダーによってローカルネットワークアドレスとポート番号が割り当てられます。 コネクションレスプロトコルを使用している場合、送信または受信操作が完了するまで、サービスプロバイダーはローカルネットワークアドレスとポート番号を割り当てません。 既定のリモートホストを変更する場合は、目的のエンドポイントで <xref:System.Net.Sockets.Socket.Connect%2A> をもう一度呼び出します。  
  
> [!NOTE]
>  ソケットが既に切断されている場合は、この方法を使用して接続を復元することはできません。 非同期の <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドのいずれかを使用して再接続します。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートエンドポイントに接続し、接続を確認します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホストに接続する非同期要求を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート ホストに接続する非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドによって、リモートホストへの接続に対する非同期要求が開始されます。 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> によって既定のリモートホストが確立されます。  
  
 完了を通知するには、EventHandler\<SocketAsyncEventArgs > delegate を実装するコールバックメソッドを作成し、コールバックを <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> イベントにアタッチする必要があります。  
  
 呼び出し元は、接続先のリモートホストの <xref:System.Net.IPEndPoint> に <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> プロパティを設定する必要があります。  
  
 呼び出し元は、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 UDP などのコネクションレスプロトコルを使用している場合は、データを送受信する前に <xref:System.Net.Sockets.Socket.ConnectAsync%2A> を呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.SendToAsync%2A> と <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> を使用して、リモートホストと通信できます。 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>を呼び出すと、指定された既定以外のアドレスから到着したデータグラムはすべて破棄されます。 既定のリモートホストを変更する場合は、目的のエンドポイントで <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドをもう一度呼び出します。  
  
 既定のリモートホストをブロードキャストアドレスに設定する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> を呼び出し、`true`にブロードキャストを設定する必要があります。 これが行われていない場合は、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドによって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 必要に応じて、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドが成功した後に、ソケットでアトミックに送信されるバッファーを指定することもできます。 この場合、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> プロパティは、送信するデータを格納するバッファーに設定する必要があります。また、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> プロパティは、バッファーから送信するデータのバイト数に設定する必要があります。 接続が確立されると、このバッファーのデータが送信されます。  
  
 接続指向プロトコルを使用していて、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出さない場合は、基になるサービスプロバイダーによって、最も適切なローカルネットワークアドレスとポート番号が割り当てられます。  
  
 コネクションレスプロトコルを使用している場合、サービスプロバイダーは、<xref:System.Net.Sockets.Socket.SendAsync%2A> または <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッドを呼び出すまで、ローカルネットワークの IP アドレスとポート番号を割り当てません。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドは、<xref:System.Net.Sockets.Socket> のアドレスファミリと <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> が同じアドレスファミリでない場合に <xref:System.NotSupportedException> をスローします。  
  
> [!NOTE]
>  このメソッドの呼び出し時に <xref:System.Net.Sockets.SocketException> を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合に発生します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> がリッスンしているか、<paramref name="e" /> パラメーターで指定されている <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。 この例外は、ローカル エンドポイントと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> が同じアドレス ファミリではない場合にも発生します。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか 1 つ。</param>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート ホストに接続する非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用している場合は、M:System.Net.Sockets.Socket.ConnectAsync (SocketAsyncEventArgs) メソッドによって、の非同期要求が開始されます。このメソッドは、の非同期要求を開始します。リモートホストへの接続。 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> は、`socketType` パラメーターと `protocolType` パラメーターで指定された既定のリモートホストを確立します。  
  
 完了を通知するには、EventHandler\<SocketAsyncEventArgs > delegate を実装するコールバックメソッドを作成し、コールバックを <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> イベントにアタッチする必要があります。  
  
 呼び出し元は、接続先のリモートホストの <xref:System.Net.IPEndPoint> に <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> プロパティを設定する必要があります。  
  
 呼び出し元は、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 UDP などのコネクションレスプロトコルを使用している場合は、データを送受信する前に <xref:System.Net.Sockets.Socket.ConnectAsync%2A> を呼び出す必要はありません。 <xref:System.Net.Sockets.Socket.SendToAsync%2A> と <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> を使用して、リモートホストと通信できます。 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>を呼び出すと、指定された既定以外のアドレスから到着したデータグラムはすべて破棄されます。 既定のリモートホストを変更する場合は、目的のエンドポイントで <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドをもう一度呼び出します。  
  
 既定のリモートホストをブロードキャストアドレスに設定する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> を呼び出し、`true`にブロードキャストを設定する必要があります。 これが行われていない場合は、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドによって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 必要に応じて、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドが成功した後に、ソケットでアトミックに送信されるバッファーを指定することもできます。 この場合、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> プロパティは、送信するデータを格納するバッファーに設定する必要があります。また、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> プロパティは、バッファーから送信するデータのバイト数に設定する必要があります。 接続が確立されると、このバッファーのデータが送信されます。  
  
 接続指向プロトコルを使用していて、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出さない場合は、基になるサービスプロバイダーによって、最も適切なローカルネットワークアドレスとポート番号が割り当てられます。  
  
 コネクションレスプロトコルを使用している場合、サービスプロバイダーは、<xref:System.Net.Sockets.Socket.SendAsync%2A> または <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッドを呼び出すまで、ローカルネットワークの IP アドレスとポート番号を割り当てません。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドは、<xref:System.Net.Sockets.Socket> のアドレスファミリと <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> が同じアドレスファミリでない場合に <xref:System.NotSupportedException> をスローします。  
  
> [!NOTE]
>  このメソッドの呼び出し時に <xref:System.Net.Sockets.SocketException> を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合に発生します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> がリッスンしているか、<paramref name="e" /> パラメーターで指定されている <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。 この例外は、ローカル エンドポイントと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> が同じアドレス ファミリではない場合にも発生します。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最後に実行された <see cref="Overload:System.Net.Sockets.Socket.Send" /> 操作または <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 操作の時点で、<see cref="T:System.Net.Sockets.Socket" /> がリモート ホストに接続されていたかどうかを示す値を取得します。</summary>
        <value>最後に実行された操作の時点で、<see cref="T:System.Net.Sockets.Socket" /> がリモート リソースに接続されていた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Connected` プロパティは、最後の i/o 操作の <xref:System.Net.Sockets.Socket> の接続状態を取得します。 `false`を返した場合、<xref:System.Net.Sockets.Socket> は接続されていないか、接続されていません。  
  
 <xref:System.Net.Sockets.Socket.Connected%2A> プロパティの値には、最新の操作での接続の状態が反映されます。 接続の現在の状態を確認する必要がある場合は、非ブロッキングのゼロバイトの送信呼び出しを行います。 呼び出しが正常に返された場合、または WAEWOULDBLOCK エラーコード (10035) をスローした場合、ソケットはまだ接続されています。それ以外の場合、ソケットは接続されなくなります。  
  
 ユーザーデータグラムプロトコル (UDP) ソケットで <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出した場合、<xref:System.Net.Sockets.Socket.Connected%2A> プロパティは常に `true`を返します。ただし、この操作では、UDP の固有のコネクションレス特性は変更されません。  
  
   
  
## Examples  
 次のコード例では、リモートエンドポイントに接続し、<xref:System.Net.Sockets.Socket.Connected%2A> プロパティを確認して、接続の現在の状態を確認します。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">現在の接続の終了後、このソケットが再利用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>ソケット接続を閉じ、ソケットを再利用できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用している場合は、このメソッドを使用してソケットを閉じることができます。 このメソッドは接続を終了し、<xref:System.Net.Sockets.Socket.Connected%2A> プロパティを `false`に設定します。 ただし、`reuseSocket` が `true`場合は、ソケットを再利用できます。  
  
 ソケットが閉じられる前にすべてのデータが送受信されるようにするには、<xref:System.Net.Sockets.Socket.Disconnect%2A> メソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Shutdown%2A> を呼び出す必要があります。  
  
 最初に <xref:System.Net.Sockets.Socket.Shutdown%2A>を呼び出さずに <xref:System.Net.Sockets.Socket.Disconnect%2A> を呼び出す必要がある場合は、<xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> オプションを `false` に設定し、ゼロ以外のタイムアウト間隔を指定して、送信用のキューに格納されたデータが送信されるようにすることができます。 <xref:System.Net.Sockets.Socket.Disconnect%2A> は、データが送信されるか、指定されたタイムアウトが経過するまでブロックします。 <xref:System.Net.Sockets.SocketOptionName.DontLinger> を `false` に設定し、タイムアウト間隔をゼロに指定した場合、<xref:System.Net.Sockets.Socket.Close%2A> は接続を解放し、発信キューに格納されたデータを自動的に破棄します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、同期通信用のソケットを作成し、いくつかのデータをリモートホストに送信します。 次に、<xref:System.Net.Sockets.Socket.Shutdown%2A>を呼び出して、送信と受信のアクティビティを停止し、<xref:System.Net.Sockets.Socket.Disconnect%2A>してソケット接続を閉じます。  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは、Windows 2000 以前でのみサポートされます。それ以外の場合は、例外がスローされます。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート エンドポイントからの切断の非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用する場合、<xref:System.Net.Sockets.Socket.DisconnectAsync%2A> メソッドを呼び出すと、リモートエンドポイントからの切断が要求されます。 <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> を `e` パラメーターで `true` に設定すると、ソケットを再利用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> パラメーターを null 値にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> を使い終わったら、`Dispose`を呼び出します。 `Dispose`メソッドによって、<xref:System.Net.Sockets.Socket> は使用不可の状態になります。 `Dispose`呼び出し後は、<xref:System.Net.Sockets.Socket>によって占有されていたメモリをガベージ コレクターがクリアできるよう、<xref:System.Net.Sockets.Socket> へのすべての参照を解放する必要があります。  
  
 詳細については、[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)および[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket>への最後の参照を解放する前に、必ず`Dispose`を呼び出してください。 そうしないと、ガベージ コレクターが <xref:System.Net.Sockets.Socket> オブジェクトの `Finalize` メソッドを呼び出すまで、使用されているリソースは解放されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> が使用しているアンマネージド リソースを解放します。オプションでマネージド リソースも破棄します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック `Dispose()` メソッドと <xref:System.Object.Finalize%2A> メソッドによって呼び出されます。 `Dispose()` は、`disposing` パラメーターを `true`に設定して、protected `Dispose(Boolean)` メソッドを呼び出します。 <xref:System.Object.Finalize%2A> は `disposing` を `false`に設定して `Dispose` を呼び出します。  
  
 `disposing` パラメーターが `true` の場合、このメソッドは、この <xref:System.Net.Sockets.Socket> が参照しているすべてのマネージド オブジェクトによって保持されているリソースをすべて解放します。 このメソッドは、参照される各オブジェクトの `Dispose()` メソッドを呼び出します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> は、他のオブジェクトから複数回呼び出すことができます。 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> をオーバーライドする場合は、以前に <see langword="Dispose" /> を呼び出したときに破棄されたオブジェクトを参照しないように注意する必要があります。 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />を実装する方法の詳細については、「 [Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)」を参照してください。  
  
<see langword="Dispose" /> と <see cref="M:System.Object.Finalize" />の詳細については、「[アンマネージリソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)」と「 [Finalize メソッドのオーバーライド](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))」を参照してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> でインターネット プロトコル (IP) データグラムの断片化を許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を、取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> でデータグラムの断片化を許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 データグラムのサイズが、転送メディアの最大転送単位 (MTU) を超えると、断片化が必要になります。 送信ホスト (すべてのインターネットプロトコルバージョン) または中間ルーター (インターネットプロトコルバージョン4のみ) によって、データグラムが断片化される場合があります。 データグラムをフラグメント化する必要があり、<xref:System.Net.Sockets.Socket.DontFragment%2A> オプションが設定されている場合、データグラムは破棄され、インターネット制御メッセージプロトコル (ICMP) のエラーメッセージがデータグラムの送信者に送り返されます。  
  
 伝送制御プロトコル (TCP) ソケットでこのプロパティを設定しても効果はありません。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Net.Sockets.Socket.DontFragment%2A> プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このプロパティは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ファミリまたは <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットに対してだけ設定できます。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Boolean" /> が IPv4 と IPv6 の両方に使用されるデュアル モード ソケットであるかどうか指定する <see cref="T:System.Net.Sockets.Socket" /> 値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> がデュアルモードのソケットの場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">ソケット参照の複製が作成されるターゲット プロセスの ID。</param>
        <summary>ターゲット プロセスのソケット参照を複製してこのプロセスのソケットを閉じます。</summary>
        <returns>ターゲット プロセスに渡されるソケット参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ターゲットプロセスでは、<xref:System.Net.Sockets.Socket.%23ctor%2A> を使用して、重複するソケットインスタンスを作成する必要があります。  
  
 各呼び出しの引数と同じバイト配列を使用して <xref:System.Net.Sockets.Socket.%23ctor%2A> コンストラクターを複数回呼び出す場合は、基になる同じソケットを持つ複数のマネージ <xref:System.Net.Sockets.Socket> インスタンスを作成します。 この方法は推奨されません。  
  
 ソケットを作成するプロセスで非同期メソッド (<xref:System.Net.Sockets.Socket.BeginReceive%2A> または <xref:System.Net.Sockets.Socket.BeginSend%2A>) が使用されている場合、プロセスはまず <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> プロパティを true に設定する必要があります。それ以外の場合、ソケットは作成プロセスの完了ポートにバインドされるため、ターゲットプロセスで <xref:System.ArgumentNullException> がスローされる可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="targetProcessID" /> が有効なプロセス ID ではありません。 
- または - 
ソケット参照の複製に失敗しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> でブロードキャスト パケットの送受信を許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> でブロードキャスト パケットを許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ブロードキャストは特定のサブネットに限定され、ユーザーデータグラムプロトコル (UDP) を使用する必要があります。インターネットプロトコルバージョン4では、パケットを255.255.255.255 に送信してローカルサブネットにブロードキャストできます。または、宛先ブロードキャストアドレスを使用することもできます。これは、ホスト部分ですべてのビットが設定されたインターネットプロトコル (IP) アドレスのネットワーク部分です。 たとえば、IP アドレスが 192.168.1.40 (クラス C のアドレスで、ネットマスクが255.255.255.0 の場合) の場合、ネットワークの部分が最初の3つのオクテットで、ホストの部分が最後のオクテットである場合、転送先のブロードキャストアドレスは192.168.1.255 になります。  
  
 伝送制御プロトコル (TCP) ソケットでこのプロパティを設定しても効果はありません。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Net.Sockets.Socket.EnableBroadcast%2A> プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">このオプションは、データグラム ソケットに対してだけ有効です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>受信接続の試行を非同期的に受け入れます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">転送されたバイト数を格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="asyncResult">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> オブジェクトを作成してリモート ホスト通信を処理します。 このメソッドは、転送される初期データを格納するバッファーを返します。</summary>
        <returns>リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A>の呼び出しを完了します。 <xref:System.Net.Sockets.Socket.BeginAccept%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートによって呼び出されるコールバックメソッドを作成する必要があります。 このコールバックメソッドは、別個のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドから制御が戻った後、システムによって呼び出されます。  
  
 コールバックメソッド内で `asyncResult` パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、接続試行が行われている <xref:System.Net.Sockets.Socket> を取得します。 <xref:System.Net.Sockets.Socket>を取得した後は、<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを呼び出して、接続の試行を正常に完了させることができます。 このオーバーロードの `buffer` パラメーターには、<xref:System.Net.Sockets.Socket.BeginAccept%2A> への呼び出しで受信したデータが含まれています。 `bytesTransferred` パラメーターには、呼び出しで転送されたバイト数が含まれています。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、接続が受信接続キューで保留状態になるまでブロックします。 <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、受信接続を受け入れ、リモートホストとの間でデータを送受信するために使用できる新しい <xref:System.Net.Sockets.Socket> を返します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.Socket.BeginAccept%2A> を使用してソケットを作成および接続し、最初の10バイトのデータを受け入れます。 コールバックデリゲートは、非同期要求を終了するために <xref:System.Net.Sockets.Socket.EndAccept%2A> を呼び出します。 転送されたバイト数とデータは、このメソッドの `buffer` パラメーターと `bytesTransferred` パラメーターに返され、コンソールに表示されます。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> を作成してリモート ホスト通信を処理します。</summary>
        <returns>リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A>の呼び出しを完了します。 <xref:System.Net.Sockets.Socket.BeginAccept%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは、別個のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドから制御が戻った後、システムによって呼び出されます。 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドから返された `asyncResult` パラメーターを受け入れる必要があります。  
  
 コールバックメソッド内で `asyncResult` パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、接続試行が行われている <xref:System.Net.Sockets.Socket> を取得します。 <xref:System.Net.Sockets.Socket>を取得した後は、<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを呼び出して、接続の試行を正常に完了させることができます。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、接続が受信接続キューで保留状態になるまでブロックします。 <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、受信接続を受け入れ、リモートホストとの間でデータを送受信するために使用できる新しい <xref:System.Net.Sockets.Socket> を返します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期要求を終了し、受信接続要求を受け入れる新しい <xref:System.Net.Sockets.Socket> を作成します。 ソケットを使用した非同期通信を示す完全な例については、[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)を参照してください。  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、次の「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * int * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">転送されたバイト数を格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="bytesTransferred">転送されたバイト数。</param>
        <param name="asyncResult">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> オブジェクトを作成してリモート ホスト通信を処理します。 このメソッドは、初期データと、転送されたバイト数を格納するバッファーを返します。</summary>
        <returns>リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A>の呼び出しを完了します。 <xref:System.Net.Sockets.Socket.BeginAccept%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートによって呼び出されるコールバックメソッドを作成する必要があります。 このコールバックメソッドは、別個のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドから制御が戻った後、システムによって呼び出されます。 <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドから返された `asyncResult` パラメーターを受け入れる必要があります。  
  
 コールバックメソッド内で `asyncResult` パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、接続試行が行われている <xref:System.Net.Sockets.Socket> を取得します。 <xref:System.Net.Sockets.Socket>を取得した後は、<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを呼び出して、接続の試行を正常に完了させることができます。 このオーバーロードの `buffer` パラメーターには、<xref:System.Net.Sockets.Socket.BeginAccept%2A> への呼び出しで受信したデータが含まれています。 `bytesTransferred` パラメーターには、呼び出しで転送されたバイト数が含まれています。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、接続が受信接続キューで保留状態になるまでブロックします。 <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、受信接続を受け入れ、リモートホストとの間でデータを送受信するために使用できる新しい <xref:System.Net.Sockets.Socket> を返します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.Socket.BeginAccept%2A> を使用してソケットを作成および接続し、最初の10バイトのデータを受け入れます。 コールバックデリゲートは、非同期要求を終了するために <xref:System.Net.Sockets.Socket.EndAccept%2A> を呼び出します。 転送されたバイト数とデータは、このメソッドの `buffer` パラメーターと `bytesTransferred` パラメーターに返され、コンソールに表示されます。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>保留中の非同期接続要求を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> は、<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドで開始された非同期リモートホスト接続要求を完了するブロッキングメソッドです。  
  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginConnect%2A> が返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーターとして <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドによって返された <xref:System.IAsyncResult> を受け入れる必要があります。  
  
 コールバックメソッド内で <xref:System.IAsyncResult> パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、接続試行が行われている <xref:System.Net.Sockets.Socket> を取得します。 <xref:System.Net.Sockets.Socket>を取得した後は、<xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドを呼び出して、接続の試行を正常に完了させることができます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を終了します。 ソケットを使用した非同期通信を示す完全な例については、[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)を参照してください。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> は、非同期接続のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作のステータス情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>保留中の非同期切断要求を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>の呼び出しを完了します。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> メソッドは、切断が完了するまでブロックします。 非同期操作の詳細については、MSDN ライブラリの「非同期プログラミングの概要」を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期通信用のソケットを作成し、いくつかのデータをリモートホストに送信します。 データが送信されると、<xref:System.Net.Sockets.Socket.Shutdown%2A> が呼び出され、送信と受信のアクティビティが停止されます。 次に、<xref:System.Net.Sockets.Socket.BeginDisconnect%2A> が呼び出され、切断要求が開始されます。 コールバックデリゲートは、非同期要求を終了するために <xref:System.Net.Sockets.Socket.EndDisconnect%2A> を呼び出します。 要求が完了すると、ソケットが切断されているかどうかをテストするために <xref:System.Net.Sockets.Socket.Connected%2A> プロパティが照会されます。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> は、非同期接続のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.Net.WebException">切断要求がタイムアウトしました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>保留中の非同期読み取りを終了します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>保留中の非同期読み取りを終了します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドは、<xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドで開始された非同期の読み取り操作を完了します。  
  
 <xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginReceive%2A> が返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーターとして <xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドによって返された <xref:System.IAsyncResult> を受け入れる必要があります。  
  
 コールバックメソッド内で、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、<xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドに渡される状態オブジェクトを取得します。 この状態オブジェクトから受信側の <xref:System.Net.Sockets.Socket> を抽出します。 <xref:System.Net.Sockets.Socket>を取得した後、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを呼び出して、読み取り操作を正常に完了し、読み取ったバイト数を返すことができます。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドは、データが使用可能になるまでブロックします。 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceive%2A> は、受信ネットワークバッファーで使用可能な最初のエンキューされたデータグラムを読み取ります。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドによって、<xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドの `size` パラメーターで指定したバイト数まで、使用可能な量のデータが読み取られます。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  
  
 受信したデータを取得するには、<xref:System.IAsyncResult>の <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出し、結果の状態オブジェクトに格納されているバッファーを抽出します。  
  
 保留中の <xref:System.Net.Sockets.Socket.BeginReceive%2A>を取り消すには、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、保留中の非同期読み取りを終了します。 ソケットを使用した非同期通信を示す完全な例については、[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)を参照してください。  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult * SocketError -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>保留中の非同期読み取りを終了します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドは、<xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドで開始された非同期の読み取り操作を完了します。  
  
 <xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginReceive%2A> が返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーターとして <xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドによって返された <xref:System.IAsyncResult> を受け入れる必要があります。  
  
 コールバックメソッド内で、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、<xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドに渡される状態オブジェクトを取得します。 この状態オブジェクトから受信側の <xref:System.Net.Sockets.Socket> を抽出します。 <xref:System.Net.Sockets.Socket>を取得した後、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを呼び出して、読み取り操作を正常に完了し、読み取ったバイト数を返すことができます。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドは、データが使用可能になるまでブロックします。 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceive%2A> は、受信ネットワークバッファーで使用可能な最初のエンキューされたデータグラムを読み取ります。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドによって、<xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドの `size` パラメーターで指定したバイト数まで、使用可能な量のデータが読み取られます。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  
  
 受信したデータを取得するには、<xref:System.IAsyncResult>の <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出し、結果の状態オブジェクトに格納されているバッファーを抽出します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (asyncResult, endPoint)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="endPoint">コピー元 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="end_point">コピー元 <see cref="T:System.Net.EndPoint" />。</param>
        <summary>特定のエンドポイントからの、保留中の非同期読み込みを終了します。</summary>
        <returns>正常に完了した場合は、受信したバイト数。 失敗した場合は、0 を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドは、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドで開始された非同期の読み取り操作を完了します。  
  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> が返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーターとして <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドによって返された <xref:System.IAsyncResult> を受け入れる必要があります。  
  
 コールバックメソッド内で、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドに渡される状態オブジェクトを取得します。 この状態オブジェクトから受信側の <xref:System.Net.Sockets.Socket> を抽出します。 <xref:System.Net.Sockets.Socket>を取得した後、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドを呼び出して、読み取り操作を正常に完了し、読み取ったバイト数を返すことができます。  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドは、データが使用可能になるまでブロックします。 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> は、受信ネットワークバッファーで使用可能な最初のエンキューされたデータグラムを読み取ります。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドによって、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドの `size` パラメーターで指定したバイト数まで、使用可能な量のデータが読み取られます。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドが直ちに完了し、ゼロバイトが返されます。 受信したデータを取得するには、<xref:System.IAsyncResult> オブジェクトの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出し、結果の状態オブジェクトに格納されているバッファーを抽出します。 元のホストを特定するには、<xref:System.Net.EndPoint> を抽出し、それを <xref:System.Net.IPEndPoint>にキャストします。 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> メソッドを使用して IP アドレスを取得し、<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 方法を使用してポート番号を取得します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、特定の <xref:System.Net.EndPoint>からの保留中の非同期読み取りを終了します。  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="socketFlags">受信パケットの <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="endPoint">コピー元 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">受信パケットの <see cref="T:System.Net.IPAddress" /> とインターフェイス。</param>
        <summary>特定のエンドポイントからの、保留中の非同期読み込みを終了します。 また、このメソッドは、<see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> よりもパケットに関するより多くの情報を示します。</summary>
        <returns>正常に完了した場合は、受信したバイト数。 失敗した場合は、0 を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作が完了していない場合、このメソッドは、処理が完了するまでブロックします。  
  
 この操作を同期的に実行するには、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドを使用します。  
  
 データグラムがユニキャスト、マルチキャスト、またはブロードキャストアドレスを使用して送信されたかどうかを確認する必要がある場合は、`ipPacketInformation` を調べます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" /> です  
  
- または - 
 <paramref name="endPoint" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>保留中の非同期送信を終了します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>保留中の非同期送信を終了します。</summary>
        <returns>正常に終了した場合は <see cref="T:System.Net.Sockets.Socket" /> に送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> は <xref:System.Net.Sockets.Socket.BeginSend%2A>で開始された非同期送信操作を完了します。  
  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginSend%2A> が返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーターとして <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドによって返された <xref:System.IAsyncResult> を受け入れる必要があります。  
  
 コールバックメソッド内で <xref:System.IAsyncResult> パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、送信側の <xref:System.Net.Sockets.Socket>を取得します。 <xref:System.Net.Sockets.Socket>を取得した後、<xref:System.Net.Sockets.Socket.EndSend%2A> メソッドを呼び出して送信操作を正常に完了し、送信されたバイト数を返すことができます。  
  
 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndSend%2A> はデータグラムが送信されるまでブロックされます。 接続指向プロトコルを使用している場合は、バッファーの一部が送信されるまで、<xref:System.Net.Sockets.Socket.EndSend%2A> はブロックされます。 <xref:System.Net.Sockets.Socket.EndSend%2A> からの戻り値が、バッファーが完全に送信されていないことを示している場合は、<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを再度呼び出して、未送信データを保持するバッファーを変更します。  
  
 送信したデータがネットワークに直ちに表示される保証はありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、保留中の非同期送信を終了します。  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult * SocketError -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>保留中の非同期送信を終了します。</summary>
        <returns>正常に終了した場合は <see cref="T:System.Net.Sockets.Socket" /> に送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> は <xref:System.Net.Sockets.Socket.BeginSend%2A>で開始された非同期送信操作を完了します。  
  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginSend%2A> が返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーターとして <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドによって返された <xref:System.IAsyncResult> を受け入れる必要があります。  
  
 コールバックメソッド内で <xref:System.IAsyncResult> パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、送信側の <xref:System.Net.Sockets.Socket>を取得します。 <xref:System.Net.Sockets.Socket>を取得した後、<xref:System.Net.Sockets.Socket.EndSend%2A> メソッドを呼び出して送信操作を正常に完了し、送信されたバイト数を返すことができます。  
  
 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndSend%2A> はデータグラムが送信されるまでブロックされます。 接続指向プロトコルを使用している場合は、バッファーの一部が送信されるまで、<xref:System.Net.Sockets.Socket.EndSend%2A> はブロックされます。 <xref:System.Net.Sockets.Socket.EndSend%2A> からの戻り値が、バッファーが完全に送信されていないことを示している場合は、<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを再度呼び出して、未送信データを保持するバッファーを変更します。  
  
 送信したデータがネットワークに直ちに表示される保証はありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。 保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>ファイルの保留中の非同期送信を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> は <xref:System.Net.Sockets.Socket.BeginSendFile%2A>で開始された非同期送信操作を完了します。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginSendFile%2A> が返された後にシステムによって呼び出されます。 コールバックメソッドは、<xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドによって返された <xref:System.IAsyncResult> オブジェクトをパラメーターとして受け取る必要があります。  
  
 コールバックメソッド内で <xref:System.IAsyncResult> パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、送信側の <xref:System.Net.Sockets.Socket>を取得します。 <xref:System.Net.Sockets.Socket>を取得した後、<xref:System.Net.Sockets.Socket.EndSendFile%2A> メソッドを呼び出して、送信操作を正常に完了させることができます。  
  
 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndSendFile%2A> はデータグラムが送信されるまでブロックします。 接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndSendFile%2A> は、ファイル全体が送信されるまでブロックします。 送信したデータがネットワークに直ちに表示される保証はありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期通信用のソケットを作成して接続し、リモートホストへのファイル "test.txt" の非同期送信を開始します。 コールバックデリゲートは、転送を完了するために <xref:System.Net.Sockets.Socket.EndSendFile%2A> を呼び出します。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> が、非同期の <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>特定の場所への、保留中の非同期送信を終了します。</summary>
        <returns>正常に完了した場合は送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> は <xref:System.Net.Sockets.Socket.BeginSendTo%2A>で開始された非同期送信操作を完了します。  
  
 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。 このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginReceive%2A> が返された後にシステムによって呼び出されます。 コールバックメソッドは、パラメーターとして <xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドによって返された <xref:System.IAsyncResult> を受け入れる必要があります。  
  
 コールバックメソッド内で <xref:System.IAsyncResult> パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、送信側の <xref:System.Net.Sockets.Socket>を取得します。 <xref:System.Net.Sockets.Socket>を取得した後、<xref:System.Net.Sockets.Socket.EndSendTo%2A> メソッドを呼び出して送信操作を正常に完了し、送信されたバイト数を返すことができます。  
  
 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndSendTo%2A> はデータグラムが送信されるまでブロックされます。 接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndSendTo%2A> は、要求されたバイト数が送信されるまでブロックされます。 送信したデータがネットワークに直ちに表示される保証はありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、特定の場所への非同期送信を終了します。  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> で 1 つのプロセスだけにポートのバインドを許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> で 1 つのソケットだけに特定のポートのバインドを許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、Windows Server 2003 と Windows XP Service Pack 2 の場合は <see langword="true" />、それ以外のすべてのバージョンの場合は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> が `false`場合、複数のソケットで <xref:System.Net.Sockets.Socket.Bind%2A> 方法を使用して、特定のポートにバインドできます。ただし、ポートに送信されたネットワークトラフィックに対して操作を実行できるのは、ソケットの1つだけです。 複数のソケットが特定のポートにバインドするために <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> 方法を使用しようとすると、そのポートに送信されたネットワークトラフィックが、特定の IP アドレスを持つ1つのソケットによって処理されます。  
  
 <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> が `true`場合は、インターネットプロトコル (IP) アドレスに関係なく、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して特定のポートにバインドしようとしても成功します。その後、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用すると、元のバインドされたソケットが破棄されるまで、そのポートへのバインドを試行することはできません。  
  
 <xref:System.Net.Sockets.Socket.Bind%2A> が呼び出される前に、このプロパティを設定する必要があります。それ以外の場合、<xref:System.InvalidOperationException> がスローされます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">この <see cref="T:System.Net.Sockets.Socket" /> に対して <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> が呼び出されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> クラスによって使用されていたリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> クラスファイナライザーは、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出して <xref:System.Net.Sockets.Socket> を閉じ、<xref:System.Net.Sockets.Socket>に関連付けられているリソースを解放します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> インスタンスのハッシュ値を返します。</summary>
        <returns>整数ハッシュ値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
GetHashCode メソッドは、このインスタンスのハッシュコードを返します。 この値は、ハッシュテーブルのキーとして使用できます。

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> オプションの値を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションの値をオブジェクトとして返します。</summary>
        <returns>オプションの値を表すオブジェクト。 <paramref name="optionName" /> パラメーターを <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> に設定した場合、戻り値は <see cref="T:System.Net.Sockets.LingerOption" /> クラスのインスタンスです。 <paramref name="optionName" /> を <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> または <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> に設定した場合、戻り値は <see cref="T:System.Net.Sockets.MulticastOption" /> クラスのインスタンスです。 <paramref name="optionName" /> が他の値の場合、戻り値は整数です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Net.Sockets.Socket>の動作は、<xref:System.Net.Sockets.Socket> オプションによって決まります。 このオーバーロードを使用して、<xref:System.Net.Sockets.Socket> オプションの <xref:System.Net.Sockets.SocketOptionName.Linger>、<xref:System.Net.Sockets.SocketOptionName.AddMembership>、および <xref:System.Net.Sockets.SocketOptionName.DropMembership>を取得します。 <xref:System.Net.Sockets.SocketOptionName.Linger> オプションでは、`optionLevel` パラメーターに <xref:System.Net.Sockets.Socket> を使用します。 <xref:System.Net.Sockets.SocketOptionName.AddMembership> と <xref:System.Net.Sockets.SocketOptionName.DropMembership>については、<xref:System.Net.Sockets.SocketOptionLevel.IP>を使用します。 上記のオプションのいずれかの値を設定する場合は、<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを使用します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> のタイムアウト値を取得し、コンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  
  
- または - 
 <paramref name="optionName" /> が、サポートされていない値 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /> に設定されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">オプション設定を受信する <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプション設定をバイト配列として返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Net.Sockets.Socket>の動作は、<xref:System.Net.Sockets.Socket> オプションによって決まります。 このメソッドが正常に完了すると、`optionValue` パラメーターによって指定された配列に、指定された <xref:System.Net.Sockets.Socket> オプションの値が含まれます。  
  
 `optionValue` 配列の長さが、指定された <xref:System.Net.Sockets.Socket> オプションの値を格納するために必要なバイト数よりも小さい場合、<xref:System.Net.Sockets.Socket.GetSocketOption%2A> は <xref:System.Net.Sockets.SocketException>をスローします。 <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。 このオーバーロードは、ブール値または整数で表されるソケットに対して使用します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> のタイムアウト値を取得し、コンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  
  
- または - 
.NET Compact Framework アプリケーションでは、Windows CE の既定のバッファー領域は 32768 バイトに設定されます。 ソケットごとのバッファー領域は、<see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> を呼び出して変更できます。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionLength">予期される戻り値のバイト単位の長さ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションの値を配列で返します。</summary>
        <returns>ソケット オプションの値を格納している <see cref="T:System.Byte" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength` パラメーターは、返されるバイト配列の最大サイズを設定します。 オプションの値が必要なバイト数が少なくなる場合、配列にはその数のバイトだけが格納されます。 オプションの値により多くのバイトが必要な場合は、<xref:System.Net.Sockets.Socket.GetSocketOption%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 このオーバーロードは、ブール値または整数で表されるソケットに対して使用します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> のタイムアウト値を取得し、コンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  
  
- または - 
.NET Compact Framework アプリケーションでは、Windows CE の既定のバッファー領域は 32768 バイトに設定されます。 ソケットごとのバッファー領域は、<see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> を呼び出して変更できます。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> のオペレーティング システム ハンドルを取得します。</summary>
        <value><see cref="T:System.IntPtr" /> のオペレーティング システム ハンドルを表す <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">実行する操作の制御コードを指定する <see cref="T:System.Int32" /> 値。</param>
        <param name="optionInValue">操作に必要な入力データを格納する <see cref="T:System.Byte" /> 配列。</param>
        <param name="optionOutValue">操作によって返された出力データを格納する <see cref="T:System.Byte" /> 配列。</param>
        <summary>数値制御コードを使用して、<see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</summary>
        <returns><paramref name="optionOutValue" /> パラメーターのバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.IOControl%2A> メソッドは、<xref:System.Net.Sockets.Socket> クラスの現在のインスタンスの基になるオペレーティングシステム <xref:System.Net.Sockets.Socket> に低レベルのアクセスを提供します。 詳細については、 [Wsaioctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl)のドキュメントを参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、FIONREAD と使用可能なプロパティの結果を比較します。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Net.Sockets.Socket.Blocking" /> プロパティを使用せずに、ブロッキング モードを変更しようとしました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージコードを実行する場合は。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">実行する操作の制御コードを指定する <see cref="T:System.Net.Sockets.IOControlCode" /> 値。</param>
        <param name="optionInValue">操作に必要な入力データを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="optionOutValue">操作によって返された出力データを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <summary><see cref="T:System.Net.Sockets.IOControlCode" /> 列挙型を使用して制御コードを指定し、<see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</summary>
        <returns><paramref name="optionOutValue" /> パラメーターのバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Net.Sockets.Socket> クラスの現在のインスタンスの基になるオペレーティングシステム <xref:System.Net.Sockets.Socket> に低レベルのアクセスを提供します。 詳細については、 [Wsaioctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl)のドキュメントを参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.Socket.IOControl%2A> を呼び出した結果を <xref:System.Net.Sockets.IOControlCode.DataToRead> と <xref:System.Net.Sockets.Socket.Available%2A> プロパティと比較しています。  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Net.Sockets.Socket.Blocking" /> プロパティを使用せずに、ブロッキング モードを変更しようとしました。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージコードを実行する場合は。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> が特定のローカル ポートにバインドされているかどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> がローカル ポートにバインドされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ソケットは、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出すことによって明示的にバインドされている場合、または <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.SendTo%2A>、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>などのメンバーを呼び出すことによって暗黙的にバインドされている場合は、ローカルポートにバインドされていると見なされます。これは、オペレーティングシステムによって選択された、一時的なローカルポート 1024 (サーバーは、クライアントが接続できるように、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して既知のポートにバインドします。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Net.Sockets.Socket.IsBound%2A> プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> で、すべての保留中のデータを送信しようとするときにソケットを遅延して閉じるかどうかを指定する値を取得または設定します。</summary>
        <value>ソケットを閉じているときの待機方法を指定する <see cref="T:System.Net.Sockets.LingerOption" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LingerState%2A> プロパティは、<xref:System.Net.Sockets.Socket.Close%2A> メソッドの動作方法を変更します。 このプロパティを設定すると、Winsock によって接続をリセットできる条件が変更されます。 接続のリセットは、IP プロトコルの動作によっても発生する可能性があります。  
  
 このプロパティは、データが送信されたままになっている場合に <xref:System.Net.Sockets.Socket.Close%2A> を呼び出すと、接続指向接続が開いたままになる時間を制御します。  
  
 ピアにデータを送信するためにメソッドを呼び出すと、このデータは送信ネットワークバッファーに配置されます。 このプロパティを使用すると、<xref:System.Net.Sockets.TcpClient.Close%2A> メソッドによって接続が切断される前に、このデータがリモートホストに確実に送信されるようにすることができます。  
  
 残留を有効にするには、目的の値を含む <xref:System.Net.Sockets.LingerOption> インスタンスを作成し、<xref:System.Net.Sockets.Socket.LingerState%2A> プロパティをこのインスタンスに設定します。  
  
 次の表では、<xref:System.Net.Sockets.LingerOption.Enabled%2A> プロパティの使用可能な値と <xref:System.Net.Sockets.Socket.LingerState%2A> プロパティに格納されている <xref:System.Net.Sockets.LingerOption.LingerTime%2A> プロパティの <xref:System.Net.Sockets.Socket.Close%2A> メソッドの動作について説明します。  
  
|LingerState.Enabled|LingerState.LingerTime|動作|  
|-------------------------|----------------------------|--------------|  
|`false` (無効)、既定値|タイムアウトは適用されません (既定)。|既定の IP プロトコルのタイムアウトが経過するまで、保留中のデータの送信を試みます。|  
|`true` (有効)|0以外のタイムアウト|指定したタイムアウトが経過するまで保留中のデータを送信しようとします。失敗した場合は、Winsock によって接続がリセットされます。|  
|`true` (有効)|ゼロタイムアウト。|保留中のデータを破棄します。 接続指向のソケット (TCP など) の場合、Winsock によって接続がリセットされます。|  
  
 IP スタックは、接続のラウンドトリップ時間に基づいて、使用する既定の IP プロトコルタイムアウト期間を計算します。 ほとんどの場合、スタックによって計算されるタイムアウトは、アプリケーションで定義されているものよりも関連性が高くなります。 これは、<xref:System.Net.Sockets.Socket.LingerState%2A> プロパティが設定されていない場合のソケットの既定の動作です。  
  
 <xref:System.Net.Sockets.Socket.LingerState%2A> プロパティに格納されている <xref:System.Net.Sockets.LingerOption.LingerTime%2A> プロパティが既定の IP プロトコルタイムアウトよりも大きい値に設定されている場合でも、既定の IP プロトコルタイムアウトは適用され、上書きされます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Net.Sockets.Socket.LingerState%2A> プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">保留中の接続のキューの最大長。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> をリッスン状態にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> により、接続指向の <xref:System.Net.Sockets.Socket> が着信接続の試行をリッスンします。 `backlog` パラメーターは、受け入れのためにキューに入れることができる着信接続の数を指定します。 指定できる接続の最大数を決定するには、<xref:System.Net.Sockets.SocketOptionName.MaxConnections> 値を取得します。 <xref:System.Net.Sockets.Socket.Listen%2A> はブロックしません。  
  
 <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。 <xref:System.Net.Sockets.Socket.Accept%2A> または <xref:System.Net.Sockets.Socket.BeginAccept%2A> を使用して、キューからの接続を許可します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.Listen%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Listen%2A> が <xref:System.Net.Sockets.SocketException>をスローします。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
> [!NOTE]
>  バックログパラメーターは、オペレーティングシステムによって異なる値に制限されます。 より高い値を指定することもできますが、バックログはオペレーティングシステムに基づいて制限されます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.Socket> を使用して、着信接続をリッスンします。  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル エンドポイントを取得します。</summary>
        <value><see cref="T:System.Net.EndPoint" /> が通信に使用している <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティは、<xref:System.Net.Sockets.Socket> がバインドされているローカル IP アドレスとポート番号を含む <xref:System.Net.EndPoint> を取得します。 情報を取得する前に、この <xref:System.Net.EndPoint> を <xref:System.Net.IPEndPoint> にキャストする必要があります。 その後、<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> メソッドを呼び出してローカル <xref:System.Net.IPAddress>を取得し、<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> メソッドを呼び出してローカルポート番号を取得できます。  
  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティは、通常、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出した後に設定されます。 ソケットのローカル IP アドレスとポート番号の割り当てをシステムに許可した場合、最初の i/o 操作の後に <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティが設定されます。 接続指向プロトコルの場合、最初の i/o 操作は <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドの呼び出しになります。 コネクションレスプロトコルの場合、最初の i/o 操作は、送信または受信呼び出しのいずれかになります。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、ローカルとリモートのエンドポイントを取得して表示します。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発信マルチキャスト パケットが送信元アプリケーションに配信されるかどうかを指定する値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> が発信マルチキャスト パケットを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マルチキャストは、インターネット上の多対多通信のためのスケーラブルな方法です。 プロセスは、マルチキャストアドレスをサブスクライブします。次に、サブスクライブされたプロセスによって送信されたすべてのパケットが、マルチキャストアドレスをサブスクライブしている他のすべてのプロセスによって受信されます。  
  
 伝送制御プロトコル (TCP) ソケットでこのプロパティを設定しても効果はありません。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Net.Sockets.Socket.MulticastLoopback%2A> プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ストリーム <see cref="T:System.Net.Sockets.Socket" /> が Nagle アルゴリズムを使用するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> が Nagle アルゴリズムを使用する場合は <see langword="false" />。それ以外の場合は <see langword="true" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagle アルゴリズムは、ソケットが小さいパケットをバッファーに格納し、特定の状況下でそれらを結合して1つのパケットで送信することで、ネットワークトラフィックを削減するように設計されています。 TCP パケットは、40バイトのヘッダーと送信されるデータで構成されます。 TCP を使用して少量のデータパケットを送信すると、TCP ヘッダーによって生じるオーバーヘッドがネットワークトラフィックの重要な部分になる可能性があります。 負荷が高いネットワークでは、このオーバーヘッドによって発生する輻輳によって、データグラムが失われ、再送信される可能性があります。また、輻輳による過剰な伝達時間も発生する可能性があります。 Nagle アルゴリズムでは、接続で以前に転送されたデータがまだ未確認の場合に、新しい送信データがユーザーから到着したときに、新しい TCP セグメントの送信を抑制します。  
  
 ほとんどのネットワークアプリケーションでは、Nagle アルゴリズムを使用する必要があります。  
  
 ユーザーデータグラムプロトコル (UDP) ソケットでこのプロパティを設定しても効果はありません。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Net.Sockets.Socket.NoDelay%2A> プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 4 (IPv4) をサポートするかどうかを示します。</summary>
        <value>オペレーティング システムおよびネットワーク アダプターが IPv4 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティングシステムは、IPv4 プロトコルと IPv6 プロトコルの両方をサポートしている場合があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 6 (IPv6) をサポートするかどうかを示します。</summary>
        <value>オペレーティング システムおよびネットワーク アダプターが IPv6 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティングシステムは、IPv4 プロトコルと IPv6 プロトコルの両方をサポートしている場合があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="microSeconds">マイクロ秒単位の待機時間。</param>
        <param name="mode"><see cref="T:System.Net.Sockets.SelectMode" /> 値のいずれか 1 つ。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の状態を確認します。</summary>
        <returns><paramref name="mode" /> パラメーターで渡されるポーリング モードの値に基づいた <see cref="T:System.Net.Sockets.Socket" /> の状態。  
  
 <list type="table"><listheader><term> モード 
 </term><description> 戻り値 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> が呼び出されており、接続が保留中の場合は <see langword="true" />。 
- または - 
 データを読み取ることができる場合は <see langword="true" />。 
- または - 
 接続が閉じている、リセットされている、または終了している場合は <see langword="true" />。 
それ以外の場合、<see langword="false" /> を返します。  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> を処理し、接続に成功した場合は <see langword="true" />。 
- または - 
 データを送信できる場合は <see langword="true" />。 
それ以外の場合、<see langword="false" /> を返します。  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description>ブロックしない <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> を処理し、接続に失敗した場合は <see langword="true" />。 
- または - 
 <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> が設定されておらず、帯域外データを使用できる場合は <see langword="true" />。 
それ以外の場合、<see langword="false" /> を返します。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Poll%2A> メソッドは、<xref:System.Net.Sockets.Socket>の状態を確認します。 <xref:System.Net.Sockets.Socket> が読み取り可能かどうかを判断するには、`selectMode` パラメーターに <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> を指定します。 <xref:System.Net.Sockets.Socket> を書き込み可能にするかどうかを判断するには、<xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> を指定します。 エラー状態を検出するには、<xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> を使用します。 <xref:System.Net.Sockets.Socket.Poll%2A> は、指定された期間 (`microseconds`で測定) が経過するまで実行をブロックします。 応答を無期限に待機する場合は、`microSeconds` パラメーターを負の整数に設定します。 複数のソケットの状態を確認する場合は、<xref:System.Net.Sockets.Socket.Select%2A> メソッドを使用することをお勧めします。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  この方法では、ネットワークケーブルの切断など、特定の種類の接続の問題を検出することはできません。また、リモートホストが異常終了をシャットダウンしたことを確認することもできません。 これらの種類のエラーを検出するには、データの送信または受信を試みる必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、ソケットを作成し、サーバーに接続して、<xref:System.Net.Sockets.Socket.Poll%2A> を使用してソケットの状態を確認します。  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="mode" /> パラメーターが、<see cref="T:System.Net.Sockets.SelectMode" /> 値の 1 つではありません。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> のプロトコルの種類を取得します。</summary>
        <value><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A> プロパティは、<xref:System.Net.Sockets.Socket> が作成されるときに設定され、その <xref:System.Net.Sockets.Socket>によって使用されるプロトコルを指定します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.AddressFamily>、<xref:System.Net.Sockets.SocketType>、および <xref:System.Net.Sockets.ProtocolType> をコンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信し、受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。  
  
 このオーバーロードでは、受信バッファーのみを指定する必要があります。 バッファーオフセットの既定値は0で、サイズは既定でバッファーパラメーターの長さに設定され、<xref:System.Net.Sockets.SocketFlags> 値は既定で <xref:System.Net.Sockets.SocketFlags.None>に設定されます。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。  
  
 読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。  
  
 接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで、使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  
  
 コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。 受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffer` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、接続された <xref:System.Net.Sockets.Socket>でデータを受信します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <summary>バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して、受信バッファーのリストに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、buffers パラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケットとコネクションレスソケットの両方からを呼び出すことができます。  
  
 このオーバーロードでは、1つ以上の受信バッファーを指定する必要があります。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホスト接続から到着したデータのみを読み取ります。 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。  
  
 読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。  
  
 接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで、使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  
  
 コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した宛先アドレスから最初にエンキューされたデータグラムを読み取ります。 受信するデータグラムが `buffers` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffers` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
 **メモ**このメンバーは、アプリケーションでネットワークトレースを有効にしたときにトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となるバイトのスパン。</param>
        <summary>バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信し、受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。

このオーバーロードでは、受信バッファーのみを指定する必要があります。 バッファーオフセットの既定値は0で、サイズは既定でバッファーパラメーターの長さに設定され、<xref:System.Net.Sockets.SocketFlags> 値は既定で <xref:System.Net.Sockets.SocketFlags.None>に設定されます。

接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。

読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。

接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで、使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。

コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。 受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合、`buffer` はメッセージの最初の部分を格納し、余分なデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。

> [!NOTE]
> <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。

このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れています。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。  
  
 このオーバーロードでは、受信バッファーと必要な <xref:System.Net.Sockets.SocketFlags>のみを指定する必要があります。 バッファーオフセットは既定で0に設定され、サイズは既定でバイトパラメーターの長さに設定されます。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。  
  
 データを読み取ることができない場合、データが使用可能になるまで、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはブロックされます。 非ブロッキングモードで、プロトコルスタックバッファーに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。  
  
 接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  
  
 コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した宛先アドレスから最初にエンキューされたデータグラムを読み取ります。 受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffer` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、データバッファーと、接続された <xref:System.Net.Sockets.Socket>でデータを受信するための <xref:System.Net.Sockets.SocketFlags> を指定します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れています。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーのリストに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、`buffers` パラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケットとコネクションレスソケットの両方からを呼び出すことができます。  
  
 このオーバーロードでは、1つ以上の受信バッファーを指定する必要があります。 <xref:System.Net.Sockets.SocketFlags> 値は既定で <xref:System.Net.Sockets.SocketFlags.None>に設定されています。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホスト接続から到着したデータのみを読み取ります。 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。  
  
 読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。  
  
 接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで、使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  
  
 コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した宛先アドレスから最初にエンキューされたデータグラムを読み取ります。 受信するデータグラムが `buffers` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffers` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、接続された <xref:System.Net.Sockets.Socket>でデータを受信する方法を示しています。  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="buffers" />.Count が 0 です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となるバイトのスパン。</param>
        <param name="socketFlags">送受信の動作を指定する列挙値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。

このオーバーロードでは、受信バッファーのみを指定する必要があります。 バッファーオフセットの既定値は0で、サイズは既定でバッファーパラメーターの長さに設定され、<xref:System.Net.Sockets.SocketFlags> 値は既定で <xref:System.Net.Sockets.SocketFlags.None>に設定されます。

接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。

読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。

接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで、使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。

コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。 受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合、`buffer` はメッセージの最初の部分を格納し、余分なデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。

> [!NOTE]
> <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。

このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> から指定したバイト数のデータを受信して受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、`buffer` パラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。  
  
 このオーバーロードでは、受信バッファー、受信するバイト数、および必要な <xref:System.Net.Sockets.SocketFlags>を指定するだけで済みます。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。  
  
 読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。  
  
 接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、`size` パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  
  
 コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。 受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffer` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、`buffer`にあるデータを受け取り、<xref:System.Net.Sockets.SocketFlags>の <xref:System.Net.Sockets.SocketFlags.None> を指定しています。  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> が <paramref name="buffer" /> のサイズを超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーのリストに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、`buffers` パラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケットとコネクションレスソケットの両方からを呼び出すことができます。  
  
 このオーバーロードでは、1つ以上の受信バッファーを指定する必要があります。 <xref:System.Net.Sockets.SocketFlags> 値は既定で <xref:System.Net.Sockets.SocketFlags.None>に設定されています。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホスト接続から到着したデータのみを読み取ります。 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。  
  
 読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。  
  
 接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで、使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  
  
 コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。 受信するデータグラムが `buffers` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffers` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="buffers" />.Count が 0 です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となるバイトのスパン。</param>
        <param name="socketFlags">送受信の動作を指定する列挙値のビットごとの組み合わせ。</param>
        <param name="errorCode">このメソッドから制御が戻るときに、ソケットのエラー コードを定義する列挙値の 1 つを格納します。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。  

このオーバーロードでは、受信バッファーのみを指定する必要があります。 バッファーオフセットの既定値は0で、サイズは既定でバッファーパラメーターの長さに設定され、<xref:System.Net.Sockets.SocketFlags> 値は既定で <xref:System.Net.Sockets.SocketFlags.None>に設定されます。  

接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。  

読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。  

接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで、使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  

コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。 受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffer` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。  

> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  

> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信データを格納する <paramref name="buffer" />内の場所。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> から指定したバイト数のデータを受信して、受信バッファー内の指定したオフセット位置に格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。  
  
 読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 ソケットへのアクセスを試行しているときにエラーが発生しました。 下記の注釈を参照してください。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。  
  
 接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、size パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  
  
 コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。 受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffer` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、接続された <xref:System.Net.Sockets.Socket>でデータを受信する前に、データバッファー、オフセット、サイズ、およびソケットフラグを指定します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
- または - 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  
  
- または - 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信したデータを格納する、<paramref name="buffer" /> パラメーター内の位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。 接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。  
  
 読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 ソケットへのアクセスを試行しているときにエラーが発生しました。 下記の注釈を参照してください。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。  
  
 接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、size パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  
  
 コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。 受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffer` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
- または - 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていません。  
  
- または - 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトからデータを受信する非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッドは、接続されたソケットまたはバインドされたコネクションレスソケットで使用され、受信データの読み取りに使用されます。 ソケットのローカルアドレスがわかっている必要があります。  
  
 バインドされたコネクションレスソケットの場合、この関数は、受信したメッセージが受け入れられるアドレスを制限します。 関数は、接続で指定されたリモートアドレスからのメッセージのみを返します。 他のアドレスからのメッセージは、暗黙的に破棄されます。  
  
 `e` パラメーターの <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> プロパティは、Window Sockets service プロバイダーに読み取り要求に関する追加情報を提供します。 このパラメーターの使用方法の詳細については、「<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドを正常に呼び出すには、<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> または <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> が設定されている場合は <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> が設定されている場合は <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、<xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 バイトストリームスタイルのソケットの場合、バッファーがいっぱいになるか、接続が閉じられるか、内部バッファーデータが使い果たされるまで、受信データがバッファーに配置されます。  
  
 メッセージ指向のソケットの場合、受信メッセージは `e` パラメーターに関連付けられたバッファーの合計サイズまでバッファーに配置されます。 メッセージがバッファーより大きい場合、バッファーにはメッセージの最初の部分が格納されます。  
  
 接続指向のソケットの場合、<xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッドは、ソケットがバイトストリームかメッセージ指向かに応じて、2つの方法のいずれかで仮想回線の正常な終了を示すことができます。 バイトストリームの場合、読み取られたゼロバイトは正常に終了したことを示し、これ以上バイトは読み取られません。 ゼロバイトのメッセージが許可される可能性があるメッセージ指向のソケットの場合、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> がネイティブ Winsock WSAEDISCON エラーコード (10101) に設定されている <xref:System.Net.Sockets.SocketException> を使用して、正常に終了することを示します。 いずれの場合も、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> がネイティブ Winsock WSAECONNRESET エラーコード (10054) に設定されている <xref:System.Net.Sockets.SocketException> は、中止が発生したことを示します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が無効です。 <paramref name="e" /> パラメーターの <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> プロパティまたは <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティは、有効なバッファーを参照する必要があります。 これらのプロパティは、どちらか 1 つを設定できます。一度に両方のプロパティを設定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の受信バッファーのサイズを指定する値を取得または設定します。</summary>
        <value>受信バッファーのサイズ (バイト単位) を格納している <see cref="T:System.Int32" />。 既定値は 8192 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 バッファーサイズを大きくすると、空の受信確認 (データ部分のない TCP パケット) の数が減少する可能性がありますが、接続の問題の認識が遅れる可能性もあります。 大きなファイルを転送する場合や、高帯域幅の高待機時間接続 (サテライトブロードバンドプロバイダーなど) を使用している場合は、バッファーサイズを大きくすることを検討してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が 0 未満です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>データグラムを受信し、ソース エンドポイントを格納します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>データグラムを受信してデータバッファーに格納します。さらに、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`buffer` パラメーターにデータを読み取り、正常に読み取られたバイト数を返し、データの送信元のリモートホストエンドポイントをキャプチャします。 この方法は、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 このオーバーロードでは、受信 `buffer`、およびリモートホストを表す <xref:System.Net.EndPoint> を指定する必要があります。 バッファーオフセットの既定値は0です。 既定のサイズは `buffer` パラメーターの長さで、`socketFlags` の値は既定で <xref:System.Net.Sockets.SocketFlags.None>に設定されます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して <xref:System.Net.Sockets.Socket> をローカルエンドポイントに明示的にバインドする必要があります。 そうしないと、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
 コネクションレスプロトコルを使用すると、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムが `buffer`のサイズより大きい場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、可能な限り多くのメッセージを `buffer` に入力し、<xref:System.Net.Sockets.SocketException>をスローします。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な大きさのバッファーを使用して <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出すことで取得できます。  
  
 データを読み取ることができない場合、データが使用可能になるまで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはブロックされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。 これを選択する場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを呼び出して受信リモートホスト接続を受け入れる必要があります。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に接続を確立または受け入れない場合、<xref:System.Net.Sockets.SocketException>が表示されます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合も、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`remoteEP` パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。  
  
 接続指向のソケットを使用すると、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は `buffer`のサイズまで使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> で使用される <xref:System.Net.EndPoint> の <xref:System.Net.Sockets.AddressFamily> は、<xref:System.Net.EndPoint> で使用される <xref:System.Net.Sockets.Socket.SendTo%2A>の <xref:System.Net.Sockets.AddressFamily> と一致する必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートホストからコネクションレスのデータグラムを受信します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、データグラムを受信してデータバッファーに格納します。さらに、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`buffer` パラメーターにデータを読み取り、正常に読み取られたバイト数を返し、データの送信元のリモートホストエンドポイントをキャプチャします。 この方法は、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 このオーバーロードでは、受信バッファー、必要な <xref:System.Net.Sockets.SocketFlags>、およびリモートホストを表す <xref:System.Net.EndPoint> を指定する必要があります。 オフセットの既定値は0で、サイズは既定でバッファーパラメーターの長さに設定されます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して <xref:System.Net.Sockets.Socket> をローカルエンドポイントに明示的にバインドする必要があります。 そうしないと、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
 コネクションレスプロトコルを使用すると、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムが `buffer`のサイズより大きい場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、可能な限り多くのメッセージを `buffer` に入力し、<xref:System.Net.Sockets.SocketException>をスローします。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な大きさのバッファーを使用して <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出すことで取得できます。  
  
 データを読み取ることができない場合、データが使用可能になるまで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはブロックされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。 これを選択する場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを呼び出して受信リモートホスト接続を受け入れる必要があります。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に接続を確立または受け入れない場合、<xref:System.Net.Sockets.SocketException>が表示されます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合も、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`remoteEP` パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。  
  
 接続指向のソケットを使用すると、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は `buffer`のサイズまで使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> で使用される <xref:System.Net.EndPoint> の <xref:System.Net.Sockets.AddressFamily> は、<xref:System.Net.EndPoint> で使用される <xref:System.Net.Sockets.Socket.SendTo%2A>の <xref:System.Net.Sockets.AddressFamily> と一致する必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートホストからコネクションレスのデータグラムを受信します。 <xref:System.Net.Sockets.SocketFlags> は <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドに渡されます。  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを受信してデータ バッファーに格納します。さらに、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`buffer` パラメーターにデータを読み取り、正常に読み取られたバイト数を返し、データの送信元のリモートホストエンドポイントをキャプチャします。 この方法は、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 このオーバーロードでは、受信バッファー、受信するバイト数、必要な <xref:System.Net.Sockets.SocketFlags>、およびリモートホストを表す <xref:System.Net.EndPoint> を指定する必要があります。 バッファーオフセットの既定値は0です。  
  
 コネクションレスプロトコルを使用すると、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムが `buffer`のサイズより大きい場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、可能な限り多くのメッセージを `buffer` に入力し、<xref:System.Net.Sockets.SocketException>をスローします。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な大きさのバッファーを使用して <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出すことで取得できます。  
  
 データを読み取ることができない場合、データが使用可能になるまで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはブロックされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。 これを選択する場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを呼び出して受信リモートホスト接続を受け入れる必要があります。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に接続を確立または受け入れない場合、<xref:System.Net.Sockets.SocketException>が表示されます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合も、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`remoteEP` パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。  
  
 接続指向のソケットでは、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、`size` パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して <xref:System.Net.Sockets.Socket> をローカルエンドポイントに明示的にバインドする必要があります。 そうしないと、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> で使用される <xref:System.Net.EndPoint> の <xref:System.Net.Sockets.AddressFamily> は、<xref:System.Net.EndPoint> で使用される <xref:System.Net.Sockets.Socket.SendTo%2A>の <xref:System.Net.Sockets.AddressFamily> と一致する必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートホストからコネクションレスのデータグラムを受信します。 バッファーサイズと <xref:System.Net.Sockets.SocketFlags> が <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドに渡されます。  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が <paramref name="buffer" />の長さを超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
- または - 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  
  
- または - 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信したデータを格納する、<paramref name="buffer" /> パラメーター内の位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを受信して、データ バッファー内の指定した位置に格納します。またエンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`buffer` パラメーターにデータを読み取り、正常に読み取られたバイト数を返し、データの送信元のリモートホストエンドポイントをキャプチャします。 この方法は、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 コネクションレスプロトコルを使用すると、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムが `buffer`のサイズより大きい場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、可能な限り多くのメッセージを `buffer` に入力し、<xref:System.Net.Sockets.SocketException>をスローします。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な大きさのバッファーを使用して <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出すことで取得できます。  
  
 データを読み取ることができない場合、データが使用可能になるまで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはブロックされます。 非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。 <xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。 これを選択する場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを呼び出して受信リモートホスト接続を受け入れる必要があります。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に接続を確立または受け入れない場合、<xref:System.Net.Sockets.SocketException>が表示されます。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合も、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`remoteEP` パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。  
  
 接続指向のソケットを使用すると、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、`size` パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。 リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、ゼロバイトが返されます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して <xref:System.Net.Sockets.Socket> をローカルエンドポイントに明示的にバインドする必要があります。 そうしないと、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> で使用される <xref:System.Net.EndPoint> の <xref:System.Net.Sockets.AddressFamily> は、<xref:System.Net.EndPoint> で使用される <xref:System.Net.Sockets.Socket.SendTo%2A>の <xref:System.Net.Sockets.AddressFamily> と一致する必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモートホストからコネクションレスのデータグラムを受信します。 オフセット、バッファーサイズ、および <xref:System.Net.Sockets.SocketFlags> が <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドに渡されます。  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さからオフセット パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
- または - 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  
  
- または - 
ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>指定したネットワーク デバイスから、データの非同期の受信を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> メソッドは、主にコネクションレスソケットでデータを受信するために使用されます。 ソケットのローカルアドレスがわかっている必要があります。  
  
 呼び出し元は、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> プロパティを、データを受信するリモートホストの <xref:System.Net.IPEndPoint> に設定する必要があります。  
  
 `e` パラメーターの <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> プロパティは、Window Sockets service プロバイダーに読み取り要求に関する追加情報を提供します。 このパラメーターの使用方法の詳細については、「<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>」を参照してください。  
  
 このメソッドを正常に呼び出すには、<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 メッセージ指向のソケットの場合は、バッファーの合計サイズまで、受信メッセージがバッファーに格納されます。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> プロパティと <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> プロパティによって、バッファー内のデータの格納場所とデータ量が決まります。  
  
 バイトストリームスタイルのソケットの場合、バッファーがいっぱいになるか、接続が閉じられるか、内部バッファーデータが使い果たされるまで、受信データがバッファーに配置されます。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> プロパティと <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> プロパティによって、バッファー内のデータの格納場所とデータ量が決まります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信したデータを格納する、<paramref name="buffer" /> パラメーター内の位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">アドレスとインターフェイスの情報を保持する <see cref="T:System.Net.Sockets.IPPacketInformation" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータをデータ バッファー内の指定した位置で受信して、エンドポイントおよびパケット情報を格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドは、`buffer` パラメーターにデータを読み取り、正常に読み取られたバイト数を返します。さらに、データの送信元のリモートホストエンドポイントと、受信パケットに関する情報をキャプチャします。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドは、主にコネクションレスソケットでメッセージデータを受信するために使用されます。 ソケットのローカルアドレスがわかっている必要があります。 このメソッドは、データグラムと raw ソケットでのみ使用できます。 ソケットは、このメソッドを呼び出す前に、<xref:System.Net.Sockets.SocketType.Dgram> または <xref:System.Net.Sockets.SocketType.Raw> に設定されたソケットの種類を使用して初期化する必要があります。 これは <xref:System.Net.Sockets.Socket.%23ctor%2A>を使用してソケットを構築するときに行うことができます。  
  
 メッセージ指向のソケットの場合、受信メッセージは、`size` パラメーターで指定された合計サイズまでの `buffer` パラメーターに配置されます。 `offset` パラメーターは、データを配置する `buffer` 内の場所を決定します。 `buffer` に格納される実際のデータ量は、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドによって返されます。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドは、<xref:System.Net.Sockets.SocketOptionName.PacketInformation> ソケットオプションを、特定の <xref:System.Net.Sockets.Socket>に対して初めて呼び出すときに `true` するように設定します。 ただし、返された <xref:System.Net.Sockets.IPPacketInformation> オブジェクトは、ソケットオプションが設定された後にローカルコンピューターに到着したパケットに対してのみ有効です。 ソケットがローカルエンドポイントにバインドされたとき (<xref:System.Net.Sockets.Socket.Bind%2A> メソッドによって明示的に、または <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、<xref:System.Net.Sockets.Socket.SendTo%2A>、または <xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドのいずれかによって暗黙的に) にパケットが送信された場合、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドを呼び出すと、これらのパケットに対して無効な <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> オブジェクトが返されます。<xref:System.Net.Sockets.IPPacketInformation>  
  
 すべての <xref:System.Net.Sockets.IPPacketInformation> オブジェクトが有効であることを確認するには、<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> メソッドを使用してローカルエンドポイントにバインドする前に、アプリケーションで <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket オプションを `true` に設定する必要があります。  
  
 アプリケーションでは、データグラムがユニキャスト、マルチキャスト、またはブロードキャストアドレスを使用して送信されたかどうかを確認する必要がある場合に、`ipPacketInformation` パラメーターを調べることができます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> で使用される <xref:System.Net.EndPoint> の <xref:System.Net.Sockets.AddressFamily> は、<xref:System.Net.EndPoint> で使用される <xref:System.Net.Sockets.Socket.SendTo%2A>の <xref:System.Net.Sockets.AddressFamily> と一致する必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さからオフセット パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
- または - 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  
  
- または - 
.NET Framework が、AMD 64 ビット プロセッサ上で実行されています。  
  
- または - 
ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるために使用します。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>指定された <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> を使用し、指定されたバイト数のデータの非同期受信を開始して、データ バッファー内の指定された場所に格納します。さらに、エンドポイントとパケットの情報を格納します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> メソッドは、主にコネクションレスソケットでメッセージデータを受信するために使用されます。 ソケットのローカルアドレスがわかっている必要があります。 このメソッドは、データグラムと raw ソケットでのみ使用できます。 ソケットは、このメソッドを呼び出す前に、<xref:System.Net.Sockets.SocketType.Dgram> または <xref:System.Net.Sockets.SocketType.Raw> に設定されたソケットの種類を使用して初期化する必要があります。 これは <xref:System.Net.Sockets.Socket.%23ctor%2A>を使用してソケットを構築するときに行うことができます。  
  
 呼び出し元は、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> プロパティを、データを受信するリモートホストの <xref:System.Net.IPEndPoint> に設定する必要があります。  
  
 このメソッドを正常に呼び出すには、<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 メッセージ指向のソケットの場合は、バッファーの合計サイズまで、受信メッセージがバッファーに格納されます。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> プロパティと <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> プロパティによって、バッファー内のデータの格納場所とデータ量が決まります。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> メソッドは、指定された <xref:System.Net.Sockets.Socket>に対して初めて呼び出されたときに、<xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket オプションを `true` に自動的に設定します。 ただし、<xref:System.Net.Sockets.IPPacketInformation> オブジェクトは、ソケットオプションが設定された後にローカルコンピューターに到着するパケットに対してのみ有効です。 ソケットがローカルエンドポイントにバインドされたとき (<xref:System.Net.Sockets.Socket.Bind%2A> メソッドによって明示的に、または <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、<xref:System.Net.Sockets.Socket.SendTo%2A>、または <xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドのいずれかによって暗黙的に)、ソケットがパケットを送信する場合、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> メソッドを呼び出すと、これらのパケットに対して無効な <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> オブジェクトが生成されます。<xref:System.Net.Sockets.IPPacketInformation>  
  
 すべての <xref:System.Net.Sockets.IPPacketInformation> オブジェクトが有効であることを確認するには、<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> メソッドを使用してローカルエンドポイントにバインドする前に、アプリケーションで <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket オプションを`true` に設定する必要があります。  
  
 アプリケーションでは、データグラムがユニキャスト、マルチキャスト、またはブロードキャストアドレスを使用して送信されたかどうかを確認する必要がある場合に、結果の <xref:System.Net.Sockets.IPPacketInformation> オブジェクトを調べることができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>同期の <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 呼び出しがタイムアウトするまでの合計時間を指定する値を取得または設定します。</summary>
        <value>タイムアウト値 (ミリ秒)。 既定値は 0 です。タイムアウトが無期限であることを示します。 -1 の指定も、タイムアウトが無期限であることを示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオプションは、同期 <xref:System.Net.Sockets.Socket.Receive%2A> 呼び出しにのみ適用されます。 タイムアウト期間を超過すると、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドによって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が -1 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リモート エンドポイントを取得します。</summary>
        <value><see cref="T:System.Net.EndPoint" /> の通信先の <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> プロパティは、<xref:System.Net.Sockets.Socket> が接続されているリモート IP アドレスとポート番号を含む <xref:System.Net.EndPoint> を取得します。 コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> には、<xref:System.Net.Sockets.Socket> が通信する既定のリモート IP アドレスとポート番号が含まれています。 情報を取得する前に、この <xref:System.Net.EndPoint> を <xref:System.Net.IPEndPoint> にキャストする必要があります。 その後、<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> メソッドを呼び出してリモート <xref:System.Net.IPAddress>を取得し、<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> メソッドを呼び出してリモートポート番号を取得できます。  
  
 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> は、<xref:System.Net.Sockets.Socket.Accept%2A> または <xref:System.Net.Sockets.Socket.Connect%2A>の呼び出しの後に設定されます。 このプロパティにアクセスしようとすると、<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、ローカルとリモートのエンドポイントを取得して表示します。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Net.Sockets.Socket" /> オブジェクトによってカプセル化されているソケット ハンドルを表す <see cref="T:System.Net.Sockets.SafeSocketHandle" /> を取得します。</summary>
        <value>現在の <see cref="T:System.Net.Sockets.Socket" /> オブジェクトによってカプセル化されるソケットに対して安全な方法で公開されるソケットハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!IMPORTANT]
> <xref:System.Net.Sockets.SafeSocketHandle> を使用してソケットを直接操作すると、ドキュメント化されていない状態になる可能性があります。 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="checkRead">読みやすさを確認する <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="checkWrite">書き込み機能をチェックする <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="checkError">エラーをチェックする <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="microSeconds">タイムアウト値 (マイクロ秒)。 値が -1 の場合は、タイムアウトが無限であることを示します。</param>
        <summary>1 つまたは複数のソケットのステータスを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> は、1つ以上の <xref:System.Net.Sockets.Socket> インスタンスの状態を決定する静的メソッドです。 <xref:System.Net.Sockets.Socket.Select%2A> 方法を使用する前に、1つまたは複数のソケットを <xref:System.Collections.IList> に配置する必要があります。 `checkRead` パラメーターとして <xref:System.Collections.IList> を指定して <xref:System.Net.Sockets.Socket.Select%2A> を呼び出すことにより、読みやすさを確認します。 書き込み機能のソケットを確認するには、`checkWrite` パラメーターを使用します。 エラー状態を検出するには、`checkError`を使用します。 <xref:System.Net.Sockets.Socket.Select%2A>を呼び出すと、条件を満たすソケットだけが <xref:System.Collections.IList> に入力されます。  
  
 リッスン状態の場合、読みやすさとは、<xref:System.Net.Sockets.Socket.Accept%2A> の呼び出しがブロックされることなく成功することを意味します。 既に接続を受け入れている場合、読みやすさとは、データが読み取り可能であることを意味します。 このような場合、すべての受信操作はブロックされずに成功します。 読みやすさは、リモート <xref:System.Net.Sockets.Socket> が接続をシャットダウンしたかどうかを示すこともできます。この場合、<xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すとすぐに返され、バイト数は返されません。  
  
 対象のソケットの少なくとも1つ (`checkRead`、`checkWrite`、および `checkError` の一覧のソケット) が指定された条件を満たしている場合、または `microSeconds` パラメーターを超えている場合、<xref:System.Net.Sockets.Socket.Select%2A> はを返します。 `microSeconds` を-1 に設定すると、無制限のタイムアウトが指定されます。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>に対して非ブロッキング呼び出しを行うと、書き込み機能は正常に接続したことを意味します。 既に接続が確立されている場合、書き込み機能は、すべての送信操作がブロックせずに成功することを意味します。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>に対して非ブロッキング呼び出しを行った場合、`checkerror` パラメーターは、正常に接続されていないソケットを識別します。  
  
> [!NOTE]
>  1つの <xref:System.Net.Sockets.Socket>の状態を確認するだけの場合は、<xref:System.Net.Sockets.Socket.Poll%2A> メソッドを使用します。  
  
> [!NOTE]
>  この方法では、ネットワークケーブルの切断など、特定の種類の接続の問題を検出することはできません。また、リモートホストが異常終了をシャットダウンしたことを確認することもできません。 これらの種類のエラーを検出するには、データの送信または受信を試みる必要があります。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.Socket.Select%2A> を使用して、接続要求があるリッスンソケットを特定します。  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="checkRead" /> パラメーターは <see langword="null" /> または空です。  
  
および 
<paramref name="checkWrite" /> パラメーターは <see langword="null" /> または空です。 
および 
<paramref name="checkError" /> パラメーターは <see langword="null" /> または空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドに指定されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 このオーバーロードには、送信するデータを格納するバッファーが必要です。 <xref:System.Net.Sockets.SocketFlags> 値の既定値は0です。バッファーオフセットの既定値は0で、既定で送信するバイト数はバッファーのサイズに設定されます。  
  
 コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> 方法を使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。 また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に、既定のリモートホストを変更することもできます。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードでは、バッファー内のバイト数よりも少ない場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、接続された <xref:System.Net.Sockets.Socket>でデータを送信する方法を示しています。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <summary>リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 このオーバーロードには、送信するデータを含むバッファーが少なくとも1つ必要です。  
  
 コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> 方法を使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。 また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に、既定のリモートホストを変更することもできます。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードでは、バッファー内のバイト数よりも少ない場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含むバイトのスパン。</param>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドに指定されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。

このオーバーロードには、送信するデータを格納するバッファーが必要です。 <xref:System.Net.Sockets.SocketFlags> 値の既定値は0です。バッファーオフセットの既定値は0で、既定で送信するバイト数はバッファーのサイズに設定されます。

コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を受け入れる必要があります。

コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。 また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に既定のリモートホストを変更することもできます。

接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードでは、バッファー内のバイト数よりも少ない場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示されるという保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。

> [!NOTE]
><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。

このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。

> [!IMPORTANT]
>送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> メソッドは、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 このオーバーロードには、送信するデータを格納するバッファーと、<xref:System.Net.Sockets.SocketFlags>のビットごとの組み合わせが必要です。 バッファーオフセットの既定値は0で、既定で送信されるバイト数はバッファーのサイズに設定されます。 <xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーター値として指定した場合、送信しようとしているデータはルーティングされません。  
  
 コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> 方法を使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出す必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。 また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に、既定のリモートホストを変更することもできます。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードでは、バッファー内のバイト数よりも少ない場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  バッファーのサイズが、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、接続された <xref:System.Net.Sockets.Socket>でデータを送信する方法を示しています。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードには、送信するデータを含むバッファーが少なくとも1つ必要です。 <xref:System.Net.Sockets.SocketFlags> 値の既定値は0です。 <xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketFlags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。  
  
 コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> 方法を使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。 また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に、既定のリモートホストを変更することもできます。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードでは、<xref:System.Net.Sockets.Socket.Send%2A> がバッファー内のバイト数よりも少ない場合でも、正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含むバイトのスパン。</param>
        <param name="socketFlags">送受信の動作を指定する列挙値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  

  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。

このオーバーロードには、送信するデータを含むバッファー、送信するバイト数、および <xref:System.Net.Sockets.SocketFlags>のビットごとの組み合わせが必要です。 <xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しているデータはルーティングされません。

コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を受け入れる必要があります。

コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを呼び出すたびに、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出す必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。 また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に既定のリモートホストを変更することもできます。

接続指向プロトコルでは、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、要求されたバイト数が送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードでは、要求したバイト数よりも少ない時間で送信された場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。

> [!NOTE]
> サイズが、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.Send%2A> が <xref:System.Net.Sockets.SocketException>をスローします。 <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。

このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。

> [!IMPORTANT]
>送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。

## Examples

次のコード例では、buffer で見つかったデータを送信し、<xref:System.Net.Sockets.SocketFlags>の <xref:System.Net.Sockets.SocketFlags.None> を指定します。

[!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
[!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
[!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> が 0 未満か、バッファーのサイズを超える値です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
- または - 
ソケットへのアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードには、送信するデータを含むバッファーが少なくとも1つ必要です。 <xref:System.Net.Sockets.SocketFlags> 値の既定値は0です。 <xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketFlags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。  
  
 コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> 方法を使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。 また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に、既定のリモートホストを変更することもできます。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードでは、<xref:System.Net.Sockets.Socket.Send%2A> がバッファー内のバイト数よりも少ない場合でも、正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含むバイトのスパン。</param>
        <param name="socketFlags">送受信の動作を指定する列挙値のビットごとの組み合わせ。</param>
        <param name="errorCode">このメソッドから制御が戻るときに、ソケットのエラー コードを定義する列挙値の 1 つを格納します。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドに指定されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。

このオーバーロードには、送信するデータを格納するバッファーが必要です。 <xref:System.Net.Sockets.SocketFlags> 値の既定値は0です。バッファーオフセットの既定値は0で、既定で送信するバイト数はバッファーのサイズに設定されます。

コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を受け入れる必要があります。

コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。 また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に既定のリモートホストを変更することもできます。

接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードでは、バッファー内のバイト数よりも少ない場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示されるという保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。

> [!NOTE]
><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。

このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。

> [!IMPORTANT]
>送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、データ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したオフセットから開始し、指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドに指定されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 このオーバーロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信するデータはルーティングされません。  
  
 コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> が <xref:System.Net.Sockets.SocketException>をスローします。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A>を使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A>を使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。 また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に、既定のリモートホストを変更することもできます。  
  
 また、サイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、要求されたバイト数が送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードでは、要求したバイト数よりも少ない時間で送信された場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、接続されている <xref:System.Net.Sockets.Socket>にデータを送信するためのデータバッファー、オフセット、サイズ、および <xref:System.Net.Sockets.SocketFlags> を指定します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
- または - 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、データ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定したオフセットから開始し、指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドに指定されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 このオーバーロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信するデータはルーティングされません。  
  
 コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> が <xref:System.Net.Sockets.SocketException>をスローします。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。  
  
 コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A>を使用する必要があります。 <xref:System.Net.Sockets.Socket.SendTo%2A>を使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。 また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に、既定のリモートホストを変更することもできます。  
  
 また、サイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、要求されたバイト数が送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。 タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。 非ブロッキングモードでは、要求したバイト数よりも少ない時間で送信された場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。 アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示されません。 転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、接続されている <xref:System.Net.Sockets.Socket>にデータを送信するためのデータバッファー、オフセット、サイズ、および <xref:System.Net.Sockets.SocketFlags> を指定します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
- または - 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、データを非同期に送信します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドは、接続指向のソケット上の1つ以上のバッファーから送信データを書き込むために使用されます。 ただし、このメソッドは、接続操作でリモートホストを指定したコネクションレスソケットでも使用できます。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドは、<xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドで確立されたリモートホストへの非同期の送信操作を開始します。  
  
 このメソッドを正常に呼び出すには、<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> または <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> が設定されている場合は <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> が設定されている場合は <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、<xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A>を呼び出さない場合、<xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドは例外をスローします。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドを呼び出すと、別の実行スレッド内でデータを送信できるようになります。  
  
 メッセージ指向のソケットの場合、基になる Windows sockets service プロバイダーの最大メッセージサイズを超えないようにしてください。 データが長すぎて、基になるサービスプロバイダーを通じてアトミックに渡すことができない場合、データは送信されず、<xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドは、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> がネイティブ Winsock WSAEMSGSIZE エラーコード (10040) に設定された <xref:System.Net.Sockets.SocketException> をスローします。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドが正常に完了したことは、データが正常に配信されたことを示していないことに注意してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="e" /> パラメーターの <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> プロパティまたは <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティは、有効なバッファーを参照する必要があります。 これらのプロパティは、どちらか 1 つを設定できます。一度に両方のプロパティを設定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" /> がまだ接続されていないか、<see cref="M:System.Net.Sockets.Socket.Accept" />、<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />、または <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> の各メソッドによって取得されませんでした。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の送信バッファーのサイズを指定する値を取得または設定します。</summary>
        <value>送信バッファーのサイズ (バイト単位) を格納している <see cref="T:System.Int32" />。 既定値は 8192 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 バッファーサイズを大きくすると、接続の問題の認識が遅れる可能性があります。 大きなファイルを転送する場合や、高帯域幅の高待機時間接続 (サテライトブロードバンドプロバイダーなど) を使用している場合は、バッファーサイズを大きくすることを検討してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Net.Sockets.Socket.SendBufferSize%2A> プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が 0 未満です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> に、ファイルおよびオプション データを同期的に送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を含む <see cref="T:System.String" />。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <summary><see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 送信フラグを使用して、接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> を送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、接続されているソケットにファイル `fileName` を送信します。 `flags` パラメーターの既定値は <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) で、`preBuffer` と `postBuffer` のパラメーターは既定で `null`に設定されています。 `fileName` がローカルディレクトリにある場合は、ファイル名だけで識別できます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt ") と UNC 共有名 ("\\\\\\\ 共有ディレクトリ\\\myfile.txt ") はサポートされています。 ファイルが見つからない場合は、例外 <xref:System.IO.FileNotFoundException> がスローされます。  
  
 このメソッドは、Windows Sockets 2 API の `TransmitFile` 関数を使用します。 `TransmitFile` 関数とそのフラグの詳細については、 [Windows Sockets](/windows/desktop/WinSock/)のドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで指定されたリモートホストにファイルを同期的に送信します。 <xref:System.Net.Sockets.Socket.SendFile%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。そうしないと <xref:System.Net.Sockets.Socket.SendFile%2A> は <xref:System.Net.Sockets.SocketException> 例外をスローします。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を受け入れる必要があります。  
  
 接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.SendFile%2A> は、ファイルが送信されるまでブロックします。 非ブロッキングモードでは、ファイル全体が送信される前に <xref:System.Net.Sockets.Socket.SendFile%2A> が正常に完了することがあります。 送信したデータがネットワークに直ちに表示される保証はありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.SendFile%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、ソケットを作成して接続し、リモートホストにファイルを送信します。 ファイル "test.txt" は、ローカルコンピューターのルートディレクトリにあります。  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を含む <see cref="T:System.String" />。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="preBuffer">ファイルが送信される前に送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="postBuffer">ファイルが送信された後で送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="flags">1 つ以上の <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> およびデータのバッファーを送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードには、送信するファイルの名前と <xref:System.Net.Sockets.TransmitFileOptions> 値のビットごとの組み合わせが必要です。 `preBuffer` パラメーターには、ファイルの前に配置するデータが含まれています。 `postBuffer` には、ファイルに従う必要があるデータが含まれています。 `fileName` が現在の作業ディレクトリにある場合は、ファイル名だけで識別できます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt ") と UNC 共有名 ("\\\\\\\ 共有ディレクトリ\\\myfile.txt ") はサポートされています。  
  
 `flags` パラメーターは、ファイル転送に関する追加情報を Window Sockets service プロバイダーに提供します。 このパラメーターの使用方法の詳細については、「<xref:System.Net.Sockets.TransmitFileOptions>」を参照してください。  
  
 このメソッドは、Windows Sockets 2 API の `TransmitFile` 関数を使用します。 `TransmitFile` 関数とそのフラグの詳細については、 [Windows Sockets](/windows/desktop/WinSock/)のドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで指定されたリモートホストにファイルを同期的に送信します。 <xref:System.Net.Sockets.Socket.SendFile%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。  
  
 コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。それ以外の場合 <xref:System.Net.Sockets.Socket.SendFile%2A> は <xref:System.Net.Sockets.SocketException>をスローします。 接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。  
  
 接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.SendFile%2A> は、ファイル全体が送信されるまでブロックします。 非ブロッキングモードでは、ファイル全体が送信される前に <xref:System.Net.Sockets.Socket.SendFile%2A> が正常に完了することがあります。 送信したデータがネットワークに直ちに表示される保証はありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.SendFile%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、ソケットを作成して接続します。 ファイル "test.txt" は、ローカルコンピューターのルートディレクトリにあります。 この例では、データの prebuffer と postbuffer を作成し、ファイルを使用してリモートホストに送信します。 既定の <xref:System.Net.Sockets.TransmitFileOptions> が使用されます。  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">オペレーティング システムは Windows NT 以降ではありません。  
  
- または -
  
 ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルのコレクションまたはメモリ内のデータ バッファーを非同期に送信します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> メソッドは、ファイルのコレクションまたはメモリ内のデータバッファーをリモートホストに送信するために使用されます。 <xref:System.Net.Sockets.Socket> は、リモートホストに既に接続されている必要があります。  
  
 <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> が作業ディレクトリ内のファイルを参照している場合は、ファイル名だけで識別できます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。 ワイルドカードと UNC 共有名がサポートされています。 ファイルが見つからない場合は、<xref:System.IO.FileNotFoundException> がスローされます。  
  
 完了を通知するには、EventHandler\<SocketAsyncEventArgs > delegate を実装するコールバックメソッドを作成し、コールバックを <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> イベントにアタッチする必要があります。  
  
 `e` パラメーターの <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> プロパティは、Windows ソケットサービスプロバイダーにファイル転送に関する追加情報を提供します。 このパラメーターの使用方法の詳細については、「<xref:System.Net.Sockets.TransmitFileOptions>」を参照してください。  
  
 このメソッドを正常に呼び出すには、<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 このメソッドは、Windows Sockets 2 API の送信パケット関数を使用します。 送信パケット関数とそのフラグの詳細については、 [Windows ソケット](/windows/desktop/WinSock/)のドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> メソッドは、接続指向プロトコルを対象としていますが、最初に <xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも機能します。 コネクションレスプロトコルを使用する場合は、ファイルのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> は <xref:System.Net.Sockets.SocketException> 例外をスローします。  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法は、使用されているオペレーティングシステムに応じて最適化されます。 Windows server のエディションでは、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法は高パフォーマンスのために最適化されています。  
  
 Windows クライアントのエディションでは、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法は、メモリとリソースの使用率が最小になるように最適化されています。  
  
 `e` パラメーターの <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> プロパティで <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> フラグを使用すると、パフォーマンスが大幅に向上します。 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> メソッド呼び出しを開始しているスレッドが大量の計算に使用されている場合、その Apc が起動できなくなる可能性があります。 カーネルとユーザーモードの Apc には違いがあることに注意してください。 スレッドが待機状態になると、カーネル Apc が起動します。 スレッドが警告可能な待機状態になったときにユーザーモードの Apc が起動する  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> プロパティで指定されたファイルが見つかりませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。 この例外は、<see cref="T:System.Net.Sockets.Socket" /> がリモート ホストに接続されていない場合にも発生します。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">コネクションレスの <see cref="T:System.Net.Sockets.Socket" /> が使用されており、送信するファイルが基になるトランスポートの最大パケット サイズを超えています。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>同期の <see cref="Overload:System.Net.Sockets.Socket.Send" /> 呼び出しがタイムアウトするまでの合計時間を指定する値を取得または設定します。</summary>
        <value>タイムアウト値 (ミリ秒)。 プロパティに 1 から 499 までの値を設定しても、その値は 500 に変更されます。 既定値は 0 です。タイムアウトが無期限であることを示します。 -1 の指定も、タイムアウトが無期限であることを示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオプションは、同期 <xref:System.Net.Sockets.Socket.Send%2A> 呼び出しにのみ適用されます。 タイムアウト期間を超過すると、<xref:System.Net.Sockets.Socket.Send%2A> メソッドによって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Net.Sockets.Socket.SendTimeout%2A> プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が -1 未満です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>データを特定のエンドポイントに送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="remoteEP">データの送信先を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定したエンドポイントにデータを送信します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードでは、バッファーオフセットの既定値は0、既定値を送信するバイト数は `buffer` パラメーターのサイズ、<xref:System.Net.Sockets.SocketFlags> 値の既定値は0です。  
  
 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを使用して既定のリモートホストを確立する必要はありません。 この操作は、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを呼び出す場合にのみ必要です。 <xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すと、`remoteEP` パラメーターによって、その送信操作に対して指定された既定のリモートホストが上書きされます。 基になるサービスプロバイダーによって最も適切なローカルネットワークアドレスとポート番号が割り当てられるため、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要もありません。 割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了した後に、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティを使用できます。  
  
 コネクションレスプロトコルを対象としていますが、<xref:System.Net.Sockets.Socket.SendTo%2A> 接続指向プロトコルでも動作します。 接続指向プロトコルを使用している場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを使用して受信接続要求を受け入れることによって、リモートホスト接続を確立する必要があります。 リモートホスト接続を確立していない場合、または受け入れない場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合も、<xref:System.Net.Sockets.Socket.SendTo%2A> は `remoteEP` パラメーターを無視し、接続されているまたは既定のリモートホストにのみデータを送信します。  
  
 ブロックソケットは、バッファー内のすべてのバイトが送信されるまでブロックされます。 非ブロッキング <xref:System.Net.Sockets.Socket> はすぐに完了するため、`buffer`内のすべてのバイトが送信されるとは限りません。 アプリケーションは、送信されたバイト数を追跡し、アプリケーションが `buffer`内のすべてのバイトを送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
 ブロックモードでコネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A> はデータグラムが送信されるまでブロックされます。 ブロードキャストアドレスにデータを送信する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。 また、送信されたバイト数が、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、指定したリモートホストにコネクションレスのデータグラムを送信します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、特定のエンドポイントにデータを送信します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードでは、バッファーオフセットは既定で0に設定され、送信するバイト数は既定で `buffer`のサイズに設定されます。 <xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。  
  
 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを使用して既定のリモートホストを確立する必要はありません。 この操作は、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを呼び出す場合にのみ必要です。 <xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すと、`remoteEP` パラメーターによって、その送信操作に対して指定された既定のリモートホストが上書きされます。 基になるサービスプロバイダーによって最も適切なローカルネットワークアドレスとポート番号が割り当てられるため、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要もありません。 割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了した後に、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティを使用できます。  
  
 コネクションレスプロトコルを対象としていますが、<xref:System.Net.Sockets.Socket.SendTo%2A> 接続指向プロトコルでも動作します。 接続指向プロトコルを使用している場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを使用して受信接続要求を受け入れることによって、リモートホスト接続を確立する必要があります。 リモートホスト接続を確立していない場合、または受け入れない場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合も、<xref:System.Net.Sockets.Socket.SendTo%2A> は `remoteEP` パラメーターを無視し、接続されているまたは既定のリモートホストにのみデータを送信します。  
  
 ブロックソケットは、要求されたが `buffer` 内のすべてのバイトを送信するまでブロックされます。 非ブロッキング <xref:System.Net.Sockets.Socket> はすぐに完了するため、`buffer`内のすべてのバイトが送信されるとは限りません。 アプリケーションは、送信されたバイト数を追跡し、アプリケーションが `buffer`内のすべてのバイトを送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を高めるため、基になるシステムは、大量のデータが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
 ブロックモードでコネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A> はデータグラムが送信されるまでブロックされます。 ブロードキャストアドレスにデータを送信する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。 また、送信されたバイト数が、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、指定したリモートホストにコネクションレスのデータグラムを送信します。 <xref:System.Net.Sockets.SocketFlags> は <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドに渡されます。  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、指定したエンドポイントに送信します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードでは、バッファーオフセットは既定で0に設定されます。 <xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。  
  
 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを使用して既定のリモートホストを確立する必要はありません。 この操作は、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを呼び出す場合にのみ必要です。 <xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すと、`remoteEP` パラメーターによって、その送信操作に対して指定された既定のリモートホストが上書きされます。 基になるサービスプロバイダーによって最も適切なローカルネットワークアドレスとポート番号が割り当てられるため、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要もありません。 割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了した後に、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティを使用できます。  
  
 コネクションレスプロトコルを対象としていますが、<xref:System.Net.Sockets.Socket.SendTo%2A> 接続指向プロトコルでも動作します。 接続指向プロトコルを使用している場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを使用して受信接続要求を受け入れることによって、リモートホスト接続を確立する必要があります。 リモートホスト接続を確立していない場合、または受け入れない場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合も、<xref:System.Net.Sockets.Socket.SendTo%2A> は `remoteEP` パラメーターを無視し、接続されているまたは既定のリモートホストにのみデータを送信します。  
  
 ブロックされたソケットは、要求されたバイト数が送信されるまでブロックされます。 非ブロッキング <xref:System.Net.Sockets.Socket> はすぐに完了するため、1回の操作で要求されたバイト数がすべて送信されるとは限りません。 アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を高めるため、基になるシステムは、大量のデータが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
 ブロックモードでコネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A> はデータグラムが送信されるまでブロックされます。 ブロードキャストアドレスにデータを送信する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。 また、送信されたバイト数が、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、指定したリモートホストにコネクションレスのデータグラムを送信します。 サイズと <xref:System.Net.Sockets.SocketFlags> が <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドに渡されます。  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定した <paramref name="size" /> が <paramref name="buffer" /> のサイズを超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、データ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、指定したエンドポイントに送信します。送信はバッファー内の指定した位置から開始されます。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信するデータはルーティングされません。  
  
 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを使用して既定のリモートホストを確立する必要はありません。 この操作は、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを呼び出す場合にのみ必要です。 <xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すと、`remoteEP` パラメーターによって、その送信操作に対して指定された既定のリモートホストが上書きされます。 基になるサービスプロバイダーによって最も適切なローカルネットワークアドレスとポート番号が割り当てられるため、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要もありません。 割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了した後に、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティを使用できます。  
  
 コネクションレスプロトコルを対象としていますが、<xref:System.Net.Sockets.Socket.SendTo%2A> 接続指向プロトコルでも動作します。 接続指向プロトコルを使用している場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを使用して受信接続要求を受け入れることによって、リモートホスト接続を確立する必要があります。 リモートホスト接続を確立していない場合、または受け入れない場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。 どちらの場合も、<xref:System.Net.Sockets.Socket.SendTo%2A> は `remoteEP` パラメーターを無視し、接続されているまたは既定のリモートホストにのみデータを送信します。  
  
 ブロックされたソケットは、要求されたバイト数が送信されるまでブロックされます。 非ブロッキング <xref:System.Net.Sockets.Socket> はすぐに完了するため、1回の操作で要求されたバイト数がすべて送信されるとは限りません。 アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。 また、送信したデータがネットワークに直ちに表示される保証もありません。 ネットワークの効率を高めるため、基になるシステムは、大量のデータが収集されるまで転送を遅らせます。 <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。  
  
 ブロックモードでコネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A> はデータグラムが送信されるまでブロックされます。 ブロードキャストアドレスにデータを送信する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。 また、サイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、指定したリモートホストにコネクションレスのデータグラムを送信します。 オフセット、サイズ、および <xref:System.Net.Sockets.SocketFlags> が <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドに渡されます。  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> が <see langword="null" /> です。  
  
- または - 
 <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
- または - 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
- または - 
 <paramref name="size" /> が 0 未満です。  
  
- または - 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
- または - 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>特定のリモート ホストにデータを非同期的に送信します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドは、`e` パラメーターの <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> プロパティで指定されたリモートホストに対して、非同期の送信操作を開始します。 <xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドを呼び出すと、別の実行スレッド内でデータを送信できるようになります。 この方法はコネクションレスプロトコルを対象としていますが、<xref:System.Net.Sockets.Socket.SendToAsync%2A> はコネクションレスプロトコルと接続指向プロトコルの両方で動作します。  
  
 完了を通知するには、EventHandler\<SocketAsyncEventArgs > delegate を実装するコールバックメソッドを作成し、コールバックを <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> イベントにアタッチする必要があります。  
  
 このメソッドを正常に呼び出すには、<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、<xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。 コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。  
  
 接続指向プロトコルを使用している場合は、最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドを呼び出す必要があります。 それ以外の場合 <xref:System.Net.Sockets.Socket.SendToAsync%2A> は <xref:System.Net.Sockets.SocketException>をスローします。 接続指向プロトコルを使用する場合、<xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドは、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> プロパティを無視し、<xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドで確立された <xref:System.Net.EndPoint?displayProperty=nameWithType> にデータを送信します。  
  
 コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendToAsync%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドを使用して既定のリモートホストを確立する必要はありません。 この操作は、<xref:System.Net.Sockets.Socket.BeginSend%2A> または <xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドを呼び出す場合にのみ必要です。 <xref:System.Net.Sockets.Socket.SendToAsync%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドを呼び出すと、その送信操作に対して指定された既定のリモートホストだけが <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> プロパティによって上書きされます。 <xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要もありません。 この場合、基になるサービスプロバイダーによって、最も適切なローカルネットワーク IP アドレスとポート番号が割り当てられます。 基になるサービスプロバイダーで空きポートを選択する場合は、ポート番号を0にします。 割り当てられているローカルネットワークの IP アドレスとポート番号を識別する必要がある場合は、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> イベントがシグナル状態になり、関連付けられたデリゲートが呼び出された後に、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティを使用できます。  
  
 ブロードキャストアドレスにデータを送信する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> の socket オプションを true に設定する必要があります。 また、バッファーのサイズが、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。 この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.SendToAsync%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> プロパティで DontRoute フラグを指定した場合、送信するデータはルーティングされません。  
  
 メッセージ指向のソケットの場合は、基になるトランスポートの最大メッセージサイズを超えないように注意する必要があります。 バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えた場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.SendToAsync%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。 <xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドが正常に完了しても、データが正常に配信されたことは示されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">指定されたプロトコルは接続指向ですが、<see cref="T:System.Net.Sockets.Socket" /> がまだ接続されていません。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="level">このソケットに設定する IP 保護レベル。</param>
        <summary>ソケットの IP 保護レベルを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> メソッドを使用すると、同じリンクローカルまたはサイトローカルプレフィックスを持つアドレスなど、指定されたスコープでリッスンするように IPv6 または IP ソケットを制限できます。 このソケットオプションを使用すると、アプリケーションは IPv6 または IP ソケットにアクセス制限を設けることができます。 この制限により、プライベート LAN で実行されるアプリケーションを外部からの攻撃に対して簡単かつ堅牢に強化できます。 `level` パラメーターが <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>に設定されている場合は、このソケットオプションを使用してアクセス制限を削除することもできます。 このソケット オプションで待機中のソケットのスコープを変更して、適切な場合はパブリック ユーザーおよびプライベート ユーザーからの無制限のアクセスを許可したり、必要に応じて同じサイトへのアクセスのみに制限したりできます。  
  
 このソケット オプションには、<xref:System.Net.Sockets.IPProtectionLevel> 列挙型で指定されている定義済みの保護レベルが設定されています。  
  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> メソッドは、<xref:System.Net.Sockets.Socket> インスタンスのネットワークアドレストラバーサル (NAT) を有効または無効にするために使用されます。 NAT トラバーサルは、Teredo、6to4、または ISATAP トンネルを使用して提供される場合があります。  
  
 `level` パラメーターが <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>または <xref:System.Net.Sockets.IPProtectionLevel.Restricted>に設定されている場合、これにより、<xref:System.Net.Sockets.Socket> インスタンスの NAT トラバーサルが明示的に無効になります。  
  
 `level` パラメーターを <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>に設定すると、システム上のファイアウォールルールに応じて、<xref:System.Net.Sockets.Socket> の NAT トラバーサルが許可される可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="level" /> パラメーターとして <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /> を使用することはできません。 IP 保護レベルを未指定に設定することはできません。</exception>
        <exception cref="T:System.NotSupportedException">ソケットの <see cref="T:System.Net.Sockets.AddressFamily" /> は、<see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> である必要があります。</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> オプションを設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue"><see cref="T:System.Boolean" /> として表されるオプションの値。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した <see cref="T:System.Boolean" /> 値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Net.Sockets.Socket>の動作は、<xref:System.Net.Sockets.Socket> オプションによって決まります。 オプションを有効にする場合は `optionValue` を `true` に設定し、オプションを無効にする場合は `false` に設定します。  
  
 <xref:System.Net.Sockets.Socket> オプションは、プロトコルサポートのレベルによってグループ化されています。  
  
 このオーバーロードを使用して設定できるさまざまな <xref:System.Net.Sockets.Socket> オプションを以下に示します。 これらのオプションは、適切な <xref:System.Net.Sockets.SocketOptionLevel> 値によってグループ化されます。 これらのオプションのいずれかを設定する場合は、必ず、`optionLevel` パラメーターに適切な <xref:System.Net.Sockets.SocketOptionLevel> 値を使用してください。 設定するオプションは、`optionName` パラメーターで指定する必要があります。 一覧表示されているいずれかのオプションの現在の値を取得する場合は、<xref:System.Net.Sockets.Socket.GetSocketOption%2A> メソッドを使用します。  
  
 このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> ます。  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> ます。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> ます。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> ます。  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 これらのオプションの詳細については、<xref:System.Net.Sockets.SocketOptionName> 列挙体を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException> 例外が発生した場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
   
  
## Examples  
 次のコード例では、ソケットを開き、`DontLinger` と `OutOfBandInline` ソケットオプションを有効にします。  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">オプションの値を表す <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した値に設定します。この値はバイト配列で表されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Net.Sockets.Socket>の動作は、<xref:System.Net.Sockets.Socket> オプションによって決まります。 このオーバーロードを使用して、オプション値としてバイト配列を必要とする <xref:System.Net.Sockets.Socket> オプションを設定します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> のタイムアウト値を設定します。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">オプションの値。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した整数値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Net.Sockets.Socket>の動作は、<xref:System.Net.Sockets.Socket> オプションによって決まります。 <xref:System.Boolean> データ型のオプションの場合は、0以外の値を指定してオプションを有効にし、ゼロの値を指定してオプションを無効にします。 整数データ型のオプションの場合は、適切な値を指定します。 <xref:System.Net.Sockets.Socket> オプションは、プロトコルサポートのレベルによってグループ化されています。  
  
 このオーバーロードを使用して設定できるさまざまな <xref:System.Net.Sockets.Socket> オプションを以下に示します。 これらのオプションは、適切な <xref:System.Net.Sockets.SocketOptionLevel>別にグループ化されています。 これらのオプションのいずれかを設定する場合は、`optionLevel` パラメーターに適切な <xref:System.Net.Sockets.SocketOptionLevel> を使用するようにしてください。 設定するオプションは、`optionName` パラメーターで指定する必要があります。 一覧表示されているいずれかのオプションの現在の値を取得する場合は、<xref:System.Net.Sockets.Socket.GetSocketOption%2A> メソッドを使用します。  
  
 このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> ます。  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> ます。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> ます。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> ます。  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> ます。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 これらのオプションの詳細については、<xref:System.Net.Sockets.SocketOptionName> 列挙体を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> のタイムアウト値を設定します。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">オプションの値を格納する <see cref="T:System.Net.Sockets.LingerOption" /> または <see cref="T:System.Net.Sockets.MulticastOption" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した値に設定します。この値はオブジェクトで表されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の <xref:System.Net.Sockets.Socket>の動作は、<xref:System.Net.Sockets.Socket> オプションによって決まります。 このオーバーロードを使用して、<xref:System.Net.Sockets.SocketOptionName.Linger>、<xref:System.Net.Sockets.SocketOptionName.AddMembership>、および <xref:System.Net.Sockets.SocketOptionName.DropMembership>の <xref:System.Net.Sockets.Socket> オプションを設定します。 <xref:System.Net.Sockets.SocketOptionName.Linger> オプションでは、`optionLevel` パラメーターに <xref:System.Net.Sockets.Socket> を使用します。 <xref:System.Net.Sockets.SocketOptionName.AddMembership> と <xref:System.Net.Sockets.SocketOptionName.DropMembership>については、<xref:System.Net.Sockets.SocketOptionLevel.IP>を使用します。 上記のいずれかのオプションの現在の値を取得する場合は、<xref:System.Net.Sockets.Socket.GetSocketOption%2A> メソッドを使用します。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> のタイムアウト値を設定します。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">許可されなくなる操作を指定する <see cref="T:System.Net.Sockets.SocketShutdown" /> 値の 1 つ。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> での送受信を無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向の <xref:System.Net.Sockets.Socket>を使用する場合は、<xref:System.Net.Sockets.Socket>を閉じる前に常に <xref:System.Net.Sockets.Socket.Shutdown%2A> メソッドを呼び出します。 これにより、接続されたソケットが閉じられる前に、すべてのデータが送信され、受信されます。  
  
 <xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出して、<xref:System.Net.Sockets.Socket>に関連付けられているすべてのマネージリソースとアンマネージリソースを解放します。 終了後に <xref:System.Net.Sockets.Socket> を再利用しないようにしてください。  
  
 次の表は、`how` パラメーターに対して有効な <xref:System.Net.Sockets.SocketShutdown> 列挙値を示しています。  
  
|[値]|説明|  
|-----------|-----------------|  
|送信|この <xref:System.Net.Sockets.Socket>での送信を無効にします。|  
|Receive|この <xref:System.Net.Sockets.Socket>での受信を無効にします。|  
|両方|この <xref:System.Net.Sockets.Socket>で送信と受信の両方を無効にします。|  
  
 `how` を <xref:System.Net.Sockets.SocketShutdown.Send> に設定すると、後続の <xref:System.Net.Sockets.Socket.Send%2A> の呼び出しは許可されません。 コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.SocketShutdown.Send> を指定しても効果はありません。  
  
 `how` を <xref:System.Net.Sockets.SocketShutdown.Receive> に設定すると、後続の <xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しは許可されません。 これは、下位のプロトコルレイヤーには影響しません。 接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Shutdown%2A> の呼び出しの後、次のいずれかの条件が満たされると接続が終了します。  
  
-   受信を待機している受信ネットワークバッファーにデータがあります。  
  
-   さらに多くのデータが到着しました。  
  
 コネクションレスプロトコルを使用している場合は、データグラムが受け入れられ、キューに登録されます。 ただし、追加の受信データグラムに使用できるバッファー領域がない場合は、破棄され、送信側にエラーは返されません。 コネクションレス <xref:System.Net.Sockets.Socket> で <xref:System.Net.Sockets.Socket.Shutdown%2A> を使用することは推奨されません。  
  
 `how` を <xref:System.Net.Sockets.SocketShutdown.Both> に設定すると、前述のように、送信と受信の両方が無効になります。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.Shutdown%2A> メソッドを呼び出すときに <xref:System.Net.Sockets.SocketException> を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.Socket.Shutdown%2A> を使用して <xref:System.Net.Sockets.Socket>を無効にします。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の型を取得します。</summary>
        <value><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> は読み取り専用で、<xref:System.Net.Sockets.Socket> の作成時に設定されます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Net.Sockets.AddressFamily>、<xref:System.Net.Sockets.SocketType>、および <xref:System.Net.Sockets.ProtocolType> をコンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のホストで IPv4 サポートが使用可能で有効になっているかどうかを示す値を取得します。</summary>
        <value>現在のホストが IPv4 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティングシステムは、IPv4 プロトコルと IPv6 プロトコルの両方をサポートしている場合があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>互換性のために残されている特定の <see cref="T:System.Net.Dns" /> メンバー向けに、フレームワークが IPv6 をサポートしているかどうかを示す値を取得します。</summary>
        <value>互換性のために残されている特定の <see cref="T:System.Net.Dns" /> メソッド向けに、フレームワークが IPv6 をサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティングシステムは、IPv4 プロトコルと IPv6 プロトコルの両方をサポートしている場合があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> によって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<xref:System.Net.Sockets.Socket>の使用が終了したら、IDisposable を呼び出します。 IDisposable メソッドは、<xref:System.Net.Sockets.Socket> を使用できない状態のままにします。 IDisposable を呼び出した後、ガベージコレクターが <xref:System.Net.Sockets.Socket> 占有していたメモリを再利用できるように、<xref:System.Net.Sockets.Socket> へのすべての参照を解放する必要があります。 詳細については、[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)および[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)を参照してください。

> [!NOTE] 
> <xref:System.Net.Sockets.Socket>への最後の参照を解放する前に、必ず IDisposable を呼び出してください。 そうしないと、ガベージ コレクターが <xref:System.Net.Sockets.Socket> オブジェクトの `Finalize` メソッドを呼び出すまで、使用されているリソースは解放されません。

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> によって送信されたインターネット プロトコル (IP) パケットの有効期間 (TTL) の値を指定する値を取得または設定します。</summary>
        <value>TTL の値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TTL 値は、ルーターがパケットを破棄する前にパケットが通過できるルーターの最大数を示します。 ICMP (インターネット制御メッセージプロトコル) エラーメッセージが送信側に返されます。  
  
 TTL 値は 0 ~ 255 の値に設定できます。 このプロパティが設定されていない場合、ソケットの既定の TTL 値は32です。  
  
 ソケットを使用して接続が正常に確立されている場合、TCP/IP スタックでは、伝送制御プロトコル (TCP) ソケットでこのプロパティを設定することは無視されます。  
  
 <xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。 このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Net.Sockets.Socket.Ttl%2A> プロパティの使用方法を示しています。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">TTL 値には、負の数を設定できません。</exception>
        <exception cref="T:System.NotSupportedException">このプロパティは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ファミリまたは <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットに対してだけ設定できます。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 このエラーは、TTL に 255 より大きい値を設定しようとしたときにも返されます。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ソケットが重複 I/O モードだけを使用する必要があるかどうかを指定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> が重複 I/O モードだけを使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>を呼び出す <xref:System.Net.Sockets.Socket> については、このプロパティを `true` に設定します。 それ以外の場合、フレームワークは、ソケットに完了ポートを割り当てることがあります。これにより、<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>の使用が禁止されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ソケットが完了ポートにバインドされています。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
