<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d5048fb5607590f785cbe75efe7ff7e319754cba" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73339148" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="9cad8-101">Berkeley ソケット インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-101">Implements the Berkeley sockets interface.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-102"><xref:System.Net.Sockets.Socket> クラスは、ネットワーク通信用の豊富なメソッドとプロパティのセットを提供します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-102">The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications.</span></span> <span data-ttu-id="9cad8-103"><xref:System.Net.Sockets.Socket> クラスを使用すると、<xref:System.Net.Sockets.ProtocolType> 列挙に示されているいずれかの通信プロトコルを使用して、同期データ転送と非同期データ転送の両方を実行できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-103">The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.</span></span>  
  
 <span data-ttu-id="9cad8-104"><xref:System.Net.Sockets.Socket> クラスは、非同期メソッドの .NET Framework の名前付けパターンに従います。</span><span class="sxs-lookup"><span data-stu-id="9cad8-104">The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods.</span></span> <span data-ttu-id="9cad8-105">たとえば、同期 <xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、非同期の <xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドと <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドに対応します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-105">For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.</span></span>  
  
 <span data-ttu-id="9cad8-106">アプリケーションで実行中に必要なスレッドが1つだけの場合は、次のメソッドを使用します。これらのメソッドは、同期操作モード用に設計されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-106">If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</span></span>  
  
-   <span data-ttu-id="9cad8-107">TCP などの接続指向プロトコルを使用している場合、サーバーは <xref:System.Net.Sockets.Socket.Listen%2A> 方法を使用して接続をリッスンできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-107">If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="9cad8-108"><xref:System.Net.Sockets.Socket.Accept%2A> メソッドは、受信接続要求を処理し、リモートホストとデータを通信するために使用できる <xref:System.Net.Sockets.Socket> を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-108">The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host.</span></span> <span data-ttu-id="9cad8-109">この返された <xref:System.Net.Sockets.Socket> を使用して、<xref:System.Net.Sockets.Socket.Send%2A> または <xref:System.Net.Sockets.Socket.Receive%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-109">Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span> <span data-ttu-id="9cad8-110">ローカル IP アドレスとポート番号を指定する場合は、<xref:System.Net.Sockets.Socket.Listen%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-110">Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number.</span></span> <span data-ttu-id="9cad8-111">基になるサービスプロバイダーがフリーポートを割り当てる場合は、ポート番号を0にします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-111">Use a port number of zero if you want the underlying service provider to assign a free port for you.</span></span> <span data-ttu-id="9cad8-112">リッスンしているホストに接続する場合は、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-112">If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="9cad8-113">データを通信するには、<xref:System.Net.Sockets.Socket.Send%2A> または <xref:System.Net.Sockets.Socket.Receive%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-113">To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
-   <span data-ttu-id="9cad8-114">UDP などのコネクションレスプロトコルを使用している場合は、接続をリッスンする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-114">If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</span></span> <span data-ttu-id="9cad8-115"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出して、受信データグラムをすべて受け入れます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-115">Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams.</span></span> <span data-ttu-id="9cad8-116"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用して、リモートホストにデータグラムを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-116">Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.</span></span>  
  
 <span data-ttu-id="9cad8-117">実行中に個別のスレッドを使用して通信を処理するには、非同期操作モード用に設計された次のメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-117">To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</span></span>  
  
-   <span data-ttu-id="9cad8-118">TCP などの接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、および <xref:System.Net.Sockets.Socket.EndConnect%2A> の各方法を使用して、リッスンしているホストに接続します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-118">If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host.</span></span> <span data-ttu-id="9cad8-119"><xref:System.Net.Sockets.Socket.BeginSend%2A> および <xref:System.Net.Sockets.Socket.EndSend%2A> または <xref:System.Net.Sockets.Socket.BeginReceive%2A> および <xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを使用して、データを非同期に通信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-119">Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously.</span></span> <span data-ttu-id="9cad8-120">着信接続要求は <xref:System.Net.Sockets.Socket.BeginAccept%2A> と <xref:System.Net.Sockets.Socket.EndAccept%2A>を使用して処理できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-120">Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span></span>  
  
-   <span data-ttu-id="9cad8-121">UDP などのコネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.BeginSendTo%2A> と <xref:System.Net.Sockets.Socket.EndSendTo%2A> を使用してデータグラムを送信し、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> および <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> を使用してデータグラムを受信することができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-121">If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> and <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams.</span></span>  
  
 <span data-ttu-id="9cad8-122">1つのソケットに対して複数の非同期操作を実行する場合、それらの操作は、開始された順序で完了するとは限りません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-122">If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</span></span>  
  
 <span data-ttu-id="9cad8-123">データの送受信が終了したら、<xref:System.Net.Sockets.Socket.Shutdown%2A> メソッドを使用して <xref:System.Net.Sockets.Socket>を無効にします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-123">When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-124"><xref:System.Net.Sockets.Socket.Shutdown%2A>を呼び出した後、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出して、<xref:System.Net.Sockets.Socket>に関連付けられているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-124">After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 <span data-ttu-id="9cad8-125"><xref:System.Net.Sockets.Socket> クラスを使用すると、<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを使用して <xref:System.Net.Sockets.Socket> を構成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-125">The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span> <span data-ttu-id="9cad8-126"><xref:System.Net.Sockets.Socket.GetSocketOption%2A> メソッドを使用して、これらの設定を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-126">Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-127">比較的単純なアプリケーションを作成し、最大のパフォーマンスを必要としない場合は、<xref:System.Net.Sockets.TcpClient>、<xref:System.Net.Sockets.TcpListener>、および <xref:System.Net.Sockets.UdpClient>の使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-127">If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>.</span></span> <span data-ttu-id="9cad8-128">これらのクラスは、<xref:System.Net.Sockets.Socket> 通信のためのより簡単でわかりやすいインターフェイスを提供します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-128">These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-129">次のコード例では、<xref:System.Net.Sockets.Socket> クラスを使用して HTTP サーバーにデータを送信し、応答を受信する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-129">The following code example shows how the <xref:System.Net.Sockets.Socket> class can be used to send data to an HTTP server and receive the response.</span></span> <span data-ttu-id="9cad8-130">この例では、ページ全体が受信されるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-130">This example blocks until the entire page is received.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-131">発信接続を確立するか、受信要求を受け入れる。</span><span class="sxs-lookup"><span data-stu-id="9cad8-131">To establish an outgoing connection or accept an incoming request.</span></span></permission>
    <threadsafe><span data-ttu-id="9cad8-132">このクラスのインスタンスは、スレッドセーフです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-132">Instances of this class are thread safe.</span></span></threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md"><span data-ttu-id="9cad8-133">.NET Framework のネットワーク プログラミング</span><span class="sxs-lookup"><span data-stu-id="9cad8-133">Network Programming in the .NET Framework</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md"><span data-ttu-id="9cad8-134">System.Net クラスのベスト プラクティス</span><span class="sxs-lookup"><span data-stu-id="9cad8-134">Best Practices for System.Net Classes</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md"><span data-ttu-id="9cad8-135">ネットワーク アプリケーションのキャッシュ管理</span><span class="sxs-lookup"><span data-stu-id="9cad8-135">Cache Management for Network Applications</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md"><span data-ttu-id="9cad8-136">インターネット プロトコル バージョン 6</span><span class="sxs-lookup"><span data-stu-id="9cad8-136">Internet Protocol Version 6</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md"><span data-ttu-id="9cad8-137">ネットワーク プログラミングのサンプル</span><span class="sxs-lookup"><span data-stu-id="9cad8-137">Network Programming Samples</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md"><span data-ttu-id="9cad8-138">.NET Framework のネットワークのトレース</span><span class="sxs-lookup"><span data-stu-id="9cad8-138">Network Tracing in the .NET Framework</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md"><span data-ttu-id="9cad8-139">ネットワーク プログラミングにおけるセキュリティ</span><span class="sxs-lookup"><span data-stu-id="9cad8-139">Security in Network Programming</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md"><span data-ttu-id="9cad8-140">バージョン 3.5 のソケット パフォーマンスの強化</span><span class="sxs-lookup"><span data-stu-id="9cad8-140">Socket Performance Enhancements in Version 3.5</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-141"><see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-141">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><span data-ttu-id="9cad8-142"><see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> によって返されるソケット情報。</span><span class="sxs-lookup"><span data-stu-id="9cad8-142">The socket information returned by <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></param>
        <summary><span data-ttu-id="9cad8-143"><see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> から返された値を指定して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-143">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified value returned from <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-144">各呼び出しの引数と同じバイト配列を使用して <xref:System.Net.Sockets.Socket.%23ctor%2A> コンストラクターを複数回呼び出す場合は、基になるソケットが同じである複数のマネージ <xref:System.Net.Sockets.Socket>を作成します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-144">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket.</span></span> <span data-ttu-id="9cad8-145">この方法は推奨されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-145">This practice is strongly discouraged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="9cad8-146"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-146">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="9cad8-147"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか。</span><span class="sxs-lookup"><span data-stu-id="9cad8-147">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="9cad8-148">指定したソケットの種類とプロトコルを使用して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-148">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-149">`socketType` パラメーターは <xref:System.Net.Sockets.Socket> クラスの型を指定し、`protocolType` パラメーターは <xref:System.Net.Sockets.Socket>で使用されるプロトコルを指定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-149">The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-150">2つのパラメーターは独立していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-150">The two parameters are not independent.</span></span> <span data-ttu-id="9cad8-151">多くの場合、<xref:System.Net.Sockets.Socket> の型はプロトコルで暗黙の型になります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-151">Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="9cad8-152"><xref:System.Net.Sockets.Socket> 型とプロトコルの種類の組み合わせによって無効な <xref:System.Net.Sockets.Socket>が発生した場合、このコンストラクターは <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-152">If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-153">このコンストラクターが <xref:System.Net.Sockets.SocketException>をスローする場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-153">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-154">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-154">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-155">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-155">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-156">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-156">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-157"><paramref name="socketType" /> と <paramref name="protocolType" /> を組み合わせると、無効なソケットになります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-157">The combination of  <paramref name="socketType" /> and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><span data-ttu-id="9cad8-158"><see cref="T:System.Net.Sockets.AddressFamily" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-158">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></param>
        <param name="socketType"><span data-ttu-id="9cad8-159"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-159">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="9cad8-160"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-160">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="9cad8-161">指定したアドレス ファミリ、ソケットの種類、およびプロトコルを使用して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-161">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified address family, socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-162">`addressFamily` パラメーターは、<xref:System.Net.Sockets.Socket> クラスが使用するアドレス指定スキームを指定します。 `socketType` パラメーターは <xref:System.Net.Sockets.Socket> クラスの型を指定し、`protocolType` パラメーターは <xref:System.Net.Sockets.Socket>によって使用されるプロトコルを指定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-162">The `addressFamily` parameter specifies the addressing scheme that the <xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-163">この3つのパラメーターは独立していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-163">The three parameters are not independent.</span></span> <span data-ttu-id="9cad8-164">アドレスファミリによっては、それらで使用できるプロトコルが制限されている場合があります。また、多くの場合、<xref:System.Net.Sockets.Socket> の種類がプロトコルで暗黙的に使用されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-164">Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="9cad8-165">アドレスファミリ、<xref:System.Net.Sockets.Socket> の種類、およびプロトコルの種類の組み合わせによって無効な <xref:System.Net.Sockets.Socket>が生成された場合、このコンストラクターは <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-165">If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-166">このコンストラクターが <xref:System.Net.Sockets.SocketException>をスローする場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-166">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-167">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-167">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-168">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-168">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-169">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-169">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-170"><xref:System.Net.Sockets.Socket> クラスのインスタンスを作成する方法を次のコード例に示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-170">The following code example demonstrates how to create an instance of the <xref:System.Net.Sockets.Socket> class.</span></span>  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-171"><paramref name="addressFamily" />、<paramref name="socketType" />、および <paramref name="protocolType" /> を組み合わせると、無効なソケットになります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-171">The combination of <paramref name="addressFamily" />, <paramref name="socketType" />, and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cad8-172">新しく作成された接続に対して新しい <see cref="T:System.Net.Sockets.Socket" /> を作成します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-172">Creates a new <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></summary>
        <returns><span data-ttu-id="9cad8-173">新しく作成された接続に対する <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-173">A <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-174"><xref:System.Net.Sockets.Socket.Accept%2A> は、リッスンしているソケットの接続要求キューから、最初の保留中の接続要求を同期的に抽出し、新しい <xref:System.Net.Sockets.Socket>を作成して返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-174"><xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-175">この返された <xref:System.Net.Sockets.Socket> を使用して、接続キューからの追加の接続を受け入れることはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-175">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="9cad8-176">ただし、返された <xref:System.Net.Sockets.Socket> の <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> メソッドを呼び出して、リモートホストのネットワークアドレスとポート番号を識別できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-176">However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
 <span data-ttu-id="9cad8-177">ブロックモードでは、<xref:System.Net.Sockets.Socket.Accept%2A> は、受信接続の試行がキューに置かれるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-177">In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued.</span></span> <span data-ttu-id="9cad8-178">接続が受け入れられると、元の <xref:System.Net.Sockets.Socket> は、受信した接続要求を閉じるまで引き続きキューに挿入します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-178">Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.</span></span>  
  
 <span data-ttu-id="9cad8-179">非ブロッキング <xref:System.Net.Sockets.Socket>を使用してこのメソッドを呼び出し、接続要求がキューに登録されていない場合、<xref:System.Net.Sockets.Socket.Accept%2A> は <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-179">If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-180"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-180">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-181">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-181">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-182"><xref:System.Net.Sockets.Socket.Accept%2A> メソッドを呼び出す前に、まず <xref:System.Net.Sockets.Socket.Listen%2A> メソッドを呼び出して、着信接続要求をリッスンしてキューに挿入する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-182">Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-183">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-183">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-184">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-184">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-185">次のコード例では、単純な <xref:System.Net.Sockets.Socket> 接続を受け入れます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-185">The following code example accepts a simple <xref:System.Net.Sockets.Socket> connection.</span></span>  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-186">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-186">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-187"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-187">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-188">受け入れ元のソケットが、接続をリッスンしていません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-188">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="9cad8-189"><see cref="M:System.Net.Sockets.Socket.Accept" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-189">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.Accept" />.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="9cad8-190">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-190">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-191">受信接続の試行を受け入れる非同期操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-191">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="9cad8-192">I/O 操作が保留中の場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-192"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="9cad8-193">操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-193">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="9cad8-194">I/O 操作が同期的に完了した場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-194"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="9cad8-195">この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-195">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-196">接続指向プロトコルでは、<xref:System.Net.Sockets.Socket.AcceptAsync%2A> メソッドを使用して、着信接続の試行を非同期に処理できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-196">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="9cad8-197">接続を非同期に受け入れると、別の実行スレッド内でデータを送受信することができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-197">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="9cad8-198"><xref:System.Net.Sockets.Socket.AcceptAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Listen%2A> メソッドを呼び出して受信接続要求をリッスンし、キューに挿入する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-198">Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="9cad8-199">完了を通知するには、EventHandler\<SocketAsyncEventArgs > デリゲートを実装するコールバックメソッドを作成し、それを <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> イベントにフックする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-199">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="9cad8-200"><xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-200">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="9cad8-201">呼び出し元は、必要に応じて、<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> プロパティで使用する <xref:System.Net.Sockets.Socket> を指定することによって、着信接続に使用する既存の <xref:System.Net.Sockets.Socket> を指定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-201">The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="9cad8-202"><xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> プロパティが null の場合、新しい <xref:System.Net.Sockets.Socket> は、現在の <xref:System.Net.Sockets.Socket.ProtocolType%2A> と同じ <xref:System.Net.Sockets.Socket.AddressFamily%2A>、<xref:System.Net.Sockets.Socket.SocketType%2A>、および <xref:System.Net.Sockets.Socket> を使用して構築され、<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> プロパティとして設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-202">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="9cad8-203">呼び出し元は、<xref:System.Net.Sockets.Socket.AcceptAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-203">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="9cad8-204">コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-204">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="9cad8-205">必要に応じて、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドが成功した後に、ソケットの最初のデータブロックを受け取るバッファーを指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-205">Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="9cad8-206">この場合、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> プロパティは、受信するデータを格納するバッファーに設定する必要があります。また、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> プロパティは、バッファー内で受信するデータの最大バイト数に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-206">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the maximum number of bytes of data to receive in the buffer.</span></span> <span data-ttu-id="9cad8-207">これらのプロパティは、<xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> メソッドを使用して設定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-207">These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9cad8-208">渡されたバッファーの一部は、基になる Winsock AcceptEx 呼び出しで使用するために、内部的に使用されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-208">Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</span></span> <span data-ttu-id="9cad8-209">これは、返されるデータの量が、指定された <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> インスタンスの <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> プロパティの値よりも小さいことを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-209">This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instance provided.</span></span> <span data-ttu-id="9cad8-210">内部で使用されるバッファーの量は、ソケットのアドレスファミリによって異なります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-210">The amount of the buffer used internally varies based on the address family of the socket.</span></span> <span data-ttu-id="9cad8-211">必要な最小バッファーサイズは288バイトです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-211">The minimum buffer size required is 288 bytes.</span></span> <span data-ttu-id="9cad8-212">より大きなバッファーサイズが指定されている場合、<xref:System.Net.Sockets.Socket> は、Winsock AcceptEx 呼び出しによって受信されたアドレスデータ以外の追加データを期待し、この追加データを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-212">If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</span></span> <span data-ttu-id="9cad8-213">タイムアウトが発生した場合、接続はリセットされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-213">If a timeout occurs, the connection is reset.</span></span> <span data-ttu-id="9cad8-214">したがって、余分なデータが特定の量になることが予想される場合は、バッファーサイズを最小バッファーサイズに設定し、この量を加算する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-214">So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</span></span>  
  
 <span data-ttu-id="9cad8-215">完了コールバックメソッドは、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> プロパティを調べて、<xref:System.Net.Sockets.Socket.AcceptAsync%2A> 操作が成功したかどうかを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-215">The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful.</span></span>  
  
 <span data-ttu-id="9cad8-216"><xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> イベントは、接続が受け入れられず、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> プロパティが <xref:System.Net.Sockets.SocketError.ConnectionReset>に設定される場合に発生することがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-216">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span></span> <span data-ttu-id="9cad8-217">これは、ハーフオープンの SYN タイプスキャンを使用したポートスキャンの結果として発生する可能性があります (SYN > SYN-ACK-> RST シーケンス)。</span><span class="sxs-lookup"><span data-stu-id="9cad8-217">This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence).</span></span> <span data-ttu-id="9cad8-218"><xref:System.Net.Sockets.Socket.AcceptAsync%2A> メソッドを使用するアプリケーションは、この条件を処理できるように準備する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-218">Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-219">引数が有効ではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-219">An argument is not valid.</span></span> <span data-ttu-id="9cad8-220">この例外は、提供されたバッファーのサイズが不足している場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-220">This exception occurs if the buffer provided is not large enough.</span></span> <span data-ttu-id="9cad8-221">バッファーは、2 \* (sizeof(SOCKADDR_STORAGE + 16) バイト以上であることが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-221">The buffer must be at least 2 \* (sizeof(SOCKADDR_STORAGE + 16) bytes.</span></span>  
  
<span data-ttu-id="9cad8-222">この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合にも発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-222">This exception also occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-223">引数が範囲外です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-223">An argument is out of range.</span></span> <span data-ttu-id="9cad8-224">この例外は、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> が 0 未満の場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-224">The exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-225">無効な操作が要求されました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-225">An invalid operation was requested.</span></span> <span data-ttu-id="9cad8-226">この例外は、受け入れ側の <see cref="T:System.Net.Sockets.Socket" /> が接続をリッスンしていない場合、または受け入れられたソケットがバインドされている場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-226">This exception occurs if the accepting <see cref="T:System.Net.Sockets.Socket" /> is not listening for connections or the accepted socket is bound.</span></span>  
  
<span data-ttu-id="9cad8-227"><see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> メソッドを呼び出す前に、<see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> メソッドと <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-227">You must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method before calling the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span></span>  
  
<span data-ttu-id="9cad8-228">この例外は、ソケットが既に接続されている、またはソケット操作が指定された <paramref name="e" /> パラメーターを使用して既に進行中の場合にも発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-228">This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-229">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-229">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-230">このメソッドには Windows XP 以降が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-230">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-231"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-231">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-232"><see cref="T:System.Net.Sockets.Socket" /> のアドレス ファミリを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-232">Gets the address family of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="9cad8-233"><see cref="T:System.Net.Sockets.AddressFamily" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-233">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-234"><xref:System.Net.Sockets.AddressFamily> は、<xref:System.Net.Sockets.Socket> クラスのインスタンスが使用できるアドレス指定スキームを指定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-234">The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use.</span></span> <span data-ttu-id="9cad8-235">このプロパティは読み取り専用であり、<xref:System.Net.Sockets.Socket> が作成されるときに設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-235">This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-236">次のコード例では、<xref:System.Net.Sockets.AddressFamily>、<xref:System.Net.Sockets.SocketType>、および <xref:System.Net.Sockets.ProtocolType> をコンソールに表示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-236">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-237">ネットワークから受信した、読み取り可能なデータ量を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-237">Gets the amount of data that has been received from the network and is available to be read.</span></span></summary>
        <value><span data-ttu-id="9cad8-238">ネットワークから受信した、読み取り可能なデータのバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-238">The number of bytes of data received from the network and available to be read.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-239">非ブロッキング <xref:System.Net.Sockets.Socket>を使用している場合は、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に、データが読み取り用にキューに格納されているかどうかを判断するための適切な方法として <xref:System.Net.Sockets.Socket.Available%2A> を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-239">If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="9cad8-240">使用可能なデータは、読み取り用にネットワークバッファーにキューに格納されているデータの総量です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-240">The available data is the total amount of data queued in the network buffer for reading.</span></span> <span data-ttu-id="9cad8-241">データがネットワークバッファーに格納されていない場合、<xref:System.Net.Sockets.Socket.Available%2A> は0を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-241">If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.</span></span>  
  
 <span data-ttu-id="9cad8-242">リモートホストがシャットダウンまたは接続を閉じると、<xref:System.Net.Sockets.Socket.Available%2A> が <xref:System.Net.Sockets.SocketException>をスローする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-242">If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-243"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-243">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-244">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-244">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-245">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-245">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-246">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-246">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-247">次のコード例では、Ioonread と使用可能なプロパティを呼び出して、呼び出しの結果を比較しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-247">The following code example compares the results of calling IOControl with FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-248">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-248">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-249"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-249">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-250">受信接続の試行を受け入れる非同期操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-250">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callback"><span data-ttu-id="9cad8-251"><see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-251">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-252">この要求の状態情報を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-252">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="9cad8-253">受信接続の試行を受け入れる非同期操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-253">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="9cad8-254">非同期の <see cref="T:System.Net.Sockets.Socket" /> 作成を参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-254">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-255">接続指向プロトコルでは、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを使用して、着信接続の試行を非同期に処理できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-255">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="9cad8-256">接続を非同期に受け入れると、別の実行スレッド内でデータを送受信することができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-256">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="9cad8-257"><xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Listen%2A> メソッドを呼び出して受信接続要求をリッスンし、キューに挿入する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-257">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="9cad8-258"><xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-258">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="9cad8-259">これを行うには、少なくとも、`state` パラメーターを使用して、リッスンしている <xref:System.Net.Sockets.Socket> オブジェクトを <xref:System.Net.Sockets.Socket.BeginAccept%2A> に渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-259">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="9cad8-260">コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さいクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-260">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="9cad8-261">`state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-261">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-262">コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-262">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="9cad8-263">アプリケーションが <xref:System.Net.Sockets.Socket.BeginAccept%2A>を呼び出すと、通常、システムは別のスレッドを使用して、指定されたコールバックメソッドを実行し、保留中の接続が取得されるまで、<xref:System.Net.Sockets.Socket.EndAccept%2A> でブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-263">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span> <span data-ttu-id="9cad8-264"><xref:System.Net.Sockets.Socket.EndAccept%2A> は、リモートホストとの間でデータを送受信するために使用できる新しい <xref:System.Net.Sockets.Socket> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-264"><xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="9cad8-265">この返された <xref:System.Net.Sockets.Socket> を使用して、接続キューからの追加の接続を受け入れることはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-265">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="9cad8-266"><xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-266">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-267">元のスレッドの実行を継続する場合は、コールバックメソッドの <xref:System.Threading.ManualResetEvent> で Set メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-267">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="9cad8-268">また、呼び出し元のスレッドを使用してコールバックメソッドを呼び出すこともできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-268">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="9cad8-269">この場合、返された <xref:System.IAsyncResult> の <xref:System.IAsyncResult.CompletedSynchronously%2A> プロパティは、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドが同期的に完了したことを示すように設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-269">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="9cad8-270">コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-270">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="9cad8-271"><xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドへの保留中の呼び出しを取り消すには、<xref:System.Net.Sockets.Socket>を閉じます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-271">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-272">非同期操作の実行中に <xref:System.Net.Sockets.Socket.Close%2A> メソッドが呼び出されると、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに提供されたコールバックが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-272">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="9cad8-273">後続の <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドの呼び出しでは、操作が取り消されたことを示す <xref:System.ObjectDisposedException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-273">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-274">返された <xref:System.Net.Sockets.Socket> の <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> プロパティを使用して、リモートホストのネットワークアドレスとポート番号を識別できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-274">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-275"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-275">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-276">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-276">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-277">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-277">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-278">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-278">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-279">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-279">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-280">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-280">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-281">次のコード例では、受信接続を非同期的に受信しようとしています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-281">The following code example attempts to receive an incoming connection asynchronously.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-282"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-282">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-283">このメソッドには Windows NT が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-283">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-284">受け入れ元のソケットが、接続をリッスンしていません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-284">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="9cad8-285"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-285">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="9cad8-286">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-286">-or-</span></span> 
<span data-ttu-id="9cad8-287">受け入れられたソケットがバインドされています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-287">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-288"><paramref name="receiveSize" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-288"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-289">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-289">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-290">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-290">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-291">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-291">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="receiveSize"><span data-ttu-id="9cad8-292">送信元から受け入れるバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-292">The number of bytes to accept from the sender.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-293"><see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-293">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-294">この要求の状態情報を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-294">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="9cad8-295">受信接続の試行を受け入れる非同期操作を開始し、クライアント アプリケーションによって送信されるデータの最初のブロックを受信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-295">Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="9cad8-296">非同期の <see cref="T:System.Net.Sockets.Socket" /> 作成を参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-296">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-297">接続指向プロトコルでは、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを使用して、着信接続の試行を非同期に処理できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-297">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="9cad8-298">接続を非同期に受け入れると、別の実行スレッド内でデータを送受信できるようになります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-298">Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="9cad8-299">このオーバーロードでは、`receiveSize` パラメーターの初期転送で許容するバイト数を指定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-299">This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-300"><xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Listen%2A> メソッドを呼び出して受信接続要求をリッスンし、キューに挿入する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-300">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="9cad8-301"><xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-301">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="9cad8-302">これを行うには、少なくとも、`state` パラメーターを使用して、リッスンしている <xref:System.Net.Sockets.Socket> オブジェクトを <xref:System.Net.Sockets.Socket.BeginAccept%2A> に渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-302">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="9cad8-303">コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さいクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-303">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="9cad8-304">`state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-304">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-305">コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-305">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="9cad8-306">アプリケーションが <xref:System.Net.Sockets.Socket.BeginAccept%2A>を呼び出すと、通常、システムは別のスレッドを使用して、指定されたコールバックメソッドを実行し、保留中の接続が取得されるまで、<xref:System.Net.Sockets.Socket.EndAccept%2A> でブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-306">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="9cad8-307"><xref:System.Net.Sockets.Socket.EndAccept%2A> は、リモートホストとの間でデータを送受信するために使用できる新しい <xref:System.Net.Sockets.Socket> を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-307"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="9cad8-308">この返された <xref:System.Net.Sockets.Socket> を使用して、接続キューからの追加の接続を受け入れることはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-308">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="9cad8-309"><xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-309">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-310">元のスレッドの実行を継続する場合は、コールバックメソッドの <xref:System.Threading.ManualResetEvent> で Set メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-310">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="9cad8-311">また、呼び出し元のスレッドを使用してコールバックメソッドを呼び出すこともできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-311">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="9cad8-312">この場合、返された <xref:System.IAsyncResult> の <xref:System.IAsyncResult.CompletedSynchronously%2A> プロパティは、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドが同期的に完了したことを示すように設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-312">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="9cad8-313">コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-313">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="9cad8-314"><xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドへの保留中の呼び出しを取り消すには、<xref:System.Net.Sockets.Socket>を閉じます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-314">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span>  <span data-ttu-id="9cad8-315">非同期操作の実行中に <xref:System.Net.Sockets.Socket.Close%2A> メソッドが呼び出されると、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに提供されたコールバックが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-315">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="9cad8-316">後続の <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドの呼び出しでは、操作が取り消されたことを示す <xref:System.ObjectDisposedException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-316">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-317">を呼び出すと、返された <xref:System.Net.Sockets.Socket> オブジェクトの <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> プロパティを使用して、リモートホストのネットワークアドレスとポート番号を識別できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-317">You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-318"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-318">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-319">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-319">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-320">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-320">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-321">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-321">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-322">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-322">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-323">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-323">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-324">次のコード例では、ソケットを開き、非同期接続を受け入れます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-324">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="9cad8-325">この例では、ソケットは最初の10バイトのデータを受け入れます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-325">In this example, the socket accepts the initial 10 bytes of data.</span></span> <span data-ttu-id="9cad8-326">受信したバイト数とデータは、コールバックデリゲートによってコンソールに表示されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-326">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="9cad8-327">残りのデータを受信する方法の詳細については、「<xref:System.Net.Sockets.Socket.BeginReceive%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-327">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-328"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-328">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-329">このメソッドには Windows NT が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-329">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-330">受け入れ元のソケットが、接続をリッスンしていません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-330">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="9cad8-331"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-331">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="9cad8-332">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-332">-or-</span></span> 
<span data-ttu-id="9cad8-333">受け入れられたソケットがバインドされています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-333">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-334"><paramref name="receiveSize" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-334"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-335">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-335">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-336">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-336">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-337">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-337">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="acceptSocket"><span data-ttu-id="9cad8-338">受け入れた <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-338">The accepted <see cref="T:System.Net.Sockets.Socket" /> object.</span></span> <span data-ttu-id="9cad8-339">この値は <see langword="null" /> の場合もあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-339">This value may be <see langword="null" />.</span></span></param>
        <param name="receiveSize"><span data-ttu-id="9cad8-340">受信する最大バイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-340">The maximum number of bytes to receive.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-341"><see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-341">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-342">この要求の状態情報を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-342">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="9cad8-343">指定したソケットから受信接続の試行を受け入れる非同期操作を開始し、クライアント アプリケーションによって送信されるデータの最初のブロックを受信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-343">Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="9cad8-344">非同期の <see cref="T:System.Net.Sockets.Socket" /> オブジェクトの作成を参照する <see cref="T:System.IAsyncResult" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-344">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> object creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-345">接続指向プロトコルでは、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを使用して、着信接続の試行を非同期に処理できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-345">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="9cad8-346">接続を非同期に受け入れると、別の実行スレッド内でデータを送受信することができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-346">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="9cad8-347">このオーバーロードでは、`acceptSocket` パラメーターで受け入れられたソケットを指定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-347">This overload allows you to specify the accepted socket in the `acceptSocket` parameter.</span></span> <span data-ttu-id="9cad8-348">このパラメーターが `null`場合、受け入れられたソケットは <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドによって作成されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-348">If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="9cad8-349">`receiveSize` パラメーターで、初期転送時に受け入れるバイト数を指定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-349">You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-350"><xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Listen%2A> メソッドを呼び出して受信接続要求をリッスンし、キューに挿入する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-350">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="9cad8-351"><xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-351">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="9cad8-352">これを行うには、少なくとも、`state` パラメーターを使用して、リッスンしている <xref:System.Net.Sockets.Socket> オブジェクトを <xref:System.Net.Sockets.Socket.BeginAccept%2A> に渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-352">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="9cad8-353">コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さいクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-353">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="9cad8-354">`state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-354">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-355">コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-355">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="9cad8-356">アプリケーションが <xref:System.Net.Sockets.Socket.BeginAccept%2A>を呼び出すと、通常、システムは別のスレッドを使用して、指定されたコールバックメソッドを実行し、保留中の接続が取得されるまで、<xref:System.Net.Sockets.Socket.EndAccept%2A> でブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-356">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="9cad8-357"><xref:System.Net.Sockets.Socket.EndAccept%2A> は、リモートホストとの間でデータを送受信するために使用できる新しい <xref:System.Net.Sockets.Socket> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-357"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="9cad8-358">この返された <xref:System.Net.Sockets.Socket> を使用して、接続キューからの追加の接続を受け入れることはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-358">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="9cad8-359"><xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-359">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-360">元のスレッドの実行を継続する場合は、コールバックメソッドの <xref:System.Threading.ManualResetEvent> で Set メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-360">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="9cad8-361">また、呼び出し元のスレッドを使用してコールバックメソッドを呼び出すこともできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-361">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="9cad8-362">この場合、返された <xref:System.IAsyncResult> の <xref:System.IAsyncResult.CompletedSynchronously%2A> プロパティは、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドが同期的に完了したことを示すように設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-362">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="9cad8-363">コールバックメソッドの記述の詳細については、「[コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-363">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="9cad8-364"><xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドへの保留中の呼び出しを取り消すには、<xref:System.Net.Sockets.Socket>を閉じます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-364">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-365">非同期操作の実行中に <xref:System.Net.Sockets.Socket.Close%2A> メソッドが呼び出されると、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドに提供されたコールバックが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-365">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="9cad8-366">後続の <xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドの呼び出しでは、操作が取り消されたことを示す <xref:System.ObjectDisposedException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-366">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-367">返された <xref:System.Net.Sockets.Socket> オブジェクトの <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> プロパティを使用して、リモートホストのネットワークアドレスとポート番号を識別できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-367">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-368"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-368">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-369">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-369">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-370">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-370">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-371">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-371">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-372">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-372">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-373">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-373">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-374">次のコード例では、ソケットを開き、非同期接続を受け入れます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-374">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="9cad8-375">この例では、ソケットは最初の10バイトのデータを受け入れ、`acceptSocket` パラメーターを `null`ます。これにより、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドによって受け入れられたソケットが強制的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-375">In this example, the socket accepts the initial 10 bytes of data and the `acceptSocket` parameter is `null`, which forces the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to create the accepted socket.</span></span> <span data-ttu-id="9cad8-376">受信したバイト数とデータは、コールバックデリゲートによってコンソールに表示されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-376">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="9cad8-377">残りのデータを受信する方法の詳細については、「<xref:System.Net.Sockets.Socket.BeginReceive%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-377">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-378"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-378">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-379">このメソッドには Windows NT が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-379">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-380">受け入れ元のソケットが、接続をリッスンしていません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-380">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="9cad8-381"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-381">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="9cad8-382">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-382">-or-</span></span> 
<span data-ttu-id="9cad8-383">受け入れられたソケットがバインドされています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-383">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-384"><paramref name="receiveSize" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-384"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-385">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-385">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-386">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-386">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-387">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-387">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-388">リモート ホスト接続への非同期要求を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-388">Begins an asynchronous request for a remote host connection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><span data-ttu-id="9cad8-389">リモート ホストを表す <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-389">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</span></span></param>
        <param name="end_point"><span data-ttu-id="9cad8-390">リモート ホストを表す <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-390">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-391"><see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-391">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-392">この要求の状態情報を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-392">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="9cad8-393">リモート ホスト接続への非同期要求を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-393">Begins an asynchronous request for a remote host connection.</span></span></summary>
        <returns><span data-ttu-id="9cad8-394">非同期接続を参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-394">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-395">接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドは、`remoteEP` パラメーターへの接続の非同期要求を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-395">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter.</span></span> <span data-ttu-id="9cad8-396">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.BeginConnect%2A> によって既定のリモートホストが確立されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-396">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host.</span></span> <span data-ttu-id="9cad8-397">既定のリモートホストを非同期的に接続または設定すると、別の実行スレッド内でデータを送受信することができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-397">Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="9cad8-398"><xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-398">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span> <span data-ttu-id="9cad8-399">少なくとも、`state` パラメーターを使用して <xref:System.Net.Sockets.Socket.BeginConnect%2A> に <xref:System.Net.Sockets.Socket> を渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-399">At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter.</span></span> <span data-ttu-id="9cad8-400">コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket>とその他の必要な情報を保持する小さいクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-400">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="9cad8-401">`state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-401">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-402">コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-402">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="9cad8-403">アプリケーションが <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> が正常に接続されるか例外がスローされるまで、<xref:System.Net.Sockets.Socket.EndConnect%2A> をブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-403">When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception.</span></span> <span data-ttu-id="9cad8-404"><xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A>を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-404">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="9cad8-405">元のスレッドの実行を継続する場合は、コールバックメソッドの <xref:System.Threading.ManualResetEvent> で Set メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-405">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="9cad8-406">コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-406">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="9cad8-407">UDP などのコネクションレスプロトコルを使用している場合は、データを送受信する前に <xref:System.Net.Sockets.Socket.BeginConnect%2A> を呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-407">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data.</span></span> <span data-ttu-id="9cad8-408"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> と <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> を使用して、リモートホストと通信できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-408">You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host.</span></span> <span data-ttu-id="9cad8-409"><xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出すと、指定された既定以外のアドレスから到着したデータグラムはすべて破棄されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-409">If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="9cad8-410">既定のリモートホストをブロードキャストアドレスに設定する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> を呼び出し、`true`にブロードキャストを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-410">If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="9cad8-411">できない場合は、<xref:System.Net.Sockets.Socket.BeginConnect%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-411">If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="9cad8-412">接続指向プロトコルを使用していて、<xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出さない場合は、基になるサービスプロバイダーによって、最も適切なローカルネットワークアドレスとポート番号が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-412">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="9cad8-413">コネクションレスプロトコルを使用している場合、サービスプロバイダーは、<xref:System.Net.Sockets.Socket.BeginSend%2A> または <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> 方法を呼び出すまで、ローカルネットワークアドレスとポート番号を割り当てません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-413">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-414">既定のリモートホストを変更する場合は、目的のエンドポイントで <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドをもう一度呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-414">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="9cad8-415"><xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドへの保留中の呼び出しを取り消すには、<xref:System.Net.Sockets.Socket>を閉じます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-415">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-416">非同期操作の実行中に <xref:System.Net.Sockets.Socket.Close%2A> メソッドが呼び出されると、<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドに提供されたコールバックが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-416">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="9cad8-417">後続の <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドの呼び出しでは、操作が取り消されたことを示す <xref:System.ObjectDisposedException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-417">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-418"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-418">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-419">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-419">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-420">このソケットが以前に切断されていた場合は、操作が完了するまで終了しないスレッドで <xref:System.Net.Sockets.Socket.BeginConnect%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-420">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="9cad8-421">これは、基になるプロバイダーの制限です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-421">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-422">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-422">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-423">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-423">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-424">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-424">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-425">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-425">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-426">次のコード例では、非同期接続の試行を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-426">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-427"><paramref name="remoteEP" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-427"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-428">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-428">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-429"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-429">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-430">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-430">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-431"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-431">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="9cad8-432">コールバック メソッドとしてのデリゲートのマーシャ リング</span><span class="sxs-lookup"><span data-stu-id="9cad8-432">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-433">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-433">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-434">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-434">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="9cad8-435">リモート ホストの <see cref="T:System.Net.IPAddress" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-435">The <see cref="T:System.Net.IPAddress" /> of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="9cad8-436">リモート ホストのポート番号。</span><span class="sxs-lookup"><span data-stu-id="9cad8-436">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="9cad8-437">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-437">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-438">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-438">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-439">接続操作に関する情報を格納するユーザー定義のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-439">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="9cad8-440">このオブジェクトは、操作の完了時に <paramref name="requestCallback" /> デリゲートに渡されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-440">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="9cad8-441">リモート ホスト接続への非同期要求を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-441">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="9cad8-442">ホストは <see cref="T:System.Net.IPAddress" /> とポート番号で指定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-442">The host is specified by an <see cref="T:System.Net.IPAddress" /> and a port number.</span></span></summary>
        <returns><span data-ttu-id="9cad8-443">非同期接続を参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-443">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-444">非同期 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作は、<xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドを呼び出すことによって完了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-444">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="9cad8-445">通常、メソッドは `requestCallback` デリゲートによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-445">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="9cad8-446">このメソッドは、操作が完了するまでブロックしません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-446">This method does not block until the operation is complete.</span></span> <span data-ttu-id="9cad8-447">操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドオーバーロードまたは <xref:System.Net.Sockets.Socket.EndConnect%2A>のいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-447">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-448"><xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドへの保留中の呼び出しを取り消すには、<xref:System.Net.Sockets.Socket>を閉じます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-448">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-449">非同期操作の実行中に <xref:System.Net.Sockets.Socket.Close%2A> メソッドが呼び出されると、<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドに提供されたコールバックが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-449">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="9cad8-450">後続の <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドの呼び出しでは、操作が取り消されたことを示す <xref:System.ObjectDisposedException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-450">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="9cad8-451">非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-451">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-452"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-452">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-453">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-453">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-454">このソケットが以前に切断されていた場合は、操作が完了するまで終了しないスレッドで <xref:System.Net.Sockets.Socket.BeginConnect%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-454">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="9cad8-455">これは、基になるプロバイダーの制限です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-455">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="9cad8-456">また、使用する <xref:System.Net.EndPoint> は異なっている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-456">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-457">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-457">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-458">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-458">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-459">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-459">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-460">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-460">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-461">次のコード例では、非同期接続の試行を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-461">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-462"><paramref name="address" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-462"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-463">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-463">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-464"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-464">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-465"><see cref="T:System.Net.Sockets.Socket" /> はソケット ファミリに含まれません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-465">The <see cref="T:System.Net.Sockets.Socket" /> is not in the socket family.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-466">ポート番号が無効です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-466">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-467"><paramref name="address" /> の長さが 0 です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-467">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-468"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-468">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="9cad8-469">コールバック メソッドとしてのデリゲートのマーシャ リング</span><span class="sxs-lookup"><span data-stu-id="9cad8-469">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-470">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-470">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-471">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-471">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="9cad8-472">リモート ホストを指定する、少なくとも 1 つの <see cref="T:System.Net.IPAddress" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-472">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="9cad8-473">リモート ホストのポート番号。</span><span class="sxs-lookup"><span data-stu-id="9cad8-473">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="9cad8-474">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-474">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-475">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-475">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-476">接続操作に関する情報を格納するユーザー定義のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-476">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="9cad8-477">このオブジェクトは、操作の完了時に <paramref name="requestCallback" /> デリゲートに渡されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-477">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="9cad8-478">リモート ホスト接続への非同期要求を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-478">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="9cad8-479">ホストは、<see cref="T:System.Net.IPAddress" /> 配列とポート番号で指定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-479">The host is specified by an <see cref="T:System.Net.IPAddress" /> array and a port number.</span></span></summary>
        <returns><span data-ttu-id="9cad8-480">非同期接続を参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-480">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connections.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-481">非同期 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作は、<xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドを呼び出すことによって完了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-481">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="9cad8-482">通常、メソッドは `requestCallback` デリゲートによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-482">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="9cad8-483">このメソッドは、操作が完了するまでブロックしません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-483">This method does not block until the operation is complete.</span></span> <span data-ttu-id="9cad8-484">操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドオーバーロードのいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-484">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="9cad8-485"><xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドへの保留中の呼び出しを取り消すには、<xref:System.Net.Sockets.Socket>を閉じます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-485">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-486">非同期操作の実行中に <xref:System.Net.Sockets.Socket.Close%2A> メソッドが呼び出されると、<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドに提供されたコールバックが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-486">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="9cad8-487">後続の <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドの呼び出しでは、操作が取り消されたことを示す <xref:System.ObjectDisposedException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-487">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="9cad8-488">非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-488">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-489"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-489">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-490">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-490">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-491">このソケットが以前に切断されていた場合は、操作が完了するまで終了しないスレッドで <xref:System.Net.Sockets.Socket.BeginConnect%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-491">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="9cad8-492">これは、基になるプロバイダーの制限です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-492">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="9cad8-493">また、使用する <xref:System.Net.EndPoint> は異なっている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-493">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-494">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-494">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-495">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-495">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-496">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-496">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-497">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-497">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-498">次のコード例では、非同期接続の試行を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-498">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-499"><paramref name="addresses" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-499"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-500">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-500">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-501"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-501">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-502">このメソッドは <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> を使用するソケットで有効です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-502">This method is valid for sockets that use <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-503">ポート番号が無効です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-503">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-504"><paramref name="address" /> の長さが 0 です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-504">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-505"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-505">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="9cad8-506">コールバック メソッドとしてのデリゲートのマーシャ リング</span><span class="sxs-lookup"><span data-stu-id="9cad8-506">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-507">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-507">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-508">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-508">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="9cad8-509">リモート ホストの名前。</span><span class="sxs-lookup"><span data-stu-id="9cad8-509">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="9cad8-510">リモート ホストのポート番号。</span><span class="sxs-lookup"><span data-stu-id="9cad8-510">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="9cad8-511">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-511">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-512">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-512">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-513">接続操作に関する情報を格納するユーザー定義のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-513">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="9cad8-514">このオブジェクトは、操作の完了時に <paramref name="requestCallback" /> デリゲートに渡されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-514">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="9cad8-515">リモート ホスト接続への非同期要求を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-515">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="9cad8-516">ホストはホスト名とポート番号で指定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-516">The host is specified by a host name and a port number.</span></span></summary>
        <returns><span data-ttu-id="9cad8-517">非同期接続を参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-517">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-518">非同期 <xref:System.Net.Sockets.Socket.BeginConnect%2A> 操作は、<xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドを呼び出すことによって完了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-518">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="9cad8-519">通常、メソッドは `requestCallback` デリゲートによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-519">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="9cad8-520">このメソッドは、操作が完了するまでブロックしません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-520">This method does not block until the operation is complete.</span></span> <span data-ttu-id="9cad8-521">操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドオーバーロードのいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-521">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="9cad8-522"><xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドへの保留中の呼び出しを取り消すには、<xref:System.Net.Sockets.Socket>を閉じます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-522">To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-523">非同期操作の実行中に <xref:System.Net.Sockets.Socket.Close%2A> メソッドが呼び出されると、<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドに提供されたコールバックが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-523">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="9cad8-524">後続の <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドの呼び出しでは、操作が取り消されたことを示す <xref:System.ObjectDisposedException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-524">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="9cad8-525">非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-525">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-526"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-526">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-527">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-527">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-528">このソケットが以前に切断されていた場合は、操作が完了するまで終了しないスレッドで <xref:System.Net.Sockets.Socket.BeginConnect%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-528">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="9cad8-529">これは、基になるプロバイダーの制限です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-529">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="9cad8-530">また、使用する <xref:System.Net.EndPoint> は異なっている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-530">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-531">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-531">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-532">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-532">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-533">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-533">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-534">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-534">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-535">次のコード例では、非同期接続の試行を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-535">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-536"><paramref name="host" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-536"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-537"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-537">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-538">このメソッドは <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリ内のソケットに対して正しいものです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-538">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-539">ポート番号が無効です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-539">The port number is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-540"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-540">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="9cad8-541">コールバック メソッドとしてのデリゲートのマーシャ リング</span><span class="sxs-lookup"><span data-stu-id="9cad8-541">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-542">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-542">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-543">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-543">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><span data-ttu-id="9cad8-544">接続の終了後、このソケットが再利用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-544"><see langword="true" /> if this socket can be reused after the connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-545"><see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-545">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-546">この要求のステータス情報を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-546">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="9cad8-547">リモート エンドポイントからの切断の非同期要求を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-547">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="9cad8-548">非同期操作を参照する <see cref="T:System.IAsyncResult" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-548">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-549">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.BeginDisconnect%2A> メソッドを呼び出して、リモートエンドポイントからの切断を要求できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-549">If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint.</span></span> <span data-ttu-id="9cad8-550">`reuseSocket` が `true`場合は、ソケットを再利用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-550">If `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="9cad8-551"><xref:System.Net.Sockets.Socket.BeginDisconnect%2A> メソッドは、個別のスレッドを使用して、指定されたコールバックメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-551">The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method.</span></span> <span data-ttu-id="9cad8-552"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> メソッドは、保留中の切断が完了するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-552">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete.</span></span> <span data-ttu-id="9cad8-553">コールバックメソッドの記述の詳細については、「[コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-553">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-554"><xref:System.Net.Sockets.SocketException> 例外が発生した場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-554">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-555">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-555">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-556">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-556">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-557">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-557">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-558">次のコード例では、非同期通信用のソケットを作成し、いくつかのデータをリモートホストに送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-558">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="9cad8-559">データが送信されると、<xref:System.Net.Sockets.Socket.Shutdown%2A> が呼び出され、送信と受信のアクティビティが停止されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-559">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="9cad8-560">次に、<xref:System.Net.Sockets.Socket.BeginDisconnect%2A> が呼び出され、切断要求が開始されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-560">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="9cad8-561">要求が完了すると、ソケットが切断されているかどうかをテストするために <xref:System.Net.Sockets.Socket.Connected%2A> プロパティが照会されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-561">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-562">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-562">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-563"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-563">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-564">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-564">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-565">接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-565">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="9cad8-566">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-566">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-567"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-567">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-568">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-568">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-569">受信操作に関する情報を格納するユーザー定義のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-569">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="9cad8-570">このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-570">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="9cad8-571">接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-571">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-572">非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-572">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-573">非同期 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを呼び出すことによって完了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-573">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="9cad8-574">通常、メソッドは `callback` デリゲートによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-574">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="9cad8-575">このメソッドは、操作が完了するまでブロックしません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-575">This method does not block until the operation is complete.</span></span> <span data-ttu-id="9cad8-576">操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドオーバーロードのいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-576">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="9cad8-577">保留中の <xref:System.Net.Sockets.Socket.BeginReceive%2A>を取り消すには、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-577">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-578">非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-578">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-579"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-579">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-580">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-580">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-581">特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-581">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="9cad8-582">保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-582">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-583">`state` は、ユーザー定義のクラスをインスタンス化したものです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-583">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-584">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-584">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-585">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-585">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-586">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-586">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-587">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-587">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-588"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-588"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-589">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-589">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-590"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-590"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="9cad8-591">コールバック メソッドとしてのデリゲートのマーシャ リング</span><span class="sxs-lookup"><span data-stu-id="9cad8-591">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-592">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-592">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-593">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-593">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="9cad8-594">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-594">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-595"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-595">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="9cad8-596">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-596">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-597">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-597">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-598">受信操作に関する情報を格納するユーザー定義のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-598">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="9cad8-599">このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-599">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="9cad8-600">接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-600">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-601">非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-601">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-602">非同期 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを呼び出すことによって完了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-602">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="9cad8-603">通常、メソッドは `callback` デリゲートによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-603">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="9cad8-604">このメソッドは、操作が完了するまでブロックしません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-604">This method does not block until the operation is complete.</span></span> <span data-ttu-id="9cad8-605">操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドオーバーロードのいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-605">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="9cad8-606">保留中の <xref:System.Net.Sockets.Socket.BeginReceive%2A>を取り消すには、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-606">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-607">非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-607">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-608"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-608">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-609">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-609">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-610">特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-610">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="9cad8-611">保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-611">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-612">`state` は、ユーザー定義のクラスをインスタンス化したものです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-612">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-613">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-613">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-614">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-614">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-615">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-615">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-616">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-616">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-617"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-617"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-618">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-618">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-619"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-619"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="9cad8-620">コールバック メソッドとしてのデリゲートのマーシャ リング</span><span class="sxs-lookup"><span data-stu-id="9cad8-620">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-621">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-621">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-622">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-622">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-623">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-623">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="9cad8-624">受信データを格納する、<paramref name="buffer" />パラメーター内の、インデックス番号が 0 から始まる位置。</span><span class="sxs-lookup"><span data-stu-id="9cad8-624">The zero-based position in the <paramref name="buffer" /> parameter at which to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-625">受信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-625">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-626"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-626">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="9cad8-627"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-627">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-628">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-628">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-629">受信操作に関する情報を格納するユーザー定義のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-629">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="9cad8-630">このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-630">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="9cad8-631">接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-631">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-632">非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-632">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-633">非同期 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを呼び出すことによって完了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-633">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="9cad8-634">通常、メソッドは `callback` デリゲートによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-634">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="9cad8-635">このメソッドは、操作が完了するまでブロックしません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-635">This method does not block until the operation is complete.</span></span> <span data-ttu-id="9cad8-636">操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドオーバーロードのいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-636">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="9cad8-637">保留中の <xref:System.Net.Sockets.Socket.BeginReceive%2A>を取り消すには、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-637">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-638">非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-638">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-639"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-639">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-640">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-640">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-641">特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-641">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="9cad8-642">保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-642">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-643">`state` は、ユーザー定義のクラスをインスタンス化したものです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-643">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-644">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-644">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-645">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-645">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-646">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-646">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-647">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-647">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-648">次のコード例では、接続された <xref:System.Net.Sockets.Socket>からのデータの非同期受信を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-648">The following code example begins to asynchronously receive data from a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-649"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-649"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-650">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-650">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-651"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-651"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-652"><paramref name="offset" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-652"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-653">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-653">-or-</span></span> 
 <span data-ttu-id="9cad8-654"><paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-654"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="9cad8-655">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-655">-or-</span></span> 
 <span data-ttu-id="9cad8-656"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-656"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-657">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-657">-or-</span></span> 
 <span data-ttu-id="9cad8-658"><paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-658"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="9cad8-659">コールバック メソッドとしてのデリゲートのマーシャ リング</span><span class="sxs-lookup"><span data-stu-id="9cad8-659">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-660">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-660">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-661">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-661">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, errorCode, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-662">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-662">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="9cad8-663">受信データを格納する <paramref name="buffer" />内の場所。</span><span class="sxs-lookup"><span data-stu-id="9cad8-663">The location in <paramref name="buffer" /> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-664">受信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-664">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-665"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-665">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="flags"><span data-ttu-id="9cad8-666"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-666">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="9cad8-667">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-667">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="error"><span data-ttu-id="9cad8-668">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-668">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-669">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-669">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-670">受信操作に関する情報を格納するユーザー定義のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-670">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="9cad8-671">このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-671">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="9cad8-672">接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-672">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-673">非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-673">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-674">非同期 <xref:System.Net.Sockets.Socket.BeginReceive%2A> 操作は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを呼び出すことによって完了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-674">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="9cad8-675">通常、メソッドは `callback` デリゲートによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-675">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="9cad8-676">このメソッドは、操作が完了するまでブロックしません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-676">This method does not block until the operation is complete.</span></span> <span data-ttu-id="9cad8-677">操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドオーバーロードのいずれかを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-677">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="9cad8-678">保留中の <xref:System.Net.Sockets.Socket.BeginReceive%2A>を取り消すには、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-678">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-679">非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-679">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-680"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-680">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-681">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-681">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-682">特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-682">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="9cad8-683">保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-683">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-684">`state` は、ユーザー定義のクラスをインスタンス化したものです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-684">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-685">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-685">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-686">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-686">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-687">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-687">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-688">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-688">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-689"><paramref name="buffer" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-689"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-690">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-690">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-691"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-691"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-692"><paramref name="offset" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-692"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-693">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-693">-or-</span></span> 
 <span data-ttu-id="9cad8-694"><paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-694"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="9cad8-695">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-695">-or-</span></span> 
 <span data-ttu-id="9cad8-696"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-696"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-697">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-697">-or-</span></span> 
 <span data-ttu-id="9cad8-698"><paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-698"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="9cad8-699">コールバック メソッドとしてのデリゲートのマーシャ リング</span><span class="sxs-lookup"><span data-stu-id="9cad8-699">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-700">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-700">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-701">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-701">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-702">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-702">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="9cad8-703">データを格納する、<paramref name="buffer" />パラメーター内の、インデックス番号が 0 から始まる位置。</span><span class="sxs-lookup"><span data-stu-id="9cad8-703">The zero-based position in the <paramref name="buffer" /> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-704">受信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-704">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-705"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-705">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="9cad8-706"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-706">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="9cad8-707">データのソースを表す <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-707">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="remote_end"><span data-ttu-id="9cad8-708">データのソースを表す <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-708">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-709"><see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-709">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-710">この要求の状態情報を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-710">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="9cad8-711">指定したネットワーク デバイスから、データの非同期の受信を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-711">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="9cad8-712">非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-712">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-713"><xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドは、リモートホストからのコネクションレスデータグラムの非同期読み取りを開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-713">The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host.</span></span> <span data-ttu-id="9cad8-714"><xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドを呼び出すと、別の実行スレッド内でデータを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-714">Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="9cad8-715"><xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-715">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-716">これを行うには、少なくとも、`state` パラメーターに、通信に使用される接続された <xref:System.Net.Sockets.Socket> または既定のが含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-716">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="9cad8-717">コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さいクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-717">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="9cad8-718">`state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-718">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-719">コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-719">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-720">アプリケーションが <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> がデータを読み取るか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> でブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-720">When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception.</span></span> <span data-ttu-id="9cad8-721"><xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-721">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-722">元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-722">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="9cad8-723">コールバックメソッドの記述の詳細については、「[コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-723">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-724"><xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して <xref:System.Net.Sockets.Socket> をローカルエンドポイントに明示的にバインドする必要があります。この操作を行わないと、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> は <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-724">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="9cad8-725">このメソッドは、データを `buffer` パラメーターに読み込み、データの送信元のリモートホストエンドポイントをキャプチャします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-725">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent.</span></span> <span data-ttu-id="9cad8-726">このエンドポイントを取得する方法の詳細については、「<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-726">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="9cad8-727">このメソッドは、不明なホストまたは複数のホストからコネクションレスのデータグラムを非同期的に受信する場合に最も役立ちます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-727">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span> <span data-ttu-id="9cad8-728">このような場合、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-728">In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="9cad8-729">受信したデータグラムが `buffer`のサイズより大きい場合、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドは、可能な限り多くのメッセージを `buffer` に入力し、<xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-729">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-730">信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-730">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="9cad8-731">信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な大きさのバッファーを使用して <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドを呼び出すことで取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-731">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="9cad8-732">リモートホストエンドポイントが常に返されるようにするには、アプリケーションで <xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用してローカルエンドポイントに <xref:System.Net.Sockets.Socket> を明示的にバインドし、`optionLevel` パラメーターを <xref:System.Net.Sockets.SocketOptionLevel.IP> に設定して <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出すか、<xref:System.Net.Sockets.SocketOptionLevel.IPv6> としてします。適切、`optionName` パラメーターを <xref:System.Net.Sockets.SocketOptionName.PacketInformation>に設定し、`optionValue` パラメーターを使用して、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドを呼び出す前にこのオプションを有効にします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-732">To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-733">そうしないと、受信側が <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドを呼び出した後に、送信者が複数のデータグラムを送信した場合に、リモートホストエンドポイントが返されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-733">Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-734"><xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-734">Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="9cad8-735">これを選択する場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出すか、<xref:System.Net.Sockets.Socket.Accept%2A> または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出して受信接続要求を受け入れることによって、リモートホスト接続を確立する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-735">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="9cad8-736">接続を確立または受け入れる前に <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドを呼び出すと、<xref:System.Net.Sockets.SocketException>が表示されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-736">If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-737"><xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-737">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-738">どちらの場合も、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドは、`remoteEP` パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-738">In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="9cad8-739">接続指向のソケットでは、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> は、`size` パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-739">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-740">保留中の <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を取り消すには、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-740">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-741"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-741">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-742">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-742">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-743">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-743">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-744">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-744">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-745">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-745">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-746">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-746">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-747">次のコード例では、リモートホストからコネクションレスのデータグラムを非同期的に受信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-747">The following code example asynchronously receives connectionless datagrams from a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-748"><paramref name="buffer" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-748"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cad8-749">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-749">-or-</span></span> 
 <span data-ttu-id="9cad8-750"><paramref name="remoteEP" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-750"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-751">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-751">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-752"><paramref name="offset" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-752"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-753">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-753">-or-</span></span> 
 <span data-ttu-id="9cad8-754"><paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-754"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="9cad8-755">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-755">-or-</span></span> 
 <span data-ttu-id="9cad8-756"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-756"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-757">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-757">-or-</span></span> 
 <span data-ttu-id="9cad8-758"><paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-758"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-759"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-759">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-760">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-760">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="9cad8-761">コールバック メソッドとしてのデリゲートのマーシャ リング</span><span class="sxs-lookup"><span data-stu-id="9cad8-761">Marshaling a Delegate as a Callback Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-762">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-762">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="9cad8-763">データを格納する、<paramref name="buffer" />パラメーター内の、インデックス番号が 0 から始まる位置。</span><span class="sxs-lookup"><span data-stu-id="9cad8-763">The zero-based position in the <paramref name="buffer" /> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-764">受信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-764">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-765"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-765">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="9cad8-766">データのソースを表す <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-766">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-767"><see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-767">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-768">この要求の状態情報を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-768">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="9cad8-769">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータの非同期受信を開始して、データ バッファー内の指定した位置に格納します。さらに、エンドポイントとパケット情報を格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-769">Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="9cad8-770">非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-770">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-771">非同期の受信操作は、<xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> メソッドを呼び出すことによって完了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-771">The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method.</span></span> <span data-ttu-id="9cad8-772">通常、メソッドは `asyncCallback` デリゲートによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-772">Typically, the method is invoked by the `asyncCallback` delegate.</span></span>  
  
 <span data-ttu-id="9cad8-773">このメソッドは、操作が完了するまでブロックしません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-773">This method does not block until the operation completes.</span></span> <span data-ttu-id="9cad8-774">操作が完了するまでブロックするには、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-774">To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-775">保留中の <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>を取り消すには、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-775">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-776">非同期プログラミングモデルの使用方法の詳細については、「[同期メソッドの非同期呼び出し](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-776">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
 <span data-ttu-id="9cad8-777">このメソッドは、データを `buffer` パラメーターに読み込み、データの送信元のリモートホストエンドポイント、および受信パケットに関する情報をキャプチャします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-777">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</span></span> <span data-ttu-id="9cad8-778">このエンドポイントを取得する方法の詳細については、「<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-778">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="9cad8-779">このメソッドは、不明なホストまたは複数のホストからコネクションレスのデータグラムを非同期的に受信する場合に最も役立ちます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-779">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-780"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-780">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-781">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-781">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-782">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-782">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-783">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-783">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-784">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-784">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-785">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-785">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-786"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-786"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cad8-787">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-787">-or-</span></span> 
 <span data-ttu-id="9cad8-788"><paramref name="remoteEP" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-788"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-789">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-789">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-790"><paramref name="offset" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-790"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-791">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-791">-or-</span></span> 
 <span data-ttu-id="9cad8-792"><paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-792"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="9cad8-793">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-793">-or-</span></span> 
 <span data-ttu-id="9cad8-794"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-794"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-795">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-795">-or-</span></span> 
 <span data-ttu-id="9cad8-796"><paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-796"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-797"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-797">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-798">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-798">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-799">接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-799">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="9cad8-800">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-800">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-801"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-801">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-802"><see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-802">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-803">この要求の状態情報を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-803">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="9cad8-804">接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-804">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-805">非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-805">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-806"><xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドで確立されたリモートホストへの非同期の送信操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-806">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="9cad8-807">最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出さない場合、<xref:System.Net.Sockets.Socket.BeginSend%2A> は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-807"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="9cad8-808"><xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出すと、別の実行スレッド内でデータを送信できるようになります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-808">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="9cad8-809"><xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-809">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="9cad8-810">これを行うには、少なくとも、`state` パラメーターに、通信に使用される接続された <xref:System.Net.Sockets.Socket> または既定のが含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-810">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="9cad8-811">コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さなクラスまたは構造体を作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-811">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="9cad8-812">`state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-812">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-813">コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndSend%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-813">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="9cad8-814">アプリケーションが <xref:System.Net.Sockets.Socket.BeginSend%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> が要求したバイト数を送信するか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndSend%2A> でブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-814">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="9cad8-815"><xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-815">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9cad8-816">元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-816">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="9cad8-817">コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-817">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="9cad8-818">接続指向プロトコルを対象としていますが、最初に <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも <xref:System.Net.Sockets.Socket.BeginSend%2A> 機能します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-818">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="9cad8-819">コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-819">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="9cad8-820"><xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.BeginSendTo%2A> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-820">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-821">また、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A>に別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.BeginSend%2A> を呼び出す前に、既定のリモートホストを変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-821">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="9cad8-822">コネクションレスプロトコルを使用する場合は、バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-822">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-823">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.BeginSend%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-823">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="9cad8-824"><xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-824">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-825"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-825">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-826">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-826">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-827">特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-827">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="9cad8-828">保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-828">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-829">`state` は、ユーザー定義のクラスをインスタンス化したものです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-829">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-830">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-830">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-831">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-831">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-832">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-832">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-833">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-833">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-834">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-834">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-835">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-835">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-836"><paramref name="buffers" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-836"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-837"><paramref name="buffers" /> が空です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-837"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-838">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-838">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="9cad8-839">以下の解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-839">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-840"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-840">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="9cad8-841">コールバック メソッドとしてのデリゲートのマーシャ リング</span><span class="sxs-lookup"><span data-stu-id="9cad8-841">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-842">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-842">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-843">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-843">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="9cad8-844">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-844">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-845"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-845">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="9cad8-846">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-846">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-847"><see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-847">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-848">この要求の状態情報を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-848">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="9cad8-849">接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-849">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-850">非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-850">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-851"><xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドで確立されたリモートホストへの非同期の送信操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-851">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="9cad8-852">最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出さない場合、<xref:System.Net.Sockets.Socket.BeginSend%2A> は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-852"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="9cad8-853"><xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出すと、別の実行スレッド内でデータを送信できるようになります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-853">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="9cad8-854"><xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-854">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="9cad8-855">これを行うには、少なくとも、`state` パラメーターに、通信に使用される接続された <xref:System.Net.Sockets.Socket> または既定のが含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-855">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="9cad8-856">コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さなクラスまたは構造体を作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-856">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="9cad8-857">`state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-857">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-858">コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndSend%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-858">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="9cad8-859">アプリケーションが <xref:System.Net.Sockets.Socket.BeginSend%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> が要求したバイト数を送信するか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndSend%2A> でブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-859">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="9cad8-860"><xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-860">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9cad8-861">元のスレッドの実行を継続する場合は、コールバックメソッドの <xref:System.Threading.ManualResetEvent> で Set メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-861">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="9cad8-862">コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-862">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="9cad8-863">接続指向プロトコルを対象としていますが、最初に <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも <xref:System.Net.Sockets.Socket.BeginSend%2A> 機能します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-863">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="9cad8-864">コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-864">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="9cad8-865"><xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.BeginSendTo%2A> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-865">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-866">また、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A>に別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.BeginSend%2A> を呼び出す前に、既定のリモートホストを変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-866">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="9cad8-867">コネクションレスプロトコルを使用する場合は、バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-867">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-868">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.BeginSend%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-868">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="9cad8-869"><xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-869">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-870"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-870">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-871">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-871">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-872">特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-872">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="9cad8-873">保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-873">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-874">`state` は、ユーザー定義のクラスをインスタンス化したものです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-874">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-875">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-875">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-876">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-876">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-877">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-877">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-878">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-878">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-879">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-879">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-880">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-880">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-881"><paramref name="buffers" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-881"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-882"><paramref name="buffers" /> が空です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-882"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-883">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-883">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="9cad8-884">以下の解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-884">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-885"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-885">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="9cad8-886">コールバック メソッドとしてのデリゲートのマーシャ リング</span><span class="sxs-lookup"><span data-stu-id="9cad8-886">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-887">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-887">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-888">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-888">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-889">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-889">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="9cad8-890">送信を開始する、<paramref name="buffer" /> パラメーター内の、インデックス番号が 0 から始まる位置。</span><span class="sxs-lookup"><span data-stu-id="9cad8-890">The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-891">送信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-891">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-892"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-892">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="9cad8-893">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-893">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-894"><see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-894">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-895">この要求の状態情報を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-895">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="9cad8-896">接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-896">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-897">非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-897">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-898"><xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドで確立されたリモートホストへの非同期の送信操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-898">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="9cad8-899">最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出さない場合、<xref:System.Net.Sockets.Socket.BeginSend%2A> は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-899"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="9cad8-900"><xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出すと、別の実行スレッド内でデータを送信できるようになります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-900">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="9cad8-901"><xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-901">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="9cad8-902">これを行うには、少なくとも、`state` パラメーターに、通信に使用される接続された <xref:System.Net.Sockets.Socket> または既定のが含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-902">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="9cad8-903">コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さなクラスまたは構造体を作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-903">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="9cad8-904">`state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-904">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-905">コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndSend%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-905">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="9cad8-906">アプリケーションが <xref:System.Net.Sockets.Socket.BeginSend%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> が要求したバイト数を送信するか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndSend%2A> でブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-906">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="9cad8-907"><xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-907">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9cad8-908">元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-908">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="9cad8-909">コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-909">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="9cad8-910">接続指向プロトコルを対象としていますが、最初に <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも <xref:System.Net.Sockets.Socket.BeginSend%2A> 機能します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-910">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="9cad8-911">コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-911">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="9cad8-912"><xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.BeginSendTo%2A> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-912">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-913">また、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A>に別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.BeginSend%2A> を呼び出す前に、既定のリモートホストを変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-913">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="9cad8-914">コネクションレスプロトコルを使用する場合は、バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-914">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-915">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.BeginSend%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-915">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="9cad8-916"><xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-916">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-917"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-917">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-918">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-918">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-919">特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-919">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="9cad8-920">保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-920">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-921">`state` は、ユーザー定義のクラスをインスタンス化したものです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-921">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-922">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-922">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-923">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-923">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-924">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-924">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-925">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-925">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-926">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-926">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-927">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-927">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-928"><paramref name="buffer" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-928"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-929">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-929">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="9cad8-930">以下の解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-930">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-931"><paramref name="offset" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-931"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-932">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-932">-or-</span></span> 
 <span data-ttu-id="9cad8-933"><paramref name="offset" /> が <paramref name="buffer" /> の長さより小さい値です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-933"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="9cad8-934">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-934">-or-</span></span> 
 <span data-ttu-id="9cad8-935"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-935"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-936">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-936">-or-</span></span> 
 <span data-ttu-id="9cad8-937"><paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-937"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-938"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-938">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="9cad8-939">コールバック メソッドとしてのデリゲートのマーシャ リング</span><span class="sxs-lookup"><span data-stu-id="9cad8-939">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-940">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-940">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-941">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-941">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-942">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-942">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="9cad8-943">送信を開始する、<paramref name="buffer" /> パラメーター内の、インデックス番号が 0 から始まる位置。</span><span class="sxs-lookup"><span data-stu-id="9cad8-943">The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-944">送信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-944">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-945"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-945">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="9cad8-946"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-946">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-947"><see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-947">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-948">この要求の状態情報を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-948">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="9cad8-949">接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-949">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-950">非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-950">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-951"><xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドで確立されたリモートホストへの非同期の送信操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-951">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="9cad8-952">最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出さない場合、<xref:System.Net.Sockets.Socket.BeginSend%2A> は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-952"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="9cad8-953"><xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出すと、別の実行スレッド内でデータを送信できるようになります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-953">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="9cad8-954"><xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-954">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="9cad8-955">これを行うには、少なくとも、`state` パラメーターに、通信に使用される接続された <xref:System.Net.Sockets.Socket> または既定のが含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-955">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="9cad8-956">コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持する小さなクラスまたは構造体を作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-956">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="9cad8-957">`state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-957">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-958">コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndSend%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-958">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="9cad8-959">アプリケーションが <xref:System.Net.Sockets.Socket.BeginSend%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> が要求したバイト数を送信するか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndSend%2A> でブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-959">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="9cad8-960"><xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-960">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9cad8-961">元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-961">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="9cad8-962">コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-962">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="9cad8-963">接続指向プロトコルを対象としていますが、最初に <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも <xref:System.Net.Sockets.Socket.BeginSend%2A> 機能します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-963">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="9cad8-964">コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-964">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="9cad8-965"><xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.BeginSendTo%2A> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-965">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-966">また、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A>に別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.BeginSend%2A> を呼び出す前に、既定のリモートホストを変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-966">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="9cad8-967">コネクションレスプロトコルを使用する場合は、バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-967">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-968">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.BeginSend%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-968">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="9cad8-969"><xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-969">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-970"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-970">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-971">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-971">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-972">特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-972">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="9cad8-973">保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-973">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-974">`state` は、ユーザー定義のクラスをインスタンス化したものです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-974">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-975">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-975">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-976">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-976">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-977">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-977">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-978">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-978">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-979">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-979">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-980">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-980">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-981">次のコード例では、リモートホストへのデータの非同期送信を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-981">The following code example begins asynchronously sending data to a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-982"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-982"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-983">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-983">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="9cad8-984">以下の解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-984">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-985"><paramref name="offset" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-985"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-986">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-986">-or-</span></span> 
 <span data-ttu-id="9cad8-987"><paramref name="offset" /> が <paramref name="buffer" /> の長さより小さい値です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-987"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="9cad8-988">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-988">-or-</span></span> 
 <span data-ttu-id="9cad8-989"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-989"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-990">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-990">-or-</span></span> 
 <span data-ttu-id="9cad8-991"><paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-991"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-992"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-992">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="9cad8-993">コールバック メソッドとしてのデリゲートのマーシャ リング</span><span class="sxs-lookup"><span data-stu-id="9cad8-993">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="9cad8-994">非同期クライアント ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-994">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="9cad8-995">非同期サーバー ソケットの例</span><span class="sxs-lookup"><span data-stu-id="9cad8-995">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-996">接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルを非同期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-996">Sends a file asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="9cad8-997">送信するファイルのパスと名前を格納する文字列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-997">A string that contains the path and name of the file to send.</span></span> <span data-ttu-id="9cad8-998">このパラメーターは、<see langword="null" /> に設定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-998">This parameter can be <see langword="null" />.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-999"><see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-999">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-1000">この要求の状態情報を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1000">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="9cad8-1001"><see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> フラグを使用して、接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> を送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1001">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flag.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1002">非同期送信を表す <see cref="T:System.IAsyncResult" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1002">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1003">このオーバーロードは、接続されているソケットにファイル `fileName` を送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1003">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="9cad8-1004">`fileName` がローカルディレクトリにある場合は、ファイル名だけで識別できます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1004">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="9cad8-1005">ワイルドカード ("..\\\myfile.txt ") と UNC 共有名 ("\\\\\\\ 共有ディレクトリ\\\myfile.txt ") はサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1005">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="9cad8-1006">ファイルが見つからない場合は、例外 <xref:System.IO.FileNotFoundException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1006">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="9cad8-1007">このメソッドは、Windows Sockets 2 API の `TransmitFile` 関数を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1007">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="9cad8-1008">`TransmitFile` 関数とそのフラグの詳細については、 [Windows Sockets](/windows/desktop/WinSock/)のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1008">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="9cad8-1009"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> の各メソッドで確立されたリモートホストへの非同期の送信操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1009">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="9cad8-1010">最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出さない場合、<xref:System.Net.Sockets.Socket.BeginSendFile%2A> は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1010"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="9cad8-1011"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドを呼び出すと、別の実行スレッド内でファイルを送信できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1011">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="9cad8-1012">操作を完了するには、<xref:System.AsyncCallback> delegate パラメーターによって呼び出されるコールバックメソッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1012">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="9cad8-1013">これを行うには、少なくとも、`state` パラメーターに、通信に使用される <xref:System.Net.Sockets.Socket> オブジェクトが含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1013">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="9cad8-1014">コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持するクラスまたは構造体を作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1014">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="9cad8-1015">このカスタムオブジェクトのインスタンスを、`state` パラメーターを使用して <xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1015">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-1016">コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndSendFile%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1016">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="9cad8-1017">アプリケーションが <xref:System.Net.Sockets.Socket.BeginSendFile%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> がファイル全体を送信するか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndSendFile%2A> にブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1017">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="9cad8-1018">コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1018">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="9cad8-1019">接続指向プロトコルを対象としていますが、最初に <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 機能します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1019">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="9cad8-1020">コネクションレスプロトコルを使用する場合は、ファイルのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1020">With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-1021">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.BeginSendFile%2A> は <xref:System.Net.Sockets.SocketException> 例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1021">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1022"><xref:System.Net.Sockets.SocketException> 例外が発生した場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1022">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1023">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1023">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1024">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1024">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1025">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1025">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1026">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1026">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-1027">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1027">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1028">次のコード例では、非同期通信用のソケットを作成して接続します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1028">The following code example creates and connects a socket for asynchronous communication.</span></span> <span data-ttu-id="9cad8-1029">まず、ファイル ".txt" をリモートホストに非同期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1029">First, the file "text.txt" is sent asynchronously to the remote host.</span></span> <span data-ttu-id="9cad8-1030">コールバックデリゲートは、転送を完了するために <xref:System.Net.Sockets.Socket.EndSendFile%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1030">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1031"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1031">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-1032">ソケットがリモート ホストに接続されていません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1032">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9cad8-1033">ファイル <paramref name="fileName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1033">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1034">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1034">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="9cad8-1035">以下の解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1035">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="9cad8-1036">送信されるファイルのパスと名前を格納する文字列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1036">A string that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="9cad8-1037">このパラメーターは、<see langword="null" /> に設定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1037">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="9cad8-1038">ファイルが送信される前に送信されるデータを格納する <see cref="T:System.Byte" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1038">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="9cad8-1039">このパラメーターは、<see langword="null" /> に設定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1039">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="9cad8-1040">ファイルが送信された後で送信されるデータを格納する <see cref="T:System.Byte" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1040">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="9cad8-1041">このパラメーターは、<see langword="null" /> に設定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1041">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="9cad8-1042"><see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1042">A bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-1043">このオプションの完了時に呼び出される <see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1043">An <see cref="T:System.AsyncCallback" /> delegate to be invoked when this operation completes.</span></span> <span data-ttu-id="9cad8-1044">このパラメーターは、<see langword="null" /> に設定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1044">This parameter can be <see langword="null" />.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-1045">この要求の状態情報を格納するユーザー定義のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1045">A user-defined object that contains state information for this request.</span></span> <span data-ttu-id="9cad8-1046">このパラメーターは、<see langword="null" /> に設定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1046">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="9cad8-1047">接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルとデータのバッファーを非同期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1047">Sends a file and buffers of data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1048">非同期操作を表す <see cref="T:System.IAsyncResult" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1048">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1049">このオーバーロードには、送信するファイルの名前と <xref:System.Net.Sockets.TransmitFileOptions> 値のビットごとの組み合わせが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1049">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="9cad8-1050">`preBuffer` パラメーターには、ファイルの前に配置するデータが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1050">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="9cad8-1051">`postBuffer` には、ファイルに従う必要があるデータが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1051">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="9cad8-1052">`fileName` がローカルディレクトリにある場合は、ファイル名だけで識別できます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1052">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="9cad8-1053">ワイルドカード ("..\\\myfile.txt ") と UNC 共有名 ("\\\\\\\ 共有ディレクトリ\\\myfile.txt ") はサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1053">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="9cad8-1054">ファイルが見つからない場合は、例外 <xref:System.IO.FileNotFoundException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1054">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="9cad8-1055">`flags` パラメーターは、ファイル転送に関する追加情報を Window Sockets service プロバイダーに提供します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1055">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="9cad8-1056">このパラメーターの使用方法の詳細については、「<xref:System.Net.Sockets.TransmitFileOptions>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1056">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="9cad8-1057">このメソッドは、Windows Sockets 2 API の `TransmitFile` 関数を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1057">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="9cad8-1058">`TransmitFile` 関数とそのフラグの詳細については、 [Windows Sockets](/windows/desktop/WinSock/)のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1058">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="9cad8-1059"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> の各メソッドで確立されたリモートホストへの非同期の送信操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1059">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="9cad8-1060">最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出さない場合、<xref:System.Net.Sockets.Socket.BeginSendFile%2A> は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1060"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="9cad8-1061"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドを呼び出すと、別の実行スレッド内でファイルを送信できるようになります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1061">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="9cad8-1062">操作を完了するには、<xref:System.AsyncCallback> delegate パラメーターによって呼び出されるコールバックメソッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1062">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="9cad8-1063">これを行うには、少なくとも、`state` パラメーターに、通信に使用される <xref:System.Net.Sockets.Socket> オブジェクトが含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1063">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="9cad8-1064">コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket> とその他の必要な情報を保持するクラスまたは構造体を作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1064">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="9cad8-1065">このカスタムオブジェクトのインスタンスを、`state` パラメーターを使用して <xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1065">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-1066">コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndSendFile%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1066">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="9cad8-1067">アプリケーションが <xref:System.Net.Sockets.Socket.BeginSendFile%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> がファイル全体を送信するか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndSendFile%2A> にブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1067">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="9cad8-1068">コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1068">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="9cad8-1069">接続指向プロトコルを対象としていますが、最初に <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 機能します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1069">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="9cad8-1070">コネクションレスプロトコルを使用する場合は、ファイルのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1070">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-1071">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.BeginSendFile%2A> は <xref:System.Net.Sockets.SocketException> 例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1071">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1072"><xref:System.Net.Sockets.SocketException> 例外が発生した場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1072">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1073">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1073">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1074">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1074">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1075">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1075">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1076">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1076">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-1077">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1077">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1078">次のコード例では、非同期通信用のソケットを作成して接続し、リモートホストへのファイル "test.txt" の非同期送信を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1078">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="9cad8-1079">この例では、`preBuffer` とデータの `postBuffer` を作成してファイルと共に送信し、既定の <xref:System.Net.Sockets.TransmitFileOptions> 値を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1079">In this example, a `preBuffer` and a `postBuffer` of data is created to send with the file and the default <xref:System.Net.Sockets.TransmitFileOptions> value is used.</span></span> <span data-ttu-id="9cad8-1080">コールバックデリゲートは、転送を完了するために <xref:System.Net.Sockets.Socket.EndSendFile%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1080">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1081"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1081">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1082">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1082">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="9cad8-1083">以下の解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1083">See remarks section below.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-1084">オペレーティング システムは Windows NT 以降ではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1084">The operating system is not Windows NT or later.</span></span>  
  
<span data-ttu-id="9cad8-1085">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-1085">-or-</span></span>
  
 <span data-ttu-id="9cad8-1086">ソケットがリモート ホストに接続されていません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1086">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9cad8-1087">ファイル <paramref name="fileName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1087">The file <paramref name="fileName" /> was not found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-1088">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1088">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="9cad8-1089">データ送信を開始する、<paramref name="buffer" /> 内の、インデックス番号が 0 から始まる位置。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1089">The zero-based position in <paramref name="buffer" /> at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-1090">送信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1090">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-1091"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1091">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="9cad8-1092"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1092">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="9cad8-1093">リモート デバイスを表す <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1093">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <param name="remote_end"><span data-ttu-id="9cad8-1094">リモート デバイスを表す <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1094">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <param name="callback"><span data-ttu-id="9cad8-1095"><see cref="T:System.AsyncCallback" /> デリゲート。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1095">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="9cad8-1096">この要求の状態情報を格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1096">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="9cad8-1097">特定のリモート ホストにデータを非同期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1097">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1098">非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1098">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1099"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドは、`remoteEP` パラメーターで指定されたリモートホストへの非同期の送信操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1099">The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter.</span></span> <span data-ttu-id="9cad8-1100"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドを呼び出すと、別の実行スレッド内でデータを送信できるようになります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1100">Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="9cad8-1101">コネクションレスプロトコルを対象としていますが、<xref:System.Net.Sockets.Socket.BeginSendTo%2A> はコネクションレスプロトコルと接続指向プロトコルの両方で動作します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1101">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="9cad8-1102"><xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成し、その名前を <xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1102">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method.</span></span> <span data-ttu-id="9cad8-1103">これを行うには、少なくとも、`state` パラメーターに、通信に使用される接続された <xref:System.Net.Sockets.Socket> または既定のが含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1103">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="9cad8-1104">コールバックでより多くの情報が必要な場合は、<xref:System.Net.Sockets.Socket>とその他の必要な情報を保持する小さいクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1104">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="9cad8-1105">`state` パラメーターを使用して、このクラスのインスタンスを <xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1105">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="9cad8-1106">コールバックメソッドは、<xref:System.Net.Sockets.Socket.EndSendTo%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1106">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method.</span></span> <span data-ttu-id="9cad8-1107">アプリケーションが <xref:System.Net.Sockets.Socket.BeginSendTo%2A>を呼び出すと、システムは別のスレッドを使用して指定されたコールバックメソッドを実行し、<xref:System.Net.Sockets.Socket> が要求したバイト数を送信するか例外をスローするまで、<xref:System.Net.Sockets.Socket.EndSendTo%2A> でブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1107">When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="9cad8-1108"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドを呼び出した後に元のスレッドがブロックされるようにするには、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1108">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="9cad8-1109">元のスレッドの実行を継続する場合は、コールバックメソッドの T:System.Threading.ManualResetEvent に対して Set メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1109">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="9cad8-1110">コールバックメソッドの記述の詳細については[、「コールバックメソッドとしてのデリゲートのマーシャリング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1110">For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="9cad8-1111">接続指向プロトコルを使用している場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドを呼び出す必要があります。呼び出さないと、<xref:System.Net.Sockets.Socket.BeginSendTo%2A> がスローされます。<xref:System.Net.Sockets.SocketException></span><span class="sxs-lookup"><span data-stu-id="9cad8-1111">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-1112"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> は `remoteEP` パラメーターを無視し、<xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Accept%2A>、または <xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドで設定された <xref:System.Net.EndPoint> にデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1112"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-1113">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを使用して既定のリモートホストを確立する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1113">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="9cad8-1114">この操作は、<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを呼び出す場合にのみ必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1114">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="9cad8-1115"><xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドを呼び出した場合、`remoteEP` パラメーターは、その送信操作に対して指定された既定のリモートホストを上書きします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1115">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="9cad8-1116"><xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1116">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="9cad8-1117">この場合、基になるサービスプロバイダーによって、最も適切なローカルネットワークアドレスとポート番号が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1117">In this case, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="9cad8-1118">基になるサービスプロバイダーで空きポートを選択する場合は、ポート番号を0にします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1118">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="9cad8-1119">割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は、<xref:System.Net.Sockets.Socket.EndSendTo%2A> メソッドが正常に完了した後に、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティを使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1119">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="9cad8-1120">ブロードキャストアドレスにデータを送信する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1120">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-1121">-バッファーのサイズが、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1121">-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-1122">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.EndSendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1122">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="9cad8-1123"><xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1123">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1124"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1124">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1125">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1125">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1126">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1126">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1127">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1127">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1128">非同期 <xref:System.Net.Sockets.Socket> メソッドに対して、実行コンテキスト (セキュリティコンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1128">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="9cad8-1129">特定のコンテキスト (特定の非同期 <xref:System.Net.Sockets.Socket> メソッド、特定の <xref:System.Net.Sockets.Socket> インスタンス、および特定のコールバック) を初めて使用した後、そのコンテキストを使用すると、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1129">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1130">次のコード例では、指定したリモートホストにデータを非同期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1130">The following code example asynchronously sends data to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1131"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1131"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cad8-1132">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-1132">-or-</span></span> 
 <span data-ttu-id="9cad8-1133"><paramref name="remoteEP" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1133"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1134">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1134">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-1135"><paramref name="offset" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1135"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-1136">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-1136">-or-</span></span> 
 <span data-ttu-id="9cad8-1137"><paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1137"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="9cad8-1138">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-1138">-or-</span></span> 
 <span data-ttu-id="9cad8-1139"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1139"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-1140">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-1140">-or-</span></span> 
 <span data-ttu-id="9cad8-1141"><paramref name="size" /> が、 <paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1141"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1142"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1142">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-1143">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1143">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="9cad8-1144">コールバック メソッドとしてのデリゲートのマーシャ リング</span><span class="sxs-lookup"><span data-stu-id="9cad8-1144">Marshaling a Delegate as a Callback Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><span data-ttu-id="9cad8-1145"><see cref="T:System.Net.Sockets.Socket" /> に関連付けるローカル <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1145">The local <see cref="T:System.Net.EndPoint" /> to associate with the <see cref="T:System.Net.Sockets.Socket" />.</span></span></param>
        <summary><span data-ttu-id="9cad8-1146"><see cref="T:System.Net.Sockets.Socket" /> をローカル エンドポイントと関連付けます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1146">Associates a <see cref="T:System.Net.Sockets.Socket" /> with a local endpoint.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1147">特定のローカルエンドポイントを使用する必要がある場合は、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1147">Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint.</span></span> <span data-ttu-id="9cad8-1148"><xref:System.Net.Sockets.Socket.Listen%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Bind%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1148">You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="9cad8-1149">特定のローカルエンドポイントを使用する必要がない限り、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを使用する前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1149">You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint.</span></span> <span data-ttu-id="9cad8-1150"><xref:System.Net.Sockets.Socket.Bind%2A> メソッドは、コネクションレスプロトコルと接続指向プロトコルの両方で使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1150">You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="9cad8-1151"><xref:System.Net.Sockets.Socket.Bind%2A>を呼び出す前に、まずデータを通信するローカル <xref:System.Net.IPEndPoint> を作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1151">Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data.</span></span> <span data-ttu-id="9cad8-1152">どのローカルアドレスが割り当てられているか気にしない場合は、address パラメーターとして <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> を使用して <xref:System.Net.IPEndPoint> を作成することができ、基になるサービスプロバイダーによって最も適切なネットワークアドレスが割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1152">If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> as the address parameter, and the underlying service provider will assign the most appropriate network address.</span></span> <span data-ttu-id="9cad8-1153">これは、複数のネットワークインターフェイスがある場合に、アプリケーションの簡素化に役立つ可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1153">This might help simplify your application if you have multiple network interfaces.</span></span> <span data-ttu-id="9cad8-1154">使用されるローカルポートを気にしない場合は、ポート番号に0を使用して <xref:System.Net.IPEndPoint> を作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1154">If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number.</span></span> <span data-ttu-id="9cad8-1155">この場合、サービスプロバイダーは1024と5000の間の使用可能なポート番号を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1155">In this case, the service provider will assign an available port number between 1024 and 5000.</span></span>  
  
 <span data-ttu-id="9cad8-1156">上記の方法を使用すると、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>を呼び出すことによって、どのローカルネットワークアドレスとポート番号が割り当てられているかを調べることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1156">If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span></span> <span data-ttu-id="9cad8-1157">接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドを呼び出した後に、ローカルに割り当てられたネットワークアドレスを返しません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1157">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="9cad8-1158">コネクションレスプロトコルを使用している場合は、送信または受信が完了するまで、この情報にアクセスすることはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1158">If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</span></span>  
  
 <span data-ttu-id="9cad8-1159">UDP ソケットが受信パケットのインターフェイス情報を受け取る必要がある場合は、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出した直後に socket オプションを <xref:System.Net.Sockets.SocketOptionName.PacketInformation> に設定して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを明示的に呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1159">If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1160">マルチキャストデータグラムを受信する場合は、マルチキャストポート番号を指定して <xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1160">If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1161"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用して、コネクションレスのデータグラムを受信する場合は、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1161">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1162"><xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出すときに <xref:System.Net.Sockets.SocketException> を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1162">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1163">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1163">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1164">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1164">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1165">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1165">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1166">次のコード例では、指定されたローカルエンドポイントを使用して <xref:System.Net.Sockets.Socket> をバインドします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1166">The following code example binds a <xref:System.Net.Sockets.Socket> using the specified local endpoint.</span></span>  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1167"><paramref name="localEP" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1167"><paramref name="localEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1168">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1168">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1169"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1169">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-1170">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1170">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-1171"><paramref name="localEP" />によって定義されたホストからの接続を受け入れる場合。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1171">for accepting connections from the host defined by <paramref name="localEP" />.</span></span> <span data-ttu-id="9cad8-1172">関連付けられた列挙型: <see cref="F:System.Net.NetworkAccess.Accept" /></span><span class="sxs-lookup"><span data-stu-id="9cad8-1172">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></span></span></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-1173"><see cref="T:System.Net.Sockets.Socket" /> がブロッキング モードかどうかを示す値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1173">Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is in blocking mode.</span></span></summary>
        <value><span data-ttu-id="9cad8-1174"><see cref="T:System.Net.Sockets.Socket" /> がブロックする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1174"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> will block; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9cad8-1175">既定値は、<see langword="true" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1175">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1176"><xref:System.Net.Sockets.Socket.Blocking%2A> プロパティは、<xref:System.Net.Sockets.Socket> がブロッキングモードであるかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1176">The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode.</span></span>  
  
 <span data-ttu-id="9cad8-1177">ブロックモードで、すぐには完了しないメソッド呼び出しを行う場合、要求された操作が完了するまで、アプリケーションは実行をブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1177">If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</span></span> <span data-ttu-id="9cad8-1178">要求された操作が完了していなくても実行を続行する場合は、[<xref:System.Net.Sockets.Socket.Blocking%2A>] プロパティを `false`に変更します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1178">If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`.</span></span> <span data-ttu-id="9cad8-1179"><xref:System.Net.Sockets.Socket.Blocking%2A> プロパティは、非同期メソッドには影響しません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1179">The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods.</span></span> <span data-ttu-id="9cad8-1180">非同期的にデータを送受信し、実行をブロックする場合は、<xref:System.Threading.ManualResetEvent> クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1180">If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1181"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1181">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1182">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1182">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1183">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1183">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1184">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1184">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1185">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1185">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1186"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1186">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="9cad8-1187"><see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> メソッドの 1 つを呼び出してリモート ホストへの接続を要求するために使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1187">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object used to request the connection to the remote host by calling one of the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> methods.</span></span></param>
        <summary><span data-ttu-id="9cad8-1188">リモート ホスト接続への非同期要求を取り消します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1188">Cancels an asynchronous request for a remote host connection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1189"><xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> メソッドは、リモートホスト接続の非同期要求をキャンセルします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1189">The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1190"><paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1190">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1191">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1191">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1192"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1192">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-1193">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1193">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-1194"><see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、関連付けられたすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1194">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cad8-1195"><see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、関連付けられたすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1195">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1196"><xref:System.Net.Sockets.Socket.Close%2A> メソッドは、リモートホスト接続を閉じ、<xref:System.Net.Sockets.Socket>に関連付けられているすべてのマネージリソースとアンマネージリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1196">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-1197">終了時に、<xref:System.Net.Sockets.Socket.Connected%2A> プロパティが `false`に設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1197">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="9cad8-1198">接続指向プロトコルの場合、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Shutdown%2A> を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1198">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span> <span data-ttu-id="9cad8-1199">これにより、接続されたソケットが閉じられる前に、すべてのデータが送信され、受信されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1199">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="9cad8-1200">最初に <xref:System.Net.Sockets.Socket.Shutdown%2A>を呼び出さずに <xref:System.Net.Sockets.Socket.Close%2A> を呼び出す必要がある場合は、<xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> オプションを `false` に設定し、ゼロ以外のタイムアウト期間を指定することにより、送信転送のためにキューに格納されたデータが送信されるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1200">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="9cad8-1201"><xref:System.Net.Sockets.Socket.Close%2A> は、このデータが送信されるか、指定されたタイムアウトが経過するまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1201"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="9cad8-1202"><xref:System.Net.Sockets.SocketOptionName.DontLinger> を `false` に設定し、タイムアウト間隔をゼロに指定した場合、<xref:System.Net.Sockets.Socket.Close%2A> は接続を解放し、発信キューに格納されたデータを自動的に破棄します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1202">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1203"><xref:System.Net.Sockets.SocketOptionName.DontLinger> socket オプションを `false`に設定するには、<xref:System.Net.Sockets.LingerOption>を作成し、enabled プロパティを `true`に設定して、<xref:System.Net.Sockets.LingerOption.LingerTime%2A> プロパティを目的のタイムアウト期間に設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1203">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period.</span></span> <span data-ttu-id="9cad8-1204">この <xref:System.Net.Sockets.LingerOption> を <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket オプションと共に使用して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1204">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1205">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1205">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1206">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1206">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1207">次のコード例では、<xref:System.Net.Sockets.Socket>を閉じます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1207">The following code example closes a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="9cad8-1208">最大 <paramref name="timeout" /> 秒まで待ってから残りのデータを送信し、ソケットを閉じます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1208">Wait up to <paramref name="timeout" /> seconds to send any remaining data, then close the socket.</span></span></param>
        <summary><span data-ttu-id="9cad8-1209"><see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、すべての関連付けられているリソースを指定したタイムアウトで解放して、キューに置かれたデータの送信を許可します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1209">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1210"><xref:System.Net.Sockets.Socket.Close%2A> メソッドは、リモートホスト接続を閉じ、<xref:System.Net.Sockets.Socket>に関連付けられているすべてのマネージリソースとアンマネージリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1210">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-1211">終了時に、<xref:System.Net.Sockets.Socket.Connected%2A> プロパティが `false`に設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1211">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="9cad8-1212">接続指向プロトコルの場合、<xref:System.Net.Sockets.Socket.Close%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Shutdown%2A> を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1212">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>.</span></span> <span data-ttu-id="9cad8-1213">これにより、接続されたソケットが閉じられる前に、すべてのデータが送信され、受信されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1213">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="9cad8-1214">最初に <xref:System.Net.Sockets.Socket.Shutdown%2A>を呼び出さずに <xref:System.Net.Sockets.Socket.Close%2A> を呼び出す必要がある場合は、<xref:System.Net.Sockets.SocketOptionName.DontLinger> オプションを `false` に設定し、ゼロ以外のタイムアウト期間を指定することによって、送信転送用のキューに置かれたデータが送信されるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1214">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="9cad8-1215"><xref:System.Net.Sockets.Socket.Close%2A> は、このデータが送信されるか、指定されたタイムアウトが経過するまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1215"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="9cad8-1216"><xref:System.Net.Sockets.SocketOptionName.DontLinger> を `false` に設定し、タイムアウト間隔をゼロに指定した場合、<xref:System.Net.Sockets.Socket.Close%2A> は接続を解放し、発信キューに格納されたデータを自動的に破棄します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1216">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1217"><xref:System.Net.Sockets.SocketOptionName.DontLinger> socket オプションを `false`に設定するには、<xref:System.Net.Sockets.LingerOption>を作成し、enabled プロパティを `true`に設定して、<xref:System.Net.Sockets.LingerOption.LingerTime%2A> プロパティを目的のタイムアウト期間に設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1217">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period.</span></span> <span data-ttu-id="9cad8-1218">この <xref:System.Net.Sockets.LingerOption> を <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket オプションと共に使用して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1218">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1219">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1219">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1220">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1220">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1221">次のコード例は、<xref:System.Net.Sockets.Socket>を閉じる方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1221">The following code example demonstrates how to close a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-1222">リモート ホストへの接続を確立します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1222">Establishes a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><span data-ttu-id="9cad8-1223">リモート デバイスを表す <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1223">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <summary><span data-ttu-id="9cad8-1224">リモート ホストへの接続を確立します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1224">Establishes a connection to a remote host.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1225">TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドは、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> と指定されたリモートエンドポイント間のネットワーク接続を同期的に確立します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1225">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="9cad8-1226">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> によって既定のリモートホストが確立されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1226">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="9cad8-1227"><xref:System.Net.Sockets.Socket.Connect%2A>を呼び出した後、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを使用してリモートデバイスにデータを送信したり、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドを使用してリモートデバイスからデータを受信したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1227">After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-1228">UDP などのコネクションレスプロトコルを使用している場合は、データを送受信する前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1228">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="9cad8-1229"><xref:System.Net.Sockets.Socket.SendTo%2A> と <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用して、リモートホストと同期的に通信できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1229">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="9cad8-1230"><xref:System.Net.Sockets.Socket.Connect%2A>を呼び出すと、指定された既定以外のアドレスから到着したデータグラムはすべて破棄されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1230">If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="9cad8-1231">既定のリモートホストをブロードキャストアドレスに設定する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。指定しないと、<xref:System.Net.Sockets.Socket.Connect%2A> は <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1231">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-1232"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1232">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1233">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1233">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="9cad8-1234"><xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティを `false` に明示的に設定しない限り、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1234">The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-1235">TCP のような接続指向プロトコルを使用していて、ブロックを無効にすると、<xref:System.Net.Sockets.Socket.Connect%2A> は接続に時間がかかるため、<xref:System.Net.Sockets.SocketException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1235">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="9cad8-1236">コネクションレスプロトコルは、既定のリモートホストを確立するだけなので、例外をスローしません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1236">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="9cad8-1237"><xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> を使用すると、特定のエラーコードを取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1237">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1238">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1238">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="9cad8-1239">エラーによって WSAEWOULDBLOCK が返された場合、リモートホスト接続は接続指向 <xref:System.Net.Sockets.Socket>によって開始されていますが、まだ正常に完了していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1239">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="9cad8-1240"><xref:System.Net.Sockets.Socket.Poll%2A> メソッドを使用して、<xref:System.Net.Sockets.Socket> の接続がいつ終了するかを判断します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1240">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1241">接続指向プロトコルを使用していて、<xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出さなかった場合は、基になるサービスプロバイダーによってローカルネットワークアドレスとポート番号が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1241">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="9cad8-1242">コネクションレスプロトコルを使用している場合、送信または受信操作が完了するまで、サービスプロバイダーはローカルネットワークアドレスとポート番号を割り当てません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1242">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="9cad8-1243">既定のリモートホストを変更する場合は、目的のエンドポイントで <xref:System.Net.Sockets.Socket.Connect%2A> をもう一度呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1243">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1244">ソケットが既に切断されている場合は、この方法を使用して接続を復元することはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1244">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="9cad8-1245">非同期の <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドのいずれかを使用して再接続します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1245">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="9cad8-1246">これは、基になるプロバイダーの制限です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1246">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1247">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1247">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1248">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1248">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1249">次のコード例では、リモートエンドポイントに接続し、接続を確認します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1249">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1250"><paramref name="remoteEP" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1250"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1251">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1251">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1252"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1252">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-1253">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1253">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1254"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1254">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-1255">リモートホストに接続するために使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1255">for connecting to the remote host.</span></span> <span data-ttu-id="9cad8-1256">関連付けられた列挙型: <see cref="F:System.Net.NetworkAccess.Connect" /></span><span class="sxs-lookup"><span data-stu-id="9cad8-1256">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="9cad8-1257">リモート ホストの IP アドレス。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1257">The IP address of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="9cad8-1258">リモート ホストのポート番号。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1258">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="9cad8-1259">リモート ホストへの接続を確立します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1259">Establishes a connection to a remote host.</span></span> <span data-ttu-id="9cad8-1260">ホストは、IP アドレスとポート番号で指定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1260">The host is specified by an IP address and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1261">TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドは、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> と指定されたリモートエンドポイント間のネットワーク接続を同期的に確立します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1261">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="9cad8-1262">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> によって既定のリモートホストが確立されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1262">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="9cad8-1263">を呼び出した後、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを使用してリモートデバイスにデータを送信したり、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドを使用してリモートデバイスからデータを受信したりすることができ <xref:System.Net.Sockets.Socket.Connect%2A> ます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1263">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-1264">UDP などのコネクションレスプロトコルを使用している場合は、データを送受信する前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1264">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="9cad8-1265"><xref:System.Net.Sockets.Socket.SendTo%2A> と <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用して、リモートホストと同期的に通信できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1265">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="9cad8-1266">を呼び出すと <xref:System.Net.Sockets.Socket.Connect%2A> 指定した既定値以外のアドレスから到達したデータグラムは破棄されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1266">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="9cad8-1267">既定のリモートホストをブロードキャストアドレスに設定する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。指定しないと、<xref:System.Net.Sockets.Socket.Connect%2A> は <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1267">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-1268"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1268">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1269">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1269">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="9cad8-1270"><xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティを `false` に明示的に設定しない限り、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドはブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1270"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-1271">TCP のような接続指向プロトコルを使用していて、ブロックを無効にすると、<xref:System.Net.Sockets.Socket.Connect%2A> は接続に時間がかかるため、<xref:System.Net.Sockets.SocketException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1271">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="9cad8-1272">コネクションレスプロトコルは、既定のリモートホストを確立するだけなので、例外をスローしません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1272">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="9cad8-1273"><xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> を使用すると、特定のエラーコードを取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1273">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1274">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1274">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="9cad8-1275">エラーによって WSAEWOULDBLOCK が返された場合、リモートホスト接続は接続指向 <xref:System.Net.Sockets.Socket>によって開始されていますが、まだ正常に完了していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1275">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="9cad8-1276"><xref:System.Net.Sockets.Socket.Poll%2A> メソッドを使用して、<xref:System.Net.Sockets.Socket> の接続がいつ終了するかを判断します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1276">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1277">接続指向プロトコルを使用していて、<xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出さなかった場合は、基になるサービスプロバイダーによってローカルネットワークアドレスとポート番号が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1277">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="9cad8-1278">コネクションレスプロトコルを使用している場合、送信または受信操作が完了するまで、サービスプロバイダーはローカルネットワークアドレスとポート番号を割り当てません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1278">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="9cad8-1279">既定のリモートホストを変更する場合は、目的のエンドポイントで <xref:System.Net.Sockets.Socket.Connect%2A> をもう一度呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1279">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1280">ソケットが既に切断されている場合は、この方法を使用して接続を復元することはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1280">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="9cad8-1281">非同期の <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドのいずれかを使用して再接続します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1281">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="9cad8-1282">これは、基になるプロバイダーの制限です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1282">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1283">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1283">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1284">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1284">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1285">次のコード例では、リモートエンドポイントに接続し、接続を確認します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1285">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1286"><paramref name="address" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1286"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-1287">ポート番号が無効です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1287">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1288">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1288">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1289"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1289">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-1290">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1290">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1291"><paramref name="address" /> の長さが 0 です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1291">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1292"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1292">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="9cad8-1293">リモート ホストの IP アドレス。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1293">The IP addresses of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="9cad8-1294">リモート ホストのポート番号。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1294">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="9cad8-1295">リモート ホストへの接続を確立します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1295">Establishes a connection to a remote host.</span></span> <span data-ttu-id="9cad8-1296">ホストは、IP アドレスの配列とポート番号で指定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1296">The host is specified by an array of IP addresses and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1297">このメソッドは、通常、1つのホストに対して複数の IP アドレスを返すことができる <xref:System.Net.Dns.GetHostAddresses%2A>の呼び出しの直後に使用されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1297">This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host.</span></span> <span data-ttu-id="9cad8-1298">TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドは、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> と指定されたリモートエンドポイント間のネットワーク接続を同期的に確立します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1298">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="9cad8-1299">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> によって既定のリモートホストが確立されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1299">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="9cad8-1300">を呼び出した後、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを使用してリモートデバイスにデータを送信したり、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドを使用してリモートデバイスからデータを受信したりすることができ <xref:System.Net.Sockets.Socket.Connect%2A> ます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1300">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-1301">UDP などのコネクションレスプロトコルを使用している場合は、データを送受信する前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1301">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="9cad8-1302"><xref:System.Net.Sockets.Socket.SendTo%2A> と <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用して、リモートホストと同期的に通信できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1302">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="9cad8-1303">を呼び出すと <xref:System.Net.Sockets.Socket.Connect%2A> 指定した既定値以外のアドレスから到達したデータグラムは破棄されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1303">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="9cad8-1304">既定のリモートホストをブロードキャストアドレスに設定する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。指定しないと、<xref:System.Net.Sockets.Socket.Connect%2A> は <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1304">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-1305"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1305">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1306">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1306">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="9cad8-1307"><xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティを `false` に明示的に設定しない限り、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドはブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1307"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-1308">TCP のような接続指向プロトコルを使用していて、ブロックを無効にすると、<xref:System.Net.Sockets.Socket.Connect%2A> は接続に時間がかかるため、<xref:System.Net.Sockets.SocketException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1308">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="9cad8-1309">コネクションレスプロトコルは、既定のリモートホストを確立するだけなので、例外をスローしません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1309">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="9cad8-1310"><xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> を使用すると、特定のエラーコードを取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1310">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1311">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1311">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="9cad8-1312">エラーによって WSAEWOULDBLOCK が返された場合、リモートホスト接続は接続指向 <xref:System.Net.Sockets.Socket>によって開始されていますが、まだ正常に完了していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1312">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="9cad8-1313"><xref:System.Net.Sockets.Socket.Poll%2A> メソッドを使用して、<xref:System.Net.Sockets.Socket> の接続がいつ終了するかを判断します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1313">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1314">接続指向プロトコルを使用していて、<xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出さなかった場合は、基になるサービスプロバイダーによってローカルネットワークアドレスとポート番号が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1314">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="9cad8-1315">コネクションレスプロトコルを使用している場合、送信または受信操作が完了するまで、サービスプロバイダーはローカルネットワークアドレスとポート番号を割り当てません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1315">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="9cad8-1316">既定のリモートホストを変更する場合は、目的のエンドポイントで <xref:System.Net.Sockets.Socket.Connect%2A> をもう一度呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1316">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1317">ソケットが既に切断されている場合は、この方法を使用して接続を復元することはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1317">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="9cad8-1318">非同期の <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドのいずれかを使用して再接続します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1318">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="9cad8-1319">これは、基になるプロバイダーの制限です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1319">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1320">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1320">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1321">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1321">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1322">次のコード例では、リモートエンドポイントに接続し、接続を確認します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1322">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1323"><paramref name="addresses" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1323"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-1324">ポート番号が無効です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1324">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1325">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1325">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1326"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1326">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-1327">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1327">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1328"><paramref name="address" /> の長さが 0 です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1328">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1329"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1329">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="9cad8-1330">リモート ホストの名前。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1330">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="9cad8-1331">リモート ホストのポート番号。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1331">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="9cad8-1332">リモート ホストへの接続を確立します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1332">Establishes a connection to a remote host.</span></span> <span data-ttu-id="9cad8-1333">ホストはホスト名とポート番号で指定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1333">The host is specified by a host name and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1334">TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> 方法では、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> と指定したリモートホストの間のネットワーク接続を同期的に確立します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1334">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host.</span></span> <span data-ttu-id="9cad8-1335">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A> によって既定のリモートホストが確立されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1335">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="9cad8-1336">を呼び出した後、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを使用してリモートデバイスにデータを送信したり、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドを使用してリモートデバイスからデータを受信したりすることができ <xref:System.Net.Sockets.Socket.Connect%2A> ます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1336">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-1337">UDP などのコネクションレスプロトコルを使用している場合は、データを送受信する前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1337">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="9cad8-1338"><xref:System.Net.Sockets.Socket.SendTo%2A> と <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用して、リモートホストと同期的に通信できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1338">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="9cad8-1339">を呼び出すと <xref:System.Net.Sockets.Socket.Connect%2A> 指定した既定値以外のアドレスから到達したデータグラムは破棄されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1339">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="9cad8-1340">既定のリモートホストをブロードキャストアドレスに設定する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。指定しないと、<xref:System.Net.Sockets.Socket.Connect%2A> は <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1340">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-1341"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1341">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1342">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1342">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="9cad8-1343"><xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Blocking%2A> プロパティを `false` に明示的に設定しない限り、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドはブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1343"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-1344">TCP のような接続指向プロトコルを使用していて、ブロックを無効にすると、<xref:System.Net.Sockets.Socket.Connect%2A> は接続に時間がかかるため、<xref:System.Net.Sockets.SocketException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1344">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="9cad8-1345">コネクションレスプロトコルは、既定のリモートホストを確立するだけなので、例外をスローしません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1345">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="9cad8-1346"><xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> を使用すると、特定のエラーコードを取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1346">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1347">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1347">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="9cad8-1348">エラーによって WSAEWOULDBLOCK が返された場合、リモートホスト接続は接続指向 <xref:System.Net.Sockets.Socket>によって開始されていますが、まだ正常に完了していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1348">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="9cad8-1349"><xref:System.Net.Sockets.Socket.Poll%2A> メソッドを使用して、<xref:System.Net.Sockets.Socket> の接続がいつ終了するかを判断します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1349">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
 <span data-ttu-id="9cad8-1350">Ipv6 が有効になっていて、<xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> メソッドを呼び出して、IPv6 と IPv4 の両方のアドレスに解決されるホストに接続する場合、IPv4 アドレスの前に IPv6 アドレスへの接続が最初に試行されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1350">If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</span></span> <span data-ttu-id="9cad8-1351">ホストが IPv6 アドレスでリッスンしていない場合、接続の確立に時間がかかることがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1351">This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1352">接続指向プロトコルを使用していて、<xref:System.Net.Sockets.Socket.Connect%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出さなかった場合は、基になるサービスプロバイダーによってローカルネットワークアドレスとポート番号が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1352">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="9cad8-1353">コネクションレスプロトコルを使用している場合、送信または受信操作が完了するまで、サービスプロバイダーはローカルネットワークアドレスとポート番号を割り当てません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1353">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="9cad8-1354">既定のリモートホストを変更する場合は、目的のエンドポイントで <xref:System.Net.Sockets.Socket.Connect%2A> をもう一度呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1354">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1355">ソケットが既に切断されている場合は、この方法を使用して接続を復元することはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1355">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="9cad8-1356">非同期の <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドのいずれかを使用して再接続します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1356">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="9cad8-1357">これは、基になるプロバイダーの制限です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1357">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1358">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1358">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1359">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1359">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1360">次のコード例では、リモートエンドポイントに接続し、接続を確認します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1360">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1361"><paramref name="host" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1361"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-1362">ポート番号が無効です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1362">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1363">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1363">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1364"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1364">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-1365">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1365">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1366"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1366">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-1367">リモート ホストに接続する非同期要求を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1367">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="9cad8-1368">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1368">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-1369">リモート ホストに接続する非同期要求を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1369">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1370">I/O 操作が保留中の場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1370"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="9cad8-1371">操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1371">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="9cad8-1372">I/O 操作が同期的に完了した場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1372"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="9cad8-1373">この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1373">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1374">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドによって、リモートホストへの接続に対する非同期要求が開始されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1374">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="9cad8-1375">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> によって既定のリモートホストが確立されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1375">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.</span></span>  
  
 <span data-ttu-id="9cad8-1376">完了を通知するには、EventHandler\<SocketAsyncEventArgs > delegate を実装するコールバックメソッドを作成し、コールバックを <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> イベントにアタッチする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1376">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="9cad8-1377">呼び出し元は、接続先のリモートホストの <xref:System.Net.IPEndPoint> に <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> プロパティを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1377">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="9cad8-1378">呼び出し元は、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1378">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="9cad8-1379">コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1379">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="9cad8-1380">UDP などのコネクションレスプロトコルを使用している場合は、データを送受信する前に <xref:System.Net.Sockets.Socket.ConnectAsync%2A> を呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1380">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="9cad8-1381"><xref:System.Net.Sockets.Socket.SendToAsync%2A> と <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> を使用して、リモートホストと通信できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1381">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="9cad8-1382"><xref:System.Net.Sockets.Socket.ConnectAsync%2A>を呼び出すと、指定された既定以外のアドレスから到着したデータグラムはすべて破棄されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1382">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="9cad8-1383">既定のリモートホストを変更する場合は、目的のエンドポイントで <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドをもう一度呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1383">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="9cad8-1384">既定のリモートホストをブロードキャストアドレスに設定する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> を呼び出し、`true`にブロードキャストを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1384">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="9cad8-1385">これが行われていない場合は、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1385">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="9cad8-1386"><xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1386">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="9cad8-1387">必要に応じて、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドが成功した後に、ソケットでアトミックに送信されるバッファーを指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1387">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="9cad8-1388">この場合、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> プロパティは、送信するデータを格納するバッファーに設定する必要があります。また、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> プロパティは、バッファーから送信するデータのバイト数に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1388">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="9cad8-1389">接続が確立されると、このバッファーのデータが送信されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1389">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="9cad8-1390">接続指向プロトコルを使用していて、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出さない場合は、基になるサービスプロバイダーによって、最も適切なローカルネットワークアドレスとポート番号が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1390">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="9cad8-1391">コネクションレスプロトコルを使用している場合、サービスプロバイダーは、<xref:System.Net.Sockets.Socket.SendAsync%2A> または <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッドを呼び出すまで、ローカルネットワークの IP アドレスとポート番号を割り当てません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1391">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="9cad8-1392"><xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドは、<xref:System.Net.Sockets.Socket> のアドレスファミリと <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> が同じアドレスファミリでない場合に <xref:System.NotSupportedException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1392">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1393">このメソッドの呼び出し時に <xref:System.Net.Sockets.SocketException> を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1393">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1394">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1394">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1395">引数が有効ではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1395">An argument is not valid.</span></span> <span data-ttu-id="9cad8-1396">この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1396">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1397"><paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1397">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1398"><see cref="T:System.Net.Sockets.Socket" /> がリッスンしているか、<paramref name="e" /> パラメーターで指定されている <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1398">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1399">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1399">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-1400">このメソッドには Windows XP 以降が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1400">Windows XP or later is required for this method.</span></span> <span data-ttu-id="9cad8-1401">この例外は、ローカル エンドポイントと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> が同じアドレス ファミリではない場合にも発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1401">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1402"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1402">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-1403">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1403">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="9cad8-1404"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1404">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="9cad8-1405"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1405">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <param name="e"><span data-ttu-id="9cad8-1406">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1406">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-1407">リモート ホストに接続する非同期要求を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1407">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1408">I/O 操作が保留中の場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1408"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="9cad8-1409">操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1409">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="9cad8-1410">I/O 操作が同期的に完了した場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1410"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="9cad8-1411">この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1411">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1412">接続指向プロトコルを使用している場合は、M:System.Net.Sockets.Socket.ConnectAsync (SocketAsyncEventArgs) メソッドによって、の非同期要求が開始されます。このメソッドは、の非同期要求を開始します。リモートホストへの接続。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1412">If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="9cad8-1413">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> は、`socketType` パラメーターと `protocolType` パラメーターで指定された既定のリモートホストを確立します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1413">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters.</span></span>  
  
 <span data-ttu-id="9cad8-1414">完了を通知するには、EventHandler\<SocketAsyncEventArgs > delegate を実装するコールバックメソッドを作成し、コールバックを <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> イベントにアタッチする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1414">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="9cad8-1415">呼び出し元は、接続先のリモートホストの <xref:System.Net.IPEndPoint> に <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> プロパティを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1415">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="9cad8-1416">呼び出し元は、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1416">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="9cad8-1417">コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1417">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="9cad8-1418">UDP などのコネクションレスプロトコルを使用している場合は、データを送受信する前に <xref:System.Net.Sockets.Socket.ConnectAsync%2A> を呼び出す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1418">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="9cad8-1419"><xref:System.Net.Sockets.Socket.SendToAsync%2A> と <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> を使用して、リモートホストと通信できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1419">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="9cad8-1420"><xref:System.Net.Sockets.Socket.ConnectAsync%2A>を呼び出すと、指定された既定以外のアドレスから到着したデータグラムはすべて破棄されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1420">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="9cad8-1421">既定のリモートホストを変更する場合は、目的のエンドポイントで <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドをもう一度呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1421">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="9cad8-1422">既定のリモートホストをブロードキャストアドレスに設定する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> を呼び出し、`true`にブロードキャストを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1422">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="9cad8-1423">これが行われていない場合は、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1423">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="9cad8-1424"><xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1424">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="9cad8-1425">必要に応じて、<xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドが成功した後に、ソケットでアトミックに送信されるバッファーを指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1425">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="9cad8-1426">この場合、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> プロパティは、送信するデータを格納するバッファーに設定する必要があります。また、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> プロパティは、バッファーから送信するデータのバイト数に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1426">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="9cad8-1427">接続が確立されると、このバッファーのデータが送信されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1427">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="9cad8-1428">接続指向プロトコルを使用していて、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> を呼び出さない場合は、基になるサービスプロバイダーによって、最も適切なローカルネットワークアドレスとポート番号が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1428">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="9cad8-1429">コネクションレスプロトコルを使用している場合、サービスプロバイダーは、<xref:System.Net.Sockets.Socket.SendAsync%2A> または <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッドを呼び出すまで、ローカルネットワークの IP アドレスとポート番号を割り当てません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1429">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="9cad8-1430"><xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドは、<xref:System.Net.Sockets.Socket> のアドレスファミリと <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> が同じアドレスファミリでない場合に <xref:System.NotSupportedException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1430">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1431">このメソッドの呼び出し時に <xref:System.Net.Sockets.SocketException> を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1431">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1432">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1432">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1433">引数が有効ではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1433">An argument is not valid.</span></span> <span data-ttu-id="9cad8-1434">この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1434">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1435"><paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1435">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1436"><see cref="T:System.Net.Sockets.Socket" /> がリッスンしているか、<paramref name="e" /> パラメーターで指定されている <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1436">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1437">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1437">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-1438">このメソッドには Windows XP 以降が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1438">Windows XP or later is required for this method.</span></span> <span data-ttu-id="9cad8-1439">この例外は、ローカル エンドポイントと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> が同じアドレス ファミリではない場合にも発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1439">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1440"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1440">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-1441">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1441">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-1442">最後に実行された <see cref="Overload:System.Net.Sockets.Socket.Send" /> 操作または <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 操作の時点で、<see cref="T:System.Net.Sockets.Socket" /> がリモート ホストに接続されていたかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1442">Gets a value that indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is connected to a remote host as of the last <see cref="Overload:System.Net.Sockets.Socket.Send" /> or <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operation.</span></span></summary>
        <value><span data-ttu-id="9cad8-1443">最後に実行された操作の時点で、<see cref="T:System.Net.Sockets.Socket" /> がリモート リソースに接続されていた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1443"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> was connected to a remote resource as of the most recent operation; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1444">`Connected` プロパティは、最後の i/o 操作の <xref:System.Net.Sockets.Socket> の接続状態を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1444">The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation.</span></span> <span data-ttu-id="9cad8-1445">`false`を返した場合、<xref:System.Net.Sockets.Socket> は接続されていないか、接続されていません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1445">When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected.</span></span>  
  
 <span data-ttu-id="9cad8-1446"><xref:System.Net.Sockets.Socket.Connected%2A> プロパティの値には、最新の操作での接続の状態が反映されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1446">The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation.</span></span> <span data-ttu-id="9cad8-1447">接続の現在の状態を確認する必要がある場合は、非ブロッキングのゼロバイトの送信呼び出しを行います。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1447">If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</span></span> <span data-ttu-id="9cad8-1448">呼び出しが正常に返された場合、または WAEWOULDBLOCK エラーコード (10035) をスローした場合、ソケットはまだ接続されています。それ以外の場合、ソケットは接続されなくなります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1448">If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</span></span>  
  
 <span data-ttu-id="9cad8-1449">ユーザーデータグラムプロトコル (UDP) ソケットで <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出した場合、<xref:System.Net.Sockets.Socket.Connected%2A> プロパティは常に `true`を返します。ただし、この操作では、UDP の固有のコネクションレス特性は変更されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1449">If you call <xref:System.Net.Sockets.Socket.Connect%2A> on a User Datagram Protocol (UDP) socket, the <xref:System.Net.Sockets.Socket.Connected%2A> property always returns `true`; however, this action does not change the inherent connectionless nature of UDP.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1450">次のコード例では、リモートエンドポイントに接続し、<xref:System.Net.Sockets.Socket.Connected%2A> プロパティを確認して、接続の現在の状態を確認します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1450">The following code example connects to a remote endpoint, checks the <xref:System.Net.Sockets.Socket.Connected%2A> property, and checks the current state of the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><span data-ttu-id="9cad8-1451">現在の接続の終了後、このソケットが再利用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1451"><see langword="true" /> if this socket can be reused after the current connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="9cad8-1452">ソケット接続を閉じ、ソケットを再利用できるようにします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1452">Closes the socket connection and allows reuse of the socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1453">接続指向プロトコルを使用している場合は、このメソッドを使用してソケットを閉じることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1453">If you are using a connection-oriented protocol, you can use this method to close the socket.</span></span> <span data-ttu-id="9cad8-1454">このメソッドは接続を終了し、<xref:System.Net.Sockets.Socket.Connected%2A> プロパティを `false`に設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1454">This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`.</span></span> <span data-ttu-id="9cad8-1455">ただし、`reuseSocket` が `true`場合は、ソケットを再利用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1455">However, if `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="9cad8-1456">ソケットが閉じられる前にすべてのデータが送受信されるようにするには、<xref:System.Net.Sockets.Socket.Disconnect%2A> メソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Shutdown%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1456">To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-1457">最初に <xref:System.Net.Sockets.Socket.Shutdown%2A>を呼び出さずに <xref:System.Net.Sockets.Socket.Disconnect%2A> を呼び出す必要がある場合は、<xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> オプションを `false` に設定し、ゼロ以外のタイムアウト間隔を指定して、送信用のキューに格納されたデータが送信されるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1457">If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</span></span> <span data-ttu-id="9cad8-1458"><xref:System.Net.Sockets.Socket.Disconnect%2A> は、データが送信されるか、指定されたタイムアウトが経過するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1458"><xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="9cad8-1459"><xref:System.Net.Sockets.SocketOptionName.DontLinger> を `false` に設定し、タイムアウト間隔をゼロに指定した場合、<xref:System.Net.Sockets.Socket.Close%2A> は接続を解放し、発信キューに格納されたデータを自動的に破棄します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1459">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1460"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1460">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1461">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1461">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1462">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1462">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1463">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1463">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1464">次のコード例では、同期通信用のソケットを作成し、いくつかのデータをリモートホストに送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1464">The following code example creates a socket for synchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="9cad8-1465">次に、<xref:System.Net.Sockets.Socket.Shutdown%2A>を呼び出して、送信と受信のアクティビティを停止し、<xref:System.Net.Sockets.Socket.Disconnect%2A>してソケット接続を閉じます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1465">It then calls <xref:System.Net.Sockets.Socket.Shutdown%2A>, to stop the send and receive activity, and <xref:System.Net.Sockets.Socket.Disconnect%2A>, to close the socket connection.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="9cad8-1466">このメソッドは、Windows 2000 以前でのみサポートされます。それ以外の場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1466">This method requires Windows 2000 or earlier, or the exception will be thrown.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1467"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1467">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1468">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1468">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="9cad8-1469">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1469">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-1470">リモート エンドポイントからの切断の非同期要求を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1470">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1471">I/O 操作が保留中の場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1471"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="9cad8-1472">操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1472">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="9cad8-1473">I/O 操作が同期的に完了した場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1473"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="9cad8-1474">この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1474">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1475">接続指向プロトコルを使用する場合、<xref:System.Net.Sockets.Socket.DisconnectAsync%2A> メソッドを呼び出すと、リモートエンドポイントからの切断が要求されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1475">When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint.</span></span> <span data-ttu-id="9cad8-1476"><xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> を `e` パラメーターで `true` に設定すると、ソケットを再利用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1476">If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> to `true` in the `e` parameter, the socket can be reused.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1477"><paramref name="e" /> パラメーターを null 値にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1477">The <paramref name="e" /> parameter cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1478"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1478">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-1479">このメソッドには Windows XP 以降が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1479">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1480"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1480">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1481">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1481">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-1482"><see cref="T:System.Net.Sockets.Socket" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1482">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cad8-1483"><see cref="T:System.Net.Sockets.Socket" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1483">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1484"><xref:System.Net.Sockets.Socket> を使い終わったら、`Dispose`を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1484">Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-1485">`Dispose`メソッドによって、<xref:System.Net.Sockets.Socket> は使用不可の状態になります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1485">The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="9cad8-1486">`Dispose`呼び出し後は、<xref:System.Net.Sockets.Socket>によって占有されていたメモリをガベージ コレクターがクリアできるよう、<xref:System.Net.Sockets.Socket> へのすべての参照を解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1486">After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span>  
  
 <span data-ttu-id="9cad8-1487">詳細については、[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)および[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1487">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1488"><xref:System.Net.Sockets.Socket>への最後の参照を解放する前に、必ず`Dispose`を呼び出してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1488">Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-1489">そうしないと、ガベージ コレクターが <xref:System.Net.Sockets.Socket> オブジェクトの `Finalize` メソッドを呼び出すまで、使用されているリソースは解放されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1489">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="9cad8-1490">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1490"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="9cad8-1491"><see cref="T:System.Net.Sockets.Socket" /> が使用しているアンマネージド リソースを解放します。オプションでマネージド リソースも破棄します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1491">Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.Socket" />, and optionally disposes of the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1492">このメソッドは、パブリック `Dispose()` メソッドと <xref:System.Object.Finalize%2A> メソッドによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1492">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="9cad8-1493">`Dispose()` は、`disposing` パラメーターを `true` に設定して、protected `Dispose(Boolean)` メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1493">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="9cad8-1494"><xref:System.Object.Finalize%2A> は、`disposing` が `false` に設定された `Dispose` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1494"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="9cad8-1495">`disposing` パラメーターが `true` の場合、このメソッドは、この <xref:System.Net.Sockets.Socket> が参照しているすべてのマネージド オブジェクトによって保持されているリソースをすべて解放します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1495">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references.</span></span> <span data-ttu-id="9cad8-1496">このメソッドは、参照される各オブジェクトの `Dispose()` メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1496">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1497">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1497">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1498">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1498">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="9cad8-1499">
            <see langword="Dispose" /> は、他のオブジェクトから複数回呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1499">
            <see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="9cad8-1500"><see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> をオーバーライドする場合は、以前に <see langword="Dispose" /> を呼び出したときに破棄されたオブジェクトを参照しないように注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1500">When overriding <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="9cad8-1501"><see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />を実装する方法の詳細については、「 [Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1501">For more information about how to implement <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="9cad8-1502"><see langword="Dispose" /> と <see cref="M:System.Object.Finalize" />の詳細については、「[アンマネージリソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)」と「 [Finalize メソッドのオーバーライド](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1502">For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-1503"><see cref="T:System.Net.Sockets.Socket" /> でインターネット プロトコル (IP) データグラムの断片化を許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を、取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1503">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows Internet Protocol (IP) datagrams to be fragmented.</span></span></summary>
        <value><span data-ttu-id="9cad8-1504"><see cref="T:System.Net.Sockets.Socket" /> でデータグラムの断片化を許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1504"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows datagram fragmentation; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9cad8-1505">既定値は、<see langword="true" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1505">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1506">データグラムのサイズが、転送メディアの最大転送単位 (MTU) を超えると、断片化が必要になります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1506">Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</span></span> <span data-ttu-id="9cad8-1507">送信ホスト (すべてのインターネットプロトコルバージョン) または中間ルーター (インターネットプロトコルバージョン4のみ) によって、データグラムが断片化される場合があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1507">Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</span></span> <span data-ttu-id="9cad8-1508">データグラムをフラグメント化する必要があり、<xref:System.Net.Sockets.Socket.DontFragment%2A> オプションが設定されている場合、データグラムは破棄され、インターネット制御メッセージプロトコル (ICMP) のエラーメッセージがデータグラムの送信者に送り返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1508">If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</span></span>  
  
 <span data-ttu-id="9cad8-1509">伝送制御プロトコル (TCP) ソケットでこのプロパティを設定しても効果はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1509">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1510">次のコード例は、<xref:System.Net.Sockets.Socket.DontFragment%2A> プロパティの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1510">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.DontFragment%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-1511">このプロパティは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ファミリまたは <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットに対してだけ設定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1511">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1512">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1512">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1513"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1513">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-1514"><see cref="T:System.Boolean" /> が IPv4 と IPv6 の両方に使用されるデュアル モード ソケットであるかどうか指定する <see cref="T:System.Net.Sockets.Socket" /> 値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1514">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> is a dual-mode socket used for both IPv4 and IPv6.</span></span></summary>
        <value><span data-ttu-id="9cad8-1515"><see cref="T:System.Net.Sockets.Socket" /> がデュアルモードのソケットの場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1515"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is a  dual-mode socket; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9cad8-1516">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1516">The default is <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetProcessId"><span data-ttu-id="9cad8-1517">ソケット参照の複製が作成されるターゲット プロセスの ID。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1517">The ID of the target process where a duplicate of the socket reference is created.</span></span></param>
        <summary><span data-ttu-id="9cad8-1518">ターゲット プロセスのソケット参照を複製してこのプロセスのソケットを閉じます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1518">Duplicates the socket reference for the target process, and closes the socket for this process.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1519">ターゲット プロセスに渡されるソケット参照。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1519">The socket reference to be passed to the target process.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1520">ターゲットプロセスでは、<xref:System.Net.Sockets.Socket.%23ctor%2A> を使用して、重複するソケットインスタンスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1520">The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance.</span></span>  
  
 <span data-ttu-id="9cad8-1521">各呼び出しの引数と同じバイト配列を使用して <xref:System.Net.Sockets.Socket.%23ctor%2A> コンストラクターを複数回呼び出す場合は、基になる同じソケットを持つ複数のマネージ <xref:System.Net.Sockets.Socket> インスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1521">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket.</span></span> <span data-ttu-id="9cad8-1522">この方法は推奨されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1522">This practice is strongly discouraged.</span></span>  
  
 <span data-ttu-id="9cad8-1523">ソケットを作成するプロセスで非同期メソッド (<xref:System.Net.Sockets.Socket.BeginReceive%2A> または <xref:System.Net.Sockets.Socket.BeginSend%2A>) が使用されている場合、プロセスはまず <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> プロパティを true に設定する必要があります。それ以外の場合、ソケットは作成プロセスの完了ポートにバインドされるため、ターゲットプロセスで <xref:System.ArgumentNullException> がスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1523">If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1524"><paramref name="targetProcessID" /> が有効なプロセス ID ではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1524"><paramref name="targetProcessID" /> is not a valid process id.</span></span> 
<span data-ttu-id="9cad8-1525">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-1525">-or-</span></span> 
<span data-ttu-id="9cad8-1526">ソケット参照の複製に失敗しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1526">Duplication of the socket reference failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-1527"><see cref="T:System.Net.Sockets.Socket" /> でブロードキャスト パケットの送受信を許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1527">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> can send or receive broadcast packets.</span></span></summary>
        <value><span data-ttu-id="9cad8-1528"><see cref="T:System.Net.Sockets.Socket" /> でブロードキャスト パケットを許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1528"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows broadcast packets; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9cad8-1529">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1529">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1530">ブロードキャストは特定のサブネットに限定され、ユーザーデータグラムプロトコル (UDP) を使用する必要があります。インターネットプロトコルバージョン4では、パケットを255.255.255.255 に送信してローカルサブネットにブロードキャストできます。または、宛先ブロードキャストアドレスを使用することもできます。これは、ホスト部分ですべてのビットが設定されたインターネットプロトコル (IP) アドレスのネットワーク部分です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1530">Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</span></span> <span data-ttu-id="9cad8-1531">たとえば、IP アドレスが 192.168.1.40 (クラス C のアドレスで、ネットマスクが255.255.255.0 の場合) の場合、ネットワークの部分が最初の3つのオクテットで、ホストの部分が最後のオクテットである場合、転送先のブロードキャストアドレスは192.168.1.255 になります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1531">For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</span></span>  
  
 <span data-ttu-id="9cad8-1532">伝送制御プロトコル (TCP) ソケットでこのプロパティを設定しても効果はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1532">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1533">次のコード例は、<xref:System.Net.Sockets.Socket.EnableBroadcast%2A> プロパティの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1533">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1534">このオプションは、データグラム ソケットに対してだけ有効です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1534">This option is valid for a datagram socket only.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1535"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1535">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-1536">受信接続の試行を非同期的に受け入れます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1536">Asynchronously accepts an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-1537">転送されたバイト数を格納する <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1537">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="9cad8-1538">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1538">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="9cad8-1539">受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> オブジェクトを作成してリモート ホスト通信を処理します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1539">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="9cad8-1540">このメソッドは、転送される初期データを格納するバッファーを返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1540">This method returns a buffer that contains the initial data transferred.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1541">リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1541">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1542"><xref:System.Net.Sockets.Socket.EndAccept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A>の呼び出しを完了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1542"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="9cad8-1543"><xref:System.Net.Sockets.Socket.BeginAccept%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートによって呼び出されるコールバックメソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1543">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="9cad8-1544">このコールバックメソッドは、別個のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドから制御が戻った後、システムによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1544">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span>  
  
 <span data-ttu-id="9cad8-1545">コールバックメソッド内で `asyncResult` パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、接続試行が行われている <xref:System.Net.Sockets.Socket> を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1545">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="9cad8-1546"><xref:System.Net.Sockets.Socket>を取得した後は、<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを呼び出して、接続の試行を正常に完了させることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1546">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="9cad8-1547">このオーバーロードの `buffer` パラメーターには、<xref:System.Net.Sockets.Socket.BeginAccept%2A> への呼び出しで受信したデータが含まれています。 `bytesTransferred` パラメーターには、呼び出しで転送されたバイト数が含まれています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1547">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="9cad8-1548"><xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、接続が受信接続キューで保留状態になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1548">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="9cad8-1549"><xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、受信接続を受け入れ、リモートホストとの間でデータを送受信するために使用できる新しい <xref:System.Net.Sockets.Socket> を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1549">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1550"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1550">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1551">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1551">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1552">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1552">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1553">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1553">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1554">次のコード例では、<xref:System.Net.Sockets.Socket.BeginAccept%2A> を使用してソケットを作成および接続し、最初の10バイトのデータを受け入れます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1554">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="9cad8-1555">コールバックデリゲートは、非同期要求を終了するために <xref:System.Net.Sockets.Socket.EndAccept%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1555">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="9cad8-1556">転送されたバイト数とデータは、このメソッドの `buffer` パラメーターと `bytesTransferred` パラメーターに返され、コンソールに表示されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1556">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-1557">このメソッドには Windows NT が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1557">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1558"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1558">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1559"><paramref name="asyncResult" /> が空です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1559"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1560"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1560"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1561"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1561"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1562"><see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1562">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="9cad8-1563">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1563">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <param name="result"><span data-ttu-id="9cad8-1564">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1564">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="9cad8-1565">受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> を作成してリモート ホスト通信を処理します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1565">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1566">リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1566">A <see cref="T:System.Net.Sockets.Socket" /> to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1567"><xref:System.Net.Sockets.Socket.EndAccept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A>の呼び出しを完了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1567"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="9cad8-1568"><xref:System.Net.Sockets.Socket.BeginAccept%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1568">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="9cad8-1569">このコールバックメソッドは、別個のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドから制御が戻った後、システムによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1569">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="9cad8-1570"><xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドから返された `asyncResult` パラメーターを受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1570">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-1571">コールバックメソッド内で `asyncResult` パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、接続試行が行われている <xref:System.Net.Sockets.Socket> を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1571">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="9cad8-1572"><xref:System.Net.Sockets.Socket>を取得した後は、<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを呼び出して、接続の試行を正常に完了させることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1572">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span>  
  
 <span data-ttu-id="9cad8-1573"><xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、接続が受信接続キューで保留状態になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1573">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="9cad8-1574"><xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、受信接続を受け入れ、リモートホストとの間でデータを送受信するために使用できる新しい <xref:System.Net.Sockets.Socket> を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1574">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1575"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1575">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1576">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1576">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1577">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1577">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1578">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1578">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1579">次のコード例では、非同期要求を終了し、受信接続要求を受け入れる新しい <xref:System.Net.Sockets.Socket> を作成します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1579">The following code example ends an asynchronous request and creates a new <xref:System.Net.Sockets.Socket> to accept an incoming connection request.</span></span> <span data-ttu-id="9cad8-1580">ソケットを使用した非同期通信を示す完全な例については、[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1580">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1581"><paramref name="asyncResult" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1581"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1582"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1582"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1583">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1583">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="9cad8-1584">詳細については、次の「解説」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1584">See the Remarks section for more information.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1585"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1585">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1586"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1586"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-1587">このメソッドには Windows NT が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1587">Windows NT is required for this method.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * int * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-1588">転送されたバイト数を格納する <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1588">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="bytesTransferred"><span data-ttu-id="9cad8-1589">転送されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1589">The number of bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="9cad8-1590">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1590">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="9cad8-1591">受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> オブジェクトを作成してリモート ホスト通信を処理します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1591">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="9cad8-1592">このメソッドは、初期データと、転送されたバイト数を格納するバッファーを返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1592">This method returns a buffer that contains the initial data and the number of bytes transferred.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1593">リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1593">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1594"><xref:System.Net.Sockets.Socket.EndAccept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A>の呼び出しを完了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1594"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="9cad8-1595"><xref:System.Net.Sockets.Socket.BeginAccept%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートによって呼び出されるコールバックメソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1595">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="9cad8-1596">このコールバックメソッドは、別個のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドから制御が戻った後、システムによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1596">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="9cad8-1597"><xref:System.Net.Sockets.Socket.BeginAccept%2A> メソッドから返された `asyncResult` パラメーターを受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1597">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-1598">コールバックメソッド内で `asyncResult` パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、接続試行が行われている <xref:System.Net.Sockets.Socket> を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1598">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="9cad8-1599"><xref:System.Net.Sockets.Socket>を取得した後は、<xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドを呼び出して、接続の試行を正常に完了させることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1599">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="9cad8-1600">このオーバーロードの `buffer` パラメーターには、<xref:System.Net.Sockets.Socket.BeginAccept%2A> への呼び出しで受信したデータが含まれています。 `bytesTransferred` パラメーターには、呼び出しで転送されたバイト数が含まれています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1600">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="9cad8-1601"><xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、接続が受信接続キューで保留状態になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1601">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="9cad8-1602"><xref:System.Net.Sockets.Socket.EndAccept%2A> メソッドは、受信接続を受け入れ、リモートホストとの間でデータを送受信するために使用できる新しい <xref:System.Net.Sockets.Socket> を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1602">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1603"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1603">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1604">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1604">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1605">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1605">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1606">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1606">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1607">次のコード例では、<xref:System.Net.Sockets.Socket.BeginAccept%2A> を使用してソケットを作成および接続し、最初の10バイトのデータを受け入れます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1607">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="9cad8-1608">コールバックデリゲートは、非同期要求を終了するために <xref:System.Net.Sockets.Socket.EndAccept%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1608">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="9cad8-1609">転送されたバイト数とデータは、このメソッドの `buffer` パラメーターと `bytesTransferred` パラメーターに返され、コンソールに表示されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1609">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-1610">このメソッドには Windows NT が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1610">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1611"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1611">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1612"><paramref name="asyncResult" /> が空です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1612"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1613"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1613"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1614"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1614"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1615"><see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1615">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="9cad8-1616">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1616">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="9cad8-1617">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1617">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-1618">保留中の非同期接続要求を終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1618">Ends a pending asynchronous connection request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1619"><xref:System.Net.Sockets.Socket.EndConnect%2A> は、<xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドで開始された非同期リモートホスト接続要求を完了するブロッキングメソッドです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1619"><xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-1620"><xref:System.Net.Sockets.Socket.BeginConnect%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1620">Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="9cad8-1621">このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginConnect%2A> が返された後にシステムによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1621">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns.</span></span> <span data-ttu-id="9cad8-1622">コールバックメソッドは、パラメーターとして <xref:System.Net.Sockets.Socket.BeginConnect%2A> メソッドによって返された <xref:System.IAsyncResult> を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1622">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="9cad8-1623">コールバックメソッド内で <xref:System.IAsyncResult> パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、接続試行が行われている <xref:System.Net.Sockets.Socket> を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1623">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="9cad8-1624"><xref:System.Net.Sockets.Socket>を取得した後は、<xref:System.Net.Sockets.Socket.EndConnect%2A> メソッドを呼び出して、接続の試行を正常に完了させることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1624">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1625"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1625">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1626">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1626">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1627">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1627">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1628">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1628">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1629">次のコード例では、非同期接続の試行を終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1629">The following code example ends the asynchronous connection attempt.</span></span> <span data-ttu-id="9cad8-1630">ソケットを使用した非同期通信を示す完全な例については、[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1630">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1631"><paramref name="asyncResult" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1631"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1632"><see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1632"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1633"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> は、非同期接続のために以前に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1633"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1634">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1634">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1635"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1635">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="9cad8-1636">この非同期操作のステータス情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1636">An <see cref="T:System.IAsyncResult" /> object that stores state information and any user-defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-1637">保留中の非同期切断要求を終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1637">Ends a pending asynchronous disconnect request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1638"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>の呼び出しを完了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1638"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span></span> <span data-ttu-id="9cad8-1639"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> メソッドは、切断が完了するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1639">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes.</span></span> <span data-ttu-id="9cad8-1640">非同期操作の詳細については、MSDN ライブラリの「非同期プログラミングの概要」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1640">For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1641"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1641">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1642">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1642">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1643">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1643">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1644">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1644">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1645">次のコード例では、非同期通信用のソケットを作成し、いくつかのデータをリモートホストに送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1645">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="9cad8-1646">データが送信されると、<xref:System.Net.Sockets.Socket.Shutdown%2A> が呼び出され、送信と受信のアクティビティが停止されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1646">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="9cad8-1647">次に、<xref:System.Net.Sockets.Socket.BeginDisconnect%2A> が呼び出され、切断要求が開始されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1647">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="9cad8-1648">コールバックデリゲートは、非同期要求を終了するために <xref:System.Net.Sockets.Socket.EndDisconnect%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1648">The callback delegate calls <xref:System.Net.Sockets.Socket.EndDisconnect%2A> to end the asynchronous request.</span></span> <span data-ttu-id="9cad8-1649">要求が完了すると、ソケットが切断されているかどうかをテストするために <xref:System.Net.Sockets.Socket.Connected%2A> プロパティが照会されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1649">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-1650">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1650">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1651"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1651">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1652"><paramref name="asyncResult" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1652"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1653"><see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1653"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1654"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> は、非同期接続のために以前に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1654"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1655">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1655">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.Net.WebException"><span data-ttu-id="9cad8-1656">切断要求がタイムアウトしました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1656">The disconnect request has timed out.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-1657">保留中の非同期読み取りを終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1657">Ends a pending asynchronous read.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="9cad8-1658">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1658">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="9cad8-1659">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1659">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-1660">保留中の非同期読み取りを終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1660">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1661">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1661">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1662"><xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドは、<xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドで開始された非同期の読み取り操作を完了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1662">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-1663"><xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1663">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="9cad8-1664">このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginReceive%2A> が返された後にシステムによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1664">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="9cad8-1665">コールバックメソッドは、パラメーターとして <xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドによって返された <xref:System.IAsyncResult> を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1665">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="9cad8-1666">コールバックメソッド内で、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、<xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドに渡される状態オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1666">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="9cad8-1667">この状態オブジェクトから受信側の <xref:System.Net.Sockets.Socket> を抽出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1667">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="9cad8-1668"><xref:System.Net.Sockets.Socket>を取得した後、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを呼び出して、読み取り操作を正常に完了し、読み取ったバイト数を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1668">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="9cad8-1669"><xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドは、データが使用可能になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1669">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="9cad8-1670">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceive%2A> は、受信ネットワークバッファーで使用可能な最初のエンキューされたデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1670">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="9cad8-1671">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドによって、<xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドの `size` パラメーターで指定したバイト数まで、使用可能な量のデータが読み取られます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1671">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="9cad8-1672">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1672">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="9cad8-1673">受信したデータを取得するには、<xref:System.IAsyncResult>の <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出し、結果の状態オブジェクトに格納されているバッファーを抽出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1673">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
 <span data-ttu-id="9cad8-1674">保留中の <xref:System.Net.Sockets.Socket.BeginReceive%2A>を取り消すには、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1674">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1675"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1675">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1676">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1676">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1677">特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1677">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="9cad8-1678">保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1678">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1679">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1679">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1680">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1680">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1681">次のコード例では、保留中の非同期読み取りを終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1681">The following code example ends a pending asynchronous read.</span></span> <span data-ttu-id="9cad8-1682">ソケットを使用した非同期通信を示す完全な例については、[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1682">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1683"><paramref name="asyncResult" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1683"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1684"><see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1684"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1685"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> が、非同期の読み取りのために以前に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1685"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1686">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1686">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1687"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1687">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult * SocketError -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="9cad8-1688">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1688">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="9cad8-1689">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1689">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="9cad8-1690">保留中の非同期読み取りを終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1690">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1691">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1691">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1692"><xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドは、<xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドで開始された非同期の読み取り操作を完了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1692">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-1693"><xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1693">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="9cad8-1694">このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginReceive%2A> が返された後にシステムによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1694">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="9cad8-1695">コールバックメソッドは、パラメーターとして <xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドによって返された <xref:System.IAsyncResult> を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1695">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="9cad8-1696">コールバックメソッド内で、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、<xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドに渡される状態オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1696">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="9cad8-1697">この状態オブジェクトから受信側の <xref:System.Net.Sockets.Socket> を抽出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1697">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="9cad8-1698"><xref:System.Net.Sockets.Socket>を取得した後、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドを呼び出して、読み取り操作を正常に完了し、読み取ったバイト数を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1698">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="9cad8-1699"><xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドは、データが使用可能になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1699">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="9cad8-1700">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceive%2A> は、受信ネットワークバッファーで使用可能な最初のエンキューされたデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1700">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="9cad8-1701">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドによって、<xref:System.Net.Sockets.Socket.BeginReceive%2A> メソッドの `size` パラメーターで指定したバイト数まで、使用可能な量のデータが読み取られます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1701">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="9cad8-1702">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.EndReceive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1702">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="9cad8-1703">受信したデータを取得するには、<xref:System.IAsyncResult>の <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出し、結果の状態オブジェクトに格納されているバッファーを抽出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1703">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1704"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1704">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1705">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1705">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1706">特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1706">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="9cad8-1707">保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1707">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1708">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1708">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1709">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1709">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1710"><paramref name="asyncResult" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1710"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1711"><see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1711"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1712"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> が、非同期の読み取りのために以前に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1712"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1713">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1713">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1714"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1714">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (asyncResult, endPoint)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="9cad8-1715">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1715">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="9cad8-1716">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1716">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="endPoint"><span data-ttu-id="9cad8-1717">コピー元 <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1717">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <param name="end_point"><span data-ttu-id="9cad8-1718">コピー元 <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1718">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <summary><span data-ttu-id="9cad8-1719">特定のエンドポイントからの、保留中の非同期読み込みを終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1719">Ends a pending asynchronous read from a specific endpoint.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1720">正常に完了した場合は、受信したバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1720">If successful, the number of bytes received.</span></span> <span data-ttu-id="9cad8-1721">失敗した場合は、0 を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1721">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1722"><xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドは、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドで開始された非同期の読み取り操作を完了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1722">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-1723"><xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1723">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="9cad8-1724">このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> が返された後にシステムによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1724">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns.</span></span> <span data-ttu-id="9cad8-1725">コールバックメソッドは、パラメーターとして <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドによって返された <xref:System.IAsyncResult> を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1725">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="9cad8-1726">コールバックメソッド内で、<xref:System.IAsyncResult> の <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドに渡される状態オブジェクトを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1726">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-1727">この状態オブジェクトから受信側の <xref:System.Net.Sockets.Socket> を抽出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1727">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="9cad8-1728"><xref:System.Net.Sockets.Socket>を取得した後、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドを呼び出して、読み取り操作を正常に完了し、読み取ったバイト数を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1728">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="9cad8-1729"><xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドは、データが使用可能になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1729">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="9cad8-1730">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> は、受信ネットワークバッファーで使用可能な最初のエンキューされたデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1730">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="9cad8-1731">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドによって、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> メソッドの `size` パラメーターで指定したバイト数まで、使用可能な量のデータが読み取られます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1731">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-1732">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1732">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span> <span data-ttu-id="9cad8-1733">受信したデータを取得するには、<xref:System.IAsyncResult> オブジェクトの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出し、結果の状態オブジェクトに格納されているバッファーを抽出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1733">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object.</span></span> <span data-ttu-id="9cad8-1734">元のホストを特定するには、<xref:System.Net.EndPoint> を抽出し、それを <xref:System.Net.IPEndPoint>にキャストします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1734">To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>.</span></span> <span data-ttu-id="9cad8-1735"><xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> メソッドを使用して IP アドレスを取得し、<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> 方法を使用してポート番号を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1735">Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to obtain the port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1736"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1736">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1737">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1737">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1738">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1738">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1739">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1739">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1740">次のコード例では、特定の <xref:System.Net.EndPoint>からの保留中の非同期読み取りを終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1740">The following code example ends a pending asynchronous read from a specific <xref:System.Net.EndPoint>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1741"><paramref name="asyncResult" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1741"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1742"><see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1742"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1743"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> が、非同期の読み取りのために以前に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1743"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1744">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1744">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1745"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1745">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="9cad8-1746">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1746">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-1747">受信パケットの <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1747">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values for the received packet.</span></span></param>
        <param name="endPoint"><span data-ttu-id="9cad8-1748">コピー元 <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1748">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="9cad8-1749">受信パケットの <see cref="T:System.Net.IPAddress" /> とインターフェイス。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1749">The <see cref="T:System.Net.IPAddress" /> and interface of the received packet.</span></span></param>
        <summary><span data-ttu-id="9cad8-1750">特定のエンドポイントからの、保留中の非同期読み込みを終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1750">Ends a pending asynchronous read from a specific endpoint.</span></span> <span data-ttu-id="9cad8-1751">また、このメソッドは、<see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> よりもパケットに関するより多くの情報を示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1751">This method also reveals more information about the packet than <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1752">正常に完了した場合は、受信したバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1752">If successful, the number of bytes received.</span></span> <span data-ttu-id="9cad8-1753">失敗した場合は、0 を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1753">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1754">操作が完了していない場合、このメソッドは、処理が完了するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1754">If the operation has not completed, this method blocks until it does.</span></span>  
  
 <span data-ttu-id="9cad8-1755">この操作を同期的に実行するには、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1755">To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-1756">データグラムがユニキャスト、マルチキャスト、またはブロードキャストアドレスを使用して送信されたかどうかを確認する必要がある場合は、`ipPacketInformation` を調べます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1756">Examine `ipPacketInformation` if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1757"><paramref name="asyncResult" /> は <see langword="null" /> です</span><span class="sxs-lookup"><span data-stu-id="9cad8-1757"><paramref name="asyncResult" /> is <see langword="null" /></span></span>  
  
<span data-ttu-id="9cad8-1758">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-1758">-or-</span></span> 
 <span data-ttu-id="9cad8-1759"><paramref name="endPoint" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1759"><paramref name="endPoint" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1760"><see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1760"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1761"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> が、非同期の読み取りのために以前に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1761"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1762">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1762">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1763"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1763">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-1764">保留中の非同期送信を終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1764">Ends a pending asynchronous send.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="9cad8-1765">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1765">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="9cad8-1766">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1766">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-1767">保留中の非同期送信を終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1767">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1768">正常に終了した場合は <see cref="T:System.Net.Sockets.Socket" /> に送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1768">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1769"><xref:System.Net.Sockets.Socket.EndSend%2A> は <xref:System.Net.Sockets.Socket.BeginSend%2A>で開始された非同期送信操作を完了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1769"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-1770"><xref:System.Net.Sockets.Socket.BeginSend%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1770">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="9cad8-1771">このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginSend%2A> が返された後にシステムによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1771">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="9cad8-1772">コールバックメソッドは、パラメーターとして <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドによって返された <xref:System.IAsyncResult> を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1772">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="9cad8-1773">コールバックメソッド内で <xref:System.IAsyncResult> パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、送信側の <xref:System.Net.Sockets.Socket>を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1773">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-1774"><xref:System.Net.Sockets.Socket>を取得した後、<xref:System.Net.Sockets.Socket.EndSend%2A> メソッドを呼び出して送信操作を正常に完了し、送信されたバイト数を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1774">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="9cad8-1775">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndSend%2A> はデータグラムが送信されるまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1775">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="9cad8-1776">接続指向プロトコルを使用している場合は、バッファーの一部が送信されるまで、<xref:System.Net.Sockets.Socket.EndSend%2A> はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1776">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="9cad8-1777"><xref:System.Net.Sockets.Socket.EndSend%2A> からの戻り値が、バッファーが完全に送信されていないことを示している場合は、<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを再度呼び出して、未送信データを保持するバッファーを変更します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1777">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="9cad8-1778">送信したデータがネットワークに直ちに表示される保証はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1778">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-1779">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1779">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-1780"><xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1780">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1781"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1781">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1782">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1782">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1783">特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1783">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="9cad8-1784">保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1784">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1785">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1785">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-1786">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1786">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1787">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1787">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1788">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1788">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1789">次のコード例では、保留中の非同期送信を終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1789">The following code example ends a pending asynchronous send.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1790"><paramref name="asyncResult" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1790"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1791"><see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1791"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1792"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1792"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1793">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1793">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1794"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1794">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult * SocketError -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="9cad8-1795">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1795">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="9cad8-1796">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1796">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="9cad8-1797">保留中の非同期送信を終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1797">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1798">正常に終了した場合は <see cref="T:System.Net.Sockets.Socket" /> に送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1798">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1799"><xref:System.Net.Sockets.Socket.EndSend%2A> は <xref:System.Net.Sockets.Socket.BeginSend%2A>で開始された非同期送信操作を完了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1799"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-1800"><xref:System.Net.Sockets.Socket.BeginSend%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1800">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="9cad8-1801">このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginSend%2A> が返された後にシステムによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1801">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="9cad8-1802">コールバックメソッドは、パラメーターとして <xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドによって返された <xref:System.IAsyncResult> を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1802">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="9cad8-1803">コールバックメソッド内で <xref:System.IAsyncResult> パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、送信側の <xref:System.Net.Sockets.Socket>を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1803">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-1804"><xref:System.Net.Sockets.Socket>を取得した後、<xref:System.Net.Sockets.Socket.EndSend%2A> メソッドを呼び出して送信操作を正常に完了し、送信されたバイト数を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1804">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="9cad8-1805">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndSend%2A> はデータグラムが送信されるまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1805">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="9cad8-1806">接続指向プロトコルを使用している場合は、バッファーの一部が送信されるまで、<xref:System.Net.Sockets.Socket.EndSend%2A> はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1806">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="9cad8-1807"><xref:System.Net.Sockets.Socket.EndSend%2A> からの戻り値が、バッファーが完全に送信されていないことを示している場合は、<xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドを再度呼び出して、未送信データを保持するバッファーを変更します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1807">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="9cad8-1808">送信したデータがネットワークに直ちに表示される保証はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1808">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-1809">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1809">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-1810"><xref:System.Net.Sockets.Socket.BeginSend%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1810">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1811"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1811">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1812">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1812">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1813">特定のスレッドによって開始されるすべての i/o は、そのスレッドが終了すると取り消されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1813">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="9cad8-1814">保留中の非同期操作は、操作が完了する前にスレッドが終了した場合に失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1814">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1815">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1815">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-1816">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1816">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1817">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1817">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1818">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1818">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1819"><paramref name="asyncResult" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1819"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1820"><see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1820"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1821"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1821"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1822">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1822">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1823"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1823">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="9cad8-1824">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1824">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-1825">ファイルの保留中の非同期送信を終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1825">Ends a pending asynchronous send of a file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1826"><xref:System.Net.Sockets.Socket.EndSendFile%2A> は <xref:System.Net.Sockets.Socket.BeginSendFile%2A>で開始された非同期送信操作を完了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1826"><xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-1827"><xref:System.Net.Sockets.Socket.BeginSendFile%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1827">Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="9cad8-1828">このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginSendFile%2A> が返された後にシステムによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1828">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns.</span></span> <span data-ttu-id="9cad8-1829">コールバックメソッドは、<xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドによって返された <xref:System.IAsyncResult> オブジェクトをパラメーターとして受け取る必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1829">The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="9cad8-1830">コールバックメソッド内で <xref:System.IAsyncResult> パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、送信側の <xref:System.Net.Sockets.Socket>を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1830">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-1831"><xref:System.Net.Sockets.Socket>を取得した後、<xref:System.Net.Sockets.Socket.EndSendFile%2A> メソッドを呼び出して、送信操作を正常に完了させることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1831">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.</span></span>  
  
 <span data-ttu-id="9cad8-1832">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndSendFile%2A> はデータグラムが送信されるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1832">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent.</span></span> <span data-ttu-id="9cad8-1833">接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndSendFile%2A> は、ファイル全体が送信されるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1833">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="9cad8-1834">送信したデータがネットワークに直ちに表示される保証はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1834">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-1835">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1835">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-1836"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1836">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1837"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1837">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1838">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1838">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1839">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1839">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1840">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1840">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1841">次のコード例では、非同期通信用のソケットを作成して接続し、リモートホストへのファイル "test.txt" の非同期送信を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1841">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="9cad8-1842">コールバックデリゲートは、転送を完了するために <xref:System.Net.Sockets.Socket.EndSendFile%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1842">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-1843">このメソッドには Windows NT が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1843">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1844"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1844">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1845"><paramref name="asyncResult" /> が空です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1845"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1846"><see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1846"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1847"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> が、非同期の <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> のために以前に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1847"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> was previously called for the asynchronous <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1848">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1848">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="9cad8-1849">以下の解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1849">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="9cad8-1850">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1850">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="9cad8-1851">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1851">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-1852">特定の場所への、保留中の非同期送信を終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1852">Ends a pending asynchronous send to a specific location.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1853">正常に完了した場合は送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1853">If successful, the number of bytes sent; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1854"><xref:System.Net.Sockets.Socket.EndSendTo%2A> は <xref:System.Net.Sockets.Socket.BeginSendTo%2A>で開始された非同期送信操作を完了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1854"><xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-1855"><xref:System.Net.Sockets.Socket.BeginSendTo%2A>を呼び出す前に、<xref:System.AsyncCallback> デリゲートを実装するコールバックメソッドを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1855">Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="9cad8-1856">このコールバックメソッドは個別のスレッドで実行され、<xref:System.Net.Sockets.Socket.BeginReceive%2A> が返された後にシステムによって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1856">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="9cad8-1857">コールバックメソッドは、パラメーターとして <xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドによって返された <xref:System.IAsyncResult> を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1857">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="9cad8-1858">コールバックメソッド内で <xref:System.IAsyncResult> パラメーターの <xref:System.IAsyncResult.AsyncState%2A> メソッドを呼び出して、送信側の <xref:System.Net.Sockets.Socket>を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1858">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-1859"><xref:System.Net.Sockets.Socket>を取得した後、<xref:System.Net.Sockets.Socket.EndSendTo%2A> メソッドを呼び出して送信操作を正常に完了し、送信されたバイト数を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1859">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="9cad8-1860">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndSendTo%2A> はデータグラムが送信されるまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1860">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="9cad8-1861">接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndSendTo%2A> は、要求されたバイト数が送信されるまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1861">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="9cad8-1862">送信したデータがネットワークに直ちに表示される保証はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1862">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-1863">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1863">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-1864"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1864">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1865"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1865">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1866">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1866">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1867">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1867">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1868">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1868">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1869">次のコード例では、特定の場所への非同期送信を終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1869">The following code example ends an asynchronous send to a specific location.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-1870"><paramref name="asyncResult" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1870"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-1871"><see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1871"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1872"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1872"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1873">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1873">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1874"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1874">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-1875"><see cref="T:System.Net.Sockets.Socket" /> で 1 つのプロセスだけにポートのバインドを許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1875">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows only one process to bind to a port.</span></span></summary>
        <value><span data-ttu-id="9cad8-1876"><see cref="T:System.Net.Sockets.Socket" /> で 1 つのソケットだけに特定のポートのバインドを許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1876"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows only one socket to bind to a specific port; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9cad8-1877">既定値は、Windows Server 2003 と Windows XP Service Pack 2 の場合は <see langword="true" />、それ以外のすべてのバージョンの場合は <see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1877">The default is <see langword="true" /> for Windows Server 2003 and Windows XP Service Pack 2, and <see langword="false" /> for all other versions.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1878"><xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> が `false`場合、複数のソケットで <xref:System.Net.Sockets.Socket.Bind%2A> 方法を使用して、特定のポートにバインドできます。ただし、ポートに送信されたネットワークトラフィックに対して操作を実行できるのは、ソケットの1つだけです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1878">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</span></span> <span data-ttu-id="9cad8-1879">複数のソケットが特定のポートにバインドするために <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> 方法を使用しようとすると、そのポートに送信されたネットワークトラフィックが、特定の IP アドレスを持つ1つのソケットによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1879">If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</span></span>  
  
 <span data-ttu-id="9cad8-1880"><xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> が `true`場合は、インターネットプロトコル (IP) アドレスに関係なく、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して特定のポートにバインドしようとしても成功します。その後、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用すると、元のバインドされたソケットが破棄されるまで、そのポートへのバインドを試行することはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1880">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `true`, the first use of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to that port will fail until the original bound socket is destroyed.</span></span>  
  
 <span data-ttu-id="9cad8-1881"><xref:System.Net.Sockets.Socket.Bind%2A> が呼び出される前に、このプロパティを設定する必要があります。それ以外の場合、<xref:System.InvalidOperationException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1881">This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1882">次のコード例は、<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> プロパティの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1882">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1883">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1883">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1884"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1884">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1885">この <see cref="T:System.Net.Sockets.Socket" /> に対して <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> が呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1885"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> has been called for this <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cad8-1886"><see cref="T:System.Net.Sockets.Socket" /> クラスによって使用されていたリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1886">Frees resources used by the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1887"><xref:System.Net.Sockets.Socket> クラスファイナライザーは、<xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出して <xref:System.Net.Sockets.Socket> を閉じ、<xref:System.Net.Sockets.Socket>に関連付けられているリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1887">The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cad8-1888"><see cref="T:System.Net.Sockets.Socket" /> インスタンスのハッシュ値を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1888">Returns a hash value for a <see cref="T:System.Net.Sockets.Socket" /> instance.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1889">整数ハッシュ値。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1889">An integer hash value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="9cad8-1890">GetHashCode メソッドは、このインスタンスのハッシュコードを返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1890">The GetHashCode method returns a hash code of this instance.</span></span> <span data-ttu-id="9cad8-1891">この値は、ハッシュテーブルのキーとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1891">This value can be used as a key in hash tables.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-1892"><see cref="T:System.Net.Sockets.Socket" /> オプションの値を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1892">Returns the value of a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="9cad8-1893"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1893">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="9cad8-1894"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1894">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <summary><span data-ttu-id="9cad8-1895">指定した <see cref="T:System.Net.Sockets.Socket" /> オプションの値をオブジェクトとして返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1895">Returns the value of a specified <see cref="T:System.Net.Sockets.Socket" /> option, represented as an object.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1896">オプションの値を表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1896">An object that represents the value of the option.</span></span> <span data-ttu-id="9cad8-1897"><paramref name="optionName" /> パラメーターを <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> に設定した場合、戻り値は <see cref="T:System.Net.Sockets.LingerOption" /> クラスのインスタンスです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1897">When the <paramref name="optionName" /> parameter is set to <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> the return value is an instance of the <see cref="T:System.Net.Sockets.LingerOption" /> class.</span></span> <span data-ttu-id="9cad8-1898"><paramref name="optionName" /> を <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> または <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> に設定した場合、戻り値は <see cref="T:System.Net.Sockets.MulticastOption" /> クラスのインスタンスです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1898">When <paramref name="optionName" /> is set to <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> or <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, the return value is an instance of the <see cref="T:System.Net.Sockets.MulticastOption" /> class.</span></span> <span data-ttu-id="9cad8-1899"><paramref name="optionName" /> が他の値の場合、戻り値は整数です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1899">When <paramref name="optionName" /> is any other value, the return value is an integer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1900">現在の <xref:System.Net.Sockets.Socket>の動作は、<xref:System.Net.Sockets.Socket> オプションによって決まります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1900"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-1901">このオーバーロードを使用して、<xref:System.Net.Sockets.Socket> オプションの <xref:System.Net.Sockets.SocketOptionName.Linger>、<xref:System.Net.Sockets.SocketOptionName.AddMembership>、および <xref:System.Net.Sockets.SocketOptionName.DropMembership>を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1901">Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="9cad8-1902"><xref:System.Net.Sockets.SocketOptionName.Linger> オプションでは、`optionLevel` パラメーターに <xref:System.Net.Sockets.Socket> を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1902">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="9cad8-1903"><xref:System.Net.Sockets.SocketOptionName.AddMembership> と <xref:System.Net.Sockets.SocketOptionName.DropMembership>については、<xref:System.Net.Sockets.SocketOptionLevel.IP>を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1903">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="9cad8-1904">上記のオプションのいずれかの値を設定する場合は、<xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1904">If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1905"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1905">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1906">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1906">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1907">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1907">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1908">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1908">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1909">次のコード例では、<xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> のタイムアウト値を取得し、コンソールに表示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1909">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1910">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1910">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="9cad8-1911">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-1911">-or-</span></span> 
 <span data-ttu-id="9cad8-1912"><paramref name="optionName" /> が、サポートされていない値 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /> に設定されました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1912"><paramref name="optionName" /> was set to the unsupported value <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1913"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1913">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="9cad8-1914"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1914">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="9cad8-1915"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1915">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="9cad8-1916">オプション設定を受信する <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1916">An array of type <see cref="T:System.Byte" /> that is to receive the option setting.</span></span></param>
        <summary><span data-ttu-id="9cad8-1917">指定した <see cref="T:System.Net.Sockets.Socket" /> オプション設定をバイト配列として返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1917">Returns the specified <see cref="T:System.Net.Sockets.Socket" /> option setting, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1918">現在の <xref:System.Net.Sockets.Socket>の動作は、<xref:System.Net.Sockets.Socket> オプションによって決まります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1918"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-1919">このメソッドが正常に完了すると、`optionValue` パラメーターによって指定された配列に、指定された <xref:System.Net.Sockets.Socket> オプションの値が含まれます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1919">Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option.</span></span>  
  
 <span data-ttu-id="9cad8-1920">`optionValue` 配列の長さが、指定された <xref:System.Net.Sockets.Socket> オプションの値を格納するために必要なバイト数よりも小さい場合、<xref:System.Net.Sockets.Socket.GetSocketOption%2A> は <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1920">When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-1921"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1921">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1922">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1922">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="9cad8-1923">このオーバーロードは、ブール値または整数で表されるソケットに対して使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1923">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1924">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1924">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1925">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1925">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1926">次のコード例では、<xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> のタイムアウト値を取得し、コンソールに表示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1926">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1927">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1927">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="9cad8-1928">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-1928">-or-</span></span> 
<span data-ttu-id="9cad8-1929">.NET Compact Framework アプリケーションでは、Windows CE の既定のバッファー領域は 32768 バイトに設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1929">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="9cad8-1930">ソケットごとのバッファー領域は、<see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> を呼び出して変更できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1930">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1931"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1931">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="9cad8-1932"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1932">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="9cad8-1933"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1933">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionLength"><span data-ttu-id="9cad8-1934">予期される戻り値のバイト単位の長さ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1934">The length, in bytes, of the expected return value.</span></span></param>
        <summary><span data-ttu-id="9cad8-1935">指定した <see cref="T:System.Net.Sockets.Socket" /> オプションの値を配列で返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1935">Returns the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option in an array.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1936">ソケット オプションの値を格納している <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1936">An array of type <see cref="T:System.Byte" /> that contains the value of the socket option.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1937">`optionLength` パラメーターは、返されるバイト配列の最大サイズを設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1937">The `optionLength` parameter sets the maximum size of the returned byte array.</span></span> <span data-ttu-id="9cad8-1938">オプションの値が必要なバイト数が少なくなる場合、配列にはその数のバイトだけが格納されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1938">If the option value requires fewer bytes, the array will contain only that many bytes.</span></span> <span data-ttu-id="9cad8-1939">オプションの値により多くのバイトが必要な場合は、<xref:System.Net.Sockets.Socket.GetSocketOption%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1939">If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-1940">このオーバーロードは、ブール値または整数で表されるソケットに対して使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1940">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1941"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1941">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1942">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1942">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1943">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1943">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1944">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1944">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1945">次のコード例では、<xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> のタイムアウト値を取得し、コンソールに表示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1945">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1946">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1946">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="9cad8-1947">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-1947">-or-</span></span> 
<span data-ttu-id="9cad8-1948">.NET Compact Framework アプリケーションでは、Windows CE の既定のバッファー領域は 32768 バイトに設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1948">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="9cad8-1949">ソケットごとのバッファー領域は、<see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> を呼び出して変更できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1949">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1950"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1950">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-1951"><see cref="T:System.Net.Sockets.Socket" /> のオペレーティング システム ハンドルを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1951">Gets the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="9cad8-1952"><see cref="T:System.IntPtr" /> のオペレーティング システム ハンドルを表す <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1952">An <see cref="T:System.IntPtr" /> that represents the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-1953"><see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1953">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="9cad8-1954">実行する操作の制御コードを指定する <see cref="T:System.Int32" /> 値。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1954">An <see cref="T:System.Int32" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="9cad8-1955">操作に必要な入力データを格納する <see cref="T:System.Byte" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1955">A <see cref="T:System.Byte" /> array that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="9cad8-1956">操作によって返された出力データを格納する <see cref="T:System.Byte" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1956">A <see cref="T:System.Byte" /> array that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-1957">数値制御コードを使用して、<see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1957">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using numerical control codes.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1958"><paramref name="optionOutValue" /> パラメーターのバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1958">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1959"><xref:System.Net.Sockets.Socket.IOControl%2A> メソッドは、<xref:System.Net.Sockets.Socket> クラスの現在のインスタンスの基になるオペレーティングシステム <xref:System.Net.Sockets.Socket> に低レベルのアクセスを提供します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1959">The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="9cad8-1960">詳細については、 [Wsaioctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl)のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1960">For more information, see the [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) documentation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1961"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1961">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1962">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1962">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1963">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1963">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1964">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1964">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1965">次のコード例では、FIONREAD と使用可能なプロパティの結果を比較します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1965">The following code example compares the results of FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1966">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1966">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1967"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1967">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1968"><see cref="P:System.Net.Sockets.Socket.Blocking" /> プロパティを使用せずに、ブロッキング モードを変更しようとしました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1968">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-1969">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1969">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="9cad8-1970">アンマネージコードを実行する場合は。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1970">to execute unmanaged code.</span></span> <span data-ttu-id="9cad8-1971"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-1971">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="9cad8-1972">実行する操作の制御コードを指定する <see cref="T:System.Net.Sockets.IOControlCode" /> 値。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1972">A <see cref="T:System.Net.Sockets.IOControlCode" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="9cad8-1973">操作に必要な入力データを格納する <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1973">An array of type <see cref="T:System.Byte" /> that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="9cad8-1974">操作によって返された出力データを格納する <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1974">An array of type <see cref="T:System.Byte" /> that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-1975"><see cref="T:System.Net.Sockets.IOControlCode" /> 列挙型を使用して制御コードを指定し、<see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1975">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using the <see cref="T:System.Net.Sockets.IOControlCode" /> enumeration to specify control codes.</span></span></summary>
        <returns><span data-ttu-id="9cad8-1976"><paramref name="optionOutValue" /> パラメーターのバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1976">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1977">このメソッドは、<xref:System.Net.Sockets.Socket> クラスの現在のインスタンスの基になるオペレーティングシステム <xref:System.Net.Sockets.Socket> に低レベルのアクセスを提供します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1977">This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="9cad8-1978">詳細については、 [Wsaioctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl)のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1978">For more, see the [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) documentation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1979"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1979">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-1980">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1980">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-1981">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1981">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-1982">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1982">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1983">次のコード例では、<xref:System.Net.Sockets.Socket.IOControl%2A> を呼び出した結果を <xref:System.Net.Sockets.IOControlCode.DataToRead> と <xref:System.Net.Sockets.Socket.Available%2A> プロパティと比較しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1983">The following code example compares the results of calling <xref:System.Net.Sockets.Socket.IOControl%2A> with <xref:System.Net.Sockets.IOControlCode.DataToRead> and the <xref:System.Net.Sockets.Socket.Available%2A> property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-1984">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1984">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-1985"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1985">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-1986"><see cref="P:System.Net.Sockets.Socket.Blocking" /> プロパティを使用せずに、ブロッキング モードを変更しようとしました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1986">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="9cad8-1987">アンマネージコードを実行する場合は。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1987">to execute unmanaged code.</span></span> <span data-ttu-id="9cad8-1988"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-1988">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-1989"><see cref="T:System.Net.Sockets.Socket" /> が特定のローカル ポートにバインドされているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1989">Gets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is bound to a specific local port.</span></span></summary>
        <value><span data-ttu-id="9cad8-1990"><see cref="T:System.Net.Sockets.Socket" /> がローカル ポートにバインドされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1990"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is bound to a local port; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1991">ソケットは、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出すことによって明示的にバインドされている場合、または一時的なローカルポートを使用する <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.SendTo%2A>、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>などのメンバーを呼び出すことによって暗黙的にバインドされている場合は、ローカルポートにバインドされていると見なされます (1024 を超える空きポート)。。オペレーティングシステムによって選択されます)。サーバーは、クライアントが接続できるように、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して既知のポートにバインドします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1991">A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-1992">次のコード例は、<xref:System.Net.Sockets.Socket.IsBound%2A> プロパティの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1992">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.IsBound%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-1993"><see cref="T:System.Net.Sockets.Socket" /> で、すべての保留中のデータを送信しようとするときにソケットを遅延して閉じるかどうかを指定する値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1993">Gets or sets a value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> will delay closing a socket in an attempt to send all pending data.</span></span></summary>
        <value><span data-ttu-id="9cad8-1994">ソケットを閉じているときの待機方法を指定する <see cref="T:System.Net.Sockets.LingerOption" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1994">A <see cref="T:System.Net.Sockets.LingerOption" /> that specifies how to linger while closing a socket.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-1995"><xref:System.Net.Sockets.Socket.LingerState%2A> プロパティは、<xref:System.Net.Sockets.Socket.Close%2A> メソッドの動作方法を変更します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1995">The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves.</span></span> <span data-ttu-id="9cad8-1996">このプロパティを設定すると、Winsock によって接続をリセットできる条件が変更されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1996">This property when set modifies the conditions under which the connection can be reset by Winsock.</span></span> <span data-ttu-id="9cad8-1997">接続のリセットは、IP プロトコルの動作によっても発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1997">Connection resets can still occur based on the IP protocol behavior.</span></span>  
  
 <span data-ttu-id="9cad8-1998">このプロパティは、データが送信されたままになっている場合に <xref:System.Net.Sockets.Socket.Close%2A> を呼び出すと、接続指向接続が開いたままになる時間を制御します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1998">This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent.</span></span>  
  
 <span data-ttu-id="9cad8-1999">ピアにデータを送信するためにメソッドを呼び出すと、このデータは送信ネットワークバッファーに配置されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-1999">When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</span></span> <span data-ttu-id="9cad8-2000">このプロパティを使用すると、<xref:System.Net.Sockets.TcpClient.Close%2A> メソッドによって接続が切断される前に、このデータがリモートホストに確実に送信されるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2000">This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.</span></span>  
  
 <span data-ttu-id="9cad8-2001">残留を有効にするには、目的の値を含む <xref:System.Net.Sockets.LingerOption> インスタンスを作成し、<xref:System.Net.Sockets.Socket.LingerState%2A> プロパティをこのインスタンスに設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2001">To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance.</span></span>  
  
 <span data-ttu-id="9cad8-2002">次の表では、<xref:System.Net.Sockets.LingerOption.Enabled%2A> プロパティの使用可能な値と <xref:System.Net.Sockets.Socket.LingerState%2A> プロパティに格納されている <xref:System.Net.Sockets.LingerOption.LingerTime%2A> プロパティの <xref:System.Net.Sockets.Socket.Close%2A> メソッドの動作について説明します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2002">The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
|<span data-ttu-id="9cad8-2003">LingerState. 有効</span><span class="sxs-lookup"><span data-stu-id="9cad8-2003">LingerState.Enabled</span></span>|<span data-ttu-id="9cad8-2004">Lingerstate</span><span class="sxs-lookup"><span data-stu-id="9cad8-2004">LingerState.LingerTime</span></span>|<span data-ttu-id="9cad8-2005">動作</span><span class="sxs-lookup"><span data-stu-id="9cad8-2005">Behavior</span></span>|  
|-------------------------|----------------------------|--------------|  
|<span data-ttu-id="9cad8-2006">`false` (無効)、既定値</span><span class="sxs-lookup"><span data-stu-id="9cad8-2006">`false` (disabled), the default value</span></span>|<span data-ttu-id="9cad8-2007">タイムアウトは適用されません (既定)。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2007">The time-out is not applicable, (default).</span></span>|<span data-ttu-id="9cad8-2008">既定の IP プロトコルのタイムアウトが経過するまで、保留中のデータの送信を試みます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2008">Attempts to send pending data until the default IP protocol time-out expires.</span></span>|  
|<span data-ttu-id="9cad8-2009">`true` (有効)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2009">`true` (enabled)</span></span>|<span data-ttu-id="9cad8-2010">0以外のタイムアウト</span><span class="sxs-lookup"><span data-stu-id="9cad8-2010">A nonzero time-out</span></span>|<span data-ttu-id="9cad8-2011">指定したタイムアウトが経過するまで保留中のデータを送信しようとします。失敗した場合は、Winsock によって接続がリセットされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2011">Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</span></span>|  
|<span data-ttu-id="9cad8-2012">`true` (有効)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2012">`true` (enabled)</span></span>|<span data-ttu-id="9cad8-2013">ゼロタイムアウト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2013">A zero timeout.</span></span>|<span data-ttu-id="9cad8-2014">保留中のデータを破棄します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2014">Discards any pending data.</span></span> <span data-ttu-id="9cad8-2015">接続指向のソケット (TCP など) の場合、Winsock によって接続がリセットされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2015">For connection-oriented socket (TCP, for example), Winsock resets the connection.</span></span>|  
  
 <span data-ttu-id="9cad8-2016">IP スタックは、接続のラウンドトリップ時間に基づいて、使用する既定の IP プロトコルタイムアウト期間を計算します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2016">The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</span></span> <span data-ttu-id="9cad8-2017">ほとんどの場合、スタックによって計算されるタイムアウトは、アプリケーションで定義されているものよりも関連性が高くなります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2017">In most cases, the time-out computed by the stack is more relevant than one defined by an application.</span></span> <span data-ttu-id="9cad8-2018">これは、<xref:System.Net.Sockets.Socket.LingerState%2A> プロパティが設定されていない場合のソケットの既定の動作です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2018">This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.</span></span>  
  
 <span data-ttu-id="9cad8-2019"><xref:System.Net.Sockets.Socket.LingerState%2A> プロパティに格納されている <xref:System.Net.Sockets.LingerOption.LingerTime%2A> プロパティが既定の IP プロトコルタイムアウトよりも大きい値に設定されている場合でも、既定の IP プロトコルタイムアウトは適用され、上書きされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2019">When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2020">次のコード例は、<xref:System.Net.Sockets.Socket.LingerState%2A> プロパティの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2020">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2021">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2021">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2022"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2022">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog"><span data-ttu-id="9cad8-2023">保留中の接続のキューの最大長。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2023">The maximum length of the pending connections queue.</span></span></param>
        <summary><span data-ttu-id="9cad8-2024"><see cref="T:System.Net.Sockets.Socket" /> をリッスン状態にします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2024">Places a <see cref="T:System.Net.Sockets.Socket" /> in a listening state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2025"><xref:System.Net.Sockets.Socket.Listen%2A> により、接続指向の <xref:System.Net.Sockets.Socket> が着信接続の試行をリッスンします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2025"><xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts.</span></span> <span data-ttu-id="9cad8-2026">`backlog` パラメーターは、受け入れのためにキューに入れることができる着信接続の数を指定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2026">The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance.</span></span> <span data-ttu-id="9cad8-2027">指定できる接続の最大数を決定するには、<xref:System.Net.Sockets.SocketOptionName.MaxConnections> 値を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2027">To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value.</span></span> <span data-ttu-id="9cad8-2028"><xref:System.Net.Sockets.Socket.Listen%2A> はブロックしません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2028"><xref:System.Net.Sockets.Socket.Listen%2A> does not block.</span></span>  
  
 <span data-ttu-id="9cad8-2029"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2029">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2030">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2030">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="9cad8-2031"><xref:System.Net.Sockets.Socket.Accept%2A> または <xref:System.Net.Sockets.Socket.BeginAccept%2A> を使用して、キューからの接続を許可します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2031">Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2032"><xref:System.Net.Sockets.Socket.Listen%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Listen%2A> が <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2032">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2033">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2033">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2034">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2034">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2035">バックログパラメーターは、オペレーティングシステムによって異なる値に制限されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2035">The backlog parameter is limited to different values depending on the Operating System.</span></span> <span data-ttu-id="9cad8-2036">より高い値を指定することもできますが、バックログはオペレーティングシステムに基づいて制限されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2036">You may specify a higher value, but the backlog will be limited based on the Operating System.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2037">次のコード例では、<xref:System.Net.Sockets.Socket> を使用して、着信接続をリッスンします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2037">The following code example uses <xref:System.Net.Sockets.Socket> to listen for incoming connections.</span></span>  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2038">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2038">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2039"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2039">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-2040">ローカル エンドポイントを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2040">Gets the local endpoint.</span></span></summary>
        <value><span data-ttu-id="9cad8-2041"><see cref="T:System.Net.EndPoint" /> が通信に使用している <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2041">The <see cref="T:System.Net.EndPoint" /> that the <see cref="T:System.Net.Sockets.Socket" /> is using for communications.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2042"><xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティは、<xref:System.Net.Sockets.Socket> がバインドされているローカル IP アドレスとポート番号を含む <xref:System.Net.EndPoint> を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2042">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound.</span></span> <span data-ttu-id="9cad8-2043">情報を取得する前に、この <xref:System.Net.EndPoint> を <xref:System.Net.IPEndPoint> にキャストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2043">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="9cad8-2044">その後、<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> メソッドを呼び出してローカル <xref:System.Net.IPAddress>を取得し、<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> メソッドを呼び出してローカルポート番号を取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2044">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the local port number.</span></span>  
  
 <span data-ttu-id="9cad8-2045"><xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティは、通常、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出した後に設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2045">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="9cad8-2046">ソケットのローカル IP アドレスとポート番号の割り当てをシステムに許可した場合、最初の i/o 操作の後に <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティが設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2046">If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation.</span></span> <span data-ttu-id="9cad8-2047">接続指向プロトコルの場合、最初の i/o 操作は <xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドの呼び出しになります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2047">For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2048">コネクションレスプロトコルの場合、最初の i/o 操作は、送信または受信呼び出しのいずれかになります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2048">For connectionless protocols, the first I/O operation would be any of the send or receive calls.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2049"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2049">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2050">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2050">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2051">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2051">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2052">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2052">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2053">次のコード例では、ローカルとリモートのエンドポイントを取得して表示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2053">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2054">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2054">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2055"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2055">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-2056">発信マルチキャスト パケットが送信元アプリケーションに配信されるかどうかを指定する値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2056">Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</span></span></summary>
        <value><span data-ttu-id="9cad8-2057"><see cref="T:System.Net.Sockets.Socket" /> が発信マルチキャスト パケットを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2057"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> receives outgoing multicast packets; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2058">マルチキャストは、インターネット上の多対多通信のためのスケーラブルな方法です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2058">Multicast is a scalable method for many-to-many communication on the Internet.</span></span> <span data-ttu-id="9cad8-2059">プロセスは、マルチキャストアドレスをサブスクライブします。次に、サブスクライブされたプロセスによって送信されたすべてのパケットが、マルチキャストアドレスをサブスクライブしている他のすべてのプロセスによって受信されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2059">A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</span></span>  
  
 <span data-ttu-id="9cad8-2060">伝送制御プロトコル (TCP) ソケットでこのプロパティを設定しても効果はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2060">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2061">次のコード例は、<xref:System.Net.Sockets.Socket.MulticastLoopback%2A> プロパティの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2061">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2062">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2062">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2063"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2063">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-2064">ストリーム <see cref="T:System.Net.Sockets.Socket" /> が Nagle アルゴリズムを使用するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2064">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the stream <see cref="T:System.Net.Sockets.Socket" /> is using the Nagle algorithm.</span></span></summary>
        <value><span data-ttu-id="9cad8-2065"><see cref="T:System.Net.Sockets.Socket" /> が Nagle アルゴリズムを使用する場合は <see langword="false" />。それ以外の場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2065"><see langword="false" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses the Nagle algorithm; otherwise, <see langword="true" />.</span></span> <span data-ttu-id="9cad8-2066">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2066">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2067">Nagle アルゴリズムは、ソケットが小さいパケットをバッファーに格納し、特定の状況下でそれらを結合して1つのパケットで送信することで、ネットワークトラフィックを削減するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2067">The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</span></span> <span data-ttu-id="9cad8-2068">TCP パケットは、40バイトのヘッダーと送信されるデータで構成されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2068">A TCP packet consists of 40 bytes of header plus the data being sent.</span></span> <span data-ttu-id="9cad8-2069">TCP を使用して少量のデータパケットを送信すると、TCP ヘッダーによって生じるオーバーヘッドがネットワークトラフィックの重要な部分になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2069">When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.</span></span> <span data-ttu-id="9cad8-2070">負荷が高いネットワークでは、このオーバーヘッドによって発生する輻輳によって、データグラムが失われ、再送信される可能性があります。また、輻輳による過剰な伝達時間も発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2070">On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</span></span> <span data-ttu-id="9cad8-2071">Nagle アルゴリズムでは、接続で以前に転送されたデータがまだ未確認の場合に、新しい送信データがユーザーから到着したときに、新しい TCP セグメントの送信を抑制します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2071">The Nagle algorithm inhibits the sending of new TCP segments when new outgoing data arrives from the user if any previously transmitted data on the connection remains unacknowledged.</span></span>  
  
 <span data-ttu-id="9cad8-2072">ほとんどのネットワークアプリケーションでは、Nagle アルゴリズムを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2072">The majority of network applications should use the Nagle algorithm.</span></span>  
  
 <span data-ttu-id="9cad8-2073">ユーザーデータグラムプロトコル (UDP) ソケットでこのプロパティを設定しても効果はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2073">Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2074">次のコード例は、<xref:System.Net.Sockets.Socket.NoDelay%2A> プロパティの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2074">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.NoDelay%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2075"><see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2075">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2076"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2076">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-2077">基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 4 (IPv4) をサポートするかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2077">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</span></span></summary>
        <value><span data-ttu-id="9cad8-2078">オペレーティング システムおよびネットワーク アダプターが IPv4 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2078"><see langword="true" /> if the operating system and network adaptors support the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2079">オペレーティングシステムは、IPv4 プロトコルと IPv6 プロトコルの両方をサポートしている場合があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2079">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-2080">基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 6 (IPv6) をサポートするかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2080">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</span></span></summary>
        <value><span data-ttu-id="9cad8-2081">オペレーティング システムおよびネットワーク アダプターが IPv6 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2081"><see langword="true" /> if the operating system and network adaptors support the IPv6 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2082">オペレーティングシステムは、IPv4 プロトコルと IPv6 プロトコルの両方をサポートしている場合があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2082">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="microSeconds"><span data-ttu-id="9cad8-2083">マイクロ秒単位の待機時間。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2083">The time to wait for a response, in microseconds.</span></span></param>
        <param name="mode"><span data-ttu-id="9cad8-2084"><see cref="T:System.Net.Sockets.SelectMode" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2084">One of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></param>
        <summary><span data-ttu-id="9cad8-2085"><see cref="T:System.Net.Sockets.Socket" /> の状態を確認します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2085">Determines the status of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2086"><paramref name="mode" /> パラメーターで渡されるポーリング モードの値に基づいた <see cref="T:System.Net.Sockets.Socket" /> の状態。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2086">The status of the <see cref="T:System.Net.Sockets.Socket" /> based on the polling mode value passed in the <paramref name="mode" /> parameter.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="9cad8-2087">モード</span><span class="sxs-lookup"><span data-stu-id="9cad8-2087">Mode</span></span> 
 </term><description> <span data-ttu-id="9cad8-2088">戻り値</span><span class="sxs-lookup"><span data-stu-id="9cad8-2088">Return Value</span></span> 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><span data-ttu-id="9cad8-2089"><see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> が呼び出されており、接続が保留中の場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2089"><see langword="true" /> if <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> has been called and a connection is pending;</span></span> 
<span data-ttu-id="9cad8-2090">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2090">-or-</span></span> 
 <span data-ttu-id="9cad8-2091">データを読み取ることができる場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2091"><see langword="true" /> if data is available for reading;</span></span> 
<span data-ttu-id="9cad8-2092">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2092">-or-</span></span> 
 <span data-ttu-id="9cad8-2093">接続が閉じている、リセットされている、または終了している場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2093"><see langword="true" /> if the connection has been closed, reset, or terminated;</span></span> 
<span data-ttu-id="9cad8-2094">それ以外の場合、<see langword="false" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2094">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><span data-ttu-id="9cad8-2095"><see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> を処理し、接続に成功した場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2095"><see langword="true" />, if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, and the connection has succeeded;</span></span> 
<span data-ttu-id="9cad8-2096">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2096">-or-</span></span> 
 <span data-ttu-id="9cad8-2097">データを送信できる場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2097"><see langword="true" /> if data can be sent;</span></span> 
<span data-ttu-id="9cad8-2098">それ以外の場合、<see langword="false" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2098">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><span data-ttu-id="9cad8-2099">ブロックしない <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> を処理し、接続に失敗した場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2099"><see langword="true" /> if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> that does not block, and the connection has failed;</span></span> 
<span data-ttu-id="9cad8-2100">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2100">-or-</span></span> 
 <span data-ttu-id="9cad8-2101"><see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> が設定されておらず、帯域外データを使用できる場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2101"><see langword="true" /> if <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> is not set and out-of-band data is available;</span></span> 
<span data-ttu-id="9cad8-2102">それ以外の場合、<see langword="false" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2102">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2103"><xref:System.Net.Sockets.Socket.Poll%2A> メソッドは、<xref:System.Net.Sockets.Socket>の状態を確認します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2103">The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-2104"><xref:System.Net.Sockets.Socket> が読み取り可能かどうかを判断するには、`selectMode` パラメーターに <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> を指定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2104">Specify <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable.</span></span> <span data-ttu-id="9cad8-2105"><xref:System.Net.Sockets.Socket> を書き込み可能にするかどうかを判断するには、<xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> を指定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2105">Specify <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> to determine if the <xref:System.Net.Sockets.Socket> is writable.</span></span> <span data-ttu-id="9cad8-2106">エラー状態を検出するには、<xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2106">Use <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> to detect an error condition.</span></span> <span data-ttu-id="9cad8-2107"><xref:System.Net.Sockets.Socket.Poll%2A> は、指定された期間 (`microseconds`で測定) が経過するまで実行をブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2107"><xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses.</span></span> <span data-ttu-id="9cad8-2108">応答を無期限に待機する場合は、`microSeconds` パラメーターを負の整数に設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2108">Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response.</span></span> <span data-ttu-id="9cad8-2109">複数のソケットの状態を確認する場合は、<xref:System.Net.Sockets.Socket.Select%2A> メソッドを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2109">If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2110"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2110">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2111">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2111">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2112">この方法では、ネットワークケーブルの切断など、特定の種類の接続の問題を検出することはできません。また、リモートホストが異常終了をシャットダウンしたことを確認することもできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2112">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="9cad8-2113">これらの種類のエラーを検出するには、データの送信または受信を試みる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2113">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2114">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2114">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2115">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2115">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2116">次のコード例では、ソケットを作成し、サーバーに接続して、<xref:System.Net.Sockets.Socket.Poll%2A> を使用してソケットの状態を確認します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2116">The following code example creates a socket, connects to a server, and uses <xref:System.Net.Sockets.Socket.Poll%2A> to check the status of the socket.</span></span>  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-2117"><paramref name="mode" /> パラメーターが、<see cref="T:System.Net.Sockets.SelectMode" /> 値の 1 つではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2117">The <paramref name="mode" /> parameter is not one of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2118">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2118">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="9cad8-2119">以下の解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2119">See remarks below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2120"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2120">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-2121"><see cref="T:System.Net.Sockets.Socket" /> のプロトコルの種類を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2121">Gets the protocol type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="9cad8-2122"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2122">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2123"><xref:System.Net.Sockets.Socket.ProtocolType%2A> プロパティは、<xref:System.Net.Sockets.Socket> が作成されるときに設定され、その <xref:System.Net.Sockets.Socket>によって使用されるプロトコルを指定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2123">The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2124">次のコード例では、<xref:System.Net.Sockets.AddressFamily>、<xref:System.Net.Sockets.SocketType>、および <xref:System.Net.Sockets.ProtocolType> をコンソールに表示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2124">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-2125">バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2125">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2126">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2126">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <summary><span data-ttu-id="9cad8-2127">バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信し、受信バッファーに格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2127">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2128">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2128">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2129"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2129">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="9cad8-2130">接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2130">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="9cad8-2131">このオーバーロードでは、受信バッファーのみを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2131">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="9cad8-2132">バッファーオフセットの既定値は0で、サイズは既定でバッファーパラメーターの長さに設定され、<xref:System.Net.Sockets.SocketFlags> 値は既定で <xref:System.Net.Sockets.SocketFlags.None>に設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2132">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="9cad8-2133">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2133">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="9cad8-2134"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2134">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2135">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2135">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2136"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2136"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="9cad8-2137">読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2137">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-2138">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2138">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2139">非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2139">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2140"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2140">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2141"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2141">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="9cad8-2142">接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで、使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2142">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="9cad8-2143">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2143">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="9cad8-2144">コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2144">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="9cad8-2145">受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffer` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2145">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2146"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2146">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2147">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2147">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2148">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2148">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2149">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2149">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2150">次のコード例では、接続された <xref:System.Net.Sockets.Socket>でデータを受信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2150">The following code example receives data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2151"><paramref name="buffer" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2151"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2152">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2152">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2153"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2153">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-2154">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2154">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2155">ネットワークからの接続を受け入れるために使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2155">for accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2156"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2156">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="9cad8-2157">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2157">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <summary><span data-ttu-id="9cad8-2158">バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して、受信バッファーのリストに格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2158">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2159">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2159">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2160">このメソッドは、buffers パラメーターにデータを読み込み、正常に読み取られたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2160">This method reads data into the buffers parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="9cad8-2161">接続指向ソケットとコネクションレスソケットの両方からを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2161">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="9cad8-2162">このオーバーロードでは、1つ以上の受信バッファーを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2162">This overload requires you to provide one or more receive buffers.</span></span>  
  
 <span data-ttu-id="9cad8-2163">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2163">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="9cad8-2164"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホスト接続から到着したデータのみを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2164">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2165">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2165">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2166"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2166"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="9cad8-2167">読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2167">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-2168">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2168">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2169">非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2169">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2170"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2170">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2171"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2171">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="9cad8-2172">接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで、使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2172">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="9cad8-2173">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2173">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="9cad8-2174">コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した宛先アドレスから最初にエンキューされたデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2174">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="9cad8-2175">受信するデータグラムが `buffers` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffers` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2175">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2176"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2176">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2177">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2177">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="9cad8-2178">**メモ**このメンバーは、アプリケーションでネットワークトレースを有効にしたときにトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2178">**Note** This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2179">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2179">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2180"><paramref name="buffer" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2180">The <paramref name="buffer" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2181">ソケットへのアクセスを試みているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2181">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2182"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2182">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2183">受信したデータの保存場所となるバイトのスパン。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2183">A span of bytes that is the storage location for the received data.</span></span></param>
        <summary><span data-ttu-id="9cad8-2184">バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信し、受信バッファーに格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2184">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2185">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2185">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="9cad8-2186"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2186">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="9cad8-2187">接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2187">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>

<span data-ttu-id="9cad8-2188">このオーバーロードでは、受信バッファーのみを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2188">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="9cad8-2189">バッファーオフセットの既定値は0で、サイズは既定でバッファーパラメーターの長さに設定され、<xref:System.Net.Sockets.SocketFlags> 値は既定で <xref:System.Net.Sockets.SocketFlags.None>に設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2189">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>

<span data-ttu-id="9cad8-2190">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2190">If you're using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="9cad8-2191"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2191">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2192">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2192">If you're using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2193"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2193"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>

<span data-ttu-id="9cad8-2194">読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2194">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-2195">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2195">When the time-out value is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2196">非ブロッキングモードで、プロトコルスタックバッファーに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2196">If you're in non-blocking mode, and there's no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2197"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2197">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2198"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2198">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>

<span data-ttu-id="9cad8-2199">接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで、使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2199">If you're using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="9cad8-2200">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2200">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>

<span data-ttu-id="9cad8-2201">コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2201">If you're using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="9cad8-2202">受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合、`buffer` はメッセージの最初の部分を格納し、余分なデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2202">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost, and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>

> [!NOTE]
> <span data-ttu-id="9cad8-2203"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2203">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2204">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2204">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="9cad8-2205">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2205">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2206">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2206">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2207">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2207">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2208"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2208">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-2209">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2209">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2210">ネットワークからの接続を受け入れています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2210">Accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2211"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2211">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2212">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2212">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-2213"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2213">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="9cad8-2214">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーに格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2214">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2215">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2215">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2216"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2216">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="9cad8-2217">接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2217">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="9cad8-2218">このオーバーロードでは、受信バッファーと必要な <xref:System.Net.Sockets.SocketFlags>のみを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2218">This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="9cad8-2219">バッファーオフセットは既定で0に設定され、サイズは既定でバイトパラメーターの長さに設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2219">The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</span></span>  
  
 <span data-ttu-id="9cad8-2220">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2220">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="9cad8-2221"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2221">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2222">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2222">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2223"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2223"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="9cad8-2224">データを読み取ることができない場合、データが使用可能になるまで、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2224">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available.</span></span> <span data-ttu-id="9cad8-2225">非ブロッキングモードで、プロトコルスタックバッファーに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2225">If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2226"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2226">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2227"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2227">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="9cad8-2228">接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2228">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer.</span></span> <span data-ttu-id="9cad8-2229">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2229">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="9cad8-2230">コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した宛先アドレスから最初にエンキューされたデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2230">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="9cad8-2231">受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffer` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2231">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2232"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2232">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2233">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2233">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2234">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2234">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2235">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2235">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2236">次のコード例では、データバッファーと、接続された <xref:System.Net.Sockets.Socket>でデータを受信するための <xref:System.Net.Sockets.SocketFlags> を指定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2236">The following code example specifies a data buffer, and <xref:System.Net.Sockets.SocketFlags> for receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2237"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2237"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2238">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2238">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2239"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2239">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-2240">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2240">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2241">ネットワークからの接続を受け入れています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2241">Accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2242"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2242">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="9cad8-2243">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2243">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-2244"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2244">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="9cad8-2245">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーのリストに格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2245">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2246">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2246">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2247">このメソッドは、`buffers` パラメーターにデータを読み込み、正常に読み取られたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2247">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="9cad8-2248">接続指向ソケットとコネクションレスソケットの両方からを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2248">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="9cad8-2249">このオーバーロードでは、1つ以上の受信バッファーを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2249">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="9cad8-2250"><xref:System.Net.Sockets.SocketFlags> 値は既定で <xref:System.Net.Sockets.SocketFlags.None>に設定されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2250">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="9cad8-2251">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2251">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="9cad8-2252"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホスト接続から到着したデータのみを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2252">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2253">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2253">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2254"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2254"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="9cad8-2255">読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2255">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-2256">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2256">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2257">非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2257">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2258"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2258">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2259"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2259">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="9cad8-2260">接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで、使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2260">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="9cad8-2261">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2261">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="9cad8-2262">コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した宛先アドレスから最初にエンキューされたデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2262">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="9cad8-2263">受信するデータグラムが `buffers` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffers` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2263">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2264"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2264">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2265">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2265">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2266">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2266">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2267">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2267">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2268">次のコード例は、接続された <xref:System.Net.Sockets.Socket>でデータを受信する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2268">The following code example demonstrates how to receive data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2269"><paramref name="buffers" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2269"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cad8-2270">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2270">-or-</span></span> 
 <span data-ttu-id="9cad8-2271"><paramref name="buffers" />.Count が 0 です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2271"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2272">ソケットへのアクセスを試みているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2272">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2273"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2273">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2274">ネットワークからの接続を受け入れるために使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2274">for accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2275"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2275">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2276">受信したデータの保存場所となるバイトのスパン。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2276">A span of bytes that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-2277">送受信の動作を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2277">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <summary><span data-ttu-id="9cad8-2278">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーに格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2278">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2279">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2279">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

<span data-ttu-id="9cad8-2280"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2280">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="9cad8-2281">接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2281">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>

<span data-ttu-id="9cad8-2282">このオーバーロードでは、受信バッファーのみを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2282">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="9cad8-2283">バッファーオフセットの既定値は0で、サイズは既定でバッファーパラメーターの長さに設定され、<xref:System.Net.Sockets.SocketFlags> 値は既定で <xref:System.Net.Sockets.SocketFlags.None>に設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2283">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>

<span data-ttu-id="9cad8-2284">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2284">If you're using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="9cad8-2285"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2285">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2286">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2286">If you're using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2287"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2287"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>

<span data-ttu-id="9cad8-2288">読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2288">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-2289">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2289">When the time-out value is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2290">非ブロッキングモードで、プロトコルスタックバッファーに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2290">If you're in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2291"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2291">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2292"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2292">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>

<span data-ttu-id="9cad8-2293">接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで、使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2293">If you're using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="9cad8-2294">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2294">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>

<span data-ttu-id="9cad8-2295">コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2295">If you're using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="9cad8-2296">受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合、`buffer` はメッセージの最初の部分を格納し、余分なデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2296">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost, and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>

> [!NOTE]
> <span data-ttu-id="9cad8-2297"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2297">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2298">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2298">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="9cad8-2299">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2299">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2300">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2300">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2301">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2301">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2302"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2302">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-2303">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2303">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2304">ネットワークからの接続を受け入れるために使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2304">for accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2305"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2305">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2306">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2306">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-2307">受信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2307">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-2308"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2308">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="9cad8-2309">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> から指定したバイト数のデータを受信して受信バッファーに格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2309">Receives the specified number of bytes of data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2310">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2310">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2311"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、`buffer` パラメーターにデータを読み込み、正常に読み取られたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2311">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="9cad8-2312">接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2312">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="9cad8-2313">このオーバーロードでは、受信バッファー、受信するバイト数、および必要な <xref:System.Net.Sockets.SocketFlags>を指定するだけで済みます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2313">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 <span data-ttu-id="9cad8-2314">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2314">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="9cad8-2315"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2315">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2316">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2316">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2317"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2317"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="9cad8-2318">読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2318">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-2319">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2319">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2320">非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2320">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2321"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2321">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2322"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2322">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="9cad8-2323">接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、`size` パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2323">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="9cad8-2324">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2324">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="9cad8-2325">コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2325">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="9cad8-2326">受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffer` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2326">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2327"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2327">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2328">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2328">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2329">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2329">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2330">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2330">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2331">次の例では、`buffer`にあるデータを受け取り、<xref:System.Net.Sockets.SocketFlags>の <xref:System.Net.Sockets.SocketFlags.None> を指定しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2331">The following receives the data found into `buffer`, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2332"><paramref name="buffer" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2332"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-2333"><paramref name="size" /> が <paramref name="buffer" /> のサイズを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2333"><paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2334">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2334">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2335"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2335">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-2336">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2336">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2337">ネットワークからの接続を受け入れるために使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2337">for accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2338"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2338">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="9cad8-2339">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2339">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-2340"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2340">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="9cad8-2341">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2341">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="9cad8-2342">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーのリストに格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2342">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2343">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2343">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2344">このメソッドは、`buffers` パラメーターにデータを読み込み、正常に読み取られたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2344">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="9cad8-2345">接続指向ソケットとコネクションレスソケットの両方からを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2345">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="9cad8-2346">このオーバーロードでは、1つ以上の受信バッファーを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2346">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="9cad8-2347"><xref:System.Net.Sockets.SocketFlags> 値は既定で <xref:System.Net.Sockets.SocketFlags.None>に設定されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2347">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="9cad8-2348">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2348">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="9cad8-2349"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホスト接続から到着したデータのみを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2349">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2350">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2350">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2351"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2351"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="9cad8-2352">読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2352">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-2353">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2353">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2354">非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2354">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2355"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2355">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2356"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2356">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="9cad8-2357">接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで、使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2357">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="9cad8-2358">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2358">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="9cad8-2359">コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2359">If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="9cad8-2360">受信するデータグラムが `buffers` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffers` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2360">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2361"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2361">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2362">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2362">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2363">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2363">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2364">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2364">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2365"><paramref name="buffers" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2365"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cad8-2366">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2366">-or-</span></span> 
 <span data-ttu-id="9cad8-2367"><paramref name="buffers" />.Count が 0 です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2367"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2368">ソケットへのアクセスを試みているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2368">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2369"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2369">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2370">ネットワークからの接続を受け入れるために使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2370">for accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2371"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2371">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2372">受信したデータの保存場所となるバイトのスパン。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2372">A span of bytes that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-2373">送受信の動作を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2373">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <param name="errorCode"><span data-ttu-id="9cad8-2374">このメソッドから制御が戻るときに、ソケットのエラー コードを定義する列挙値の 1 つを格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2374">When this method returns, contains one of the enumeration values that defines error codes for the socket.</span></span></param>
        <summary><span data-ttu-id="9cad8-2375">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーに格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2375">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2376">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2376">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<span data-ttu-id="9cad8-2377"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2377">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="9cad8-2378">接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2378">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  

<span data-ttu-id="9cad8-2379">このオーバーロードでは、受信バッファーのみを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2379">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="9cad8-2380">バッファーオフセットの既定値は0で、サイズは既定でバッファーパラメーターの長さに設定され、<xref:System.Net.Sockets.SocketFlags> 値は既定で <xref:System.Net.Sockets.SocketFlags.None>に設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2380">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  

<span data-ttu-id="9cad8-2381">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2381">If you're using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="9cad8-2382"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2382">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2383">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2383">If you're using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2384"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2384"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  

<span data-ttu-id="9cad8-2385">読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2385">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-2386">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2386">When the time-out value is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2387">非ブロッキングモードで、プロトコルスタックバッファーに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2387">If you're in non-blocking mode, and there's no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2388"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2388">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2389"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2389">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  

<span data-ttu-id="9cad8-2390">接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーのサイズまで、使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2390">If you're using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="9cad8-2391">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2391">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  

<span data-ttu-id="9cad8-2392">コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2392">If you're using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="9cad8-2393">受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffer` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2393">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  

> [!NOTE]
>  <span data-ttu-id="9cad8-2394"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2394">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2395">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2395">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  

> [!NOTE]
>  <span data-ttu-id="9cad8-2396">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2396">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2397">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2397">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2398">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2398">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2399"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2399">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-2400">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2400">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2401">ネットワークからの接続を受け入れるために使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2401">for accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2402"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2402">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2403">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2403">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="9cad8-2404">受信データを格納する <paramref name="buffer" />内の場所。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2404">The location in <paramref name="buffer" /> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-2405">受信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2405">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-2406"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2406">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="9cad8-2407">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> から指定したバイト数のデータを受信して、受信バッファー内の指定したオフセット位置に格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2407">Receives the specified number of bytes from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified offset position of the receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2408">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2408">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2409"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2409">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="9cad8-2410">接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2410">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="9cad8-2411">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2411">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="9cad8-2412"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2412">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2413">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2413">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2414"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2414"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="9cad8-2415">読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2415">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-2416">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2416">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2417">非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2417">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2418">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2418">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="9cad8-2419">以下の解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2419">See Remarks below.</span></span> <span data-ttu-id="9cad8-2420"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2420">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2421"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2421">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="9cad8-2422">接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、size パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2422">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="9cad8-2423">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2423">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="9cad8-2424">コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2424">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="9cad8-2425">受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffer` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2425">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2426"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2426">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2427">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2427">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2428">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2428">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2429">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2429">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2430">次のコード例では、接続された <xref:System.Net.Sockets.Socket>でデータを受信する前に、データバッファー、オフセット、サイズ、およびソケットフラグを指定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2430">The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2431"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2431"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-2432"><paramref name="offset" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2432"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-2433">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2433">-or-</span></span> 
 <span data-ttu-id="9cad8-2434"><paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2434"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="9cad8-2435">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2435">-or-</span></span> 
 <span data-ttu-id="9cad8-2436"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2436"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-2437">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2437">-or-</span></span> 
 <span data-ttu-id="9cad8-2438"><paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2438"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2439"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2439"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="9cad8-2440">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2440">-or-</span></span> 
<span data-ttu-id="9cad8-2441"><see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2441">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="9cad8-2442">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2442">-or-</span></span> 
<span data-ttu-id="9cad8-2443"><see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2443">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2444"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2444">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-2445">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2445">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2446">ネットワークからの接続を受け入れるために使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2446">for accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2447"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2447">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2448">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2448">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="9cad8-2449">受信したデータを格納する、<paramref name="buffer" /> パラメーター内の位置。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2449">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-2450">受信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2450">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-2451"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2451">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="9cad8-2452">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2452">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="9cad8-2453">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーに格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2453">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2454">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2454">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2455"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、バッファーパラメーターにデータを読み込み、正常に読み取られたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2455">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="9cad8-2456">接続指向ソケットとコネクションレスソケットの両方から <xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2456">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="9cad8-2457">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Receive%2A>を呼び出す前に受信接続を受け入れるよう <xref:System.Net.Sockets.Socket.Accept%2A> する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2457">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="9cad8-2458"><xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストから到着したデータのみを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2458">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2459">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2459">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2460"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> を使用すると、任意のホストから到着するデータを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2460"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="9cad8-2461">読み取り可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>を使用してタイムアウト値が設定されていない限り、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドはデータが使用可能になるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2461">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-2462">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2462">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2463">非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2463">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2464">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2464">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="9cad8-2465">以下の解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2465">See Remarks below.</span></span> <span data-ttu-id="9cad8-2466"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2466">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2467"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2467">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="9cad8-2468">接続指向の <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドは、size パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2468">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="9cad8-2469">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2469">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="9cad8-2470">コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.Socket.Receive%2A> は <xref:System.Net.Sockets.Socket.Connect%2A> メソッドで指定した送信先アドレスからキューに置かれた最初のデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2470">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="9cad8-2471">受信するデータグラムが `buffer` パラメーターのサイズよりも大きい場合は、メッセージの最初の部分を `buffer` 取得します。超過したデータは失われ、<xref:System.Net.Sockets.SocketException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2471">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2472"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2472">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2473">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2473">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2474">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2474">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2475">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2475">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2476"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2476"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-2477"><paramref name="offset" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2477"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-2478">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2478">-or-</span></span> 
 <span data-ttu-id="9cad8-2479"><paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2479"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="9cad8-2480">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2480">-or-</span></span> 
 <span data-ttu-id="9cad8-2481"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2481"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-2482">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2482">-or-</span></span> 
 <span data-ttu-id="9cad8-2483"><paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2483"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2484"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2484"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="9cad8-2485">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2485">-or-</span></span> 
<span data-ttu-id="9cad8-2486"><see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2486">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property is not set.</span></span>  
  
<span data-ttu-id="9cad8-2487">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2487">-or-</span></span> 
<span data-ttu-id="9cad8-2488"><see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2488">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2489"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2489">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-2490">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2490">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2491">ネットワークからの接続を受け入れるために使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2491">for accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2492"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2492">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="9cad8-2493">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2493">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-2494">接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトからデータを受信する非同期要求を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2494">Begins an asynchronous request to receive data from a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2495">I/O 操作が保留中の場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2495"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="9cad8-2496">操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2496">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="9cad8-2497">I/O 操作が同期的に完了した場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2497"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="9cad8-2498">この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2498">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2499"><xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッドは、接続されたソケットまたはバインドされたコネクションレスソケットで使用され、受信データの読み取りに使用されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2499">The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</span></span> <span data-ttu-id="9cad8-2500">ソケットのローカルアドレスがわかっている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2500">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="9cad8-2501">バインドされたコネクションレスソケットの場合、この関数は、受信したメッセージが受け入れられるアドレスを制限します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2501">For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</span></span> <span data-ttu-id="9cad8-2502">関数は、接続で指定されたリモートアドレスからのメッセージのみを返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2502">The function only returns messages from the remote address specified in the connection.</span></span> <span data-ttu-id="9cad8-2503">他のアドレスからのメッセージは、暗黙的に破棄されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2503">Messages from other addresses are silently discarded.</span></span>  
  
 <span data-ttu-id="9cad8-2504">`e` パラメーターの <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> プロパティは、Window Sockets service プロバイダーに読み取り要求に関する追加情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2504">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="9cad8-2505">このパラメーターの使用方法の詳細については、「<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2505">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9cad8-2506">このメソッドを正常に呼び出すには、<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2506">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="9cad8-2507"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> または <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="9cad8-2507"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="9cad8-2508"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> が設定されている場合は <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="9cad8-2508"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="9cad8-2509"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> が設定されている場合は <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="9cad8-2509"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="9cad8-2510">呼び出し元は、<xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2510">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="9cad8-2511">コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2511">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="9cad8-2512">バイトストリームスタイルのソケットの場合、バッファーがいっぱいになるか、接続が閉じられるか、内部バッファーデータが使い果たされるまで、受信データがバッファーに配置されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2512">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span>  
  
 <span data-ttu-id="9cad8-2513">メッセージ指向のソケットの場合、受信メッセージは `e` パラメーターに関連付けられたバッファーの合計サイズまでバッファーに配置されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2513">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter.</span></span> <span data-ttu-id="9cad8-2514">メッセージがバッファーより大きい場合、バッファーにはメッセージの最初の部分が格納されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2514">If the message is larger than the buffer, the buffer is filled with the first part of the message.</span></span>  
  
 <span data-ttu-id="9cad8-2515">接続指向のソケットの場合、<xref:System.Net.Sockets.Socket.ReceiveAsync%2A> メソッドは、ソケットがバイトストリームかメッセージ指向かに応じて、2つの方法のいずれかで仮想回線の正常な終了を示すことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2515">For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</span></span> <span data-ttu-id="9cad8-2516">バイトストリームの場合、読み取られたゼロバイトは正常に終了したことを示し、これ以上バイトは読み取られません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2516">For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</span></span> <span data-ttu-id="9cad8-2517">ゼロバイトのメッセージが許可される可能性があるメッセージ指向のソケットの場合、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> がネイティブ Winsock WSAEDISCON エラーコード (10101) に設定されている <xref:System.Net.Sockets.SocketException> を使用して、正常に終了することを示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2517">For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</span></span> <span data-ttu-id="9cad8-2518">いずれの場合も、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> がネイティブ Winsock WSAECONNRESET エラーコード (10054) に設定されている <xref:System.Net.Sockets.SocketException> は、中止が発生したことを示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2518">In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-2519">引数が無効です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2519">An argument was invalid.</span></span> <span data-ttu-id="9cad8-2520"><paramref name="e" /> パラメーターの <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> プロパティまたは <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティは、有効なバッファーを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2520">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="9cad8-2521">これらのプロパティは、どちらか 1 つを設定できます。一度に両方のプロパティを設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2521">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-2522"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2522">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-2523">このメソッドには Windows XP 以降が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2523">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2524"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2524">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2525">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2525">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-2526"><see cref="T:System.Net.Sockets.Socket" /> の受信バッファーのサイズを指定する値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2526">Gets or sets a value that specifies the size of the receive buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="9cad8-2527">受信バッファーのサイズ (バイト単位) を格納している <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2527">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the receive buffer.</span></span> <span data-ttu-id="9cad8-2528">既定値は 8192 です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2528">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2529">バッファーサイズを大きくすると、空の受信確認 (データ部分のない TCP パケット) の数が減少する可能性がありますが、接続の問題の認識が遅れる可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2529">A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</span></span> <span data-ttu-id="9cad8-2530">大きなファイルを転送する場合や、高帯域幅の高待機時間接続 (サテライトブロードバンドプロバイダーなど) を使用している場合は、バッファーサイズを大きくすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2530">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2531">次のコード例は、<xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> プロパティの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2531">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2532">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2532">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2533"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2533">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-2534">設定操作として指定された値が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2534">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-2535">データグラムを受信し、ソース エンドポイントを格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2535">Receives a datagram and stores the source endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2536">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2536">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="9cad8-2537">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2537">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="9cad8-2538">データグラムを受信してデータバッファーに格納します。さらに、エンドポイントを格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2538">Receives a datagram into the data buffer and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2539">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2539">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2540"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`buffer` パラメーターにデータを読み取り、正常に読み取られたバイト数を返し、データの送信元のリモートホストエンドポイントをキャプチャします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2540">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="9cad8-2541">この方法は、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2541">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="9cad8-2542">このオーバーロードでは、受信 `buffer`、およびリモートホストを表す <xref:System.Net.EndPoint> を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2542">This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="9cad8-2543">バッファーオフセットの既定値は0です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2543">The buffer offset defaults to 0.</span></span> <span data-ttu-id="9cad8-2544">既定のサイズは `buffer` パラメーターの長さで、`socketFlags` の値は既定で <xref:System.Net.Sockets.SocketFlags.None>に設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2544">The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2545"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して <xref:System.Net.Sockets.Socket> をローカルエンドポイントに明示的にバインドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2545">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="9cad8-2546">そうしないと、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2546">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="9cad8-2547">コネクションレスプロトコルを使用すると、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2547">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="9cad8-2548">受信したデータグラムが `buffer`のサイズより大きい場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、可能な限り多くのメッセージを `buffer` に入力し、<xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2548">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2549">信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2549">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="9cad8-2550">信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な大きさのバッファーを使用して <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出すことで取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2550">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="9cad8-2551">データを読み取ることができない場合、データが使用可能になるまで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2551">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="9cad8-2552">非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2552">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2553"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2553">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2554"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2554">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="9cad8-2555"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2555">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="9cad8-2556">これを選択する場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを呼び出して受信リモートホスト接続を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2556">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2557"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に接続を確立または受け入れない場合、<xref:System.Net.Sockets.SocketException>が表示されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2557">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2558"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2558">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2559">どちらの場合も、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`remoteEP` パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2559">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="9cad8-2560">接続指向のソケットを使用すると、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は `buffer`のサイズまで使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2560">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="9cad8-2561">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2561">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2562"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2562">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2563">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2563">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2564"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> で使用される <xref:System.Net.EndPoint> の <xref:System.Net.Sockets.AddressFamily> は、<xref:System.Net.EndPoint> で使用される <xref:System.Net.Sockets.Socket.SendTo%2A>の <xref:System.Net.Sockets.AddressFamily> と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2564">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2565">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2565">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2566">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2566">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2567">次のコード例では、リモートホストからコネクションレスのデータグラムを受信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2567">The following code example receives a connectionless datagram from a remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2568"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2568"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cad8-2569">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2569">-or-</span></span> 
 <span data-ttu-id="9cad8-2570"><paramref name="remoteEP" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2570"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2571">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2571">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2572"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2572">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-2573">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2573">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2574">ネットワークからの接続を受け入れるために使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2574">for accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2575"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2575">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2576">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2576">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-2577"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2577">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="9cad8-2578">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2578">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="9cad8-2579">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、データグラムを受信してデータバッファーに格納します。さらに、エンドポイントを格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2579">Receives a datagram into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2580">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2580">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2581"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`buffer` パラメーターにデータを読み取り、正常に読み取られたバイト数を返し、データの送信元のリモートホストエンドポイントをキャプチャします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2581">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="9cad8-2582">この方法は、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2582">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="9cad8-2583">このオーバーロードでは、受信バッファー、必要な <xref:System.Net.Sockets.SocketFlags>、およびリモートホストを表す <xref:System.Net.EndPoint> を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2583">This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="9cad8-2584">オフセットの既定値は0で、サイズは既定でバッファーパラメーターの長さに設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2584">The offset defaults to 0 and the size defaults to the length of the buffer parameter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2585"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して <xref:System.Net.Sockets.Socket> をローカルエンドポイントに明示的にバインドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2585">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="9cad8-2586">そうしないと、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2586">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="9cad8-2587">コネクションレスプロトコルを使用すると、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2587">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="9cad8-2588">受信したデータグラムが `buffer`のサイズより大きい場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、可能な限り多くのメッセージを `buffer` に入力し、<xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2588">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2589">信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2589">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="9cad8-2590">信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な大きさのバッファーを使用して <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出すことで取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2590">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="9cad8-2591">データを読み取ることができない場合、データが使用可能になるまで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2591">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="9cad8-2592">非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2592">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2593"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2593">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2594"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2594">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="9cad8-2595"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2595">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="9cad8-2596">これを選択する場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを呼び出して受信リモートホスト接続を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2596">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2597"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に接続を確立または受け入れない場合、<xref:System.Net.Sockets.SocketException>が表示されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2597">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2598"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2598">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2599">どちらの場合も、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`remoteEP` パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2599">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="9cad8-2600">接続指向のソケットを使用すると、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は `buffer`のサイズまで使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2600">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="9cad8-2601">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2601">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2602"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2602">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2603">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2603">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2604"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> で使用される <xref:System.Net.EndPoint> の <xref:System.Net.Sockets.AddressFamily> は、<xref:System.Net.EndPoint> で使用される <xref:System.Net.Sockets.Socket.SendTo%2A>の <xref:System.Net.Sockets.AddressFamily> と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2604">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2605">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2605">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2606">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2606">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2607">次のコード例では、リモートホストからコネクションレスのデータグラムを受信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2607">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="9cad8-2608"><xref:System.Net.Sockets.SocketFlags> は <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドに渡されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2608"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2609"><paramref name="buffer" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2609"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cad8-2610">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2610">-or-</span></span> 
 <span data-ttu-id="9cad8-2611"><paramref name="remoteEP" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2611"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2612">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2612">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2613"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2613">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-2614">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2614">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2615">ネットワークからの接続を受け入れるために使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2615">for accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2616"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2616">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2617">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2617">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-2618">受信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2618">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-2619"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2619">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="9cad8-2620">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2620">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="9cad8-2621">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを受信してデータ バッファーに格納します。さらに、エンドポイントを格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2621">Receives the specified number of bytes into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2622">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2622">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2623"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`buffer` パラメーターにデータを読み取り、正常に読み取られたバイト数を返し、データの送信元のリモートホストエンドポイントをキャプチャします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2623">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="9cad8-2624">この方法は、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2624">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="9cad8-2625">このオーバーロードでは、受信バッファー、受信するバイト数、必要な <xref:System.Net.Sockets.SocketFlags>、およびリモートホストを表す <xref:System.Net.EndPoint> を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2625">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="9cad8-2626">バッファーオフセットの既定値は0です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2626">The buffer offset defaults to 0.</span></span>  
  
 <span data-ttu-id="9cad8-2627">コネクションレスプロトコルを使用すると、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2627">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="9cad8-2628">受信したデータグラムが `buffer`のサイズより大きい場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、可能な限り多くのメッセージを `buffer` に入力し、<xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2628">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2629">信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2629">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="9cad8-2630">信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な大きさのバッファーを使用して <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出すことで取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2630">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="9cad8-2631">データを読み取ることができない場合、データが使用可能になるまで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2631">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="9cad8-2632">非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2632">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2633"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2633">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2634"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2634">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="9cad8-2635"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2635">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="9cad8-2636">これを選択する場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを呼び出して受信リモートホスト接続を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2636">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2637"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に接続を確立または受け入れない場合、<xref:System.Net.Sockets.SocketException>が表示されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2637">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2638"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2638">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2639">どちらの場合も、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`remoteEP` パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2639">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="9cad8-2640">接続指向のソケットでは、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、`size` パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2640">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="9cad8-2641">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2641">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2642"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して <xref:System.Net.Sockets.Socket> をローカルエンドポイントに明示的にバインドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2642">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="9cad8-2643">そうしないと、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2643">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2644"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2644">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2645">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2645">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2646"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> で使用される <xref:System.Net.EndPoint> の <xref:System.Net.Sockets.AddressFamily> は、<xref:System.Net.EndPoint> で使用される <xref:System.Net.Sockets.Socket.SendTo%2A>の <xref:System.Net.Sockets.AddressFamily> と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2646">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2647">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2647">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2648">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2648">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2649">次のコード例では、リモートホストからコネクションレスのデータグラムを受信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2649">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="9cad8-2650">バッファーサイズと <xref:System.Net.Sockets.SocketFlags> が <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドに渡されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2650">The buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2651"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2651"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cad8-2652">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2652">-or-</span></span> 
 <span data-ttu-id="9cad8-2653"><paramref name="remoteEP" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2653"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-2654"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2654"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-2655">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2655">-or-</span></span> 
 <span data-ttu-id="9cad8-2656"><paramref name="size" /> が <paramref name="buffer" />の長さを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2656"><paramref name="size" /> is greater than the length of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2657"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2657"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="9cad8-2658">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2658">-or-</span></span> 
<span data-ttu-id="9cad8-2659"><see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2659">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="9cad8-2660">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2660">-or-</span></span> 
<span data-ttu-id="9cad8-2661"><see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2661">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2662"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2662">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-2663">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2663">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2664">ネットワークからの接続を受け入れるために使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2664">for accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2665"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2665">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2666">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2666">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="9cad8-2667">受信したデータを格納する、<paramref name="buffer" /> パラメーター内の位置。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2667">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-2668">受信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2668">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-2669"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2669">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="9cad8-2670">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2670">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="9cad8-2671">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを受信して、データ バッファー内の指定した位置に格納します。またエンドポイントを格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2671">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2672">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2672">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2673"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`buffer` パラメーターにデータを読み取り、正常に読み取られたバイト数を返し、データの送信元のリモートホストエンドポイントをキャプチャします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2673">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="9cad8-2674">この方法は、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2674">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="9cad8-2675">コネクションレスプロトコルを使用すると、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、ローカルネットワークバッファーに受信した最初のエンキューされたデータグラムを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2675">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="9cad8-2676">受信したデータグラムが `buffer`のサイズより大きい場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、可能な限り多くのメッセージを `buffer` に入力し、<xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2676">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2677">信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2677">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="9cad8-2678">信頼できるプロトコルを使用している場合は、余分なデータがサービスプロバイダーによって保持され、十分な大きさのバッファーを使用して <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出すことで取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2678">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="9cad8-2679">データを読み取ることができない場合、データが使用可能になるまで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドはブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2679">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="9cad8-2680">非ブロッキングモードで、プロトコルスタックバッファーのに使用できるデータがない場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、<xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2680">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2681"><xref:System.Net.Sockets.Socket.Available%2A> プロパティを使用して、データを読み取ることができるかどうかを判断できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2681">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="9cad8-2682"><xref:System.Net.Sockets.Socket.Available%2A> が0以外の場合は、受信操作を再試行してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2682">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="9cad8-2683"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> はコネクションレスプロトコルを対象としていますが、接続指向プロトコルを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2683">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="9cad8-2684">これを選択する場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを呼び出して受信リモートホスト接続を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2684">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-2685"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に接続を確立または受け入れない場合、<xref:System.Net.Sockets.SocketException>が表示されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2685">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2686"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2686">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="9cad8-2687">どちらの場合も、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドは、`remoteEP` パラメーターを無視し、接続されたまたは既定のリモートホストからのデータのみを受信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2687">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="9cad8-2688">接続指向のソケットを使用すると、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> は、`size` パラメーターで指定されたバイト数まで、使用可能な量のデータを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2688">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="9cad8-2689">リモートホストが <xref:System.Net.Sockets.Socket.Shutdown%2A> 方法で <xref:System.Net.Sockets.Socket> 接続を終了し、使用可能なすべてのデータを受信した場合は、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドが直ちに完了し、ゼロバイトが返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2689">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2690"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを使用して <xref:System.Net.Sockets.Socket> をローカルエンドポイントに明示的にバインドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2690">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="9cad8-2691">そうしないと、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2691">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2692"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2692">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2693">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2693">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2694"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> で使用される <xref:System.Net.EndPoint> の <xref:System.Net.Sockets.AddressFamily> は、<xref:System.Net.EndPoint> で使用される <xref:System.Net.Sockets.Socket.SendTo%2A>の <xref:System.Net.Sockets.AddressFamily> と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2694">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2695">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2695">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2696">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2696">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2697">次のコード例では、リモートホストからコネクションレスのデータグラムを受信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2697">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="9cad8-2698">オフセット、バッファーサイズ、および <xref:System.Net.Sockets.SocketFlags> が <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> メソッドに渡されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2698">The offset, buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2699"><paramref name="buffer" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2699"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cad8-2700">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2700">-or-</span></span> 
 <span data-ttu-id="9cad8-2701"><paramref name="remoteEP" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2701"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-2702"><paramref name="offset" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2702"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-2703">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2703">-or-</span></span> 
 <span data-ttu-id="9cad8-2704"><paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2704"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="9cad8-2705">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2705">-or-</span></span> 
 <span data-ttu-id="9cad8-2706"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2706"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-2707">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2707">-or-</span></span> 
 <span data-ttu-id="9cad8-2708"><paramref name="size" /> が、<paramref name="buffer" /> の長さからオフセット パラメーターの値を引いた値を超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2708"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2709"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2709"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="9cad8-2710">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2710">-or-</span></span> 
<span data-ttu-id="9cad8-2711"><see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2711">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="9cad8-2712">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2712">-or-</span></span> 
<span data-ttu-id="9cad8-2713">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2713">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2714"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2714">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2715">ネットワークからの接続を受け入れるために使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2715">for accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2716"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2716">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="9cad8-2717">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2717">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-2718">指定したネットワーク デバイスから、データの非同期の受信を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2718">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2719">I/O 操作が保留中の場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2719"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="9cad8-2720">操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2720">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="9cad8-2721">I/O 操作が同期的に完了した場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2721"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="9cad8-2722">この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2722">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2723"><xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> メソッドは、主にコネクションレスソケットでデータを受信するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2723">The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket.</span></span> <span data-ttu-id="9cad8-2724">ソケットのローカルアドレスがわかっている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2724">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="9cad8-2725">呼び出し元は、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> プロパティを、データを受信するリモートホストの <xref:System.Net.IPEndPoint> に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2725">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="9cad8-2726">`e` パラメーターの <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> プロパティは、Window Sockets service プロバイダーに読み取り要求に関する追加情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2726">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="9cad8-2727">このパラメーターの使用方法の詳細については、「<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2727">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9cad8-2728">このメソッドを正常に呼び出すには、<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2728">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="9cad8-2729">呼び出し元は、<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2729">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="9cad8-2730">コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2730">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="9cad8-2731">メッセージ指向のソケットの場合は、バッファーの合計サイズまで、受信メッセージがバッファーに格納されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2731">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="9cad8-2732"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> プロパティと <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> プロパティによって、バッファー内のデータの格納場所とデータ量が決まります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2732">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="9cad8-2733">バイトストリームスタイルのソケットの場合、バッファーがいっぱいになるか、接続が閉じられるか、内部バッファーデータが使い果たされるまで、受信データがバッファーに配置されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2733">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span> <span data-ttu-id="9cad8-2734"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> プロパティと <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> プロパティによって、バッファー内のデータの格納場所とデータ量が決まります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2734">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2735"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2735">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-2736"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2736">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-2737">このメソッドには Windows XP 以降が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2737">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2738"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2738">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2739">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2739">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2740">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2740">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="9cad8-2741">受信したデータを格納する、<paramref name="buffer" /> パラメーター内の位置。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2741">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-2742">受信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2742">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-2743"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2743">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="9cad8-2744">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2744">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="9cad8-2745">アドレスとインターフェイスの情報を保持する <see cref="T:System.Net.Sockets.IPPacketInformation" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2745">An <see cref="T:System.Net.Sockets.IPPacketInformation" /> holding address and interface information.</span></span></param>
        <summary><span data-ttu-id="9cad8-2746">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータをデータ バッファー内の指定した位置で受信して、エンドポイントおよびパケット情報を格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2746">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2747">受信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2747">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2748"><xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドは、`buffer` パラメーターにデータを読み取り、正常に読み取られたバイト数を返します。さらに、データの送信元のリモートホストエンドポイントと、受信パケットに関する情報をキャプチャします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2748">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</span></span>  
  
 <span data-ttu-id="9cad8-2749"><xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドは、主にコネクションレスソケットでメッセージデータを受信するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2749">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="9cad8-2750">ソケットのローカルアドレスがわかっている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2750">The socket's local address must be known.</span></span> <span data-ttu-id="9cad8-2751">このメソッドは、データグラムと raw ソケットでのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2751">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="9cad8-2752">ソケットは、このメソッドを呼び出す前に、<xref:System.Net.Sockets.SocketType.Dgram> または <xref:System.Net.Sockets.SocketType.Raw> に設定されたソケットの種類を使用して初期化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2752">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="9cad8-2753">これは <xref:System.Net.Sockets.Socket.%23ctor%2A>を使用してソケットを構築するときに行うことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2753">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-2754">メッセージ指向のソケットの場合、受信メッセージは、`size` パラメーターで指定された合計サイズまでの `buffer` パラメーターに配置されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2754">For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter.</span></span> <span data-ttu-id="9cad8-2755">`offset` パラメーターは、データを配置する `buffer` 内の場所を決定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2755">The `offset` parameter determines where in the `buffer` the data is placed.</span></span> <span data-ttu-id="9cad8-2756">`buffer` に格納される実際のデータ量は、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドによって返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2756">The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-2757"><xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドは、<xref:System.Net.Sockets.SocketOptionName.PacketInformation> ソケットオプションを、特定の <xref:System.Net.Sockets.Socket>に対して初めて呼び出すときに `true` するように設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2757">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-2758">ただし、返された <xref:System.Net.Sockets.IPPacketInformation> オブジェクトは、ソケットオプションが設定された後にローカルコンピューターに到着したパケットに対してのみ有効です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2758">However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="9cad8-2759">ソケットがローカルエンドポイントにバインドされたとき (<xref:System.Net.Sockets.Socket.Bind%2A> メソッドによって明示的に、または <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、<xref:System.Net.Sockets.Socket.SendTo%2A>、または <xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドのいずれかによって暗黙的に) にパケットが送信される場合は、そのメソッドの最初の呼び出しです。では、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> メソッドを呼び出すと、これらのパケットに対して無効な <xref:System.Net.Sockets.IPPacketInformation> オブジェクトが返されます。<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A></span><span class="sxs-lookup"><span data-stu-id="9cad8-2759">If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="9cad8-2760">すべての <xref:System.Net.Sockets.IPPacketInformation> オブジェクトが有効であることを確認するには、<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> メソッドを使用してローカルエンドポイントにバインドする前に、アプリケーションで <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket オプションを `true` に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2760">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="9cad8-2761">アプリケーションでは、データグラムがユニキャスト、マルチキャスト、またはブロードキャストアドレスを使用して送信されたかどうかを確認する必要がある場合に、`ipPacketInformation` パラメーターを調べることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2761">An application can examine the `ipPacketInformation` parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2762"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> で使用される <xref:System.Net.EndPoint> の <xref:System.Net.Sockets.AddressFamily> は、<xref:System.Net.EndPoint> で使用される <xref:System.Net.Sockets.Socket.SendTo%2A>の <xref:System.Net.Sockets.AddressFamily> と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2762">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2763">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2763">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2764">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2764">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2765"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2765"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cad8-2766">\- または</span><span class="sxs-lookup"><span data-stu-id="9cad8-2766">\- or-</span></span> 
 <span data-ttu-id="9cad8-2767"><paramref name="remoteEP" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2767"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-2768"><paramref name="offset" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2768"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-2769">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2769">-or-</span></span> 
 <span data-ttu-id="9cad8-2770"><paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2770"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="9cad8-2771">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2771">-or-</span></span> 
 <span data-ttu-id="9cad8-2772"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2772"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-2773">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2773">-or-</span></span> 
 <span data-ttu-id="9cad8-2774"><paramref name="size" /> が、<paramref name="buffer" /> の長さからオフセット パラメーターの値を引いた値を超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2774"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2775"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2775"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="9cad8-2776">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2776">-or-</span></span> 
<span data-ttu-id="9cad8-2777"><see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2777">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="9cad8-2778">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2778">-or-</span></span> 
<span data-ttu-id="9cad8-2779">.NET Framework が、AMD 64 ビット プロセッサ上で実行されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2779">The .NET Framework is running on an AMD 64-bit processor.</span></span>  
  
<span data-ttu-id="9cad8-2780">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-2780">-or-</span></span> 
<span data-ttu-id="9cad8-2781">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2781">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2782"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2782">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-2783">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2783">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="9cad8-2784">ネットワークからの接続を受け入れるために使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2784">for accepting connections from the network.</span></span> <span data-ttu-id="9cad8-2785"><see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="9cad8-2785">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="9cad8-2786">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2786">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-2787">指定された <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> を使用し、指定されたバイト数のデータの非同期受信を開始して、データ バッファー内の指定された場所に格納します。さらに、エンドポイントとパケットの情報を格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2787">Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2788">I/O 操作が保留中の場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2788"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="9cad8-2789">操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2789">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="9cad8-2790">I/O 操作が同期的に完了した場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2790"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="9cad8-2791">この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2791">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2792"><xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> メソッドは、主にコネクションレスソケットでメッセージデータを受信するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2792">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="9cad8-2793">ソケットのローカルアドレスがわかっている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2793">The socket's local address must be known.</span></span> <span data-ttu-id="9cad8-2794">このメソッドは、データグラムと raw ソケットでのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2794">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="9cad8-2795">ソケットは、このメソッドを呼び出す前に、<xref:System.Net.Sockets.SocketType.Dgram> または <xref:System.Net.Sockets.SocketType.Raw> に設定されたソケットの種類を使用して初期化する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2795">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="9cad8-2796">これは <xref:System.Net.Sockets.Socket.%23ctor%2A>を使用してソケットを構築するときに行うことができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2796">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-2797">呼び出し元は、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> プロパティを、データを受信するリモートホストの <xref:System.Net.IPEndPoint> に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2797">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="9cad8-2798">このメソッドを正常に呼び出すには、<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2798">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="9cad8-2799">呼び出し元は、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2799">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="9cad8-2800">コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2800">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="9cad8-2801">メッセージ指向のソケットの場合は、バッファーの合計サイズまで、受信メッセージがバッファーに格納されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2801">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="9cad8-2802"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> プロパティと <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> プロパティによって、バッファー内のデータの格納場所とデータ量が決まります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2802">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="9cad8-2803"><xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> メソッドは、指定された <xref:System.Net.Sockets.Socket>に対して初めて呼び出されたときに、<xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket オプションを `true` に自動的に設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2803">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-2804">ただし、<xref:System.Net.Sockets.IPPacketInformation> オブジェクトは、ソケットオプションが設定された後にローカルコンピューターに到着するパケットに対してのみ有効です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2804">However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="9cad8-2805">ソケットがローカルエンドポイントにバインドされたとき (<xref:System.Net.Sockets.Socket.Bind%2A> メソッドによって明示的に、または <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、<xref:System.Net.Sockets.Socket.SendTo%2A>、または <xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドのいずれかによって暗黙的に) にソケットが送信される場合は、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> メソッドの最初の呼び出しです。では、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> メソッドを呼び出すと、これらのパケットに対して無効な <xref:System.Net.Sockets.IPPacketInformation> オブジェクトが生成されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2805">If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="9cad8-2806">すべての <xref:System.Net.Sockets.IPPacketInformation> オブジェクトが有効であることを確認するには、<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> メソッドを使用してローカルエンドポイントにバインドする前に、アプリケーションで <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket オプションを`true` に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2806">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to`true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="9cad8-2807">アプリケーションでは、データグラムがユニキャスト、マルチキャスト、またはブロードキャストアドレスを使用して送信されたかどうかを確認する必要がある場合に、結果の <xref:System.Net.Sockets.IPPacketInformation> オブジェクトを調べることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2807">An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2808"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2808">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-2809">このメソッドには Windows XP 以降が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2809">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2810"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2810">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2811">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2811">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-2812">同期の <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 呼び出しがタイムアウトするまでの合計時間を指定する値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2812">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Receive" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="9cad8-2813">タイムアウト値 (ミリ秒)。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2813">The time-out value, in milliseconds.</span></span> <span data-ttu-id="9cad8-2814">既定値は 0 です。タイムアウトが無期限であることを示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2814">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="9cad8-2815">-1 の指定も、タイムアウトが無期限であることを示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2815">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2816">このオプションは、同期 <xref:System.Net.Sockets.Socket.Receive%2A> 呼び出しにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2816">This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only.</span></span> <span data-ttu-id="9cad8-2817">タイムアウト期間を超過すると、<xref:System.Net.Sockets.Socket.Receive%2A> メソッドによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2817">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2818">次のコード例は、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> プロパティの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2818">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2819">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2819">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2820"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2820">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-2821">設定操作として指定された値が -1 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2821">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-2822">リモート エンドポイントを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2822">Gets the remote endpoint.</span></span></summary>
        <value><span data-ttu-id="9cad8-2823"><see cref="T:System.Net.EndPoint" /> の通信先の <see cref="T:System.Net.Sockets.Socket" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2823">The <see cref="T:System.Net.EndPoint" /> with which the <see cref="T:System.Net.Sockets.Socket" /> is communicating.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2824">接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> プロパティは、<xref:System.Net.Sockets.Socket> が接続されているリモート IP アドレスとポート番号を含む <xref:System.Net.EndPoint> を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2824">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected.</span></span> <span data-ttu-id="9cad8-2825">コネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> には、<xref:System.Net.Sockets.Socket> が通信する既定のリモート IP アドレスとポート番号が含まれています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2825">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate.</span></span> <span data-ttu-id="9cad8-2826">情報を取得する前に、この <xref:System.Net.EndPoint> を <xref:System.Net.IPEndPoint> にキャストする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2826">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="9cad8-2827">その後、<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> メソッドを呼び出してリモート <xref:System.Net.IPAddress>を取得し、<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> メソッドを呼び出してリモートポート番号を取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2827">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the remote port number.</span></span>  
  
 <span data-ttu-id="9cad8-2828"><xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> は、<xref:System.Net.Sockets.Socket.Accept%2A> または <xref:System.Net.Sockets.Socket.Connect%2A>の呼び出しの後に設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2828">The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-2829">このプロパティにアクセスしようとすると、<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2829">If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2830"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2830">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2831">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2831">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2832">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2832">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2833">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2833">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2834">次のコード例では、ローカルとリモートのエンドポイントを取得して表示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2834">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2835">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2835">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2836"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2836">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-2837">現在の <see cref="T:System.Net.Sockets.Socket" /> オブジェクトによってカプセル化されているソケット ハンドルを表す <see cref="T:System.Net.Sockets.SafeSocketHandle" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2837">Gets a <see cref="T:System.Net.Sockets.SafeSocketHandle" /> that represents the socket handle that the current <see cref="T:System.Net.Sockets.Socket" /> object encapsulates.</span></span></summary>
        <value><span data-ttu-id="9cad8-2838">現在の <see cref="T:System.Net.Sockets.Socket" /> オブジェクトによってカプセル化されるソケットに対して安全な方法で公開されるソケットハンドル。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2838">A socket handle exposed in a safe manner for the socket that the current <see cref="T:System.Net.Sockets.Socket" /> object encapsulates.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!IMPORTANT]
> <span data-ttu-id="9cad8-2839"><xref:System.Net.Sockets.SafeSocketHandle> を使用してソケットを直接操作すると、ドキュメント化されていない状態になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2839">Using the <xref:System.Net.Sockets.SafeSocketHandle> to operate on the socket directly may result in an undocumented state.</span></span> 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="checkRead"><span data-ttu-id="9cad8-2840">読みやすさを確認する <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2840">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for readability.</span></span></param>
        <param name="checkWrite"><span data-ttu-id="9cad8-2841">書き込み機能をチェックする <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2841">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for writability.</span></span></param>
        <param name="checkError"><span data-ttu-id="9cad8-2842">エラーをチェックする <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2842">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for errors.</span></span></param>
        <param name="microSeconds"><span data-ttu-id="9cad8-2843">タイムアウト値 (マイクロ秒)。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2843">The time-out value, in microseconds.</span></span> <span data-ttu-id="9cad8-2844">値が -1 の場合は、タイムアウトが無限であることを示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2844">A -1 value indicates an infinite time-out.</span></span></param>
        <summary><span data-ttu-id="9cad8-2845">1 つまたは複数のソケットのステータスを判断します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2845">Determines the status of one or more sockets.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2846"><xref:System.Net.Sockets.Socket.Select%2A> は、1つ以上の <xref:System.Net.Sockets.Socket> インスタンスの状態を決定する静的メソッドです。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2846"><xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances.</span></span> <span data-ttu-id="9cad8-2847"><xref:System.Net.Sockets.Socket.Select%2A> 方法を使用する前に、1つまたは複数のソケットを <xref:System.Collections.IList> に配置する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2847">You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span> <span data-ttu-id="9cad8-2848">`checkRead` パラメーターとして <xref:System.Collections.IList> を指定して <xref:System.Net.Sockets.Socket.Select%2A> を呼び出すことにより、読みやすさを確認します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2848">Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter.</span></span> <span data-ttu-id="9cad8-2849">書き込み機能のソケットを確認するには、`checkWrite` パラメーターを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2849">To check your sockets for writability, use the `checkWrite` parameter.</span></span> <span data-ttu-id="9cad8-2850">エラー状態を検出するには、`checkError`を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2850">For detecting error conditions, use `checkError`.</span></span> <span data-ttu-id="9cad8-2851"><xref:System.Net.Sockets.Socket.Select%2A>を呼び出すと、条件を満たすソケットだけが <xref:System.Collections.IList> に入力されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2851">After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions.</span></span>  
  
 <span data-ttu-id="9cad8-2852">リッスン状態の場合、読みやすさとは、<xref:System.Net.Sockets.Socket.Accept%2A> の呼び出しがブロックされることなく成功することを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2852">If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking.</span></span> <span data-ttu-id="9cad8-2853">既に接続を受け入れている場合、読みやすさとは、データが読み取り可能であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2853">If you have already accepted the connection, readability means that data is available for reading.</span></span> <span data-ttu-id="9cad8-2854">このような場合、すべての受信操作はブロックされずに成功します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2854">In these cases, all receive operations will succeed without blocking.</span></span> <span data-ttu-id="9cad8-2855">読みやすさは、リモート <xref:System.Net.Sockets.Socket> が接続をシャットダウンしたかどうかを示すこともできます。この場合、<xref:System.Net.Sockets.Socket.Receive%2A> を呼び出すとすぐに返され、バイト数は返されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2855">Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.</span></span>  
  
 <span data-ttu-id="9cad8-2856">対象のソケットの少なくとも1つ (`checkRead`、`checkWrite`、および `checkError` の一覧のソケット) が指定された条件を満たしている場合、または `microSeconds` パラメーターを超えている場合、<xref:System.Net.Sockets.Socket.Select%2A> はを返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2856"><xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first.</span></span> <span data-ttu-id="9cad8-2857">`microSeconds` を-1 に設定すると、無制限のタイムアウトが指定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2857">Setting `microSeconds` to -1 specifies an infinite time-out.</span></span>  
  
 <span data-ttu-id="9cad8-2858"><xref:System.Net.Sockets.Socket.Connect%2A>に対して非ブロッキング呼び出しを行うと、書き込み機能は正常に接続したことを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2858">If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully.</span></span> <span data-ttu-id="9cad8-2859">既に接続が確立されている場合、書き込み機能は、すべての送信操作がブロックせずに成功することを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2859">If you already have a connection established, writability means that all send operations will succeed without blocking.</span></span>  
  
 <span data-ttu-id="9cad8-2860"><xref:System.Net.Sockets.Socket.Connect%2A>に対して非ブロッキング呼び出しを行った場合、`checkerror` パラメーターは、正常に接続されていないソケットを識別します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2860">If you have made a non-blocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, the `checkerror` parameter identifies sockets that have not connected successfully.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2861">1つの <xref:System.Net.Sockets.Socket>の状態を確認するだけの場合は、<xref:System.Net.Sockets.Socket.Poll%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2861">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2862">この方法では、ネットワークケーブルの切断など、特定の種類の接続の問題を検出することはできません。また、リモートホストが異常終了をシャットダウンしたことを確認することもできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2862">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="9cad8-2863">これらの種類のエラーを検出するには、データの送信または受信を試みる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2863">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2864"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2864">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2865">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2865">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2866">次のコード例では、<xref:System.Net.Sockets.Socket.Select%2A> を使用して、接続要求があるリッスンソケットを特定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2866">The following code example uses <xref:System.Net.Sockets.Socket.Select%2A> to determine which listening sockets have a connection request.</span></span>  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2867"><paramref name="checkRead" /> パラメーターは <see langword="null" /> または空です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2867">The <paramref name="checkRead" /> parameter is <see langword="null" /> or empty.</span></span>  
  
<span data-ttu-id="9cad8-2868">および</span><span class="sxs-lookup"><span data-stu-id="9cad8-2868">-and-</span></span> 
<span data-ttu-id="9cad8-2869"><paramref name="checkWrite" /> パラメーターは <see langword="null" /> または空です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2869">The <paramref name="checkWrite" /> parameter is <see langword="null" /> or empty</span></span> 
<span data-ttu-id="9cad8-2870">および</span><span class="sxs-lookup"><span data-stu-id="9cad8-2870">-and-</span></span> 
<span data-ttu-id="9cad8-2871"><paramref name="checkError" /> パラメーターは <see langword="null" /> または空です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2871">The <paramref name="checkError" /> parameter is <see langword="null" /> or empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2872">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2872">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-2873">接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2873">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2874">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2874">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="9cad8-2875">接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2875">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2876"><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2876">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2877"><xref:System.Net.Sockets.Socket.Send%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドに指定されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2877"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="9cad8-2878"><xref:System.Net.Sockets.Socket.Send%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2878"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="9cad8-2879">このオーバーロードには、送信するデータを格納するバッファーが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2879">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="9cad8-2880"><xref:System.Net.Sockets.SocketFlags> 値の既定値は0です。バッファーオフセットの既定値は0で、既定で送信するバイト数はバッファーのサイズに設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2880">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>  
  
 <span data-ttu-id="9cad8-2881">コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2881">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2882">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2882">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="9cad8-2883">コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> 方法を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2883">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="9cad8-2884"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2884">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="9cad8-2885"><xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2885">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-2886">また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に、既定のリモートホストを変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2886">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-2887">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2887">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-2888">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2888">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2889">非ブロッキングモードでは、バッファー内のバイト数よりも少ない場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2889">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="9cad8-2890">アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2890">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="9cad8-2891">また、送信したデータがネットワークに直ちに表示される保証もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2891">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-2892">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2892">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-2893"><xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2893">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2894"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2894">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2895">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2895">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2896">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2896">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-2897">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2897">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2898">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2898">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2899">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2899">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2900">次のコード例は、接続された <xref:System.Net.Sockets.Socket>でデータを送信する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2900">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2901"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2901"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2902">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2902">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2903"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2903">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="9cad8-2904">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2904">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="9cad8-2905">リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2905">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2906"><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2906">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2907"><xref:System.Net.Sockets.Socket.Send%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2907"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="9cad8-2908">このオーバーロードには、送信するデータを含むバッファーが少なくとも1つ必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2908">This overload requires at least one buffer that contains the data you want to send.</span></span>  
  
 <span data-ttu-id="9cad8-2909">コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2909">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2910">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2910">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="9cad8-2911">コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> 方法を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2911">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="9cad8-2912"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2912">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="9cad8-2913"><xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2913">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-2914">また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に、既定のリモートホストを変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2914">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-2915">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2915">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-2916">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2916">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2917">非ブロッキングモードでは、バッファー内のバイト数よりも少ない場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2917">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="9cad8-2918">アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2918">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="9cad8-2919">また、送信したデータがネットワークに直ちに表示される保証もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2919">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-2920">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2920">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-2921"><xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2921">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2922"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2922">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2923">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2923">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2924">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2924">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-2925">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2925">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2926">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2926">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2927">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2927">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2928"><paramref name="buffers" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2928"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-2929"><paramref name="buffers" /> が空です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2929"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2930">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2930">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="9cad8-2931">以下の解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2931">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2932"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2932">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2933">送信されるデータを含むバイトのスパン。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2933">A span of bytes that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="9cad8-2934">接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2934">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2935"><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2935">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="9cad8-2936"><xref:System.Net.Sockets.Socket.Send%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドに指定されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2936"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="9cad8-2937"><xref:System.Net.Sockets.Socket.Send%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2937"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>

<span data-ttu-id="9cad8-2938">このオーバーロードには、送信するデータを格納するバッファーが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2938">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="9cad8-2939"><xref:System.Net.Sockets.SocketFlags> 値の既定値は0です。バッファーオフセットの既定値は0で、既定で送信するバイト数はバッファーのサイズに設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2939">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>

<span data-ttu-id="9cad8-2940">コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2940">If you're using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2941">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2941">If you're using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>

<span data-ttu-id="9cad8-2942">コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2942">If you're using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="9cad8-2943"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2943">If you don't use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you'll have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="9cad8-2944"><xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2944">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-2945">また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に既定のリモートホストを変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2945">You can also change the default remote host before calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>

<span data-ttu-id="9cad8-2946">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2946">If you're using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-2947">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2947">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2948">非ブロッキングモードでは、バッファー内のバイト数よりも少ない場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2948">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="9cad8-2949">アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2949">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="9cad8-2950">また、送信したデータがネットワークに直ちに表示されるという保証もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2950">There's also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-2951">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2951">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-2952"><xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2952">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>

> [!NOTE]
><span data-ttu-id="9cad8-2953"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2953">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2954">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2954">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="9cad8-2955">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2955">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2956">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2956">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>

> [!IMPORTANT]
><span data-ttu-id="9cad8-2957">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2957">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-2958">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2958">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2959">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2959">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2960"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2960">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-2961">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2961">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-2962"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2962">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="9cad8-2963">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2963">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2964"><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2964">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2965"><xref:System.Net.Sockets.Socket.Send%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2965"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="9cad8-2966"><xref:System.Net.Sockets.Socket.Send%2A> メソッドは、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2966">The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="9cad8-2967">このオーバーロードには、送信するデータを格納するバッファーと、<xref:System.Net.Sockets.SocketFlags>のビットごとの組み合わせが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2967">This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="9cad8-2968">バッファーオフセットの既定値は0で、既定で送信されるバイト数はバッファーのサイズに設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2968">The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span> <span data-ttu-id="9cad8-2969"><xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーター値として指定した場合、送信しようとしているデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2969">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="9cad8-2970">コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2970">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2971">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2971">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="9cad8-2972">コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> 方法を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2972">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="9cad8-2973"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2973">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="9cad8-2974"><xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2974">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-2975">また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に、既定のリモートホストを変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2975">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-2976">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2976">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-2977">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2977">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2978">非ブロッキングモードでは、バッファー内のバイト数よりも少ない場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2978">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="9cad8-2979">アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2979">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="9cad8-2980">また、送信したデータがネットワークに直ちに表示される保証もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2980">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-2981">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2981">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-2982"><xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2982">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2983">バッファーのサイズが、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2983">You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-2984">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2984">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-2985"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2985">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-2986">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2986">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2987">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2987">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-2988">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2988">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-2989">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2989">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-2990">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2990">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-2991">次のコード例は、接続された <xref:System.Net.Sockets.Socket>でデータを送信する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2991">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-2992"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2992"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-2993">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2993">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-2994"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2994">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="9cad8-2995">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2995">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-2996"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2996">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="9cad8-2997">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2997">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-2998"><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2998">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-2999">このオーバーロードには、送信するデータを含むバッファーが少なくとも1つ必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-2999">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="9cad8-3000"><xref:System.Net.Sockets.SocketFlags> 値の既定値は0です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3000">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="9cad8-3001"><xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketFlags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3001">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="9cad8-3002">コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3002">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3003">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3003">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="9cad8-3004">コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> 方法を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3004">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="9cad8-3005"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3005">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="9cad8-3006"><xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3006">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-3007">また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に、既定のリモートホストを変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3007">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-3008">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3008">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-3009">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3009">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3010">非ブロッキングモードでは、<xref:System.Net.Sockets.Socket.Send%2A> がバッファー内のバイト数よりも少ない場合でも、正常に完了することがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3010">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="9cad8-3011">アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3011">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="9cad8-3012">また、送信したデータがネットワークに直ちに表示される保証もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3012">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-3013">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3013">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-3014"><xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3014">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3015"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3015">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3016">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3016">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3017">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3017">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-3018">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3018">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3019">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3019">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3020">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3020">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-3021"><paramref name="buffers" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3021"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-3022"><paramref name="buffers" /> が空です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3022"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3023">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3023">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3024"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3024">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-3025">送信されるデータを含むバイトのスパン。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3025">A span of bytes that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-3026">送受信の動作を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3026">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <summary><span data-ttu-id="9cad8-3027">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3027">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-3028"><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3028">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  

  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3029">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3029">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3030"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3030">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-3031">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3031">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-3032">送信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3032">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-3033"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3033">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="9cad8-3034">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3034">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-3035"><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3035">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<span data-ttu-id="9cad8-3036"><xref:System.Net.Sockets.Socket.Send%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで確立されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3036"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="9cad8-3037"><xref:System.Net.Sockets.Socket.Send%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3037"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>

<span data-ttu-id="9cad8-3038">このオーバーロードには、送信するデータを含むバッファー、送信するバイト数、および <xref:System.Net.Sockets.SocketFlags>のビットごとの組み合わせが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3038">This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="9cad8-3039"><xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しているデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3039">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you're sending won't be routed.</span></span>

<span data-ttu-id="9cad8-3040">コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3040">If you're using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3041">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3041">If you're using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>

<span data-ttu-id="9cad8-3042">コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3042">If you're using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="9cad8-3043"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを呼び出すたびに、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3043">If you don'tuse the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you'll have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="9cad8-3044"><xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3044">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you've established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-3045">また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に既定のリモートホストを変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3045">You can also change the default remote host before calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>

<span data-ttu-id="9cad8-3046">接続指向プロトコルでは、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、要求されたバイト数が送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3046">With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-3047">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3047">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3048">非ブロッキングモードでは、要求したバイト数よりも少ない時間で送信された場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3048">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="9cad8-3049">アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3049">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="9cad8-3050">また、送信したデータがネットワークに直ちに表示される保証もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3050">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-3051">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3051">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-3052"><xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3052">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>

> [!NOTE]
> <span data-ttu-id="9cad8-3053">サイズが、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3053">You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-3054">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.Send%2A> が <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3054">If it does, the datagram won't be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3055"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3055">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3056">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3056">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="9cad8-3057">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3057">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3058">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3058">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>

> [!IMPORTANT]
><span data-ttu-id="9cad8-3059">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3059">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-3060">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3060">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>

## Examples

<span data-ttu-id="9cad8-3061">次のコード例では、buffer で見つかったデータを送信し、<xref:System.Net.Sockets.SocketFlags>の <xref:System.Net.Sockets.SocketFlags.None> を指定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3061">The following code example sends the data found in buffer, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>

[!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
[!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
[!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-3062"><paramref name="buffer" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3062"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-3063"><paramref name="size" /> が 0 未満か、バッファーのサイズを超える値です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3063"><paramref name="size" /> is less than 0 or exceeds the size of the buffer.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3064"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3064"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="9cad8-3065">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3065">-or-</span></span> 
<span data-ttu-id="9cad8-3066">ソケットへのアクセス中にオペレーティング システム エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3066">An operating system error occurs while accessing the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3067"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3067">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="9cad8-3068">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3068">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-3069"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3069">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="9cad8-3070">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3070">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="9cad8-3071">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3071">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-3072"><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3072">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3073">このオーバーロードには、送信するデータを含むバッファーが少なくとも1つ必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3073">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="9cad8-3074"><xref:System.Net.Sockets.SocketFlags> 値の既定値は0です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3074">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="9cad8-3075"><xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketFlags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3075">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="9cad8-3076">コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3076">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3077">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3077">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="9cad8-3078">コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> 方法を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3078">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="9cad8-3079"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3079">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="9cad8-3080"><xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3080">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-3081">また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に、既定のリモートホストを変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3081">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-3082">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3082">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-3083">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3083">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3084">非ブロッキングモードでは、<xref:System.Net.Sockets.Socket.Send%2A> がバッファー内のバイト数よりも少ない場合でも、正常に完了することがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3084">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="9cad8-3085">アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3085">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="9cad8-3086">また、送信したデータがネットワークに直ちに表示される保証もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3086">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-3087">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3087">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-3088"><xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3088">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3089"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3089">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3090">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3090">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3091">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3091">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-3092">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3092">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3093">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3093">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3094">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3094">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-3095"><paramref name="buffers" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3095"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-3096"><paramref name="buffers" /> が空です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3096"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3097">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3097">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3098"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3098">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-3099">送信されるデータを含むバイトのスパン。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3099">A span of bytes that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-3100">送受信の動作を指定する列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3100">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <param name="errorCode"><span data-ttu-id="9cad8-3101">このメソッドから制御が戻るときに、ソケットのエラー コードを定義する列挙値の 1 つを格納します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3101">When this method returns, contains one of the enumeration values that defines error codes for the socket.</span></span></param>
        <summary><span data-ttu-id="9cad8-3102">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3102">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-3103"><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3103">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<span data-ttu-id="9cad8-3104"><xref:System.Net.Sockets.Socket.Send%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドに指定されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3104"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="9cad8-3105"><xref:System.Net.Sockets.Socket.Send%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3105"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>

<span data-ttu-id="9cad8-3106">このオーバーロードには、送信するデータを格納するバッファーが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3106">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="9cad8-3107"><xref:System.Net.Sockets.SocketFlags> 値の既定値は0です。バッファーオフセットの既定値は0で、既定で送信するバイト数はバッファーのサイズに設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3107">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>

<span data-ttu-id="9cad8-3108">コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3108">If you're using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3109">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3109">If you're using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>

<span data-ttu-id="9cad8-3110">コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3110">If you're using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="9cad8-3111"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3111">If you don't use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you'll have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="9cad8-3112"><xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3112">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you've established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-3113">また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に既定のリモートホストを変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3113">You can also change the default remote host before calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>

<span data-ttu-id="9cad8-3114">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、バッファー内のすべてのバイトが送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3114">If you're using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-3115">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3115">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3116">非ブロッキングモードでは、バッファー内のバイト数よりも少ない場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3116">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="9cad8-3117">アプリケーションは、送信されたバイト数を追跡し、アプリケーションがバッファー内のバイトを送信するまで操作を再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3117">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="9cad8-3118">また、送信したデータがネットワークに直ちに表示されるという保証もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3118">There's also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-3119">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3119">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-3120"><xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3120">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>

> [!NOTE]
><span data-ttu-id="9cad8-3121"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3121">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3122">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3122">After you've obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="9cad8-3123">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3123">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3124">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3124">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>

> [!IMPORTANT]
><span data-ttu-id="9cad8-3125">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3125">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-3126">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3126">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3127">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3127">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3128"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3128">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-3129">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3129">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="9cad8-3130">データの送信を開始する、データ バッファー内の位置。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3130">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-3131">送信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3131">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-3132"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3132">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="9cad8-3133">指定したオフセットから開始し、指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3133">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-3134"><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3134">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3135"><xref:System.Net.Sockets.Socket.Send%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドに指定されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3135"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="9cad8-3136"><xref:System.Net.Sockets.Socket.Send%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3136"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="9cad8-3137">このオーバーロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信するデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3137">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="9cad8-3138">コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> が <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3138">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3139">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3139">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="9cad8-3140">コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3140">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="9cad8-3141"><xref:System.Net.Sockets.Socket.SendTo%2A>を使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3141">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="9cad8-3142"><xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3142">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-3143">また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に、既定のリモートホストを変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3143">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-3144">また、サイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3144">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-3145">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3145">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="9cad8-3146">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、要求されたバイト数が送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3146">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-3147">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3147">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3148">非ブロッキングモードでは、要求したバイト数よりも少ない時間で送信された場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3148">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="9cad8-3149">アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3149">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="9cad8-3150">また、送信したデータがネットワークに直ちに表示される保証もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3150">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-3151">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3151">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-3152"><xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3152">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3153"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3153">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3154">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3154">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3155">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3155">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-3156">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3156">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3157">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3157">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3158">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3158">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3159">次のコード例では、接続されている <xref:System.Net.Sockets.Socket>にデータを送信するためのデータバッファー、オフセット、サイズ、および <xref:System.Net.Sockets.SocketFlags> を指定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3159">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-3160"><paramref name="buffer" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3160"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-3161"><paramref name="offset" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3161"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-3162">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3162">-or-</span></span> 
 <span data-ttu-id="9cad8-3163"><paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3163"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="9cad8-3164">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3164">-or-</span></span> 
 <span data-ttu-id="9cad8-3165"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3165"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-3166">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3166">-or-</span></span> 
 <span data-ttu-id="9cad8-3167"><paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3167"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3168"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3168"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="9cad8-3169">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3169">-or-</span></span> 
<span data-ttu-id="9cad8-3170"><see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3170">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3171"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3171">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-3172">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3172">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="9cad8-3173">データの送信を開始する、データ バッファー内の位置。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3173">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-3174">送信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3174">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-3175"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3175">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="9cad8-3176">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3176">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="9cad8-3177">指定したオフセットから開始し、指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3177">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" /></span></span></summary>
        <returns><span data-ttu-id="9cad8-3178"><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3178">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3179"><xref:System.Net.Sockets.Socket.Send%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドに指定されたリモートホストにデータを同期的に送信し、正常に送信されたバイト数を返します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3179"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="9cad8-3180"><xref:System.Net.Sockets.Socket.Send%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3180"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="9cad8-3181">このオーバーロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信するデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3181">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="9cad8-3182">コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。または、<xref:System.Net.Sockets.Socket.Send%2A> が <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3182">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3183">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3183">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="9cad8-3184">コネクションレスプロトコルを使用していて、複数の異なるホストにデータを送信することを計画している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3184">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="9cad8-3185"><xref:System.Net.Sockets.Socket.SendTo%2A>を使用しない場合は、<xref:System.Net.Sockets.Socket.Send%2A>を呼び出すたびに <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3185">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="9cad8-3186"><xref:System.Net.Sockets.Socket.Connect%2A>を使用して既定のリモートホストを確立した後でも、<xref:System.Net.Sockets.Socket.SendTo%2A> を使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3186">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="9cad8-3187">また、<xref:System.Net.Sockets.Socket.Connect%2A>への別の呼び出しを行うことによって、<xref:System.Net.Sockets.Socket.Send%2A> を呼び出す前に、既定のリモートホストを変更することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3187">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-3188">また、サイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3188">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-3189">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.Send%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3189">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="9cad8-3190">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>を使用してタイムアウトが設定されていない限り、要求されたバイト数が送信されるまで、<xref:System.Net.Sockets.Socket.Send%2A> はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3190">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-3191">タイムアウト値を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A> の呼び出しによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3191">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3192">非ブロッキングモードでは、要求したバイト数よりも少ない時間で送信された場合でも、<xref:System.Net.Sockets.Socket.Send%2A> は正常に完了することがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3192">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="9cad8-3193">アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3193">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="9cad8-3194">また、送信したデータがネットワークに直ちに表示される保証もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3194">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-3195">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3195">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-3196"><xref:System.Net.Sockets.Socket.Send%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3196">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3197"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3197">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3198">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3198">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3199">送信が正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3199">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="9cad8-3200">転送されるデータを保持するためにトランスポートシステム内で使用できるバッファー領域がない場合、ソケットが非ブロッキングモードに設定されていない限り、send はブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3200">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3201">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3201">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3202">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3202">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3203">次のコード例では、接続されている <xref:System.Net.Sockets.Socket>にデータを送信するためのデータバッファー、オフセット、サイズ、および <xref:System.Net.Sockets.SocketFlags> を指定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3203">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-3204"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3204"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-3205"><paramref name="offset" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3205"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-3206">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3206">-or-</span></span> 
 <span data-ttu-id="9cad8-3207"><paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3207"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="9cad8-3208">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3208">-or-</span></span> 
 <span data-ttu-id="9cad8-3209"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3209"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-3210">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3210">-or-</span></span> 
 <span data-ttu-id="9cad8-3211"><paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3211"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3212"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3212"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="9cad8-3213">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3213">-or-</span></span> 
<span data-ttu-id="9cad8-3214"><see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3214">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3215"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3215">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="9cad8-3216">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3216">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-3217">接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、データを非同期に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3217">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="9cad8-3218">I/O 操作が保留中の場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3218"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="9cad8-3219">操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3219">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="9cad8-3220">I/O 操作が同期的に完了した場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3220"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="9cad8-3221">この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3221">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3222"><xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドは、接続指向のソケット上の1つ以上のバッファーから送信データを書き込むために使用されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3222">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</span></span> <span data-ttu-id="9cad8-3223">ただし、このメソッドは、接続操作でリモートホストを指定したコネクションレスソケットでも使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3223">This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</span></span>  
  
 <span data-ttu-id="9cad8-3224"><xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドは、<xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドで確立されたリモートホストへの非同期の送信操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3224">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-3225">このメソッドを正常に呼び出すには、<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3225">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="9cad8-3226"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> または <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="9cad8-3226"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="9cad8-3227"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> が設定されている場合は <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="9cad8-3227"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="9cad8-3228"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> が設定されている場合は <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="9cad8-3228"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="9cad8-3229">呼び出し元は、<xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3229">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="9cad8-3230">コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3230">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="9cad8-3231">最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A>を呼び出さない場合、<xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドは例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3231">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span></span>  
  
 <span data-ttu-id="9cad8-3232"><xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドを呼び出すと、別の実行スレッド内でデータを送信できるようになります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3232">Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="9cad8-3233">メッセージ指向のソケットの場合、基になる Windows sockets service プロバイダーの最大メッセージサイズを超えないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3233">For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</span></span> <span data-ttu-id="9cad8-3234">データが長すぎて、基になるサービスプロバイダーを通じてアトミックに渡すことができない場合、データは送信されず、<xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドは、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> がネイティブ Winsock WSAEMSGSIZE エラーコード (10040) に設定された <xref:System.Net.Sockets.SocketException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3234">If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEMSGSIZE error code (10040).</span></span>  
  
 <span data-ttu-id="9cad8-3235"><xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドが正常に完了したことは、データが正常に配信されたことを示していないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3235">Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-3236"><paramref name="e" /> パラメーターの <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> プロパティまたは <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティは、有効なバッファーを参照する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3236">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="9cad8-3237">これらのプロパティは、どちらか 1 つを設定できます。一度に両方のプロパティを設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3237">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-3238"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3238">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-3239">このメソッドには Windows XP 以降が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3239">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3240"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3240">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3241"><see cref="T:System.Net.Sockets.Socket" /> がまだ接続されていないか、<see cref="M:System.Net.Sockets.Socket.Accept" />、<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />、または <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> の各メソッドによって取得されませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3241">The <see cref="T:System.Net.Sockets.Socket" /> is not yet connected or was not obtained via an <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />,or <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, method.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-3242"><see cref="T:System.Net.Sockets.Socket" /> の送信バッファーのサイズを指定する値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3242">Gets or sets a value that specifies the size of the send buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="9cad8-3243">送信バッファーのサイズ (バイト単位) を格納している <see cref="T:System.Int32" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3243">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the send buffer.</span></span> <span data-ttu-id="9cad8-3244">既定値は 8192 です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3244">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3245">バッファーサイズを大きくすると、接続の問題の認識が遅れる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3245">A larger buffer size might delay the recognition of connection difficulties.</span></span> <span data-ttu-id="9cad8-3246">大きなファイルを転送する場合や、高帯域幅の高待機時間接続 (サテライトブロードバンドプロバイダーなど) を使用している場合は、バッファーサイズを大きくすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3246">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3247">次のコード例は、<xref:System.Net.Sockets.Socket.SendBufferSize%2A> プロパティの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3247">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3248">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3248">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3249"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3249">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-3250">設定操作として指定された値が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3250">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-3251">接続された <see cref="T:System.Net.Sockets.Socket" /> に、ファイルおよびオプション データを同期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3251">Sends a file and optional data synchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="9cad8-3252">送信されるファイルのパスと名前を含む <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3252">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="9cad8-3253">このパラメーターは、<see langword="null" /> に設定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3253">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="9cad8-3254"><see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 送信フラグを使用して、接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> を送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3254">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object with the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> transmit flag.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3255">このオーバーロードは、接続されているソケットにファイル `fileName` を送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3255">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="9cad8-3256">`flags` パラメーターの既定値は <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) で、`preBuffer` と `postBuffer` のパラメーターは既定で `null`に設定されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3256">The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`.</span></span> <span data-ttu-id="9cad8-3257">`fileName` がローカルディレクトリにある場合は、ファイル名だけで識別できます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3257">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="9cad8-3258">ワイルドカード ("..\\\myfile.txt ") と UNC 共有名 ("\\\\\\\ 共有ディレクトリ\\\myfile.txt ") はサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3258">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="9cad8-3259">ファイルが見つからない場合は、例外 <xref:System.IO.FileNotFoundException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3259">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="9cad8-3260">このメソッドは、Windows Sockets 2 API の `TransmitFile` 関数を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3260">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="9cad8-3261">`TransmitFile` 関数とそのフラグの詳細については、 [Windows Sockets](/windows/desktop/WinSock/)のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3261">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="9cad8-3262"><xref:System.Net.Sockets.Socket.SendFile%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで指定されたリモートホストにファイルを同期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3262"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-3263"><xref:System.Net.Sockets.Socket.SendFile%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3263"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="9cad8-3264">コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。そうしないと <xref:System.Net.Sockets.Socket.SendFile%2A> は <xref:System.Net.Sockets.SocketException> 例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3264">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span> <span data-ttu-id="9cad8-3265">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3265">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="9cad8-3266">接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.SendFile%2A> は、ファイルが送信されるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3266">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent.</span></span> <span data-ttu-id="9cad8-3267">非ブロッキングモードでは、ファイル全体が送信される前に <xref:System.Net.Sockets.Socket.SendFile%2A> が正常に完了することがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3267">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="9cad8-3268">送信したデータがネットワークに直ちに表示される保証はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3268">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-3269">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3269">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-3270"><xref:System.Net.Sockets.Socket.SendFile%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3270">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3271"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3271">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3272">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3272">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3273">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3273">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3274">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3274">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3275">次のコード例では、ソケットを作成して接続し、リモートホストにファイルを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3275">The following code example creates and connects a socket and then sends a file to the remote host.</span></span> <span data-ttu-id="9cad8-3276">ファイル "test.txt" は、ローカルコンピューターのルートディレクトリにあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3276">The file "test.txt" is located in the root directory of the local machine.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-3277">ソケットがリモート ホストに接続されていません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3277">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3278"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3278">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-3279"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3279">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9cad8-3280">ファイル <paramref name="fileName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3280">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3281">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3281">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="9cad8-3282">送信されるファイルのパスと名前を含む <see cref="T:System.String" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3282">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="9cad8-3283">このパラメーターは、<see langword="null" /> に設定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3283">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="9cad8-3284">ファイルが送信される前に送信されるデータを格納する <see cref="T:System.Byte" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3284">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="9cad8-3285">このパラメーターは、<see langword="null" /> に設定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3285">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="9cad8-3286">ファイルが送信された後で送信されるデータを格納する <see cref="T:System.Byte" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3286">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="9cad8-3287">このパラメーターは、<see langword="null" /> に設定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3287">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="9cad8-3288">1 つ以上の <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3288">One or more of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <summary><span data-ttu-id="9cad8-3289">指定した <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> およびデータのバッファーを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3289">Sends the file <paramref name="fileName" /> and buffers of data to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the specified <see cref="T:System.Net.Sockets.TransmitFileOptions" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3290">このオーバーロードには、送信するファイルの名前と <xref:System.Net.Sockets.TransmitFileOptions> 値のビットごとの組み合わせが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3290">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="9cad8-3291">`preBuffer` パラメーターには、ファイルの前に配置するデータが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3291">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="9cad8-3292">`postBuffer` には、ファイルに従う必要があるデータが含まれています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3292">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="9cad8-3293">`fileName` が現在の作業ディレクトリにある場合は、ファイル名だけで識別できます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3293">If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="9cad8-3294">ワイルドカード ("..\\\myfile.txt ") と UNC 共有名 ("\\\\\\\ 共有ディレクトリ\\\myfile.txt ") はサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3294">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span>  
  
 <span data-ttu-id="9cad8-3295">`flags` パラメーターは、ファイル転送に関する追加情報を Window Sockets service プロバイダーに提供します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3295">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="9cad8-3296">このパラメーターの使用方法の詳細については、「<xref:System.Net.Sockets.TransmitFileOptions>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3296">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="9cad8-3297">このメソッドは、Windows Sockets 2 API の `TransmitFile` 関数を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3297">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="9cad8-3298">`TransmitFile` 関数とそのフラグの詳細については、 [Windows Sockets](/windows/desktop/WinSock/)のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3298">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="9cad8-3299"><xref:System.Net.Sockets.Socket.SendFile%2A> は、<xref:System.Net.Sockets.Socket.Connect%2A> または <xref:System.Net.Sockets.Socket.Accept%2A> メソッドで指定されたリモートホストにファイルを同期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3299"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-3300"><xref:System.Net.Sockets.Socket.SendFile%2A> は、接続指向プロトコルとコネクションレスプロトコルの両方に使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3300"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="9cad8-3301">コネクションレスプロトコルを使用している場合は、このメソッドを呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> を呼び出す必要があります。それ以外の場合 <xref:System.Net.Sockets.Socket.SendFile%2A> は <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3301">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3302">接続指向プロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.Connect%2A> を使用してリモートホスト接続を確立するか、<xref:System.Net.Sockets.Socket.Accept%2A> を使用して受信接続を許可する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3302">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="9cad8-3303">接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.SendFile%2A> は、ファイル全体が送信されるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3303">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="9cad8-3304">非ブロッキングモードでは、ファイル全体が送信される前に <xref:System.Net.Sockets.Socket.SendFile%2A> が正常に完了することがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3304">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="9cad8-3305">送信したデータがネットワークに直ちに表示される保証はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3305">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-3306">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3306">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-3307"><xref:System.Net.Sockets.Socket.SendFile%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3307">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3308"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3308">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3309">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3309">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3310">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3310">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3311">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3311">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3312">次のコード例では、ソケットを作成して接続します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3312">The following code example creates and connects a socket.</span></span> <span data-ttu-id="9cad8-3313">ファイル "test.txt" は、ローカルコンピューターのルートディレクトリにあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3313">The file "test.txt" is located in the root directory of the local machine.</span></span> <span data-ttu-id="9cad8-3314">この例では、データの prebuffer と postbuffer を作成し、ファイルを使用してリモートホストに送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3314">In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</span></span> <span data-ttu-id="9cad8-3315">既定の <xref:System.Net.Sockets.TransmitFileOptions> が使用されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3315">The default <xref:System.Net.Sockets.TransmitFileOptions> are used.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-3316">オペレーティング システムは Windows NT 以降ではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3316">The operating system is not Windows NT or later.</span></span>  
  
<span data-ttu-id="9cad8-3317">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3317">-or-</span></span>
  
 <span data-ttu-id="9cad8-3318">ソケットがリモート ホストに接続されていません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3318">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3319"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3319">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-3320"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3320">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9cad8-3321">ファイル <paramref name="fileName" /> が見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3321">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3322">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3322">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="9cad8-3323">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3323">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-3324">接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルのコレクションまたはメモリ内のデータ バッファーを非同期に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3324">Sends a collection of files or in memory data buffers asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="9cad8-3325">I/O 操作が保留中の場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3325"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="9cad8-3326">操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3326">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="9cad8-3327">I/O 操作が同期的に完了した場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3327"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="9cad8-3328">この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3328">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3329"><xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> メソッドは、ファイルのコレクションまたはメモリ内のデータバッファーをリモートホストに送信するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3329">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host.</span></span> <span data-ttu-id="9cad8-3330"><xref:System.Net.Sockets.Socket> は、リモートホストに既に接続されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3330">The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.</span></span>  
  
 <span data-ttu-id="9cad8-3331"><xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> が作業ディレクトリ内のファイルを参照している場合は、ファイル名だけで識別できます。それ以外の場合は、ファイルの完全なパスと名前を指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3331">If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="9cad8-3332">ワイルドカードと UNC 共有名がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3332">Wildcards and UNC share names are supported.</span></span> <span data-ttu-id="9cad8-3333">ファイルが見つからない場合は、<xref:System.IO.FileNotFoundException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3333">If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="9cad8-3334">完了を通知するには、EventHandler\<SocketAsyncEventArgs > delegate を実装するコールバックメソッドを作成し、コールバックを <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> イベントにアタッチする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3334">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="9cad8-3335">`e` パラメーターの <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> プロパティは、Windows ソケットサービスプロバイダーにファイル転送に関する追加情報を提供します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3335">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="9cad8-3336">このパラメーターの使用方法の詳細については、「<xref:System.Net.Sockets.TransmitFileOptions>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3336">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="9cad8-3337">このメソッドを正常に呼び出すには、<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3337">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="9cad8-3338">呼び出し元は、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3338">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="9cad8-3339">コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3339">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="9cad8-3340">このメソッドは、Windows Sockets 2 API の送信パケット関数を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3340">This method uses the TransmitPackets function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="9cad8-3341">送信パケット関数とそのフラグの詳細については、 [Windows ソケット](/windows/desktop/WinSock/)のドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3341">For more information about the TransmitPackets function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="9cad8-3342"><xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> メソッドは、接続指向プロトコルを対象としていますが、最初に <xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドを呼び出して既定のリモートホストを確立した場合、コネクションレスプロトコルでも機能します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3342">Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host.</span></span> <span data-ttu-id="9cad8-3343">コネクションレスプロトコルを使用する場合は、ファイルのサイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3343">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-3344">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> は <xref:System.Net.Sockets.SocketException> 例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3344">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
 <span data-ttu-id="9cad8-3345"><xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法は、使用されているオペレーティングシステムに応じて最適化されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3345">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used.</span></span> <span data-ttu-id="9cad8-3346">Windows server のエディションでは、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法は高パフォーマンスのために最適化されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3346">On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.</span></span>  
  
 <span data-ttu-id="9cad8-3347">Windows クライアントのエディションでは、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> 方法は、メモリとリソースの使用率が最小になるように最適化されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3347">On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization.</span></span>  
  
 <span data-ttu-id="9cad8-3348">`e` パラメーターの <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> プロパティで <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> フラグを使用すると、パフォーマンスが大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3348">Use of the <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter can deliver significant performance benefits.</span></span> <span data-ttu-id="9cad8-3349"><xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> メソッド呼び出しを開始しているスレッドが大量の計算に使用されている場合、その Apc が起動できなくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3349">If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</span></span> <span data-ttu-id="9cad8-3350">カーネルとユーザーモードの Apc には違いがあることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3350">Note that there is a difference between kernel and user-mode APCs.</span></span> <span data-ttu-id="9cad8-3351">スレッドが待機状態になると、カーネル Apc が起動します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3351">Kernel APCs launch when a thread is in a wait state.</span></span> <span data-ttu-id="9cad8-3352">スレッドが警告可能な待機状態になったときにユーザーモードの Apc が起動する</span><span class="sxs-lookup"><span data-stu-id="9cad8-3352">User-mode APCs launch when a thread is in an alertable wait state</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="9cad8-3353"><see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> プロパティで指定されたファイルが見つかりませんでした。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3353">The file specified in the <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> property was not found.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-3354"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3354">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-3355">このメソッドには Windows XP 以降が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3355">Windows XP or later is required for this method.</span></span> <span data-ttu-id="9cad8-3356">この例外は、<see cref="T:System.Net.Sockets.Socket" /> がリモート ホストに接続されていない場合にも発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3356">This exception also occurs if the <see cref="T:System.Net.Sockets.Socket" /> is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3357"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3357">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3358">コネクションレスの <see cref="T:System.Net.Sockets.Socket" /> が使用されており、送信するファイルが基になるトランスポートの最大パケット サイズを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3358">A connectionless <see cref="T:System.Net.Sockets.Socket" /> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-3359">同期の <see cref="Overload:System.Net.Sockets.Socket.Send" /> 呼び出しがタイムアウトするまでの合計時間を指定する値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3359">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Send" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="9cad8-3360">タイムアウト値 (ミリ秒)。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3360">The time-out value, in milliseconds.</span></span> <span data-ttu-id="9cad8-3361">プロパティに 1 から 499 までの値を設定しても、その値は 500 に変更されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3361">If you set the property with a value between 1 and 499, the value will be changed to 500.</span></span> <span data-ttu-id="9cad8-3362">既定値は 0 です。タイムアウトが無期限であることを示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3362">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="9cad8-3363">-1 の指定も、タイムアウトが無期限であることを示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3363">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3364">このオプションは、同期 <xref:System.Net.Sockets.Socket.Send%2A> 呼び出しにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3364">This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only.</span></span> <span data-ttu-id="9cad8-3365">タイムアウト期間を超過すると、<xref:System.Net.Sockets.Socket.Send%2A> メソッドによって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3365">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3366">次のコード例は、<xref:System.Net.Sockets.Socket.SendTimeout%2A> プロパティの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3366">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3367">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3367">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3368"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3368">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-3369">設定操作として指定された値が -1 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3369">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-3370">データを特定のエンドポイントに送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3370">Sends data to a specific endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-3371">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3371">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="9cad8-3372">データの送信先を表す <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3372">The <see cref="T:System.Net.EndPoint" /> that represents the destination for the data.</span></span></param>
        <summary><span data-ttu-id="9cad8-3373">指定したエンドポイントにデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3373">Sends data to the specified endpoint.</span></span></summary>
        <returns><span data-ttu-id="9cad8-3374">送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3374">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3375">このオーバーロードでは、バッファーオフセットの既定値は0、既定値を送信するバイト数は `buffer` パラメーターのサイズ、<xref:System.Net.Sockets.SocketFlags> 値の既定値は0です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3375">In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the `buffer` parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span>  
  
 <span data-ttu-id="9cad8-3376">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを使用して既定のリモートホストを確立する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3376">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="9cad8-3377">この操作は、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを呼び出す場合にのみ必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3377">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="9cad8-3378"><xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すと、`remoteEP` パラメーターによって、その送信操作に対して指定された既定のリモートホストが上書きされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3378">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="9cad8-3379">基になるサービスプロバイダーによって最も適切なローカルネットワークアドレスとポート番号が割り当てられるため、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3379">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="9cad8-3380">割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了した後に、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティを使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3380">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="9cad8-3381">コネクションレスプロトコルを対象としていますが、<xref:System.Net.Sockets.Socket.SendTo%2A> 接続指向プロトコルでも動作します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3381">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="9cad8-3382">接続指向プロトコルを使用している場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを使用して受信接続要求を受け入れることによって、リモートホスト接続を確立する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3382">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-3383">リモートホスト接続を確立していない場合、または受け入れない場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3383">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3384"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3384">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="9cad8-3385">どちらの場合も、<xref:System.Net.Sockets.Socket.SendTo%2A> は `remoteEP` パラメーターを無視し、接続されているまたは既定のリモートホストにのみデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3385">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="9cad8-3386">ブロックソケットは、バッファー内のすべてのバイトが送信されるまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3386">Blocking sockets will block until the all of the bytes in the buffer are sent.</span></span> <span data-ttu-id="9cad8-3387">非ブロッキング <xref:System.Net.Sockets.Socket> はすぐに完了するため、`buffer`内のすべてのバイトが送信されるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3387">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="9cad8-3388">アプリケーションは、送信されたバイト数を追跡し、アプリケーションが `buffer`内のすべてのバイトを送信するまで操作を再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3388">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="9cad8-3389">また、送信したデータがネットワークに直ちに表示される保証もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3389">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-3390">ネットワークの効率を向上させるために、基になるシステムは、大量の送信データが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3390">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="9cad8-3391"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3391">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="9cad8-3392">ブロックモードでコネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A> はデータグラムが送信されるまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3392">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="9cad8-3393">ブロードキャストアドレスにデータを送信する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3393">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-3394">また、送信されたバイト数が、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3394">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-3395">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3395">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3396"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3396">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3397">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3397">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3398">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3398">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3399">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3399">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3400">次のコード例では、指定したリモートホストにコネクションレスのデータグラムを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3400">The following code example sends a connectionless datagram to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-3401"><paramref name="buffer" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3401"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cad8-3402">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3402">-or-</span></span> 
 <span data-ttu-id="9cad8-3403"><paramref name="remoteEP" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3403"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3404">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3404">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3405"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3405">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-3406">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3406">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-3407"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3407">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="9cad8-3408">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3408">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="9cad8-3409">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、特定のエンドポイントにデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3409">Sends data to a specific endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-3410">送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3410">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3411">このオーバーロードでは、バッファーオフセットは既定で0に設定され、送信するバイト数は既定で `buffer`のサイズに設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3411">In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`.</span></span> <span data-ttu-id="9cad8-3412"><xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3412">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="9cad8-3413">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを使用して既定のリモートホストを確立する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3413">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="9cad8-3414">この操作は、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを呼び出す場合にのみ必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3414">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="9cad8-3415"><xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すと、`remoteEP` パラメーターによって、その送信操作に対して指定された既定のリモートホストが上書きされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3415">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="9cad8-3416">基になるサービスプロバイダーによって最も適切なローカルネットワークアドレスとポート番号が割り当てられるため、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3416">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="9cad8-3417">割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了した後に、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティを使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3417">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="9cad8-3418">コネクションレスプロトコルを対象としていますが、<xref:System.Net.Sockets.Socket.SendTo%2A> 接続指向プロトコルでも動作します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3418">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="9cad8-3419">接続指向プロトコルを使用している場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを使用して受信接続要求を受け入れることによって、リモートホスト接続を確立する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3419">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-3420">リモートホスト接続を確立していない場合、または受け入れない場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3420">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3421"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3421">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="9cad8-3422">どちらの場合も、<xref:System.Net.Sockets.Socket.SendTo%2A> は `remoteEP` パラメーターを無視し、接続されているまたは既定のリモートホストにのみデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3422">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="9cad8-3423">ブロックソケットは、要求されたが `buffer` 内のすべてのバイトを送信するまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3423">Blocking sockets will block until the requested all of the bytes in the `buffer` are sent.</span></span> <span data-ttu-id="9cad8-3424">非ブロッキング <xref:System.Net.Sockets.Socket> はすぐに完了するため、`buffer`内のすべてのバイトが送信されるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3424">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="9cad8-3425">アプリケーションは、送信されたバイト数を追跡し、アプリケーションが `buffer`内のすべてのバイトを送信するまで操作を再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3425">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="9cad8-3426">また、送信したデータがネットワークに直ちに表示される保証もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3426">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-3427">ネットワークの効率を高めるため、基になるシステムは、大量のデータが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3427">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="9cad8-3428"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3428">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="9cad8-3429">ブロックモードでコネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A> はデータグラムが送信されるまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3429">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="9cad8-3430">ブロードキャストアドレスにデータを送信する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3430">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-3431">また、送信されたバイト数が、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3431">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-3432">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3432">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3433"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3433">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3434">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3434">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3435">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3435">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3436">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3436">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3437">次のコード例では、指定したリモートホストにコネクションレスのデータグラムを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3437">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="9cad8-3438"><xref:System.Net.Sockets.SocketFlags> は <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドに渡されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3438"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-3439"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3439"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cad8-3440">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3440">-or-</span></span> 
 <span data-ttu-id="9cad8-3441"><paramref name="remoteEP" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3441"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3442">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3442">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3443"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3443">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-3444">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3444">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-3445">送信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3445">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-3446"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3446">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="9cad8-3447">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3447">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="9cad8-3448">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、指定したエンドポイントに送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3448">Sends the specified number of bytes of data to the specified endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-3449">送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3449">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3450">このオーバーロードでは、バッファーオフセットは既定で0に設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3450">In this overload, the buffer offset defaults to 0.</span></span> <span data-ttu-id="9cad8-3451"><xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信しようとしているデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3451">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="9cad8-3452">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを使用して既定のリモートホストを確立する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3452">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="9cad8-3453">この操作は、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを呼び出す場合にのみ必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3453">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="9cad8-3454"><xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すと、`remoteEP` パラメーターによって、その送信操作に対して指定された既定のリモートホストが上書きされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3454">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="9cad8-3455">基になるサービスプロバイダーによって最も適切なローカルネットワークアドレスとポート番号が割り当てられるため、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3455">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="9cad8-3456">割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了した後に、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティを使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3456">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="9cad8-3457">コネクションレスプロトコルを対象としていますが、<xref:System.Net.Sockets.Socket.SendTo%2A> 接続指向プロトコルでも動作します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3457">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="9cad8-3458">接続指向プロトコルを使用している場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを使用して受信接続要求を受け入れることによって、リモートホスト接続を確立する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3458">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-3459">リモートホスト接続を確立していない場合、または受け入れない場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3459">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3460"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3460">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="9cad8-3461">どちらの場合も、<xref:System.Net.Sockets.Socket.SendTo%2A> は `remoteEP` パラメーターを無視し、接続されているまたは既定のリモートホストにのみデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3461">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="9cad8-3462">ブロックされたソケットは、要求されたバイト数が送信されるまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3462">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="9cad8-3463">非ブロッキング <xref:System.Net.Sockets.Socket> はすぐに完了するため、1回の操作で要求されたバイト数がすべて送信されるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3463">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="9cad8-3464">アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3464">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="9cad8-3465">また、送信したデータがネットワークに直ちに表示される保証もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3465">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-3466">ネットワークの効率を高めるため、基になるシステムは、大量のデータが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3466">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="9cad8-3467"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3467">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="9cad8-3468">ブロックモードでコネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A> はデータグラムが送信されるまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3468">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="9cad8-3469">ブロードキャストアドレスにデータを送信する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3469">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-3470">また、送信されたバイト数が、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3470">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-3471">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3471">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3472"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3472">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3473">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3473">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3474">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3474">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3475">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3475">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3476">次のコード例では、指定したリモートホストにコネクションレスのデータグラムを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3476">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="9cad8-3477">サイズと <xref:System.Net.Sockets.SocketFlags> が <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドに渡されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3477">The size and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-3478"><paramref name="buffer" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3478"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cad8-3479">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3479">-or-</span></span> 
 <span data-ttu-id="9cad8-3480"><paramref name="remoteEP" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3480"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-3481">指定した <paramref name="size" /> が <paramref name="buffer" /> のサイズを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3481">The specified <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3482">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3482">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3483"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3483">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="9cad8-3484">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3484">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="9cad8-3485">データの送信を開始する、データ バッファー内の位置。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3485">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="9cad8-3486">送信するバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3486">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="9cad8-3487"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3487">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="9cad8-3488">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3488">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="9cad8-3489">指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、指定したエンドポイントに送信します。送信はバッファー内の指定した位置から開始されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3489">Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="9cad8-3490">送信されたバイト数。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3490">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3491">このオーバーロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute> フラグを `socketflags` パラメーターとして指定した場合、送信するデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3491">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="9cad8-3492">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Connect%2A> メソッドを使用して既定のリモートホストを確立する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3492">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="9cad8-3493">この操作は、<xref:System.Net.Sockets.Socket.Send%2A> メソッドを呼び出す場合にのみ必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3493">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="9cad8-3494"><xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すと、`remoteEP` パラメーターによって、その送信操作に対して指定された既定のリモートホストが上書きされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3494">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="9cad8-3495">基になるサービスプロバイダーによって最も適切なローカルネットワークアドレスとポート番号が割り当てられるため、<xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3495">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="9cad8-3496">割り当てられたローカルネットワークアドレスとポート番号を識別する必要がある場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了した後に、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティを使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3496">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="9cad8-3497">コネクションレスプロトコルを対象としていますが、<xref:System.Net.Sockets.Socket.SendTo%2A> 接続指向プロトコルでも動作します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3497">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="9cad8-3498">接続指向プロトコルを使用している場合は、最初に <xref:System.Net.Sockets.Socket.Connect%2A> メソッドを呼び出すか、<xref:System.Net.Sockets.Socket.Accept%2A> メソッドを使用して受信接続要求を受け入れることによって、リモートホスト接続を確立する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3498">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="9cad8-3499">リモートホスト接続を確立していない場合、または受け入れない場合は、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3499">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3500"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドを呼び出す前に、コネクションレスプロトコルの既定のリモートホストを確立することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3500">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="9cad8-3501">どちらの場合も、<xref:System.Net.Sockets.Socket.SendTo%2A> は `remoteEP` パラメーターを無視し、接続されているまたは既定のリモートホストにのみデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3501">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="9cad8-3502">ブロックされたソケットは、要求されたバイト数が送信されるまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3502">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="9cad8-3503">非ブロッキング <xref:System.Net.Sockets.Socket> はすぐに完了するため、1回の操作で要求されたバイト数がすべて送信されるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3503">Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="9cad8-3504">アプリケーションは、送信されたバイト数を追跡し、要求されたバイト数をアプリケーションが送信するまで操作を再試行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3504">It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="9cad8-3505">また、送信したデータがネットワークに直ちに表示される保証もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3505">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="9cad8-3506">ネットワークの効率を高めるため、基になるシステムは、大量のデータが収集されるまで転送を遅らせます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3506">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="9cad8-3507"><xref:System.Net.Sockets.Socket.SendTo%2A> メソッドが正常に完了すると、基になるシステムにネットワーク送信用のデータをバッファーするための余裕があることを意味します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3507">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="9cad8-3508">ブロックモードでコネクションレスプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A> はデータグラムが送信されるまでブロックされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3508">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="9cad8-3509">ブロードキャストアドレスにデータを送信する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、socket オプションを <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3509">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9cad8-3510">また、サイズが基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3510">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-3511">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.SendTo%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3511">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3512"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3512">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3513">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3513">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3514">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3514">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3515">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3515">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3516">次のコード例では、指定したリモートホストにコネクションレスのデータグラムを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3516">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="9cad8-3517">オフセット、サイズ、および <xref:System.Net.Sockets.SocketFlags> が <xref:System.Net.Sockets.Socket.SendTo%2A> メソッドに渡されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3517">The offset, size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-3518"><paramref name="buffer" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3518"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="9cad8-3519">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3519">-or-</span></span> 
 <span data-ttu-id="9cad8-3520"><paramref name="remoteEP" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3520"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-3521"><paramref name="offset" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3521"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-3522">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3522">-or-</span></span> 
 <span data-ttu-id="9cad8-3523"><paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3523"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="9cad8-3524">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3524">-or-</span></span> 
 <span data-ttu-id="9cad8-3525"><paramref name="size" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3525"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="9cad8-3526">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3526">-or-</span></span> 
 <span data-ttu-id="9cad8-3527"><paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3527"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3528"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3528"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="9cad8-3529">- または -</span><span class="sxs-lookup"><span data-stu-id="9cad8-3529">-or-</span></span> 
<span data-ttu-id="9cad8-3530"><see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3530">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3531"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3531">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="9cad8-3532">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3532">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="9cad8-3533">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3533">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="9cad8-3534">特定のリモート ホストにデータを非同期的に送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3534">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="9cad8-3535">I/O 操作が保留中の場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3535"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="9cad8-3536">操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3536">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="9cad8-3537">I/O 操作が同期的に完了した場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3537"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="9cad8-3538">この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3538">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3539"><xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドは、`e` パラメーターの <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> プロパティで指定されたリモートホストに対して、非同期の送信操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3539">The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property of the `e` parameter.</span></span> <span data-ttu-id="9cad8-3540"><xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドを呼び出すと、別の実行スレッド内でデータを送信できるようになります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3540">Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="9cad8-3541">この方法はコネクションレスプロトコルを対象としていますが、<xref:System.Net.Sockets.Socket.SendToAsync%2A> はコネクションレスプロトコルと接続指向プロトコルの両方で動作します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3541">Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="9cad8-3542">完了を通知するには、EventHandler\<SocketAsyncEventArgs > delegate を実装するコールバックメソッドを作成し、コールバックを <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> イベントにアタッチする必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3542">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="9cad8-3543">このメソッドを正常に呼び出すには、<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> オブジェクトの次のプロパティとイベントが必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3543">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="9cad8-3544">呼び出し元は、<xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドを呼び出す前に、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> プロパティを任意のユーザー状態オブジェクトに設定して、コールバックメソッドで情報を取得できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3544">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="9cad8-3545">コールバックが1つのオブジェクトよりも多くの情報を必要とする場合は、他の必要な状態情報をメンバーとして保持するために、小さなクラスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3545">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="9cad8-3546">接続指向プロトコルを使用している場合は、最初に <xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3546">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span> <span data-ttu-id="9cad8-3547">それ以外の場合 <xref:System.Net.Sockets.Socket.SendToAsync%2A> は <xref:System.Net.Sockets.SocketException>をスローします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3547">Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3548">接続指向プロトコルを使用する場合、<xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドは、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> プロパティを無視し、<xref:System.Net.Sockets.Socket.Accept%2A>、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>、<xref:System.Net.Sockets.Socket.BeginAccept%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドで確立された <xref:System.Net.EndPoint?displayProperty=nameWithType> にデータを送信します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3548">When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property and send data to the <xref:System.Net.EndPoint?displayProperty=nameWithType> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-3549">コネクションレスプロトコルを使用している場合は、<xref:System.Net.Sockets.Socket.SendToAsync%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドを使用して既定のリモートホストを確立する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3549">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span></span> <span data-ttu-id="9cad8-3550">この操作は、<xref:System.Net.Sockets.Socket.BeginSend%2A> または <xref:System.Net.Sockets.Socket.SendAsync%2A> メソッドを呼び出す場合にのみ必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3550">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods.</span></span> <span data-ttu-id="9cad8-3551"><xref:System.Net.Sockets.Socket.SendToAsync%2A>を呼び出す前に <xref:System.Net.Sockets.Socket.BeginConnect%2A>、<xref:System.Net.Sockets.Socket.Connect%2A>、または <xref:System.Net.Sockets.Socket.ConnectAsync%2A> メソッドを呼び出すと、その送信操作に対して指定された既定のリモートホストだけが <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> プロパティによって上書きされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3551">If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="9cad8-3552"><xref:System.Net.Sockets.Socket.Bind%2A> メソッドを呼び出す必要もありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3552">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="9cad8-3553">この場合、基になるサービスプロバイダーによって、最も適切なローカルネットワーク IP アドレスとポート番号が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3553">In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</span></span> <span data-ttu-id="9cad8-3554">基になるサービスプロバイダーで空きポートを選択する場合は、ポート番号を0にします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3554">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="9cad8-3555">割り当てられているローカルネットワークの IP アドレスとポート番号を識別する必要がある場合は、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> イベントがシグナル状態になり、関連付けられたデリゲートが呼び出された後に、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A> プロパティを使用できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3555">If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event is signaled and the associated delegates are called.</span></span>  
  
 <span data-ttu-id="9cad8-3556">ブロードキャストアドレスにデータを送信する場合は、最初に <xref:System.Net.Sockets.Socket.SetSocketOption%2A> メソッドを呼び出し、<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> の socket オプションを true に設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3556">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> to true.</span></span> <span data-ttu-id="9cad8-3557">また、バッファーのサイズが、基になるサービスプロバイダーの最大パケットサイズを超えていないことを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3557">You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="9cad8-3558">この場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.SendToAsync%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3558">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="9cad8-3559"><xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> プロパティで DontRoute フラグを指定した場合、送信するデータはルーティングされません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3559">If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="9cad8-3560">メッセージ指向のソケットの場合は、基になるトランスポートの最大メッセージサイズを超えないように注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3560">For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</span></span> <span data-ttu-id="9cad8-3561">バッファーのサイズが基になるサービスプロバイダーの最大パケットサイズを超えた場合、データグラムは送信されず、<xref:System.Net.Sockets.Socket.SendToAsync%2A> によって <xref:System.Net.Sockets.SocketException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3561">If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="9cad8-3562"><xref:System.Net.Sockets.Socket.SendToAsync%2A> メソッドが正常に完了しても、データが正常に配信されたことは示されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3562">The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-3563"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3563">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-3564"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3564">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-3565">このメソッドには Windows XP 以降が必要です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3565">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3566"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3566">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3567">指定されたプロトコルは接続指向ですが、<see cref="T:System.Net.Sockets.Socket" /> がまだ接続されていません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3567">The protocol specified is connection-oriented, but the <see cref="T:System.Net.Sockets.Socket" /> is not yet connected.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="level"><span data-ttu-id="9cad8-3568">このソケットに設定する IP 保護レベル。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3568">The IP protection level to set on this socket.</span></span></param>
        <summary><span data-ttu-id="9cad8-3569">ソケットの IP 保護レベルを設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3569">Set the IP protection level on a socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3570"><xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> メソッドを使用すると、同じリンクローカルまたはサイトローカルプレフィックスを持つアドレスなど、指定されたスコープでリッスンするように IPv6 または IP ソケットを制限できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3570">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</span></span> <span data-ttu-id="9cad8-3571">このソケットオプションを使用すると、アプリケーションは IPv6 または IP ソケットにアクセス制限を設けることができます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3571">This socket option enables applications to place access restrictions on IPv6 or IP sockets.</span></span> <span data-ttu-id="9cad8-3572">この制限により、プライベート LAN で実行されるアプリケーションを外部からの攻撃に対して簡単かつ堅牢に強化できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3572">Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</span></span> <span data-ttu-id="9cad8-3573">`level` パラメーターが <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>に設定されている場合は、このソケットオプションを使用してアクセス制限を削除することもできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3573">This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span></span> <span data-ttu-id="9cad8-3574">このソケット オプションで待機中のソケットのスコープを変更して、適切な場合はパブリック ユーザーおよびプライベート ユーザーからの無制限のアクセスを許可したり、必要に応じて同じサイトへのアクセスのみに制限したりできます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3574">This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</span></span>  
  
 <span data-ttu-id="9cad8-3575">このソケット オプションには、<xref:System.Net.Sockets.IPProtectionLevel> 列挙型で指定されている定義済みの保護レベルが設定されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3575">This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration.</span></span>  
  
 <span data-ttu-id="9cad8-3576"><xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> メソッドは、<xref:System.Net.Sockets.Socket> インスタンスのネットワークアドレストラバーサル (NAT) を有効または無効にするために使用されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3576">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance.</span></span> <span data-ttu-id="9cad8-3577">NAT トラバーサルは、Teredo、6to4、または ISATAP トンネルを使用して提供される場合があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3577">NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</span></span>  
  
 <span data-ttu-id="9cad8-3578">`level` パラメーターが <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>または <xref:System.Net.Sockets.IPProtectionLevel.Restricted>に設定されている場合、これにより、<xref:System.Net.Sockets.Socket> インスタンスの NAT トラバーサルが明示的に無効になります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3578">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, or <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, this explicitly disables NAT traversal for a <xref:System.Net.Sockets.Socket> instance.</span></span>  
  
 <span data-ttu-id="9cad8-3579">`level` パラメーターを <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>に設定すると、システム上のファイアウォールルールに応じて、<xref:System.Net.Sockets.Socket> の NAT トラバーサルが許可される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3579">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, this may allow NAT traversal for a <xref:System.Net.Sockets.Socket> depending on firewall rules in place on the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9cad8-3580"><paramref name="level" /> パラメーターとして <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /> を使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3580">The <paramref name="level" /> parameter cannot be <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span></span> <span data-ttu-id="9cad8-3581">IP 保護レベルを未指定に設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3581">The IP protection level cannot be set to unspecified.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-3582">ソケットの <see cref="T:System.Net.Sockets.AddressFamily" /> は、<see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> である必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3582">The <see cref="T:System.Net.Sockets.AddressFamily" /> of the socket must be either <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span></span></exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9cad8-3583"><see cref="T:System.Net.Sockets.Socket" /> オプションを設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3583">Sets a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="9cad8-3584"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3584">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="9cad8-3585"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3585">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="9cad8-3586"><see cref="T:System.Boolean" /> として表されるオプションの値。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3586">The value of the option, represented as a <see cref="T:System.Boolean" />.</span></span></param>
        <summary><span data-ttu-id="9cad8-3587">指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した <see cref="T:System.Boolean" /> 値に設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3587">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified <see cref="T:System.Boolean" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3588">現在の <xref:System.Net.Sockets.Socket>の動作は、<xref:System.Net.Sockets.Socket> オプションによって決まります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3588"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-3589">オプションを有効にする場合は `optionValue` を `true` に設定し、オプションを無効にする場合は `false` に設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3589">Set `optionValue` to `true` to enable the option, or to `false` to disable the option.</span></span>  
  
 <span data-ttu-id="9cad8-3590"><xref:System.Net.Sockets.Socket> オプションは、プロトコルサポートのレベルによってグループ化されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3590"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="9cad8-3591">このオーバーロードを使用して設定できるさまざまな <xref:System.Net.Sockets.Socket> オプションを以下に示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3591">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="9cad8-3592">これらのオプションは、適切な <xref:System.Net.Sockets.SocketOptionLevel> 値によってグループ化されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3592">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value.</span></span> <span data-ttu-id="9cad8-3593">これらのオプションのいずれかを設定する場合は、必ず、`optionLevel` パラメーターに適切な <xref:System.Net.Sockets.SocketOptionLevel> 値を使用してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3593">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter.</span></span> <span data-ttu-id="9cad8-3594">設定するオプションは、`optionName` パラメーターで指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3594">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="9cad8-3595">一覧表示されているいずれかのオプションの現在の値を取得する場合は、<xref:System.Net.Sockets.Socket.GetSocketOption%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3595">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-3596">このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> ます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3596"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <span data-ttu-id="9cad8-3597">このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> ます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3597"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="9cad8-3598">このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> ます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3598"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="9cad8-3599">このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> ます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3599"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="9cad8-3600">これらのオプションの詳細については、<xref:System.Net.Sockets.SocketOptionName> 列挙体を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3600">For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3601"><xref:System.Net.Sockets.SocketException> 例外が発生した場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3601">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3602">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3602">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3603">次のコード例では、ソケットを開き、`DontLinger` と `OutOfBandInline` ソケットオプションを有効にします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3603">The following code example opens a socket and enables the `DontLinger` and the `OutOfBandInline` socket options.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3604"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3604">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3605">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3605">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="9cad8-3606"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3606">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="9cad8-3607"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3607">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="9cad8-3608">オプションの値を表す <see cref="T:System.Byte" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3608">An array of type <see cref="T:System.Byte" /> that represents the value of the option.</span></span></param>
        <summary><span data-ttu-id="9cad8-3609">指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した値に設定します。この値はバイト配列で表されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3609">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3610">現在の <xref:System.Net.Sockets.Socket>の動作は、<xref:System.Net.Sockets.Socket> オプションによって決まります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3610"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-3611">このオーバーロードを使用して、オプション値としてバイト配列を必要とする <xref:System.Net.Sockets.Socket> オプションを設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3611">Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3612"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3612">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3613">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3613">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3614">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3614">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3615">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3615">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3616">次のコード例では、<xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> のタイムアウト値を設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3616">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3617">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3617">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3618"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3618">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="9cad8-3619"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3619">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="9cad8-3620"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3620">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="9cad8-3621">オプションの値。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3621">A value of the option.</span></span></param>
        <summary><span data-ttu-id="9cad8-3622">指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した整数値に設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3622">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3623">現在の <xref:System.Net.Sockets.Socket>の動作は、<xref:System.Net.Sockets.Socket> オプションによって決まります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3623"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-3624"><xref:System.Boolean> データ型のオプションの場合は、0以外の値を指定してオプションを有効にし、ゼロの値を指定してオプションを無効にします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3624">For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</span></span> <span data-ttu-id="9cad8-3625">整数データ型のオプションの場合は、適切な値を指定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3625">For an option with an integer data type, specify the appropriate value.</span></span> <span data-ttu-id="9cad8-3626"><xref:System.Net.Sockets.Socket> オプションは、プロトコルサポートのレベルによってグループ化されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3626"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="9cad8-3627">このオーバーロードを使用して設定できるさまざまな <xref:System.Net.Sockets.Socket> オプションを以下に示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3627">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="9cad8-3628">これらのオプションは、適切な <xref:System.Net.Sockets.SocketOptionLevel>別にグループ化されています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3628">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>.</span></span> <span data-ttu-id="9cad8-3629">これらのオプションのいずれかを設定する場合は、`optionLevel` パラメーターに適切な <xref:System.Net.Sockets.SocketOptionLevel> を使用するようにしてください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3629">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter.</span></span> <span data-ttu-id="9cad8-3630">設定するオプションは、`optionName` パラメーターで指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3630">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="9cad8-3631">一覧表示されているいずれかのオプションの現在の値を取得する場合は、<xref:System.Net.Sockets.Socket.GetSocketOption%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3631">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="9cad8-3632">このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> ます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3632"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <span data-ttu-id="9cad8-3633">このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> ます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3633"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="9cad8-3634">このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> ます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3634"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="9cad8-3635">このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> ます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3635"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="9cad8-3636">このオーバーロードを使用して設定できるオプション <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> ます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3636"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 <span data-ttu-id="9cad8-3637">これらのオプションの詳細については、<xref:System.Net.Sockets.SocketOptionName> 列挙体を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3637">For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3638"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3638">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3639">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3639">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3640">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3640">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3641">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3641">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3642">次のコード例では、<xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> のタイムアウト値を設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3642">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3643">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3643">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3644"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3644">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="9cad8-3645"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3645">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="9cad8-3646"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3646">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="9cad8-3647">オプションの値を格納する <see cref="T:System.Net.Sockets.LingerOption" /> または <see cref="T:System.Net.Sockets.MulticastOption" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3647">A <see cref="T:System.Net.Sockets.LingerOption" /> or <see cref="T:System.Net.Sockets.MulticastOption" /> that contains the value of the option.</span></span></param>
        <summary><span data-ttu-id="9cad8-3648">指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した値に設定します。この値はオブジェクトで表されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3648">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3649">現在の <xref:System.Net.Sockets.Socket>の動作は、<xref:System.Net.Sockets.Socket> オプションによって決まります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3649"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-3650">このオーバーロードを使用して、<xref:System.Net.Sockets.SocketOptionName.Linger>、<xref:System.Net.Sockets.SocketOptionName.AddMembership>、および <xref:System.Net.Sockets.SocketOptionName.DropMembership>の<xref:System.Net.Sockets.Socket> オプションを設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3650">Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="9cad8-3651"><xref:System.Net.Sockets.SocketOptionName.Linger> オプションでは、`optionLevel` パラメーターに <xref:System.Net.Sockets.Socket> を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3651">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="9cad8-3652"><xref:System.Net.Sockets.SocketOptionName.AddMembership> と <xref:System.Net.Sockets.SocketOptionName.DropMembership>については、<xref:System.Net.Sockets.SocketOptionLevel.IP>を使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3652">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="9cad8-3653">上記のいずれかのオプションの現在の値を取得する場合は、<xref:System.Net.Sockets.Socket.GetSocketOption%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3653">If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3654"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3654">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3655">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3655">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3656">次のコード例では、<xref:System.Net.Sockets.LingerOption> と <xref:System.Net.Sockets.Socket.Send%2A> のタイムアウト値を設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3656">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9cad8-3657"><paramref name="optionValue" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3657"><paramref name="optionValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3658">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3658">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3659"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3659">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how"><span data-ttu-id="9cad8-3660">許可されなくなる操作を指定する <see cref="T:System.Net.Sockets.SocketShutdown" /> 値の 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3660">One of the <see cref="T:System.Net.Sockets.SocketShutdown" /> values that specifies the operation that will no longer be allowed.</span></span></param>
        <summary><span data-ttu-id="9cad8-3661"><see cref="T:System.Net.Sockets.Socket" /> での送受信を無効にします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3661">Disables sends and receives on a <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3662">接続指向の <xref:System.Net.Sockets.Socket>を使用する場合は、<xref:System.Net.Sockets.Socket>を閉じる前に常に <xref:System.Net.Sockets.Socket.Shutdown%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3662">When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-3663">これにより、接続されたソケットが閉じられる前に、すべてのデータが送信され、受信されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3663">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="9cad8-3664"><xref:System.Net.Sockets.Socket.Close%2A> メソッドを呼び出して、<xref:System.Net.Sockets.Socket>に関連付けられているすべてのマネージリソースとアンマネージリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3664">Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-3665">終了後に <xref:System.Net.Sockets.Socket> を再利用しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3665">Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.</span></span>  
  
 <span data-ttu-id="9cad8-3666">次の表は、`how` パラメーターに対して有効な <xref:System.Net.Sockets.SocketShutdown> 列挙値を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3666">The following table shows the <xref:System.Net.Sockets.SocketShutdown> enumeration values that are valid for the `how` parameter.</span></span>  
  
|<span data-ttu-id="9cad8-3667">[値]</span><span class="sxs-lookup"><span data-stu-id="9cad8-3667">Value</span></span>|<span data-ttu-id="9cad8-3668">説明</span><span class="sxs-lookup"><span data-stu-id="9cad8-3668">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="9cad8-3669">送信</span><span class="sxs-lookup"><span data-stu-id="9cad8-3669">Send</span></span>|<span data-ttu-id="9cad8-3670">この <xref:System.Net.Sockets.Socket>での送信を無効にします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3670">Disable sending on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="9cad8-3671">Receive</span><span class="sxs-lookup"><span data-stu-id="9cad8-3671">Receive</span></span>|<span data-ttu-id="9cad8-3672">この <xref:System.Net.Sockets.Socket>での受信を無効にします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3672">Disable receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="9cad8-3673">両方</span><span class="sxs-lookup"><span data-stu-id="9cad8-3673">Both</span></span>|<span data-ttu-id="9cad8-3674">この <xref:System.Net.Sockets.Socket>で送信と受信の両方を無効にします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3674">Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
  
 <span data-ttu-id="9cad8-3675">`how` を <xref:System.Net.Sockets.SocketShutdown.Send> に設定すると、後続の <xref:System.Net.Sockets.Socket.Send%2A> の呼び出しは許可されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3675">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed.</span></span> <span data-ttu-id="9cad8-3676">コネクションレス <xref:System.Net.Sockets.Socket>を使用している場合、<xref:System.Net.Sockets.SocketShutdown.Send> を指定しても効果はありません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3676">If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect.</span></span>  
  
 <span data-ttu-id="9cad8-3677">`how` を <xref:System.Net.Sockets.SocketShutdown.Receive> に設定すると、後続の <xref:System.Net.Sockets.Socket.Receive%2A> の呼び出しは許可されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3677">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed.</span></span> <span data-ttu-id="9cad8-3678">これは、下位のプロトコルレイヤーには影響しません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3678">This has no effect on lower protocol layers.</span></span> <span data-ttu-id="9cad8-3679">接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Shutdown%2A> の呼び出しの後、次のいずれかの条件が満たされると接続が終了します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3679">If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span></span>  
  
-   <span data-ttu-id="9cad8-3680">受信を待機している受信ネットワークバッファーにデータがあります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3680">Data is in the incoming network buffer waiting to be received.</span></span>  
  
-   <span data-ttu-id="9cad8-3681">さらに多くのデータが到着しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3681">More data has arrived.</span></span>  
  
 <span data-ttu-id="9cad8-3682">コネクションレスプロトコルを使用している場合は、データグラムが受け入れられ、キューに登録されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3682">If you are using a connectionless protocol, datagrams are accepted and queued.</span></span> <span data-ttu-id="9cad8-3683">ただし、追加の受信データグラムに使用できるバッファー領域がない場合は、破棄され、送信側にエラーは返されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3683">However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</span></span> <span data-ttu-id="9cad8-3684">コネクションレス <xref:System.Net.Sockets.Socket> で <xref:System.Net.Sockets.Socket.Shutdown%2A> を使用することは推奨されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3684">Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.</span></span>  
  
 <span data-ttu-id="9cad8-3685">`how` を <xref:System.Net.Sockets.SocketShutdown.Both> に設定すると、前述のように、送信と受信の両方が無効になります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3685">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Both> disables both sends and receives as described above.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3686"><xref:System.Net.Sockets.Socket.Shutdown%2A> メソッドを呼び出すときに <xref:System.Net.Sockets.SocketException> を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3686">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3687">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3687">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cad8-3688">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3688">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="9cad8-3689">詳細については、「 [.NET Framework のネットワークトレース](~/docs/framework/network-programming/network-tracing.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3689">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3690">次のコード例では、<xref:System.Net.Sockets.Socket.Shutdown%2A> を使用して <xref:System.Net.Sockets.Socket>を無効にします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3690">The following code example uses <xref:System.Net.Sockets.Socket.Shutdown%2A> to disable the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3691">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3691">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3692"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3692">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-3693"><see cref="T:System.Net.Sockets.Socket" /> の型を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3693">Gets the type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="9cad8-3694"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3694">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3695"><xref:System.Net.Sockets.Socket.SocketType%2A> は読み取り専用で、<xref:System.Net.Sockets.Socket> の作成時に設定されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3695"><xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3696">次のコード例では、<xref:System.Net.Sockets.AddressFamily>、<xref:System.Net.Sockets.SocketType>、および <xref:System.Net.Sockets.ProtocolType> をコンソールに表示します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3696">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-3697">現在のホストで IPv4 サポートが使用可能で有効になっているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3697">Gets a value indicating whether IPv4 support is available and enabled on the current host.</span></span></summary>
        <value><span data-ttu-id="9cad8-3698">現在のホストが IPv4 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3698"><see langword="true" /> if the current host supports the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3699">オペレーティングシステムは、IPv4 プロトコルと IPv6 プロトコルの両方をサポートしている場合があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3699">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-3700">互換性のために残されている特定の <see cref="T:System.Net.Dns" /> メンバー向けに、フレームワークが IPv6 をサポートしているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3700">Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> members.</span></span></summary>
        <value><span data-ttu-id="9cad8-3701">互換性のために残されている特定の <see cref="T:System.Net.Dns" /> メソッド向けに、フレームワークが IPv6 をサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3701"><see langword="true" /> if the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> methods; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3702">オペレーティングシステムは、IPv4 プロトコルと IPv6 プロトコルの両方をサポートしている場合があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3702">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9cad8-3703"><see cref="T:System.Net.Sockets.Socket" /> によって使用されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3703">Releases all resources used by the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="9cad8-3704"><xref:System.Net.Sockets.Socket>の使用が終了したら、IDisposable を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3704">Call IDisposable.Dispose when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-3705">IDisposable メソッドは、<xref:System.Net.Sockets.Socket> を使用できない状態のままにします。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3705">The IDisposable.Dispose method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="9cad8-3706">IDisposable を呼び出した後、ガベージコレクターが <xref:System.Net.Sockets.Socket> 占有していたメモリを再利用できるように、<xref:System.Net.Sockets.Socket> へのすべての参照を解放する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3706">After calling IDisposable.Dispose, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span> <span data-ttu-id="9cad8-3707">詳細については、[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)および[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3707">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>

> [!NOTE] 
> <span data-ttu-id="9cad8-3708"><xref:System.Net.Sockets.Socket>への最後の参照を解放する前に、必ず IDisposable を呼び出してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3708">Always call IDisposable.Dispose before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="9cad8-3709">そうしないと、ガベージ コレクターが <xref:System.Net.Sockets.Socket> オブジェクトの `Finalize` メソッドを呼び出すまで、使用されているリソースは解放されません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3709">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-3710"><see cref="T:System.Net.Sockets.Socket" /> によって送信されたインターネット プロトコル (IP) パケットの有効期間 (TTL) の値を指定する値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3710">Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="9cad8-3711">TTL の値。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3711">The TTL value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3712">TTL 値は、ルーターがパケットを破棄する前にパケットが通過できるルーターの最大数を示します。 ICMP (インターネット制御メッセージプロトコル) エラーメッセージが送信側に返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3712">The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</span></span>  
  
 <span data-ttu-id="9cad8-3713">TTL 値は 0 ~ 255 の値に設定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3713">The TTL value may be set to a value from 0 to 255.</span></span> <span data-ttu-id="9cad8-3714">このプロパティが設定されていない場合、ソケットの既定の TTL 値は32です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3714">When this property is not set, the default TTL value for a socket is 32.</span></span>  
  
 <span data-ttu-id="9cad8-3715">ソケットを使用して接続が正常に確立されている場合、TCP/IP スタックでは、伝送制御プロトコル (TCP) ソケットでこのプロパティを設定することは無視されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3715">Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</span></span>  
  
 <span data-ttu-id="9cad8-3716"><xref:System.Net.Sockets.SocketException>を受け取った場合は、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> プロパティを使用して、特定のエラーコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3716">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="9cad8-3717">このコードを取得したら、 [Windows Sockets version 2 API エラーコード](/windows/desktop/winsock/windows-sockets-error-codes-2)のドキュメントを参照して、エラーの詳細な説明を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3717">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9cad8-3718">次のコード例は、<xref:System.Net.Sockets.Socket.Ttl%2A> プロパティの使用方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3718">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.Ttl%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="9cad8-3719">TTL 値には、負の数を設定できません。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3719">The TTL value can't be set to a negative number.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9cad8-3720">このプロパティは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ファミリまたは <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットに対してだけ設定できます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3720">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="9cad8-3721">ソケットへのアクセスを試行しているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3721">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="9cad8-3722">このエラーは、TTL に 255 より大きい値を設定しようとしたときにも返されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3722">This error is also returned when an attempt was made to set TTL to a value higher than 255.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9cad8-3723"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3723">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="9cad8-3724">ソケットが重複 I/O モードだけを使用する必要があるかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3724">Specifies whether the socket should only use Overlapped I/O mode.</span></span></summary>
        <value><span data-ttu-id="9cad8-3725"><see cref="T:System.Net.Sockets.Socket" /> が重複 I/O モードだけを使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3725"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses only overlapped I/O; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="9cad8-3726">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3726">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9cad8-3727"><xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>を呼び出す <xref:System.Net.Sockets.Socket> については、このプロパティを `true` に設定します。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3727">Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span> <span data-ttu-id="9cad8-3728">それ以外の場合、フレームワークは、ソケットに完了ポートを割り当てることがあります。これにより、<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>の使用が禁止されます。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3728">Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="9cad8-3729">ソケットが完了ポートにバインドされています。</span><span class="sxs-lookup"><span data-stu-id="9cad8-3729">The socket has been bound to a completion port.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
