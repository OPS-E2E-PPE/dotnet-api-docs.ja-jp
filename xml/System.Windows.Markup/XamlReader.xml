<Type Name="XamlReader" FullName="System.Windows.Markup.XamlReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e755e4c3071677dd3046499343ef3ece21d1dcfd" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70358839" /></Metadata><TypeSignature Language="C#" Value="public class XamlReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlReader extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.XamlReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlReader" />
  <TypeSignature Language="F#" Value="type XamlReader = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="e9c3b-101">WPF の既定の XAML リーダーおよび関連付けられている XAML オブジェクト ライターを使用して、XAML 入力を読み取り、オブジェクト グラフを作成します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-101">Reads XAML input and creates an object graph, using the WPF default XAML reader and an associated XAML object writer.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9c3b-102">同期<xref:System.Windows.Markup.XamlReader.Load%2A>メソッドは静的ですが、非同期<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>メソッドは静的ではなく、使用する<xref:System.Windows.Markup.XamlReader>クラスのインスタンスを必要とします。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-102">The synchronous <xref:System.Windows.Markup.XamlReader.Load%2A> methods are static, but the asynchronous <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> methods are not static and require an instance of the <xref:System.Windows.Markup.XamlReader> class to use.</span></span>  
  
 <span data-ttu-id="e9c3b-103">`Load`メソッドの出力は、作成されたオブジェクトツリーまたはオブジェクトグラフのルートオブジェクトを表す単一のオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-103">The output of the `Load` methods is a single object, which represents the root object of a created object tree or object graph.</span></span> <span data-ttu-id="e9c3b-104">によって<xref:System.Windows.Markup.XamlReader>作成されたオブジェクトグラフは、通常、実行時に WPF アプリケーションの既存のオブジェクトツリーに追加されます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-104">Object graphs that are created by <xref:System.Windows.Markup.XamlReader> are typically added to the existing object tree of a WPF application at run time.</span></span> <span data-ttu-id="e9c3b-105">それ以外の場合、新しいオブジェクトグラフは、WPF アプリケーションモデルのために切断されたと見なされます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-105">Otherwise the new object graph is considered disconnected for purposes of the WPF application model.</span></span> <span data-ttu-id="e9c3b-106">これは、表示されず、WPF アプリケーションのメインオブジェクトツリー (Api <xref:System.Windows.FrameworkElement.FindName%2A> <xref:System.Windows.LogicalTreeHelper>、、など<xref:System.Windows.Media.VisualTreeHelper>) に適用されるオブジェクトツリー技法を使用してアクセスできないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-106">This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>).</span></span> <span data-ttu-id="e9c3b-107">オブジェクトツリーの概念の詳細については、「 [WPF のツリー](~/docs/framework/wpf/advanced/trees-in-wpf.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-107">For more information on object tree concepts, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 <span data-ttu-id="e9c3b-108"><xref:System.Windows.Markup.XamlReader>では、次の主要なシナリオがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-108"><xref:System.Windows.Markup.XamlReader> supports the following primary scenarios:</span></span>  
  
-   <span data-ttu-id="e9c3b-109">**複製/オブジェクトファクトリ**:追加の機構を使用しない場合、一般に、WPF オブジェクトツリー内の複数の位置に参照型を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-109">**Cloning/object factory**: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree.</span></span> <span data-ttu-id="e9c3b-110">(WPF での共有または再利用をサポートするその他のメカニズムの例としては<xref:System.Windows.Freezable>、に基づくオブジェクト、の項目<xref:System.Windows.ResourceDictionary>とし<xref:System.Windows.Media.Brush>て参照されるなどの一般的な共有可能オブジェクトのサポートなどがあります)。オブジェクトツリー内に既に存在するオブジェクトを複製する方法の1つは、を<xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType>使用してオブジェクトをシリアル化することです。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-110">(Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on <xref:System.Windows.Freezable>, or support for commonly shareable objects such as <xref:System.Windows.Media.Brush> that are referenced as an item from a <xref:System.Windows.ResourceDictionary>.) One way to clone an object that is already in the object tree is to serialize the object using <xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e9c3b-111">次に、ストリームまたは<xref:System.Windows.Markup.XamlReader.Load%2A> <xref:System.Xml.XmlReader>中間のを使用して、の呼び出しの入力としてシリアル化された文字列を使用します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-111">You then use the serialized string as input for a call to <xref:System.Windows.Markup.XamlReader.Load%2A>, with a stream or <xref:System.Xml.XmlReader> as an intermediary.</span></span>  
  
-   <span data-ttu-id="e9c3b-112">**ジャストインタイム情報に基づいてオブジェクトを構築**します。多くの場合、遅延バインディングまたはユーザー指定の入力を既存のオブジェクトの状態に変更する方法があります。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-112">**Constructing objects based on just-in-time information**: There are often other ways to have late-binding or user-supplied input change the state of existing objects.</span></span> <span data-ttu-id="e9c3b-113">たとえば、同じ値を使用して複数のプロパティを設定したり、データバインディングを使用したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-113">For example you could use the same value to set more than one property, or use data binding.</span></span> <span data-ttu-id="e9c3b-114">ただし、作成するオブジェクトの型が実行時またはユーザー操作によってのみ determinable されるシナリオでは、多くの場合、入力用の<xref:System.Windows.Markup.XamlReader.Load%2A>文字列を作成することによって、このようなオブジェクトを作成するのが便利です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-114">But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for <xref:System.Windows.Markup.XamlReader.Load%2A> input is often a useful technique.</span></span>  
  
-   <span data-ttu-id="e9c3b-115">**既存のリソース技術を使用する**:この<xref:System.IO.Stream>型は、アプリケーションの境界を越えてデータやオブジェクトを転送するために他のフレームワークまたはテクノロジで頻繁に使用されます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-115">**Using existing resource techniques**: The <xref:System.IO.Stream> type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations.</span></span> <span data-ttu-id="e9c3b-116">その後、アプリケーションの<xref:System.IO.Stream>一部としてオブジェクトを作成するために最終的に使用する XAML 形式のデータを格納または取得するための手法を使用できます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-116">You can then use the <xref:System.IO.Stream> techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application.</span></span>  
  
-   <span data-ttu-id="e9c3b-117">**修正済みドキュメント:** アプリケーションでは、WPF アプリケーションオブジェクトツリーおよび UI に含めるために、ローカルまたはダウンロードされた XPS ドキュメントを読み込む場合があります。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-117">**Fixed documents:** Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e9c3b-118">このドキュメントでは、オブジェクトツリーではなく、オブジェクトグラフについて説明します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-118">This documentation sometimes describes an object graph, as opposed to an object tree.</span></span> <span data-ttu-id="e9c3b-119">厳密な親子関係は、実行時の WPF アプリケーションの実行時オブジェクトの関係に常に存在するとは限りません。そのため、オブジェクトグラフは、より広く適用される用語です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-119">A strict parent-child relationship does not always exist in the run time object relationships of a run time WPF application, so an object graph is a more widely applicable terminology.</span></span> <span data-ttu-id="e9c3b-120">ただし、wpf にも2つの異なる tree 概念化 api<xref:System.Windows.LogicalTreeHelper>( <xref:System.Windows.Media.VisualTreeHelper>) が含まれているため、ツリーの比喩は wpf のほとんどの実際のケースに適切に適用されます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-120">However, because WPF also includes two different tree conceptualization APIs (<xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>) the tree metaphor still applies adequately to most real-world cases in WPF.</span></span> <span data-ttu-id="e9c3b-121">ただし、xaml 言語の観点からは、多くの場合、オブジェクトグラフは XAML からオブジェクトがどのように作成されるかを考えるのに最適な方法です。 xaml 言語自体では、リレーションシップをツリー構造を再構築します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-121">From the XAML language perspective however, the object graph is often the best way to think about how objects are created out of XAML, because the XAML language itself does not necessarily specify helper class methodologies that bring the relationships more into a tree structure again.</span></span>  
  
## <a name="code-access-security-loose-xaml-and-xamlreader"></a><span data-ttu-id="e9c3b-122">コードアクセスセキュリティ、ルース XAML、XamlReader</span><span class="sxs-lookup"><span data-stu-id="e9c3b-122">Code Access Security, Loose XAML, and XamlReader</span></span>  
 <span data-ttu-id="e9c3b-123">XAML は、オブジェクトのインスタンス化と実行を直接表すマークアップ言語です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-123">XAML is a markup language that directly represents object instantiation and execution.</span></span> <span data-ttu-id="e9c3b-124">そのため、XAML で作成された要素は、同じように生成されたコードと同じように、システムリソース (ネットワークアクセス、ファイルシステム IO など) と対話することができます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-124">Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="e9c3b-125">セキュリティフレームワーク[!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)] [!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]をサポートします。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-125">supports the [!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)] security framework [!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)].</span></span> <span data-ttu-id="e9c3b-126">これは、 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]インターネットゾーンで実行されているコンテンツの実行アクセス許可が低下していることを意味します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-126">This means that [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] content running in the internet zone has reduced execution permissions.</span></span> <span data-ttu-id="e9c3b-127">"疎 xaml" (xaml ビューアーによって読み込み時に解釈[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]される、コンパイルされていない xaml のページ)。通常は、このインターネットゾーンで実行され、同じアクセス許可セットを使用します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-127">"Loose XAML" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] are usually run in this internet zone and use the same permission set.</span></span>  <span data-ttu-id="e9c3b-128">ただし、完全に信頼されたアプリケーションに読み込まれる XAML は、ホストアプリケーションと同じようにシステムリソースにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-128">However, XAML loaded in to a fully trusted application has the same access to the system resources as the hosting application does.</span></span> <span data-ttu-id="e9c3b-129">詳細については、「 [WPF 部分信頼セキュリティ](~/docs/framework/wpf/wpf-partial-trust-security.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-129">For more information, see [WPF Partial Trust Security](~/docs/framework/wpf/wpf-partial-trust-security.md).</span></span>  
  
 <span data-ttu-id="e9c3b-130">に対するこれらのステートメントの<xref:System.Windows.Markup.XamlReader>影響は、アプリケーションの設計で、読み込む XAML に関する信頼の決定を行う必要があることです。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-130">The implications of these statements for <xref:System.Windows.Markup.XamlReader> is that your application design must make trust decisions about the XAML you decide to load.</span></span> <span data-ttu-id="e9c3b-131">信頼されていない XAML を読み込む場合は、結果として得られるオブジェクトグラフを読み込む方法について、独自のサンドボックス手法を実装することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-131">If you are loading XAML that is not trusted, consider implementing your own sandboxing technique for how you load the resulting object graph.</span></span>  
  
 <span data-ttu-id="e9c3b-132"><xref:System.Windows.Markup.XamlReader>部分信頼コードによって呼び出すこともできます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-132"><xref:System.Windows.Markup.XamlReader> can also be called by partial trust code.</span></span> <span data-ttu-id="e9c3b-133">この場合、コードアクセスセキュリティにはインターネットセキュリティゾーンが適用されます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-133">In this case, Internet security zone is applied for code access security.</span></span> <span data-ttu-id="e9c3b-134">読み込まれた XAML 内のものがインターネットセキュリティゾーンで無効な場合は、XAML 解析の例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-134">If anything in the loaded XAML is invalid under Internet security zone, a XAML parse exception is thrown.</span></span> <span data-ttu-id="e9c3b-135">XBAP や、プラットフォームレベルで部分的に信頼されているその<xref:System.Windows.Markup.XamlReader>他のケースでは、は実行の一部であるため、明示的な部分信頼呼び出しと同じ例外動作が発生します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-135">Under XBAP and other cases that are partial trust at the platform level, where <xref:System.Windows.Markup.XamlReader> is part of the execution, you get the same exception behavior as with explicit partial trust calls.</span></span>  
  
## <a name="wpf-xaml-xaml-readerswriters-and-xaml-language-versioning"></a><span data-ttu-id="e9c3b-136">WPF XAML、XAML リーダー/ライター、および XAML 言語のバージョン管理</span><span class="sxs-lookup"><span data-stu-id="e9c3b-136">WPF XAML, XAML Readers/Writers, and XAML Language Versioning</span></span>  
 <span data-ttu-id="e9c3b-137">XAML2009 には、 [x:Reference](~/docs/framework/xaml-services/x-reference-markup-extension.md)や[x:FactoryMethod](~/docs/framework/xaml-services/x-factorymethod-directive.md)などの言語機能が含まれています。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-137">XAML2009 includes language features such as [x:Reference](~/docs/framework/xaml-services/x-reference-markup-extension.md) and [x:FactoryMethod](~/docs/framework/xaml-services/x-factorymethod-directive.md).</span></span> <span data-ttu-id="e9c3b-138">または`Load` `Parse`のシグネチャを使用して、これらの機能を使用する XAML を読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-138">You can use signatures of `Load` or `Parse` to load XAML that uses these features.</span></span> <span data-ttu-id="e9c3b-139">ただし、これらの言語機能は、マークアップコンパイルが必要な XAML ではサポートされていません (WPF アプリケーションの**ページ**ビルドアクションの xaml、ビルドアクションのマークアップコンパイルタスクを含む xaml など)。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-139">However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the **Page** build action in a WPF application, or any XAML that involves the markup compile task in the build actions).</span></span>  
  
 <span data-ttu-id="e9c3b-140">Wpf の内部にアクセスする一般的な概念である wpf の型と wpf テクノロジは、一般にサポートされています。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-140">WPF types and the WPF technology in general support concepts that rely on access to WPF internals.</span></span> <span data-ttu-id="e9c3b-141">たとえば、WPF が依存関係プロパティを実装する方法は、効率的な型メンバー参照の内部手法に依存します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-141">For instance, how WPF implements dependency properties relies on internal techniques for efficient type-member lookup.</span></span> <span data-ttu-id="e9c3b-142">これらの内部構造へのアクセスは、 <xref:System.Windows.Markup.XamlWriter> <xref:System.Windows.Markup>名前空間およびプレゼンテーションフレームワークアセンブリと<xref:System.Windows.Markup.XamlReader>の間で提供される XAML の読み取りおよび書き込み api によって有効になります。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-142">Access to these internals is enabled by the XAML reading and writing APIs provided in <xref:System.Windows.Markup.XamlWriter> and <xref:System.Windows.Markup.XamlReader> from the <xref:System.Windows.Markup> namespace and PresentationFramework assembly.</span></span> <span data-ttu-id="e9c3b-143">ただし、.xaml アセンブリ (、 <xref:System.Xaml.XamlReader?displayProperty=nameWithType> <xref:System.Xaml.XamlWriter?displayProperty=nameWithType>に基づくクラス) の下位レベルの xaml リーダーおよび xaml ライターには、WPF の内部構造へのアクセス権はありません。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-143">However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on <xref:System.Xaml.XamlReader?displayProperty=nameWithType>, <xref:System.Xaml.XamlWriter?displayProperty=nameWithType>) do not have access to the WPF internals.</span></span> <span data-ttu-id="e9c3b-144">App.xaml と WPF 固有のアセンブリとの依存関係はありません。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-144">There is no dependency from System.Xaml to any WPF-specific assembly.</span></span> <span data-ttu-id="e9c3b-145">WPF の内部構造にアクセスできない場合、システムの Xaml とライターは、wpf のすべての型、または WPF の種類に基づく型を正しくロードまたは保存することはできません。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-145">Without access to the WPF internals, System.Xaml readers and writers cannot correctly load or save all WPF types, or types based on WPF types.</span></span> <span data-ttu-id="e9c3b-146">特に、.Xaml リーダーとライターは、WPF の依存関係プロパティのバッキングプロパティストアなどの概念や、WPF がスタイル、リソースディクショナリ、テンプレートを使用する方法の詳細については理解していません。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-146">In particular, the System.Xaml readers and writers do not understand concepts such as the WPF dependency property backing property store, or all the specifics of how WPF uses styles, resource dictionaries and templates.</span></span> <span data-ttu-id="e9c3b-147">そのため、次のような選択肢があります。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-147">Therefore you have a choice to make:</span></span>  
  
-   <span data-ttu-id="e9c3b-148">WPF 型を読み込む場合、または、何らかの方法で BAML フォームで XAML を使用する場合は、プレゼンテーションフレームワークの XAML リーダーと XAML ライターを使用します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-148">If you are loading WPF types, and/or you are using XAML in BAML form in any way, use the PresentationFramework XAML readers and XAML writers.</span></span>  
  
-   <span data-ttu-id="e9c3b-149">WPF の型や BAML 形式の XAML に依存しておらず、そのフレームワークに固有の理由により、別の特定のテクノロジの XAML リーダーまたは XAML ライターの実装を使用していない場合は、.xaml XAML リーダーと XAML ライターを使用します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-149">If you are not relying on any WPF types or the BAML form of XAML, and are not using another specific technology's XAML reader or XAML writer implementation for reasons that are specific to that framework, use the System.Xaml XAML readers and XAML writers.</span></span>  
  
## <a name="systemxaml-backing-implementation-in-net-4"></a><span data-ttu-id="e9c3b-150">.NET 4 でのシステムのバッキング実装</span><span class="sxs-lookup"><span data-stu-id="e9c3b-150">System.Xaml Backing Implementation in .NET 4</span></span>  
 <span data-ttu-id="e9c3b-151"><xref:System.Windows.Markup.XamlReader>は、WPF フレームワークレベルの XAML パーサーの呼び出し可能な API サーフェイスです。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-151"><xref:System.Windows.Markup.XamlReader> is the callable API surface for the WPF framework-level XAML parser.</span></span> <span data-ttu-id="e9c3b-152">また、同じ基になる xaml パーサーによって、およびを対象[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]と[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]する WPF アプリケーションのランタイム XAML の読み込みと解析も実行されます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-152">The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] and [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)].</span></span>  
  
 <span data-ttu-id="e9c3b-153">を対象[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]とする場合、外部 API は同じですが、実装の一部は、xaml の解析[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]の技術的およびレポートの側面の多くを改善する、システムの xaml の一般的な実装に基づいて構築されます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-153">If you are targeting [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the external API is the same, but parts of the implementation are built on the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML.</span></span> <span data-ttu-id="e9c3b-154">ターゲット[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]を指定する場合は、参照として page.xaml を含める必要があります。また、報告される例外などの実装の詳細は、システムの定義済みの型から取得される場合があります。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-154">Targeting [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types.</span></span>  
  
## Examples  
 <span data-ttu-id="e9c3b-155">クラスを使用して<xref:System.Windows.Controls.Button>を文字列に変換する例を次に示します。 <xref:System.Windows.Markup.XamlWriter></span><span class="sxs-lookup"><span data-stu-id="e9c3b-155">The following example converts a <xref:System.Windows.Controls.Button> into a string using the <xref:System.Windows.Markup.XamlWriter> class.</span></span>  <span data-ttu-id="e9c3b-156">次に、 <xref:System.Windows.Controls.Button> <xref:System.Windows.Markup.XamlReader>クラスの静的<xref:System.Windows.Markup.XamlReader.Load%2A>メソッドを使用して、文字列がに再度読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-156">The string is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the <xref:System.Windows.Markup.XamlReader> class.</span></span>  
  
 [!code-csharp[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.XamlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9c3b-157"><see cref="T:System.Windows.Markup.XamlReader" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-157">Initializes a new instance of the <see cref="T:System.Windows.Markup.XamlReader" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="xamlReader.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9c3b-158">非同期読み込み操作が保留中である場合、現在の非同期読み込み操作を中止します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-158">Aborts the current asynchronous load operation, if there is an asynchronous load operation pending.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9c3b-159"><xref:System.Windows.Markup.XamlReader.CancelAsync%2A>は非同期操作です。そのため、一部の読み込みは、操作が中止される前に発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-159"><xref:System.Windows.Markup.XamlReader.CancelAsync%2A> is an asynchronous operation; therefore, some loading may occur before the operation is aborted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWpfSchemaContext">
      <MemberSignature Language="C#" Value="public static System.Xaml.XamlSchemaContext GetWpfSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xaml.XamlSchemaContext GetWpfSchemaContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetWpfSchemaContext () As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xaml::XamlSchemaContext ^ GetWpfSchemaContext();" />
      <MemberSignature Language="F#" Value="static member GetWpfSchemaContext : unit -&gt; System.Xaml.XamlSchemaContext" Usage="System.Windows.Markup.XamlReader.GetWpfSchemaContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9c3b-160"><see cref="T:System.Xaml.XamlSchemaContext" /> の WPF スキーマ コンテキスト設定を表す <see cref="T:System.Windows.Markup.XamlReader" /> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-160">Returns a <see cref="T:System.Xaml.XamlSchemaContext" /> object that represents the WPF schema context settings for a <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></summary>
        <returns><span data-ttu-id="e9c3b-161"><see cref="T:System.Xaml.XamlSchemaContext" /> の WPF スキーマ コンテキスト設定を表す <see cref="T:System.Windows.Markup.XamlReader" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-161">A <see cref="T:System.Xaml.XamlSchemaContext" /> object that represents the WPF schema context settings for a <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e9c3b-162">XAML 入力を読み取り、対応するオブジェクト ツリーのルートを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-162">Reads XAML input and returns the root of the corresponding object tree.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="e9c3b-163">ストリーム形式の読み込む XAML。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-163">The XAML to load, in stream form.</span></span></param>
        <summary><span data-ttu-id="e9c3b-164">指定した <see cref="T:System.IO.Stream" /> 内の XAML 入力を読み取り、対応するオブジェクト ツリーのルートである <see cref="T:System.Object" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-164">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns an <see cref="T:System.Object" /> that is the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="e9c3b-165">作成されたオブジェクト ツリーのルートのオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-165">The object at the root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e9c3b-166">クラスを使用して<xref:System.Windows.Controls.Button> <xref:System.IO.MemoryStream>をに保存する例を次<xref:System.Windows.Markup.XamlWriter>に示します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-166">The following example saves a <xref:System.Windows.Controls.Button> into a <xref:System.IO.MemoryStream> using the <xref:System.Windows.Markup.XamlWriter> class.</span></span> <span data-ttu-id="e9c3b-167">次に、 <xref:System.Windows.Controls.Button> <xref:System.Windows.Markup.XamlReader>クラスの静的<xref:System.Windows.Markup.XamlReader.Load%2A>メソッドを使用して、ストリームがに再度読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-167">The stream is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the <xref:System.Windows.Markup.XamlReader> class.</span></span>  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e9c3b-168"><paramref name="stream" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-168"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xaml.XamlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xaml.XamlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XamlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xaml::XamlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xaml.XamlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xaml.XamlReader" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="e9c3b-169"><see cref="T:System.Xaml.XamlReader" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-169">A <see cref="T:System.Xaml.XamlReader" /> object.</span></span> <span data-ttu-id="e9c3b-170">入力 XAML で初期化されていることが求められます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-170">This is expected to be initialized with input XAML.</span></span></param>
        <summary><span data-ttu-id="e9c3b-171">指定した <see cref="T:System.Xaml.XamlReader" /> を使用して XAML 入力を読み取り、対応するオブジェクト ツリーのルートであるオブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-171">Reads the XAML input through a provided <see cref="T:System.Xaml.XamlReader" /> and returns an object that is the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="e9c3b-172">作成されたオブジェクト ツリーのルートとなるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-172">The object that is the root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9c3b-173">入力<xref:System.Xaml.XamlReader>はにする<xref:System.Windows.Baml2006.Baml2006Reader>ことができます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-173">The input <xref:System.Xaml.XamlReader> can be <xref:System.Windows.Baml2006.Baml2006Reader>.</span></span> <span data-ttu-id="e9c3b-174">これは、実行時またはローカライズツールの目的で、BAML を読み込む方法です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-174">This is how you can load BAML at run time, or for localization tool purposes.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e9c3b-175"><paramref name="reader" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-175"><paramref name="reader" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="e9c3b-176">XAML 入力を既に XML 形式で読み込んでいる <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-176">The <see cref="T:System.Xml.XmlReader" /> that has already loaded the XAML input to load in XML form.</span></span></param>
        <summary><span data-ttu-id="e9c3b-177">指定した <see cref="T:System.Xml.XmlReader" /> 内の XAML 入力を読み取り、対応するオブジェクト ツリーのルートであるオブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-177">Reads the XAML input in the specified <see cref="T:System.Xml.XmlReader" /> and returns an object that is the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="e9c3b-178">作成されたオブジェクト ツリーのルートとなるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-178">The object that is the root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e9c3b-179">クラスを使用して<xref:System.Windows.Controls.Button>を文字列に変換する例を次に示します。 <xref:System.Windows.Markup.XamlWriter></span><span class="sxs-lookup"><span data-stu-id="e9c3b-179">The following example converts a <xref:System.Windows.Controls.Button> into a string using the <xref:System.Windows.Markup.XamlWriter> class.</span></span>  <span data-ttu-id="e9c3b-180">次に、 <xref:System.Windows.Controls.Button> <xref:System.Windows.Markup.XamlReader>クラスの静的<xref:System.Windows.Markup.XamlReader.Load%2A>メソッドを使用して、文字列がに再度読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-180">The string is then loaded back into a <xref:System.Windows.Controls.Button> using the static <xref:System.Windows.Markup.XamlReader.Load%2A> method on the <xref:System.Windows.Markup.XamlReader> class.</span></span>  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e9c3b-181"><paramref name="reader" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-181"><paramref name="reader" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="e9c3b-182">読み込む XAML 入力を格納しているストリーム。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-182">The stream that contains the XAML input to load.</span></span></param>
        <param name="parserContext"><span data-ttu-id="e9c3b-183">パーサーで使用するコンテキスト情報。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-183">Context information used by the parser.</span></span></param>
        <summary><span data-ttu-id="e9c3b-184">指定した <see cref="T:System.IO.Stream" /> 内の XAML 入力を読み取り、対応するオブジェクト ツリーのルートであるオブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-184">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns an object that is the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="e9c3b-185">作成されたオブジェクト ツリーのルートとなるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-185">The object that is the root of the created object tree.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e9c3b-186"><paramref name="stream" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-186"><paramref name="stream" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e9c3b-187">- または -</span><span class="sxs-lookup"><span data-stu-id="e9c3b-187">-or-</span></span> 
 <span data-ttu-id="e9c3b-188"><paramref name="parserContext" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-188"><paramref name="parserContext" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadAsync">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e9c3b-189">XAML マークアップを読み取り、指定したマークアップのルートに対応するオブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-189">Reads XAML markup and returns an object that corresponds to the root of the specified markup.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream -&gt; obj" Usage="xamlReader.LoadAsync stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="e9c3b-190">読み込む XAML 入力を格納しているストリーム。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-190">The stream containing the XAML input to load.</span></span></param>
        <summary><span data-ttu-id="e9c3b-191">指定した <see cref="T:System.IO.Stream" /> 内の XAML 入力を読み取り、対応するオブジェクト ツリーのルートを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-191">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="e9c3b-192">作成されたオブジェクト ツリーのルートとなるオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-192">The object that is the root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9c3b-193">非同期 XAML 読み込み操作は、最初は単にルートオブジェクトであるオブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-193">An asynchronous XAML load operation will initially return an object that is purely the root object.</span></span> <span data-ttu-id="e9c3b-194">非同期的に XAML 解析が続行され、子オブジェクトがルートの下に格納されます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-194">Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</span></span> <span data-ttu-id="e9c3b-195">これは、一般的な WPF XAML 処理の動作と、オブジェクトの有効期間の WPF 概念との相互作用とは対照的です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-195">This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</span></span> <span data-ttu-id="e9c3b-196">一般的な (非同期ではない) 相互作用では、要素を返す前にすべての子コレクションを含むオブジェクトのすべてのプロパティが入力され、読み込まれたものとして報告されます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-196">In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</span></span> <span data-ttu-id="e9c3b-197">この動作は、ルートオブジェクトが使用可能になる最後のオブジェクトであるツリーを作成するためのボトムアップ方式に相当します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-197">That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</span></span>  
  
 <span data-ttu-id="e9c3b-198">通常、返されたオブジェクトは、WPF アプリケーションのオブジェクトツリー内のある場所に割り当てられます。これにはコンテンツがまだ埋め込まれている可能性があり、コンテンツ全体が UI の一部として公開されている場合は、レイアウトの増分更新が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-198">You typically would assign the returned object to some location in your WPF application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</span></span> <span data-ttu-id="e9c3b-199">このため、通常は、非同期的に読み込まれたオブジェクトを XAML から分離または仮想化し、アプリケーション固有のロジックまたはアプリケーション<xref:System.Windows.Markup.XamlReader.LoadCompleted>の状態を使用してが処理されたときに通知します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-199">For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.</span></span>  
  
 <span data-ttu-id="e9c3b-200">が xaml 入力を非同期に読み込むためには、xaml 入力のルート要素に属性と値`x:SynchronousMode="Async"`が含まれている必要があります。 <xref:System.Windows.Markup.XamlReader.LoadAsync%2A></span><span class="sxs-lookup"><span data-stu-id="e9c3b-200">In order for <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value `x:SynchronousMode="Async"`.</span></span> <span data-ttu-id="e9c3b-201">値は大文字と小文字を区別して扱われます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-201">The value is treated as case sensitive.</span></span> <span data-ttu-id="e9c3b-202">XAML 入力ルートにが含ま`x:SynchronousMode="Async"`れていない場合、例外はスローされず、呼び出しは同期読み込みとして処理されます (「」を参照してください<xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>)。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-202">If the XAML input root does not contain `x:SynchronousMode="Async"`, no exception is thrown, and the call is processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>).</span></span>  
  
 <span data-ttu-id="e9c3b-203">一度に実行できるのは、 <xref:System.Windows.Markup.XamlReader>クラスのインスタンスごとに1つの非同期読み込み操作だけです。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-203">Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.</span></span>  <span data-ttu-id="e9c3b-204"><xref:System.Windows.Markup.XamlReader>クラスの同じインスタンスで複数の非同期操作を実行しようとすると<xref:System.InvalidOperationException> 、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-204">If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e9c3b-205"><paramref name="stream" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-205"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9c3b-206">1 つの <see cref="T:System.Windows.Markup.XamlReader" /> で、複数の読み込み操作が同時に保留になります。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-206">Multiple load operations are pending concurrently with the same <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadAsync (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.Xml.XmlReader -&gt; obj" Usage="xamlReader.LoadAsync reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><span data-ttu-id="e9c3b-207">XAML 入力を既に読み込んでいる (読み取っている) 既存の <see cref="T:System.Xml.XmlReader" />。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-207">An existing  <see cref="T:System.Xml.XmlReader" /> that has already loaded/read the XAML input.</span></span></param>
        <summary><span data-ttu-id="e9c3b-208">指定した <see cref="T:System.Xml.XmlReader" /> 内の XAML 入力を読み取り、対応するオブジェクト ツリーのルートを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-208">Reads the XAML input in the specified <see cref="T:System.Xml.XmlReader" /> and returns the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="e9c3b-209">作成されたオブジェクト ツリーのルート。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-209">The root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9c3b-210">非同期 XAML 読み込み操作は、最初は単にルートオブジェクトであるオブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-210">An asynchronous XAML load operation will initially return an object that is purely the root object.</span></span> <span data-ttu-id="e9c3b-211">非同期的に XAML 解析が続行され、子オブジェクトがルートの下に格納されます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-211">Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</span></span> <span data-ttu-id="e9c3b-212">これは、一般的な WPF XAML 処理の動作と、オブジェクトの有効期間の WPF 概念との相互作用とは対照的です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-212">This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</span></span> <span data-ttu-id="e9c3b-213">一般的な (非同期ではない) 相互作用では、要素を返す前にすべての子コレクションを含むオブジェクトのすべてのプロパティが入力され、読み込まれたものとして報告されます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-213">In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</span></span> <span data-ttu-id="e9c3b-214">この動作は、ルートオブジェクトが使用可能になる最後のオブジェクトであるツリーを作成するためのボトムアップ方式に相当します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-214">That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</span></span>  
  
 <span data-ttu-id="e9c3b-215">通常、返されるオブジェクト<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>は、アプリケーションのオブジェクトツリー内のある場所に割り当てられます。その際、コンテンツがまだ入力されている可能性があります。また、コンテンツ全体がUI.</span><span class="sxs-lookup"><span data-stu-id="e9c3b-215">You typically would assign the returned object from <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</span></span> <span data-ttu-id="e9c3b-216">このため、通常は、非同期的に読み込まれたオブジェクトを XAML から分離または仮想化し、アプリケーション固有のロジックまたはアプリケーション<xref:System.Windows.Markup.XamlReader.LoadCompleted>の状態を使用してが処理されたときに通知します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-216">For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.</span></span>  
  
 <span data-ttu-id="e9c3b-217">が xaml 入力を非同期に読み込むためには、xaml マークアップのルート要素に属性と値`x:SynchronousMode="Async"`が含まれている必要があります。 <xref:System.Windows.Markup.XamlReader.LoadAsync%2A></span><span class="sxs-lookup"><span data-stu-id="e9c3b-217">In order for <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value `x:SynchronousMode="Async"`.</span></span> <span data-ttu-id="e9c3b-218">値は大文字と小文字を区別して扱われます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-218">The value is treated as case sensitive.</span></span> <span data-ttu-id="e9c3b-219">XAML マークアップルートにが含ま`x:SynchronousMode="Async"`れていない場合、例外はスローされず、呼び出しは同期読み込みとして処理されます (「」を参照してください<xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>)。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-219">If the XAML markup root does not contain `x:SynchronousMode="Async"`, no exception is thrown, and the call is instead processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>).</span></span>  
  
 <span data-ttu-id="e9c3b-220">一度に実行できるのは、 <xref:System.Windows.Markup.XamlReader>クラスのインスタンスごとに1つの非同期読み込み操作だけです。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-220">Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.</span></span>  <span data-ttu-id="e9c3b-221"><xref:System.Windows.Markup.XamlReader>クラスの同じインスタンスで複数の非同期操作を実行しようとすると<xref:System.InvalidOperationException> 、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-221">If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e9c3b-222"><paramref name="reader" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-222"><paramref name="reader" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9c3b-223">1 つの <see cref="T:System.Windows.Markup.XamlReader" /> で、複数の読み込み操作が同時に実行されます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-223">Multiple load operations are performed concurrently with the same <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="xamlReader.LoadAsync (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="e9c3b-224">読み込む XAML 入力を格納しているストリーム。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-224">A stream containing the XAML input to load.</span></span></param>
        <param name="parserContext"><span data-ttu-id="e9c3b-225">パーサーで使用するコンテキスト情報。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-225">Context information used by the parser.</span></span></param>
        <summary><span data-ttu-id="e9c3b-226">指定した <see cref="T:System.IO.Stream" /> 内の XAML 入力を読み取り、対応するオブジェクト ツリーのルートを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-226">Reads the XAML input in the specified <see cref="T:System.IO.Stream" /> and returns the root of the corresponding object tree.</span></span></summary>
        <returns><span data-ttu-id="e9c3b-227">作成されたオブジェクト ツリーのルート。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-227">The root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9c3b-228">非同期 XAML 読み込み操作は、最初は単にルートオブジェクトであるオブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-228">An asynchronous XAML load operation will initially return an object that is purely the root object.</span></span> <span data-ttu-id="e9c3b-229">非同期的に XAML 解析が続行され、子オブジェクトがルートの下に格納されます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-229">Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</span></span> <span data-ttu-id="e9c3b-230">これは、一般的な WPF XAML 処理の動作と、オブジェクトの有効期間の WPF 概念との相互作用とは対照的です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-230">This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</span></span> <span data-ttu-id="e9c3b-231">一般的な (非同期ではない) 相互作用では、要素を返す前にすべての子コレクションを含むオブジェクトのすべてのプロパティが入力され、読み込まれたものとして報告されます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-231">In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</span></span> <span data-ttu-id="e9c3b-232">この動作は、ルートオブジェクトが使用可能になる最後のオブジェクトであるツリーを作成するためのボトムアップ方式に相当します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-232">That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</span></span>  
  
 <span data-ttu-id="e9c3b-233">通常、返されるオブジェクトは、アプリケーションのオブジェクトツリー内のある場所に割り当てられます。これには、コンテンツがまだ入力されている可能性があり、コンテンツ全体が UI の一部として公開されている場合は、レイアウトの増分更新が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-233">You typically would assign the returned object to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</span></span> <span data-ttu-id="e9c3b-234">このため、通常は、非同期的に読み込まれたオブジェクトを XAML から分離または仮想化し、アプリケーション固有のロジックまたはアプリケーション<xref:System.Windows.Markup.XamlReader.LoadCompleted>の状態を使用してが処理されたときに通知します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-234">For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <xref:System.Windows.Markup.XamlReader.LoadCompleted> is handled.</span></span>  
  
 <span data-ttu-id="e9c3b-235">がマーク`x:SynchronousMode="Async"`アップを非同期に読み込むためには、XAMLマークアップのルート要素に属性と値が含まれている必要<xref:System.Windows.Markup.XamlReader.LoadAsync%2A>があります。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-235">In order for <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> to load markup asynchronously, the root element in the XAML markup must contain the attribute and value `x:SynchronousMode="Async"`.</span></span> <span data-ttu-id="e9c3b-236">値は大文字と小文字を区別して扱われます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-236">The value is treated as case sensitive.</span></span> <span data-ttu-id="e9c3b-237">XAML マークアップルートにが含ま`x:SynchronousMode="Async"`れていない場合、例外はスローされず、呼び出しは同期読み込みとして処理されます (「」を参照してください<xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>)。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-237">If the XAML markup root does not contain `x:SynchronousMode="Async"`, no exception is thrown, and the call is processed as a synchronous load (see <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>).</span></span>  
  
 <span data-ttu-id="e9c3b-238">一度に実行できるのは、 <xref:System.Windows.Markup.XamlReader>クラスのインスタンスごとに1つの非同期読み込み操作だけです。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-238">Only one asynchronous load operation per instance of the <xref:System.Windows.Markup.XamlReader> class can be performed at a time.</span></span>  <span data-ttu-id="e9c3b-239"><xref:System.Windows.Markup.XamlReader>クラスの同じインスタンスで複数の非同期操作を実行しようとすると<xref:System.InvalidOperationException> 、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-239">If more than one asynchronous operation is attempted on the same instance of the <xref:System.Windows.Markup.XamlReader> class an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e9c3b-240"><paramref name="stream" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-240"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9c3b-241">1 つの <see cref="T:System.Windows.Markup.XamlReader" /> で、複数の読み込み操作が同時に実行されます。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-241">Multiple load operations are performed concurrently with the same <see cref="T:System.Windows.Markup.XamlReader" />.</span></span></exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AsyncCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AsyncCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Markup.XamlReader.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As AsyncCompletedEventHandler " FrameworkAlternate="netcore-3.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AsyncCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " Usage="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As AsyncCompletedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9c3b-242">非同期の読み込み操作の完了時に発生します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-242">Occurs when an asynchronous load operation completes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9c3b-243"><xref:System.Windows.Markup.XamlReader.LoadCompleted>は、非同期読み込み操作が中止されたときにも発生します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-243"><xref:System.Windows.Markup.XamlReader.LoadCompleted> is also raised when an asynchronous load operation aborts.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.AsyncCompletedEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e9c3b-244">指定したテキスト文字列内のマークアップを読み取り、指定したマークアップのルートに対応するオブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-244">Reads the markup in the specified text string and returns an object that corresponds to the root of the specified markup.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (xamlText As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse xamlText" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlText"><span data-ttu-id="e9c3b-245">単一のテキスト文字列としての入力 XAML。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-245">The input XAML, as a single text string.</span></span></param>
        <summary><span data-ttu-id="e9c3b-246">指定したテキスト文字列内の XAML 入力を読み取り、指定したマークアップのルートに対応するオブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-246">Reads the XAML input in the specified text string and returns an object that corresponds to the root of the specified markup.</span></span></summary>
        <returns><span data-ttu-id="e9c3b-247">作成されたオブジェクト ツリーのルート。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-247">The root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9c3b-248">の実装は<xref:System.Windows.Markup.XamlReader.Load%2A> 、文字列からストリームを作成した後に、内部的にを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-248">The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string.</span></span> <span data-ttu-id="e9c3b-249">考え<xref:System.Windows.Markup.XamlReader.Load%2A>られる例外などの追加情報については、「」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-249">See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse (xamlText, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="xamlText"><span data-ttu-id="e9c3b-250">単一のテキスト文字列としての入力 XAML。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-250">The input XAML, as a single text string.</span></span></param>
        <param name="parserContext"><span data-ttu-id="e9c3b-251">パーサーで使用するコンテキスト情報。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-251">Context information used by the parser.</span></span></param>
        <summary><span data-ttu-id="e9c3b-252">指定したテキスト文字列 (指定した <see cref="T:System.Windows.Markup.ParserContext" /> を使用) 内の XAML マークアップを読み取り、指定したマークアップのルートに対応するオブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-252">Reads the XAML markup in the specified text string (using a specified <see cref="T:System.Windows.Markup.ParserContext" />) and returns an object that corresponds to the root of the specified markup.</span></span></summary>
        <returns><span data-ttu-id="e9c3b-253">作成されたオブジェクト ツリーのルート。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-253">The root of the created object tree.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9c3b-254">の実装は<xref:System.Windows.Markup.XamlReader.Load%2A> 、文字列からストリームを作成した後に、内部的にを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-254">The implementation calls <xref:System.Windows.Markup.XamlReader.Load%2A> internally after creating a stream from the string.</span></span> <span data-ttu-id="e9c3b-255">考え<xref:System.Windows.Markup.XamlReader.Load%2A>られる例外などの追加情報については、「」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="e9c3b-255">See <xref:System.Windows.Markup.XamlReader.Load%2A> for additional information such as possible exceptions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
