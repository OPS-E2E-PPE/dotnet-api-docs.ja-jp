<Type Name="Rune" FullName="System.Text.Rune">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ff9c267452a86e0b4821e842a90dedf5d05b6760" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82303972" /></Metadata><TypeSignature Language="C#" Value="public struct Rune : IComparable&lt;System.Text.Rune&gt;, IEquatable&lt;System.Text.Rune&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Rune extends System.ValueType implements class System.IComparable`1&lt;valuetype System.Text.Rune&gt;, class System.IEquatable`1&lt;valuetype System.Text.Rune&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Text.Rune" />
  <TypeSignature Language="VB.NET" Value="Public Structure Rune&#xA;Implements IComparable(Of Rune), IEquatable(Of Rune)" />
  <TypeSignature Language="C++ CLI" Value="public value class Rune : IComparable&lt;System::Text::Rune&gt;, IEquatable&lt;System::Text::Rune&gt;" />
  <TypeSignature Language="F#" Value="type Rune = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Text.Rune&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Text.Rune&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="7b217-101">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ ([ U+0000..U+D7FF ] (æœ€åˆã¨æœ€å¾Œã®è¦ç´ ã‚’å«ã‚€) ã¾ãŸã¯ [ U+E000..U+10FFFF ] (æœ€åˆã¨æœ€å¾Œã®è¦ç´ ã‚’å«ã‚€)) ã‚’è¡¨ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-101">Represents a Unicode scalar value ([ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive).</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-102"><xref:System.Text.Rune> ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¡¨ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ã‚µãƒ­ã‚²ãƒ¼ãƒˆç¯„å›²ã‚’é™¤ãä»»æ„ã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆ (U + D800..U + DFFF)ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-102">A <xref:System.Text.Rune> instance represents a Unicode scalar value, which means any code point excluding the surrogate range (U+D800..U+DFFF).</span></span> <span data-ttu-id="7b217-103">å‹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã¨å¤‰æ›æ¼”ç®—å­ã«ã‚ˆã£ã¦å…¥åŠ›ãŒæ¤œè¨¼ã•ã‚Œã‚‹ãŸã‚ã€åŸºã«ãªã‚‹ <xref:System.Text.Rune> ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒæ•´å½¢å¼ã§ã‚ã‚‹ã¨ä»®å®šã—ã¦ã€ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼ã¯ Api ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-103">The type's constructors and conversion operators validate the input, so consumers can call the APIs assuming that the underlying <xref:System.Text.Rune> instance is well formed.</span></span>

<span data-ttu-id="7b217-104">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã€ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã€ã‚µãƒ­ã‚²ãƒ¼ãƒˆç¯„å›²ã€ãŠã‚ˆã³é©åˆ‡ãªå½¢å¼ã®ç”¨èªã«ã¤ã„ã¦è©³ã—ãç†è§£ã—ã¦ã„ãªã„å ´åˆã¯ã€ã€Œ [.net ã§ã®æ–‡å­—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã®æ¦‚è¦](/dotnet/standard/base-types/character-encoding-introduction)ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-104">If you aren't familiar with the terms Unicode scalar value, code point, surrogate range, and well-formed, see [Introduction to character encoding in .NET](/dotnet/standard/base-types/character-encoding-introduction).</span></span>

<span data-ttu-id="7b217-105">æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-105">The following sections explain:</span></span>

* [<span data-ttu-id="7b217-106">ãƒ«ãƒ¼ãƒ³å‹ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆ</span><span class="sxs-lookup"><span data-stu-id="7b217-106">When to use the Rune type</span></span>](#when-to-use-the-rune-type)
* [<span data-ttu-id="7b217-107">ãƒ«ãƒ¼ãƒ³å‹ã‚’ä½¿ç”¨ã—ãªã„å ´åˆ</span><span class="sxs-lookup"><span data-stu-id="7b217-107">When not to use the Rune type</span></span>](#when-not-to-use-rune)
* [<span data-ttu-id="7b217-108">ãƒ«ãƒ¼ãƒ³ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹æ–¹æ³•</span><span class="sxs-lookup"><span data-stu-id="7b217-108">How to instantiate a Rune</span></span>](#how-to-instantiate-a-rune)
* [<span data-ttu-id="7b217-109">ãƒ«ãƒ¼ãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ç…§ä¼šã™ã‚‹æ–¹æ³•</span><span class="sxs-lookup"><span data-stu-id="7b217-109">How to query properties of a Rune instance</span></span>](#query-properties-of-a-rune)
* [<span data-ttu-id="7b217-110">`Rune` ã‚’ UTF-8 ã¾ãŸã¯ UTF-16 ã«å¤‰æ›ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-110">Convert a `Rune` to UTF-8 or UTF-16</span></span>](#convert-a-rune-to-utf-8-or-utf-16)
* [<span data-ttu-id="7b217-111">.NET ã¨ãã®ä»–ã®è¨€èªã®ãƒ«ãƒ¼ãƒ³</span><span class="sxs-lookup"><span data-stu-id="7b217-111">Rune in .NET vs. other languages</span></span>](#rune-in-net-vs-other-languages)

### <a name="when-to-use-the-rune-type"></a><span data-ttu-id="7b217-112">ãƒ«ãƒ¼ãƒ³å‹ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆ</span><span class="sxs-lookup"><span data-stu-id="7b217-112">When to use the Rune type</span></span>

<span data-ttu-id="7b217-113">ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã¯ã€`Rune` ã®ç¨®é¡ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-113">Consider using the `Rune` type if your code:</span></span>

* <span data-ttu-id="7b217-114">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’å¿…è¦ã¨ã™ã‚‹ Api ã‚’å‘¼ã³å‡ºã—ã¾ã™</span><span class="sxs-lookup"><span data-stu-id="7b217-114">Calls APIs that require Unicode scalar values</span></span>
* <span data-ttu-id="7b217-115">ã‚µãƒ­ã‚²ãƒ¼ãƒˆãƒšã‚¢ã‚’æ˜ç¤ºçš„ã«å‡¦ç†ã—ã¾ã™</span><span class="sxs-lookup"><span data-stu-id="7b217-115">Explicitly handles surrogate pairs</span></span>

#### <a name="apis-that-require-unicode-scalar-values"></a><span data-ttu-id="7b217-116">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’å¿…è¦ã¨ã™ã‚‹ Api</span><span class="sxs-lookup"><span data-stu-id="7b217-116">APIs that require Unicode scalar values</span></span>

<span data-ttu-id="7b217-117">ã‚³ãƒ¼ãƒ‰ãŒ `string` ã¾ãŸã¯ `ReadOnlySpan<char>`å†…ã® `char` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’åå¾©å‡¦ç†ã™ã‚‹å ´åˆã€ä¸€éƒ¨ã® `char` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚µãƒ­ã‚²ãƒ¼ãƒˆç¯„å›²å†…ã® `char` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§æ­£ã—ãæ©Ÿèƒ½ã—ã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-117">If your code iterates through the `char` instances in a `string` or a `ReadOnlySpan<char>`, some of the `char` methods won't work correctly on `char` instances that are in the surrogate range.</span></span> <span data-ttu-id="7b217-118">ãŸã¨ãˆã°ã€æ¬¡ã® Api ã§ã¯ã€æ­£ã—ãæ©Ÿèƒ½ã™ã‚‹ãŸã‚ã« `char` ã‚¹ã‚«ãƒ©ãƒ¼å€¤ãŒå¿…è¦ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-118">For example, the following APIs require a scalar value `char` to work correctly:</span></span>

* <xref:System.Char.GetNumericValue%2A?displayProperty=nameWithType>
* <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType>
* <xref:System.Char.IsDigit%2A?displayProperty=nameWithType>
* <xref:System.Char.IsLetter%2A?displayProperty=nameWithType>
* <xref:System.Char.IsLetterOrDigit%2A?displayProperty=nameWithType>
* <xref:System.Char.IsLower%2A?displayProperty=nameWithType>
* <xref:System.Char.IsNumber%2A?displayProperty=nameWithType>
* <xref:System.Char.IsPunctuation%2A?displayProperty=nameWithType>
* <xref:System.Char.IsSymbol%2A?displayProperty=nameWithType>
* <xref:System.Char.IsUpper%2A?displayProperty=nameWithType>

<span data-ttu-id="7b217-119">æ¬¡ã®ä¾‹ã¯ã€`char` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã‚µãƒ­ã‚²ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ã‚ã‚‹å ´åˆã«æ­£ã—ãæ©Ÿèƒ½ã—ãªã„ã‚³ãƒ¼ãƒ‰ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-119">The following example shows code that won't work correctly if any of the `char` instances are surrogate code points:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/CountLettersInString.cs" id="SnippetBadExample":::

<span data-ttu-id="7b217-120">`ReadOnlySpan<char>`ã§å‹•ä½œã™ã‚‹åŒç­‰ã®ã‚³ãƒ¼ãƒ‰ã‚’æ¬¡ã«ç¤ºã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-120">Here's equivalent code that works with a `ReadOnlySpan<char>`:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/CountLettersInSpan.cs" id="SnippetBadExample":::

<span data-ttu-id="7b217-121">ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã¯ã€è‹±èªãªã©ã®ä¸€éƒ¨ã®è¨€èªã§æ­£ã—ãå‹•ä½œã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-121">The preceding code works correctly with some languages such as English:</span></span>

```csharp
CountLettersInString("Hello")
// Returns 5
```

<span data-ttu-id="7b217-122">ãŸã ã—ã€æ¬¡ã®ã‚ˆã†ãªåŸºæœ¬çš„ãªå¤šè¨€èªãƒ—ãƒ¬ãƒ¼ãƒ³ä»¥å¤–ã®è¨€èªã§ã¯æ­£ã—ãæ©Ÿèƒ½ã—ã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-122">But it won't work correctly for languages outside the Basic Multilingual Plane, such as Osage:</span></span>

```csharp
CountLettersInString("ğ“ğ“˜ğ“»ğ“˜ğ“»ğ“Ÿ ğ’»ğ“Ÿ")
// Returns 0
```

<span data-ttu-id="7b217-123">Osage ãƒ†ã‚­ã‚¹ãƒˆã«å¯¾ã—ã¦ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒèª¤ã£ãŸçµæœã‚’è¿”ã™ç†ç”±ã¨ã—ã¦ã€Osage æ–‡å­—ã® `char` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã‚µãƒ­ã‚²ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ã‚ã‚‹ã“ã¨ãŒæŒ™ã’ã‚‰ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-123">The reason this method returns incorrect results for Osage text is that the `char` instances for Osage letters are surrogate code points.</span></span> <span data-ttu-id="7b217-124">1ã¤ã®ã‚µãƒ­ã‚²ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«ã¯ã€ãã‚ŒãŒæ–‡å­—ã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã™ã‚‹ã®ã«ååˆ†ãªæƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-124">No single surrogate code point has enough information to determine if it's a letter.</span></span>

<span data-ttu-id="7b217-125">ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’ `char`ã§ã¯ãªã `Rune` ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´ã—ãŸå ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯åŸºæœ¬çš„ãªå¤šè¨€èªãƒ—ãƒ¬ãƒ¼ãƒ³ä»¥å¤–ã®ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¨æ­£å¸¸ã«å‹•ä½œã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-125">If you change this code to use `Rune` instead of `char`, the method works correctly with code points outside the Basic Multilingual Plane:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/CountLettersInString.cs" id="SnippetGoodExample":::

<span data-ttu-id="7b217-126">`ReadOnlySpan<char>`ã§å‹•ä½œã™ã‚‹åŒç­‰ã®ã‚³ãƒ¼ãƒ‰ã‚’æ¬¡ã«ç¤ºã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-126">Here's equivalent code that works with a `ReadOnlySpan<char>`:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/CountLettersInSpan.cs" id="SnippetGoodExample":::

<span data-ttu-id="7b217-127">ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€Osage æ–‡å­—ãŒæ­£ã—ãã‚«ã‚¦ãƒ³ãƒˆã•ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-127">The preceding code counts Osage letters correctly:</span></span>

```csharp
CountLettersInString("ğ“ğ“˜ğ“»ğ“˜ğ“»ğ“Ÿ ğ’»ğ“Ÿ")
// Returns 8
```

#### <a name="code-that-explicitly-handles-surrogate-pairs"></a><span data-ttu-id="7b217-128">ã‚µãƒ­ã‚²ãƒ¼ãƒˆãƒšã‚¢ã‚’æ˜ç¤ºçš„ã«å‡¦ç†ã™ã‚‹ã‚³ãƒ¼ãƒ‰</span><span class="sxs-lookup"><span data-stu-id="7b217-128">Code that explicitly handles surrogate pairs</span></span>

<span data-ttu-id="7b217-129">ã‚³ãƒ¼ãƒ‰ãŒã‚µãƒ­ã‚²ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§æ˜ç¤ºçš„ã«æ“ä½œã™ã‚‹ Api (æ¬¡ã®ãƒ¡ã‚½ãƒƒãƒ‰ãªã©) ã‚’å‘¼ã³å‡ºã™å ´åˆã¯ã€`Rune` ã®å‹ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-129">Consider using the `Rune` type if your code calls APIs that explicitly operate on surrogate code points, such as the following methods:</span></span>

* <xref:System.Char.IsSurrogate%2A?displayProperty=nameWithType>
* <xref:System.Char.IsSurrogatePair%2A?displayProperty=nameWithType>
* <xref:System.Char.IsHighSurrogate%2A?displayProperty=nameWithType>
* <xref:System.Char.IsLowSurrogate%2A?displayProperty=nameWithType>
* <xref:System.Char.ConvertFromUtf32%2A?displayProperty=nameWithType>
* <xref:System.Char.ConvertToUtf32%2A?displayProperty=nameWithType>

<span data-ttu-id="7b217-130">ãŸã¨ãˆã°ã€æ¬¡ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯ã€ã‚µãƒ­ã‚²ãƒ¼ãƒˆ `char` ã®ãƒšã‚¢ã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã®ç‰¹åˆ¥ãªãƒ­ã‚¸ãƒƒã‚¯ãŒã‚ã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-130">For example, the following method has special logic to deal with surrogate `char` pairs:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/WorkWithSurrogates.cs" id="SnippetUseChar":::

<span data-ttu-id="7b217-131">ã“ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã¯ã€æ¬¡ã®ä¾‹ã®ã‚ˆã†ã« `Rune`ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ã‚ˆã‚Šç°¡å˜ã«ãªã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-131">Such code is simpler if it uses `Rune`, as in the following example:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/WorkWithSurrogates.cs" id="SnippetUseRune":::

### <a name="when-not-to-use-rune"></a><span data-ttu-id="7b217-132">`Rune` ã‚’ä½¿ç”¨ã—ãªã„å ´åˆ</span><span class="sxs-lookup"><span data-stu-id="7b217-132">When not to use `Rune`</span></span>

<span data-ttu-id="7b217-133">ã‚³ãƒ¼ãƒ‰ã®å ´åˆã€`Rune` ã®ç¨®é¡ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-133">You don't need to use the `Rune` type if your code:</span></span>

* <span data-ttu-id="7b217-134">å®Œå…¨ã«ä¸€è‡´ã™ã‚‹ `char` ã‚’æ¤œç´¢ã—ã¾ã™</span><span class="sxs-lookup"><span data-stu-id="7b217-134">Looks for exact `char` matches</span></span>
* <span data-ttu-id="7b217-135">æ—¢çŸ¥ã® char å€¤ã«æ–‡å­—åˆ—ã‚’åˆ†å‰²ã—ã¾ã™</span><span class="sxs-lookup"><span data-stu-id="7b217-135">Splits a string on a known char value</span></span>

<span data-ttu-id="7b217-136">`Rune` ã®å‹ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ã‚³ãƒ¼ãƒ‰ãŒæ¬¡ã®ã‚ˆã†ãªå ´åˆã«æ­£ã—ããªã„çµæœã‚’è¿”ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-136">Using the `Rune` type may return incorrect results if your code:</span></span>

* <span data-ttu-id="7b217-137">`string` å†…ã®è¡¨ç¤ºæ–‡å­—æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆã—ã¾ã™</span><span class="sxs-lookup"><span data-stu-id="7b217-137">Counts the number of display characters in a `string`</span></span>

#### <a name="look-for-exact-char-matches"></a><span data-ttu-id="7b217-138">å®Œå…¨ã«ä¸€è‡´ã™ã‚‹ `char` ã‚’æ¤œç´¢ã™ã‚‹</span><span class="sxs-lookup"><span data-stu-id="7b217-138">Look for exact `char` matches</span></span>

<span data-ttu-id="7b217-139">æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€ç‰¹å®šã®æ–‡å­—ã‚’æ¤œç´¢ã™ã‚‹ `string` ã‚’åå¾©å‡¦ç†ã—ã€æœ€åˆã«ä¸€è‡´ã—ãŸæ–‡å­—åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-139">The following code iterates through a `string` looking for specific characters, returning the index of the first match.</span></span> <span data-ttu-id="7b217-140">ã‚³ãƒ¼ãƒ‰ãŒ1ã¤ã® `char`ã§è¡¨ã•ã‚Œã‚‹æ–‡å­—ã‚’æ¤œç´¢ã™ã‚‹ãŸã‚ã€`Rune`ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã†ã«ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-140">There's no need to change this code to use `Rune`, as the code is looking for characters that are represented by a single `char`.</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/FindFirstLetter.cs" id="SnippetExample":::

#### <a name="split-a-string-on-a-known-char"></a><span data-ttu-id="7b217-141">æ—¢çŸ¥ã® `char` ã§æ–‡å­—åˆ—ã‚’åˆ†å‰²ã™ã‚‹</span><span class="sxs-lookup"><span data-stu-id="7b217-141">Split a string on a known `char`</span></span>

<span data-ttu-id="7b217-142">æ¬¡ã®ä¾‹ã®ã‚ˆã†ã«ã€`string.Split` ã‚’å‘¼ã³å‡ºã—ã€`' '` (ã‚¹ãƒšãƒ¼ã‚¹) ã‚„ `','` (ã‚³ãƒ³ãƒ) ãªã©ã®åŒºåˆ‡ã‚Šè¨˜å·ã‚’ä½¿ç”¨ã™ã‚‹ã®ãŒä¸€èˆ¬çš„ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-142">It's common to call `string.Split` and use delimiters such as `' '` (space) or `','` (comma), as in the following example:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/SplitStringOnChar.cs" id="SnippetExample":::

<span data-ttu-id="7b217-143">ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯1ã¤ã® `char`ã§è¡¨ã•ã‚Œã‚‹æ–‡å­—ã‚’æ¤œç´¢ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ `Rune` ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-143">There is no need to use `Rune` here, because the code is looking for characters that are represented by a single `char`.</span></span>

#### <a name="count-the-number-of-display-characters-in-a-string"></a><span data-ttu-id="7b217-144">`string` å†…ã®è¡¨ç¤ºæ–‡å­—æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹</span><span class="sxs-lookup"><span data-stu-id="7b217-144">Count the number of display characters in a `string`</span></span>

<span data-ttu-id="7b217-145">æ–‡å­—åˆ—å†…ã® `Rune` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ•°ãŒã€æ–‡å­—åˆ—ã‚’è¡¨ç¤ºã™ã‚‹ã¨ãã«è¡¨ç¤ºã•ã‚Œã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ perceivable ã®æ–‡å­—æ•°ã¨ä¸€è‡´ã—ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-145">The number of `Rune` instances in a string might not match the number of user-perceivable characters shown when displaying the string.</span></span>

<span data-ttu-id="7b217-146">`Rune` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¡¨ã—ã¦ã„ã‚‹ãŸã‚ã€ [unicode ãƒ†ã‚­ã‚¹ãƒˆã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³](https://www.unicode.org/reports/tr29/)ã«å¾“ã†ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§ã¯ã€`Rune` ã‚’è¡¨ç¤ºæ–‡å­—ã‚’ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹ãŸã‚ã®æ§‹æˆè¦ç´ ã¨ã—ã¦ä½¿ç”¨ã§ãã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-146">Since `Rune` instances represent Unicode scalar values, components that follow the [Unicode text segmentation guidelines](https://www.unicode.org/reports/tr29/) can use `Rune` as a building block for counting display characters.</span></span>

<span data-ttu-id="7b217-147"><xref:System.Globalization.StringInfo> å‹ã¯ã€è¡¨ç¤ºæ–‡å­—ã‚’ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã¾ã™ãŒã€.NET 5 ä»¥å¤–ã® .NET ã®å®Ÿè£…ã§ã¯ã€ã™ã¹ã¦ã®ã‚·ãƒŠãƒªã‚ªã§é©åˆ‡ã«ã‚«ã‚¦ãƒ³ãƒˆã•ã‚Œã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-147">The <xref:System.Globalization.StringInfo> type can be used to count display characters, but in implementations of .NET other than .NET 5 it doesn't count correctly in all scenarios.</span></span>

<span data-ttu-id="7b217-148">è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã€Œ[æ›¸è¨˜ç´ ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼](/dotnet/standard/base-types/character-encoding-introduction#grapheme-clusters)ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-148">For more information, see [Grapheme clusters](/dotnet/standard/base-types/character-encoding-introduction#grapheme-clusters).</span></span>

### <a name="how-to-instantiate-a-rune"></a><span data-ttu-id="7b217-149">`Rune` ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹æ–¹æ³•</span><span class="sxs-lookup"><span data-stu-id="7b217-149">How to instantiate a `Rune`</span></span>

<span data-ttu-id="7b217-150">`Rune` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—ã™ã‚‹ã«ã¯ã€ã„ãã¤ã‹ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-150">There are several ways to get a `Rune` instance.</span></span> <span data-ttu-id="7b217-151">ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ã€ã‹ã‚‰ç›´æ¥ `Rune` ã‚’ä½œæˆã§ãã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-151">You can use a constructor to create a `Rune` directly from:</span></span>

* <span data-ttu-id="7b217-152">ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-152">A code point.</span></span>

  :::code language="csharp" source="~/snippets/System.Text/Rune/csharp/InstantiateRunes.cs" id="SnippetCodePoint":::

* <span data-ttu-id="7b217-153">1ã¤ã® `char`ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-153">A single `char`.</span></span>

  :::code language="csharp" source="~/snippets/System.Text/Rune/csharp/InstantiateRunes.cs" id="SnippetChar":::

* <span data-ttu-id="7b217-154">ã‚µãƒ­ã‚²ãƒ¼ãƒˆ `char` ãƒšã‚¢ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-154">A surrogate `char` pair.</span></span>

  :::code language="csharp" source="~/snippets/System.Text/Rune/csharp/InstantiateRunes.cs" id="SnippetSurrogate":::

<span data-ttu-id="7b217-155">å…¥åŠ›ãŒæœ‰åŠ¹ãª Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¡¨ã—ã¦ã„ãªã„å ´åˆã€ã™ã¹ã¦ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã¯ `ArgumentException` ã‚’ã‚¹ãƒ­ãƒ¼ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-155">All of the constructors throw an `ArgumentException` if the input doesn't represent a valid Unicode scalar value.</span></span>

<span data-ttu-id="7b217-156">ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã«ä¾‹å¤–ãŒã‚¹ãƒ­ãƒ¼ã•ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹å‘¼ã³å‡ºã—å…ƒã«ã¯ã€<xref:System.Text.Rune.TryCreate%2A?displayProperty=nameWithType> ãƒ¡ã‚½ãƒƒãƒ‰ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-156">There are <xref:System.Text.Rune.TryCreate%2A?displayProperty=nameWithType> methods available for callers who don't want exceptions to be thrown on failure.</span></span>

<span data-ttu-id="7b217-157">`Rune` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€æ—¢å­˜ã®å…¥åŠ›ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‹ã‚‰èª­ã¿å–ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-157">`Rune` instances can also be read from existing input sequences.</span></span> <span data-ttu-id="7b217-158">ãŸã¨ãˆã°ã€UTF-16 ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ `ReadOnlySpan<char>` ã‚’æŒ‡å®šã—ãŸå ´åˆã€<xref:System.Text.Rune.DecodeFromUtf16%2A?displayProperty=nameWithType> ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å…¥åŠ›ã‚¹ãƒ‘ãƒ³ã®å…ˆé ­ã«ã‚ã‚‹æœ€åˆã® `Rune` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-158">For instance, given a `ReadOnlySpan<char>` that represents UTF-16 data, the <xref:System.Text.Rune.DecodeFromUtf16%2A?displayProperty=nameWithType> method returns the first `Rune` instance at the beginning of the input span.</span></span> <span data-ttu-id="7b217-159"><xref:System.Text.Rune.DecodeFromUtf8%2A?displayProperty=nameWithType> ãƒ¡ã‚½ãƒƒãƒ‰ã¯åŒæ§˜ã«å‹•ä½œã—ã€UTF-8 ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ `ReadOnlySpan<byte>` ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-159">The <xref:System.Text.Rune.DecodeFromUtf8%2A?displayProperty=nameWithType> method operates similarly, accepting a `ReadOnlySpan<byte>` parameter that represents UTF-8 data.</span></span> <span data-ttu-id="7b217-160">ã‚¹ãƒ‘ãƒ³ã®å…ˆé ­ã§ã¯ãªãã€ã‚¹ãƒ‘ãƒ³ã®æœ«å°¾ã‹ã‚‰èª­ã¿å–ã‚‹åŒç­‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-160">There are equivalent methods to read from the end of the span instead of the beginning of the span.</span></span>

### <a name="query-properties-of-a-rune"></a><span data-ttu-id="7b217-161">`Rune` ã®ã‚¯ã‚¨ãƒªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£</span><span class="sxs-lookup"><span data-stu-id="7b217-161">Query properties of a `Rune`</span></span>

<span data-ttu-id="7b217-162">`Rune` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ•´æ•°ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆå€¤ã‚’å–å¾—ã™ã‚‹ã«ã¯ã€<xref:System.Text.Rune.Value?displayProperty=nameWithType> ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-162">To get the integer code point value of a `Rune` instance, use the <xref:System.Text.Rune.Value?displayProperty=nameWithType> property.</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/InstantiateRunes.cs" id="SnippetValue":::

<span data-ttu-id="7b217-163">`char` ã®ç¨®é¡ã§ä½¿ç”¨ã§ãã‚‹é™çš„ Api ã®å¤šãã¯ã€`Rune` ã®ç¨®é¡ã§ã‚‚ä½¿ç”¨ã§ãã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-163">Many of the static APIs available on the `char` type are also available on the `Rune` type.</span></span> <span data-ttu-id="7b217-164">ãŸã¨ãˆã°ã€<xref:System.Text.Rune.IsWhiteSpace%2A?displayProperty=nameWithType> ã¨ <xref:System.Text.Rune.GetUnicodeCategory%2A?displayProperty=nameWithType> ã¯ <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> ãƒ¡ã‚½ãƒƒãƒ‰ã¨ <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> ãƒ¡ã‚½ãƒƒãƒ‰ã«ç›¸å½“ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-164">For instance, <xref:System.Text.Rune.IsWhiteSpace%2A?displayProperty=nameWithType> and <xref:System.Text.Rune.GetUnicodeCategory%2A?displayProperty=nameWithType> are equivalents to <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> and <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="7b217-165">`Rune` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ã‚µãƒ­ã‚²ãƒ¼ãƒˆãƒšã‚¢ã‚’æ­£ã—ãå‡¦ç†ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-165">The `Rune` methods correctly handle surrogate pairs.</span></span>

<span data-ttu-id="7b217-166">æ¬¡ã®ã‚³ãƒ¼ãƒ‰ä¾‹ã§ã¯ã€å…¥åŠ›ã¨ã—ã¦ `ReadOnlySpan<char>` ã‚’å—ã‘å–ã‚Šã€æ–‡å­—ã¾ãŸã¯æ•°å­—ã§ã¯ãªã„ `Rune` ã”ã¨ã«ã‚¹ãƒ‘ãƒ³ã®å…ˆé ­ã¨æœ«å°¾ã®ä¸¡æ–¹ã‹ã‚‰ãƒˆãƒªãƒ ã—ã¦ã„ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-166">The following example code takes a `ReadOnlySpan<char>` as input and trims from both the start and the end of the span every `Rune` that isn't a letter or a digit.</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/TrimNonLettersAndNonDigits.cs" id="SnippetExample":::

<span data-ttu-id="7b217-167">`char` ã¨ `Rune`ã«ã¯ API ã®é•ã„ãŒã„ãã¤ã‹ã‚ã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-167">There are some API differences between `char` and `Rune`.</span></span> <span data-ttu-id="7b217-168">æ¬¡ã«ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-168">For example:</span></span>

* <span data-ttu-id="7b217-169">å®šç¾©ã«ã‚ˆã£ã¦ `Rune` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã‚µãƒ­ã‚²ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«ã™ã‚‹ã“ã¨ã¯ã§ããªã„ãŸã‚ã€<xref:System.Char.IsSurrogate(System.Char)?displayProperty=nameWithType>ã«ç›¸å½“ã™ã‚‹ `Rune` ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-169">There is no `Rune` equivalent  to <xref:System.Char.IsSurrogate(System.Char)?displayProperty=nameWithType>, since `Rune` instances by definition can never be surrogate code points.</span></span>
* <span data-ttu-id="7b217-170"><xref:System.Text.Rune.GetUnicodeCategory%2A?displayProperty=nameWithType> ã¯ã€å¿…ãšã—ã‚‚ <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType>ã¨åŒã˜çµæœã‚’è¿”ã—ã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-170">The <xref:System.Text.Rune.GetUnicodeCategory%2A?displayProperty=nameWithType> doesn't always return the same result as <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7b217-171"><xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>ã¨åŒã˜å€¤ãŒè¿”ã•ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-171">It does return the same value as <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7b217-172">è©³ç´°ã«ã¤ã„ã¦ã¯ã€<xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType>ã®**è§£èª¬**ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-172">For more information, see the **Remarks** on <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType>.</span></span>

### <a name="convert-a-rune-to-utf-8-or-utf-16"></a><span data-ttu-id="7b217-173">`Rune` ã‚’ UTF-8 ã¾ãŸã¯ UTF-16 ã«å¤‰æ›ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-173">Convert a `Rune` to UTF-8 or UTF-16</span></span>

<span data-ttu-id="7b217-174">`Rune` ã¯ Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã§ã‚ã‚‹ãŸã‚ã€UTF-8ã€UTF-16ã€ã¾ãŸã¯32ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã«å¤‰æ›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-174">Since a `Rune` is a Unicode scalar value, it can be converted to UTF-8, UTF-16, or UTF-32 encoding.</span></span> <span data-ttu-id="7b217-175">`Rune` å‹ã«ã¯ã€UTF-8 ãŠã‚ˆã³ UTF-16 ã«å¤‰æ›ã™ã‚‹ãŸã‚ã®ã‚µãƒãƒ¼ãƒˆãŒçµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-175">The `Rune` type has built-in support for conversion to UTF-8 and UTF-16.</span></span>

<span data-ttu-id="7b217-176"><xref:System.Text.Rune.EncodeToUtf16%2A?displayProperty=nameWithType> ã¯ã€`Rune` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ `char` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«å¤‰æ›ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-176">The <xref:System.Text.Rune.EncodeToUtf16%2A?displayProperty=nameWithType> converts a `Rune` instance to `char` instances.</span></span> <span data-ttu-id="7b217-177">`Rune` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ UTF-16 ã«å¤‰æ›ã—ãŸçµæœã¨ã—ã¦å¾—ã‚‰ã‚Œã‚‹ `char` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ•°ã‚’ç…§ä¼šã™ã‚‹ã«ã¯ã€<xref:System.Text.Rune.Utf16SequenceLength?displayProperty=nameWithType> ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-177">To query the number of `char` instances that would result from converting a `Rune` instance to UTF-16, use the <xref:System.Text.Rune.Utf16SequenceLength?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="7b217-178">UTF-8 å¤‰æ›ã§ã‚‚åŒæ§˜ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå­˜åœ¨ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-178">Similar methods exist for UTF-8 conversion.</span></span>

<span data-ttu-id="7b217-179">æ¬¡ã®ä¾‹ã§ã¯ã€`Rune` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ `char` é…åˆ—ã«å¤‰æ›ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-179">The following example converts a `Rune` instance to a `char` array.</span></span> <span data-ttu-id="7b217-180">ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã€`rune` å¤‰æ•°ã« `Rune` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã‚ã‚‹ã“ã¨ã‚’å‰æã¨ã—ã¦ã„ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-180">The code assumes you have a `Rune` instance in the `rune` variable:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/EncodeRune.cs" id="SnippetUtf16CharArray":::

<span data-ttu-id="7b217-181">`string` ã¯ä¸€é€£ã® UTF-16 æ–‡å­—ã§ã‚ã‚‹ãŸã‚ã€æ¬¡ã®ä¾‹ã§ã¯ã€`Rune` ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚‚ UTF-16 ã«å¤‰æ›ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-181">Since a `string` is a sequence of UTF-16 chars, the following example also converts a `Rune` instance to UTF-16:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/EncodeRune.cs" id="SnippetUtf16String":::

<span data-ttu-id="7b217-182">æ¬¡ã®ä¾‹ã§ã¯ã€`Rune` ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ `UTF-8` ãƒã‚¤ãƒˆé…åˆ—ã«å¤‰æ›ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-182">The following example converts a `Rune` instance to a `UTF-8` byte array:</span></span>

:::code language="csharp" source="~/snippets/System.Text/Rune/csharp/EncodeRune.cs" id="SnippetUtf8ByteArray":::

<span data-ttu-id="7b217-183"><xref:System.Text.Rune.EncodeToUtf16%2A?displayProperty=nameWithType> ãƒ¡ã‚½ãƒƒãƒ‰ã¨ <xref:System.Text.Rune.EncodeToUtf8%2A?displayProperty=nameWithType> ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€æ›¸ãè¾¼ã¾ã‚ŒãŸå®Ÿéš›ã®è¦ç´ æ•°ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-183">The <xref:System.Text.Rune.EncodeToUtf16%2A?displayProperty=nameWithType> and <xref:System.Text.Rune.EncodeToUtf8%2A?displayProperty=nameWithType> methods return the actual number of elements written.</span></span> <span data-ttu-id="7b217-184">ã‚³ãƒ”ãƒ¼å…ˆã®ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒçŸ­ã™ãã¦çµæœã‚’æ ¼ç´ã§ããªã„å ´åˆã¯ã€ä¾‹å¤–ãŒã‚¹ãƒ­ãƒ¼ã•ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-184">They throw an exception if the destination buffer is too short to contain the result.</span></span> <span data-ttu-id="7b217-185">ä¾‹å¤–ã‚’å›é¿ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å‘¼ã³å‡ºã—å…ƒã«å¯¾ã—ã¦ã€ã‚¹ãƒ­ãƒ¼ã•ã‚Œãªã„ <xref:System.Text.Rune.TryEncodeToUtf8%2A> ãŠã‚ˆã³ <xref:System.Text.Rune.EncodeToUtf16%2A> ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ã‚ã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-185">There are non-throwing <xref:System.Text.Rune.TryEncodeToUtf8%2A> and <xref:System.Text.Rune.EncodeToUtf16%2A> methods as well for callers who want to avoid exceptions.</span></span>

### <a name="rune-in-net-vs-other-languages"></a><span data-ttu-id="7b217-186">.NET ã¨ãã®ä»–ã®è¨€èªã®ãƒ«ãƒ¼ãƒ³</span><span class="sxs-lookup"><span data-stu-id="7b217-186">Rune in .NET vs. other languages</span></span>

<span data-ttu-id="7b217-187">"ãƒ«ãƒ¼ãƒ³" ã¨ã„ã†ç”¨èªã¯ã€Unicode è¦æ ¼ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-187">The term "rune" is not defined in the Unicode Standard.</span></span> <span data-ttu-id="7b217-188">æ—¥ä»˜ã¨ã„ã†ç”¨èªã¯ã€ [utf-8 ã®ä½œæˆ](https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt)ã«æˆ»ã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-188">The term dates back to [the creation of UTF-8](https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt).</span></span> <span data-ttu-id="7b217-189">æ¸¡ã‚·ãƒ£ãƒ¼ãƒãƒ³ã¨ Ken Thompson ã¯ã€æœ€çµ‚çš„ã«ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¨ã—ã¦çŸ¥ã‚‰ã‚Œã‚‹ã“ã¨ã‚’èª¬æ˜ã™ã‚‹ç”¨èªã‚’æ¢ã—ã¦ã„ã¾ã—ãŸã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-189">Rob Pike and Ken Thompson were looking for a term to describe what would eventually become known as a code point.</span></span> <span data-ttu-id="7b217-190">[ã“ã‚Œã‚‰ã¯ "ãƒ«ãƒ¼ãƒ³" ã¨ã„ã†ç”¨èªã§æ±ºæ¸ˆ](https://twitter.com/rob_pike/status/732353233474064384)ã•ã‚Œã€å¾Œã§æ¸¡ã‚·ãƒ£ãƒ¼ãƒãƒ³ãŒ Popularize ã®ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã«å½±éŸ¿ã‚’åŠã¼ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-190">[They settled on the term "rune"](https://twitter.com/rob_pike/status/732353233474064384), and Rob Pike's later influence over the Go programming language helped popularize the term.</span></span>

<span data-ttu-id="7b217-191">ãŸã ã—ã€.NET `Rune` ã®ç¨®é¡ã¯ã€[`rune` ã®ç¨®é¡] ã¨åŒã˜ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-191">However, the .NET `Rune` type is not the equivalent of the Go `rune` type.</span></span> <span data-ttu-id="7b217-192">å¤–å‡ºå…ˆã§ã¯ã€`rune` ã®ç¨®é¡ã¯[`int32`ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹](https://blog.golang.org/strings)ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-192">In Go, the `rune` type is an [alias for `int32`](https://blog.golang.org/strings).</span></span> <span data-ttu-id="7b217-193">ã‚´ãƒ¼ãƒ«ãƒ¼ãƒ³ã¯ã€Unicode ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’è¡¨ã™ã“ã¨ã‚’ç›®çš„ã¨ã—ã¦ã„ã¾ã™ãŒã€ã‚µãƒ­ã‚²ãƒ¼ãƒˆã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚„æœ‰åŠ¹ãª Unicode ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ã¯ãªã„å€¤ãªã©ã€ä»»æ„ã®32ãƒ“ãƒƒãƒˆå€¤ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-193">A Go rune is intended to represent a Unicode code point, but it can be any 32-bit value, including surrogate code points and values that are not legal Unicode code points.</span></span>

<span data-ttu-id="7b217-194">ä»–ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®é¡ä¼¼ã™ã‚‹å‹ã«ã¤ã„ã¦ã¯ã€ã€Œ [Rust ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ– `char` type](https://doc.rust-lang.org/std/primitive.char.html) ã€ã¾ãŸã¯ã€Œ [Swift ã® `Unicode.Scalar` å‹](https://developer.apple.com/documentation/swift/unicode/scalar)ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ã©ã¡ã‚‰ã‚‚ Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¡¨ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-194">For similar types in other programming languages, see [Rust's primitive `char` type](https://doc.rust-lang.org/std/primitive.char.html) or [Swift's `Unicode.Scalar` type](https://developer.apple.com/documentation/swift/unicode/scalar), both of which represent Unicode scalar values.</span></span> <span data-ttu-id="7b217-195">ã¨åŒæ§˜ã®æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚NET ã® `Rune` å‹ã§ã€æœ‰åŠ¹ãª Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã§ã¯ãªã„å€¤ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã‚’è¨±å¯ã—ã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-195">They provide functionality similar to .NET's `Rune` type, and they disallow instantiation of values that are not legal Unicode scalar values.</span></span>

          ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(char ch);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : char -&gt; System.Text.Rune" Usage="new System.Text.Rune ch" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch"><span data-ttu-id="7b217-196">UTF-16 ã‚³ãƒ¼ãƒ‰å˜ä½ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-196">A UTF-16 code unit.</span></span></param>
        <summary><span data-ttu-id="7b217-197">æŒ‡å®šã•ã‚ŒãŸ UTF-16 ã‚³ãƒ¼ãƒ‰å˜ä½ã‹ã‚‰ <see cref="T:System.Text.Rune" /> ã‚’ä½œæˆã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-197">Creates a <see cref="T:System.Text.Rune" /> from the provided UTF-16 code unit.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7b217-198"><paramref name="ch" /> ã¯ã€UTF-16 ã‚µãƒ­ã‚²ãƒ¼ãƒˆ ã‚³ãƒ¼ãƒ‰ ãƒã‚¤ãƒ³ãƒˆ (U+D800..U+DFFFã€æœ€åˆã¨æœ€å¾Œã®è¦ç´ ã‚’å«ã‚€) ã‚’è¡¨ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-198"><paramref name="ch" /> represents a UTF-16 surrogate code point (U+D800..U+DFFF, inclusive).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(int value);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : int -&gt; System.Text.Rune" Usage="new System.Text.Rune value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-199">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-199">A Unicode scalar value.</span></span></param>
        <summary><span data-ttu-id="7b217-200">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¡¨ã™ã€æŒ‡å®šã•ã‚ŒãŸ 32 ãƒ“ãƒƒãƒˆæ•´æ•°ã‹ã‚‰ <see cref="T:System.Text.Rune" /> ã‚’ä½œæˆã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-200">Creates a <see cref="T:System.Text.Rune" /> from the specified 32-bit integer that represents a Unicode scalar value.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7b217-201"><paramref name="value" /> ã¯ Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¡¨ã—ã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-201"><paramref name="value" /> does not represent a Unicode scalar value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : uint32 -&gt; System.Text.Rune" Usage="new System.Text.Rune value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-202">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-202">A Unicode scalar value.</span></span></param>
        <summary><span data-ttu-id="7b217-203">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¡¨ã™ã€æŒ‡å®šã•ã‚ŒãŸç¬¦å·ãªã— 32 ãƒ“ãƒƒãƒˆæ•´æ•°ã‹ã‚‰ <see cref="T:System.Text.Rune" /> ã‚’ä½œæˆã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-203">Creates a <see cref="T:System.Text.Rune" /> from the specified 32-bit unsigned integer that represents a Unicode scalar value.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7b217-204"><paramref name="value" /> ã¯ Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¡¨ã—ã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-204"><paramref name="value" /> does not represent a Unicode scalar value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rune (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.#ctor(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (highSurrogate As Char, lowSurrogate As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rune(char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="F#" Value="new System.Text.Rune : char * char -&gt; System.Text.Rune" Usage="new System.Text.Rune (highSurrogate, lowSurrogate)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="highSurrogate"><span data-ttu-id="7b217-205">ã‚µãƒ­ã‚²ãƒ¼ãƒˆ ãƒšã‚¢ã®ä¸Šä½ã‚µãƒ­ã‚²ãƒ¼ãƒˆã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-205">The high surrogate of the surrogate pair.</span></span></param>
        <param name="lowSurrogate"><span data-ttu-id="7b217-206">ã‚µãƒ­ã‚²ãƒ¼ãƒˆ ãƒšã‚¢ã®ä¸‹ä½ã‚µãƒ­ã‚²ãƒ¼ãƒˆã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-206">The low surrogate of the surrogate pair.</span></span></param>
        <summary><span data-ttu-id="7b217-207">æŒ‡å®šã•ã‚ŒãŸ UTF-16 ã‚µãƒ­ã‚²ãƒ¼ãƒˆ ãƒšã‚¢ã‹ã‚‰ <see cref="T:System.Text.Rune" /> ã‚’ä½œæˆã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-207">Creates a <see cref="T:System.Text.Rune" /> from the provided UTF-16 surrogate pair.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7b217-208"><paramref name="highSurrogate" /> ã¯ UTF-16 ä¸Šä½ã‚µãƒ­ã‚²ãƒ¼ãƒˆ ã‚³ãƒ¼ãƒ‰ ãƒã‚¤ãƒ³ãƒˆã‚’è¡¨ã—ã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-208"><paramref name="highSurrogate" /> does not represent a UTF-16 high surrogate code point.</span></span>
          
<span data-ttu-id="7b217-209">- ã¾ãŸã¯ -</span><span class="sxs-lookup"><span data-stu-id="7b217-209">-or-</span></span>

<span data-ttu-id="7b217-210"><paramref name="lowSurrogate" /> ã¯ UTF-16 ä¸‹ä½ã‚µãƒ­ã‚²ãƒ¼ãƒˆ ã‚³ãƒ¼ãƒ‰ ãƒã‚¤ãƒ³ãƒˆã‚’è¡¨ã—ã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-210"><paramref name="lowSurrogate" /> does not represent a UTF-16 low surrogate code point.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Text.Rune other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Text.Rune other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.CompareTo(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Rune) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Text::Rune other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Text.Rune -&gt; int&#xA;override this.CompareTo : System.Text.Rune -&gt; int" Usage="rune.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="7b217-211">ç¾åœ¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨æ¯”è¼ƒã™ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-211">The instance to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="7b217-212">ç¾åœ¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã€æŒ‡å®šã•ã‚ŒãŸ <see cref="T:System.Text.Rune" /> ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨æ¯”è¼ƒã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-212">Compares the current instance to the specified <see cref="T:System.Text.Rune" /> instance.</span></span></summary>
        <returns><span data-ttu-id="7b217-213">ä¸¦ã¹æ›¿ãˆé †åºã«ãŠã„ã¦ã€<paramref name="other" /> ã¨ã®é–¢ä¿‚ã§ã“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä½ç½®ã‚’ç¤ºã™ç¬¦å·ä»˜ãæ•´æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-213">A signed integer indicating the position of this instance in the sort order in relation to <paramref name="other" />:</span></span> <br /><span data-ttu-id="7b217-214">- 0 æœªæº€:ã“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä½ç½®ãŒ <paramref name="other" /> ã‚ˆã‚Šã‚‚å‰ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-214">- Less than zero: This instance precedes <paramref name="other" />.</span></span> 
<br /><span data-ttu-id="7b217-215">- ã‚¼ãƒ­:ä¸¦ã¹æ›¿ãˆé †åºã«ãŠã„ã¦ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä½ç½®ãŒ <paramref name="other" /> ã¨åŒã˜ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-215">- Zero: The instance has the same position in the sort order as <paramref name="other" />.</span></span>
<br /><span data-ttu-id="7b217-216">- 0 ã‚ˆã‚Šå¤§ãã„:ã“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä½ç½®ãŒ <paramref name="other" /> ã‚ˆã‚Šã‚‚å¾Œã‚ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-216">- Greater than zero: This instance follows <paramref name="other" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeFromUtf16">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeFromUtf16 (ReadOnlySpan&lt;char&gt; source, out System.Text.Rune result, out int charsConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeFromUtf16(valuetype System.ReadOnlySpan`1&lt;char&gt; source, [out] valuetype System.Text.Rune&amp; result, [out] int32&amp; charsConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeFromUtf16 (source As ReadOnlySpan(Of Char), ByRef result As Rune, ByRef charsConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeFromUtf16(ReadOnlySpan&lt;char&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % result, [Runtime::InteropServices::Out] int % charsConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeFromUtf16 : ReadOnlySpan&lt;char&gt; * Rune * int -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeFromUtf16 (source, result, charsConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="charsConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="7b217-217">èª­ã¿å–ã‚Šå°‚ç”¨ UTF-16 æ–‡å­—ã‚¹ãƒ‘ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-217">A read-only UTF-16 character span.</span></span></param>
        <param name="result"><span data-ttu-id="7b217-218">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰åˆ¶å¾¡ãŒæˆ»ã‚‹ã¨ãã«ã€ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-218">When this method returns, the decoded rune.</span></span></param>
        <param name="charsConsumed"><span data-ttu-id="7b217-219">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰åˆ¶å¾¡ãŒæˆ»ã‚‹ã¨ãã«ã€ãƒ«ãƒ¼ãƒ³ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«èª­ã¿å–ã‚‰ã‚ŒãŸæ–‡å­—æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-219">When this method returns, the number of characters read to create the rune.</span></span></param>
        <summary><span data-ttu-id="7b217-220">æŒ‡å®šã•ã‚ŒãŸ UTF-16 ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ã®å…ˆé ­ã§ <see cref="T:System.Text.Rune" /> ã‚’å¾©å·ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-220">Decodes the <see cref="T:System.Text.Rune" /> at the beginning of the provided UTF-16 source buffer.</span></span></summary>
        <returns><span data-ttu-id="7b217-221">UTF-16 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæœ‰åŠ¹ãªã‚¹ã‚«ãƒ©ãƒ¼å€¤ã§ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒå§‹ã¾ã‚‹å ´åˆã€<see cref="F:System.Buffers.OperationStatus.Done" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-221"><see cref="F:System.Buffers.OperationStatus.Done" /> if the source buffer begins with a valid UTF-16 encoded scalar value.</span></span> <span data-ttu-id="7b217-222">çµæœã¨ã—ã¦ã€å¾©å·ã•ã‚ŒãŸ <see cref="T:System.Text.Rune" /> ãŒ <paramref name="result" /> ã«å«ã¾ã‚Œã¾ã™ã€‚<paramref name="charsConsumed" /> ã«ã¯ <see cref="T:System.Text.Rune" /> ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ç›®çš„ã§å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ãƒ¼ã§ä½¿ç”¨ã•ã‚Œã‚‹ <see cref="T:System.Char" /> å€¤ã®æ•°ãŒå«ã¾ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-222"><paramref name="result" /> then contains the decoded <see cref="T:System.Text.Rune" />, and <paramref name="charsConsumed" /> contains the number of <see cref="T:System.Char" /> values used in the input buffer to encode the <see cref="T:System.Text.Rune" />.</span></span>
            
<span data-ttu-id="7b217-223">ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒç©ºã‹ã€ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³ã® UTF-16 ä¸Šä½ã‚µãƒ­ã‚²ãƒ¼ãƒˆæ–‡å­—ã®ã¿ãŒå«ã¾ã‚Œã‚‹å ´åˆã€<see cref="F:System.Buffers.OperationStatus.NeedMoreData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-223"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" /> if the source buffer is empty or contains only a standalone UTF-16 high surrogate character.</span></span> <span data-ttu-id="7b217-224">çµæœã¨ã—ã¦ã€<paramref name="result" /> ã« <see cref="P:System.Text.Rune.ReplacementChar" /> ãŒå«ã¾ã‚Œã€<paramref name="charsConsumed" /> ã«ã¯å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ãƒ¼ã®é•·ã•ãŒå«ã¾ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-224"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="charsConsumed" /> contains the length of the input buffer.</span></span>
            
<span data-ttu-id="7b217-225">UTF-16 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸã€å½¢å¼ãŒæ­£ã—ããªã„ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã§ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒå§‹ã¾ã‚‹å ´åˆã€<see cref="F:System.Buffers.OperationStatus.InvalidData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-225"><see cref="F:System.Buffers.OperationStatus.InvalidData" /> if the source buffer begins with an ill-formed UTF-16 encoded scalar value.</span></span> <span data-ttu-id="7b217-226">çµæœã¨ã—ã¦ã€<paramref name="result" /> ã« <see cref="P:System.Text.Rune.ReplacementChar" /> ãŒå«ã¾ã‚Œã€<paramref name="charsConsumed" /> ã«ã¯å½¢å¼ãŒæ­£ã—ããªã„ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸ <see cref="T:System.Char" /> å€¤ã®æ•°ãŒå«ã¾ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-226"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="charsConsumed" /> contains the number of <see cref="T:System.Char" /> values used to encode the ill-formed sequence.</span></span>
<span data-ttu-id="7b217-227">.</span><span class="sxs-lookup"><span data-stu-id="7b217-227">.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-228">ä¸€èˆ¬çš„ãªè¦å‰‡ã§ã¯ã€ãƒ«ãƒ¼ãƒ—å†…ã§ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã€ãƒ«ãƒ¼ãƒ—ã®å„åå¾©å‡¦ç†ã® `charsConsumed` è¦ç´ ã«ã‚ˆã£ã¦ã€`source` ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚’ã‚¹ãƒ©ã‚¤ã‚¹ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-228">The general convention is to call this method in a loop, slicing the `source` buffer by `charsConsumed` elements on each iteration of the loop.</span></span> <span data-ttu-id="7b217-229">ãƒ«ãƒ¼ãƒ—ã®å„åå¾©å‡¦ç†ã§ã¯ã€ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸå ´åˆã¯ã€å®Ÿéš›ã®ã‚¹ã‚«ãƒ©ãƒ¼å€¤ãŒ `result` ã«å«ã¾ã‚Œã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚Œãªã‹ã£ãŸå ´åˆã¯ <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> ãŒå«ã¾ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-229">On each iteration of the loop, `result` contains the real scalar value if the data was successfully decoded, or it contains <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> if the data was not successfully decoded.</span></span> <span data-ttu-id="7b217-230">ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ãƒ«ãƒ¼ãƒ—ã®åå¾©å‡¦ç†ä¸­ã«ã€ç„¡åŠ¹ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è‡ªå‹•çš„ã« U + FFFD ã§ç½®ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-230">This pattern provides convenient automatic U+FFFD substitution of invalid sequences while iterating through the loop.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeFromUtf8">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeFromUtf8 (ReadOnlySpan&lt;byte&gt; source, out System.Text.Rune result, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeFromUtf8(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] valuetype System.Text.Rune&amp; result, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeFromUtf8 (source As ReadOnlySpan(Of Byte), ByRef result As Rune, ByRef bytesConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeFromUtf8(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % result, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeFromUtf8 : ReadOnlySpan&lt;byte&gt; * Rune * int -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeFromUtf8 (source, result, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="7b217-231">UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸèª­ã¿å–ã‚Šå°‚ç”¨ãƒã‚¤ãƒˆ ã‚¹ãƒ‘ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-231">A read-only UTF-8 encoded byte span.</span></span></param>
        <param name="result"><span data-ttu-id="7b217-232">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰åˆ¶å¾¡ãŒæˆ»ã‚‹ã¨ãã«ã€ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-232">When this method returns, the decoded rune.</span></span></param>
        <param name="bytesConsumed"><span data-ttu-id="7b217-233">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰åˆ¶å¾¡ãŒæˆ»ã‚‹ã¨ãã«ã€ãƒ«ãƒ¼ãƒ³ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«èª­ã¿å–ã‚‰ã‚ŒãŸãƒã‚¤ãƒˆæ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-233">When this method returns, the number of bytes read to create the rune.</span></span></param>
        <summary><span data-ttu-id="7b217-234">æŒ‡å®šã•ã‚ŒãŸ UTF-8 ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ã®å…ˆé ­ã§ <see cref="T:System.Text.Rune" /> ã‚’å¾©å·ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-234">Decodes the <see cref="T:System.Text.Rune" /> at the beginning of the provided UTF-8 source buffer.</span></span></summary>
        <returns><span data-ttu-id="7b217-235">UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæœ‰åŠ¹ãªã‚¹ã‚«ãƒ©ãƒ¼å€¤ã§ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒå§‹ã¾ã‚‹å ´åˆã€<see cref="F:System.Buffers.OperationStatus.Done" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-235"><see cref="F:System.Buffers.OperationStatus.Done" /> if the source buffer begins with a valid UTF-8 encoded scalar value.</span></span> <span data-ttu-id="7b217-236">çµæœã¨ã—ã¦ã€å¾©å·ã•ã‚ŒãŸ <see cref="T:System.Text.Rune" /> ãŒ <paramref name="result" /> ã«å«ã¾ã‚Œã¾ã™ã€‚<paramref name="bytesConsumed" /> ã«ã¯ <see cref="T:System.Text.Rune" /> ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ç›®çš„ã§å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ãƒ¼ã§ä½¿ç”¨ã•ã‚Œã‚‹ <see cref="T:System.Byte" /> å€¤ã®æ•°ãŒå«ã¾ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-236"><paramref name="result" /> then contains the decoded <see cref="T:System.Text.Rune" />, and <paramref name="bytesConsumed" /> contains the number of <see cref="T:System.Byte" /> values used in the input buffer to encode the <see cref="T:System.Text.Rune" />.</span></span>
            
<span data-ttu-id="7b217-237">ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒç©ºã‹ã€ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³ã® UTF-8 ä¸Šä½ã‚µãƒ­ã‚²ãƒ¼ãƒˆæ–‡å­—ã®ã¿ãŒå«ã¾ã‚Œã‚‹å ´åˆã€<see cref="F:System.Buffers.OperationStatus.NeedMoreData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-237"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" /> if the source buffer is empty or contains only a standalone UTF-8 high surrogate character.</span></span> <span data-ttu-id="7b217-238">çµæœã¨ã—ã¦ã€<paramref name="result" /> ã« <see cref="P:System.Text.Rune.ReplacementChar" /> ãŒå«ã¾ã‚Œã€<paramref name="bytesConsumed" /> ã«ã¯å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ãƒ¼ã®é•·ã•ãŒå«ã¾ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-238"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="bytesConsumed" /> contains the length of the input buffer.</span></span>
            
<span data-ttu-id="7b217-239">UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸã€å½¢å¼ãŒæ­£ã—ããªã„ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã§å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒå§‹ã¾ã‚‹å ´åˆã€<see cref="F:System.Buffers.OperationStatus.InvalidData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-239"><see cref="F:System.Buffers.OperationStatus.InvalidData" /> if the source buffer begins with an ill-formed UTF-8 encoded scalar value.</span></span> <span data-ttu-id="7b217-240">çµæœã¨ã—ã¦ã€<paramref name="result" /> ã« <see cref="P:System.Text.Rune.ReplacementChar" /> ãŒå«ã¾ã‚Œã€<paramref name="bytesConsumed" /> ã«ã¯å½¢å¼ãŒæ­£ã—ããªã„ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ç›®çš„ã§å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ãƒ¼ã§ä½¿ç”¨ã•ã‚ŒãŸ <see cref="T:System.Byte" /> å€¤ã®æ•°ãŒå«ã¾ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-240"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="bytesConsumed" /> contains the number of <see cref="T:System.Byte" /> values used in the input buffer to encode the ill-formed sequence.</span></span>
<span data-ttu-id="7b217-241">.</span><span class="sxs-lookup"><span data-stu-id="7b217-241">.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-242">ä¸€èˆ¬çš„ãªè¦å‰‡ã§ã¯ã€ãƒ«ãƒ¼ãƒ—å†…ã§ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã€ãƒ«ãƒ¼ãƒ—ã®å„åå¾©å‡¦ç†ã® `bytesConsumed` è¦ç´ ã«ã‚ˆã£ã¦ã€`source` ãƒãƒƒãƒ•ã‚¡ãƒ¼ã‚’ã‚¹ãƒ©ã‚¤ã‚¹ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-242">The general convention is to call this method in a loop, slicing the `source` buffer by `bytesConsumed` elements on each iteration of the loop.</span></span> <span data-ttu-id="7b217-243">ãƒ«ãƒ¼ãƒ—ã®å„åå¾©å‡¦ç†ã§ã¯ã€`result` ãŒæ­£å¸¸ã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸå ´åˆã¯å®Ÿéš›ã®ã‚¹ã‚«ãƒ©ãƒ¼å€¤ãŒå«ã¾ã‚Œã€ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚Œãªã‹ã£ãŸå ´åˆã¯ <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> ãŒå«ã¾ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-243">On each iteration of the loop, `result` contains the real scalar value if successfully decoded, or it contains <xref:System.Text.Rune.ReplacementChar?displayProperty=nameWithType> if the data could not be successfully decoded.</span></span> <span data-ttu-id="7b217-244">ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ãƒ«ãƒ¼ãƒ—ã®åå¾©å‡¦ç†ä¸­ã«ã€ç„¡åŠ¹ãªã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’è‡ªå‹•çš„ã« U + FFFD ã§ç½®ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-244">This pattern provides convenient automatic U+FFFD substitution of invalid sequences while iterating through the loop.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeLastFromUtf16">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeLastFromUtf16 (ReadOnlySpan&lt;char&gt; source, out System.Text.Rune result, out int charsConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeLastFromUtf16(valuetype System.ReadOnlySpan`1&lt;char&gt; source, [out] valuetype System.Text.Rune&amp; result, [out] int32&amp; charsConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeLastFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeLastFromUtf16 (source As ReadOnlySpan(Of Char), ByRef result As Rune, ByRef charsConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeLastFromUtf16(ReadOnlySpan&lt;char&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % result, [Runtime::InteropServices::Out] int % charsConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeLastFromUtf16 : ReadOnlySpan&lt;char&gt; * Rune * int -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeLastFromUtf16 (source, result, charsConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="charsConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="7b217-245">UTF-16 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸèª­ã¿å–ã‚Šå°‚ç”¨æ–‡å­—ã‚¹ãƒ‘ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-245">A read-only UTF-16 encoded character span.</span></span></param>
        <param name="result"><span data-ttu-id="7b217-246">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰åˆ¶å¾¡ãŒæˆ»ã‚‹ã¨ãã«ã€ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-246">When this method returns, the decoded rune.</span></span></param>
        <param name="charsConsumed"><span data-ttu-id="7b217-247">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰åˆ¶å¾¡ãŒæˆ»ã‚‹ã¨ãã«ã€ãƒ«ãƒ¼ãƒ³ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«èª­ã¿å–ã‚‰ã‚ŒãŸãƒã‚¤ãƒˆæ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-247">When this method returns, the number of bytes read to create the rune.</span></span></param>
        <summary><span data-ttu-id="7b217-248">æŒ‡å®šã•ã‚ŒãŸ UTF-16 ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ã®æœ«å°¾ã§ <see cref="T:System.Text.Rune" /> ã‚’å¾©å·ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-248">Decodes the <see cref="T:System.Text.Rune" /> at the end of the provided UTF-16 source buffer.</span></span></summary>
        <returns><span data-ttu-id="7b217-249">UTF-16 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæœ‰åŠ¹ãªã‚¹ã‚«ãƒ©ãƒ¼å€¤ã§ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒå§‹ã¾ã‚‹å ´åˆã€<see cref="F:System.Buffers.OperationStatus.Done" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-249"><see cref="F:System.Buffers.OperationStatus.Done" /> if the source buffer begins with a valid UTF-16 encoded scalar value.</span></span> <span data-ttu-id="7b217-250">çµæœã¨ã—ã¦ã€å¾©å·ã•ã‚ŒãŸ <see cref="T:System.Text.Rune" /> ãŒ <paramref name="result" /> ã«å«ã¾ã‚Œã¾ã™ã€‚<paramref name="charsConsumed" /> ã«ã¯ <see cref="T:System.Text.Rune" /> ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ç›®çš„ã§å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ãƒ¼ã§ä½¿ç”¨ã•ã‚Œã‚‹ <see cref="T:System.Char" /> å€¤ã®æ•°ãŒå«ã¾ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-250"><paramref name="result" /> then contains the decoded <see cref="T:System.Text.Rune" />, and <paramref name="charsConsumed" /> contains the number of <see cref="T:System.Char" /> values used in the input buffer to encode the <see cref="T:System.Text.Rune" />.</span></span>
            
<span data-ttu-id="7b217-251">ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒç©ºã‹ã€ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³ã® UTF-16 ä¸Šä½ã‚µãƒ­ã‚²ãƒ¼ãƒˆæ–‡å­—ã®ã¿ãŒå«ã¾ã‚Œã‚‹å ´åˆã€<see cref="F:System.Buffers.OperationStatus.NeedMoreData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-251"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" /> if the source buffer is empty or contains only a standalone UTF-16 high surrogate character.</span></span> <span data-ttu-id="7b217-252">çµæœã¨ã—ã¦ã€<paramref name="result" /> ã« <see cref="P:System.Text.Rune.ReplacementChar" /> ãŒå«ã¾ã‚Œã€<paramref name="charsConsumed" /> ã«ã¯å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ãƒ¼ã®é•·ã•ãŒå«ã¾ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-252"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="charsConsumed" /> contains the length of the input buffer.</span></span>
            
<span data-ttu-id="7b217-253">UTF-16 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸã€å½¢å¼ãŒæ­£ã—ããªã„ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã§ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒå§‹ã¾ã‚‹å ´åˆã€<see cref="F:System.Buffers.OperationStatus.InvalidData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-253"><see cref="F:System.Buffers.OperationStatus.InvalidData" /> if the source buffer begins with an ill-formed UTF-16 encoded scalar value.</span></span> <span data-ttu-id="7b217-254">çµæœã¨ã—ã¦ã€<paramref name="result" /> ã« <see cref="P:System.Text.Rune.ReplacementChar" /> ãŒå«ã¾ã‚Œã€<paramref name="charsConsumed" /> ã«ã¯å½¢å¼ãŒæ­£ã—ããªã„ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ãŸ <see cref="T:System.Char" /> å€¤ã®æ•°ãŒå«ã¾ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-254"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="charsConsumed" /> contains the number of <see cref="T:System.Char" /> values used to encode the ill-formed sequence.</span></span>
<span data-ttu-id="7b217-255">.</span><span class="sxs-lookup"><span data-stu-id="7b217-255">.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-256">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ <xref:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)>ã¨ã‚ˆãä¼¼ã¦ã„ã¾ã™ãŒã€å‘¼ã³å‡ºã—å…ƒã¯å‰æ–¹ã§ã¯ãªãé€†æ–¹å‘ã«ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-256">This method is very similar to <xref:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)>, except it allows the caller to loop backward instead of forward.</span></span> <span data-ttu-id="7b217-257">ä¸€èˆ¬çš„ãªå‘¼ã³å‡ºã—è¦å‰‡ã§ã¯ã€ãƒ«ãƒ¼ãƒ—ã®å„åå¾©å‡¦ç†ã§ã€å‘¼ã³å‡ºã—å…ƒãŒ `source` ãƒãƒƒãƒ•ã‚¡ãƒ¼ã®æœ€å¾Œã® `charsConsumed` è¦ç´ ã‹ã‚‰ã‚¹ãƒ©ã‚¤ã‚¹ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-257">The typical calling convention is that on each iteration of the loop, the caller should slice off the final `charsConsumed` elements of the `source` buffer.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecodeLastFromUtf8">
      <MemberSignature Language="C#" Value="public static System.Buffers.OperationStatus DecodeLastFromUtf8 (ReadOnlySpan&lt;byte&gt; source, out System.Text.Rune value, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Buffers.OperationStatus DecodeLastFromUtf8(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] valuetype System.Text.Rune&amp; value, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.DecodeLastFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecodeLastFromUtf8 (source As ReadOnlySpan(Of Byte), ByRef value As Rune, ByRef bytesConsumed As Integer) As OperationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Buffers::OperationStatus DecodeLastFromUtf8(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::Text::Rune % value, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member DecodeLastFromUtf8 : ReadOnlySpan&lt;byte&gt; * Rune * int -&gt; System.Buffers.OperationStatus" Usage="System.Text.Rune.DecodeLastFromUtf8 (source, value, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.OperationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Text.Rune" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="7b217-258">UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸèª­ã¿å–ã‚Šå°‚ç”¨ãƒã‚¤ãƒˆ ã‚¹ãƒ‘ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-258">A read-only UTF-8 encoded byte span.</span></span></param>
        <param name="value"><span data-ttu-id="7b217-259">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰åˆ¶å¾¡ãŒæˆ»ã‚‹ã¨ãã«ã€ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-259">When this method returns, the decoded rune.</span></span></param>
        <param name="bytesConsumed"><span data-ttu-id="7b217-260">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰åˆ¶å¾¡ãŒæˆ»ã‚‹ã¨ãã«ã€ãƒ«ãƒ¼ãƒ³ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«èª­ã¿å–ã‚‰ã‚ŒãŸãƒã‚¤ãƒˆæ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-260">When this method returns, the number of bytes read to create the rune.</span></span></param>
        <summary><span data-ttu-id="7b217-261">æŒ‡å®šã•ã‚ŒãŸ UTF-8 ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ã®æœ«å°¾ã§ <see cref="T:System.Text.Rune" /> ã‚’å¾©å·ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-261">Decodes the <see cref="T:System.Text.Rune" /> at the end of the provided UTF-8 source buffer.</span></span></summary>
        <returns><span data-ttu-id="7b217-262">UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸæœ‰åŠ¹ãªã‚¹ã‚«ãƒ©ãƒ¼å€¤ã§ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒçµ‚ã‚ã‚‹å ´åˆã€<see cref="F:System.Buffers.OperationStatus.Done" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-262"><see cref="F:System.Buffers.OperationStatus.Done" /> if the source buffer ends with a valid UTF-8 encoded scalar value.</span></span> <span data-ttu-id="7b217-263">çµæœã¨ã—ã¦ã€å¾©å·ã•ã‚ŒãŸ <see cref="T:System.Text.Rune" /> ãŒ <paramref name="result" /> ã«å«ã¾ã‚Œã¾ã™ã€‚<paramref name="bytesConsumed" /> ã«ã¯ <see cref="T:System.Text.Rune" /> ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ç›®çš„ã§å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ãƒ¼ã§ä½¿ç”¨ã•ã‚Œã‚‹ <see cref="T:System.Byte" /> å€¤ã®æ•°ãŒå«ã¾ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-263"><paramref name="result" /> then contains the decoded <see cref="T:System.Text.Rune" />, and <paramref name="bytesConsumed" /> contains the number of <see cref="T:System.Byte" /> values used in the input buffer to encode the <see cref="T:System.Text.Rune" />.</span></span>
            
<span data-ttu-id="7b217-264">ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒç©ºã‹ã€ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³ã® UTF-8 ä¸Šä½ã‚µãƒ­ã‚²ãƒ¼ãƒˆæ–‡å­—ã®ã¿ãŒå«ã¾ã‚Œã‚‹å ´åˆã€<see cref="F:System.Buffers.OperationStatus.NeedMoreData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-264"><see cref="F:System.Buffers.OperationStatus.NeedMoreData" /> if the source buffer is empty or contains only a standalone UTF-8 high surrogate character.</span></span> <span data-ttu-id="7b217-265">çµæœã¨ã—ã¦ã€<paramref name="result" /> ã« <see cref="P:System.Text.Rune.ReplacementChar" /> ãŒå«ã¾ã‚Œã€<paramref name="bytesConsumed" /> ã«ã¯å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ãƒ¼ã®é•·ã•ãŒå«ã¾ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-265"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="bytesConsumed" /> contains the length of the input buffer.</span></span>
            
<span data-ttu-id="7b217-266">UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸã€å½¢å¼ãŒæ­£ã—ããªã„ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã§ã‚½ãƒ¼ã‚¹ ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒçµ‚ã‚ã‚‹å ´åˆã€<see cref="F:System.Buffers.OperationStatus.InvalidData" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-266"><see cref="F:System.Buffers.OperationStatus.InvalidData" /> if the source buffer ends with an ill-formed UTF-8 encoded scalar value.</span></span> <span data-ttu-id="7b217-267">çµæœã¨ã—ã¦ã€<paramref name="result" /> ã« <see cref="P:System.Text.Rune.ReplacementChar" /> ãŒå«ã¾ã‚Œã€<paramref name="bytesConsumed" /> ã«ã¯å½¢å¼ãŒæ­£ã—ããªã„ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ç›®çš„ã§å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ãƒ¼ã§ä½¿ç”¨ã•ã‚ŒãŸ <see cref="T:System.Byte" /> å€¤ã®æ•°ãŒå«ã¾ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-267"><paramref name="result" /> then contains <see cref="P:System.Text.Rune.ReplacementChar" />, and <paramref name="bytesConsumed" /> contains the number of <see cref="T:System.Byte" /> values used in the input buffer to encode the ill-formed sequence.</span></span>
<span data-ttu-id="7b217-268">.</span><span class="sxs-lookup"><span data-stu-id="7b217-268">.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-269">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ <xref:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)>ã¨ã‚ˆãä¼¼ã¦ã„ã¾ã™ãŒã€å‘¼ã³å‡ºã—å…ƒã¯å‰æ–¹ã§ã¯ãªãé€†æ–¹å‘ã«ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-269">This method is very similar to <xref:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)>, except it allows the caller to loop backward instead of forward.</span></span> <span data-ttu-id="7b217-270">ä¸€èˆ¬çš„ãªå‘¼ã³å‡ºã—è¦å‰‡ã§ã¯ã€ãƒ«ãƒ¼ãƒ—ã®å„åå¾©å‡¦ç†ã§ã€å‘¼ã³å‡ºã—å…ƒãŒ `source` ãƒãƒƒãƒ•ã‚¡ãƒ¼ã®æœ€å¾Œã® `bytesConsumed` è¦ç´ ã‹ã‚‰ã‚¹ãƒ©ã‚¤ã‚¹ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-270">The typical calling convention is that on each iteration of the loop, the caller should slice off the final `bytesConsumed` elements of the `source` buffer.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncodeToUtf16">
      <MemberSignature Language="C#" Value="public int EncodeToUtf16 (Span&lt;char&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EncodeToUtf16(valuetype System.Span`1&lt;char&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.EncodeToUtf16(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function EncodeToUtf16 (destination As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EncodeToUtf16(Span&lt;char&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.EncodeToUtf16 : Span&lt;char&gt; -&gt; int" Usage="rune.EncodeToUtf16 destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="7b217-271">UTF-16 ã¨ã—ã¦ã€ã“ã®å€¤ã®æ›¸ãè¾¼ã¿å…ˆã¨ãªã‚‹ãƒãƒƒãƒ•ã‚¡ãƒ¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-271">The buffer to which to write this value as UTF-16.</span></span></param>
        <summary><span data-ttu-id="7b217-272">ã“ã® <see cref="T:System.Text.Rune" /> ã‚’ UTF-16 ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ ãƒãƒƒãƒ•ã‚¡ãƒ¼ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-272">Encodes this <see cref="T:System.Text.Rune" /> to a UTF-16 destination buffer.</span></span></summary>
        <returns><span data-ttu-id="7b217-273"><paramref name="destination" /> ã«æ›¸ãè¾¼ã¾ã‚ŒãŸ <see cref="T:System.Char" /> å€¤ã®æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-273">The number of <see cref="T:System.Char" /> values written to <paramref name="destination" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7b217-274"><paramref name="destination" /> ã¯å‡ºåŠ›ã‚’ä¿æŒã§ãã‚‹ã»ã©å¤§ããã‚ã‚Šã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-274"><paramref name="destination" /> is not large enough to hold the output.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EncodeToUtf8">
      <MemberSignature Language="C#" Value="public int EncodeToUtf8 (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EncodeToUtf8(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.EncodeToUtf8(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function EncodeToUtf8 (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EncodeToUtf8(Span&lt;System::Byte&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.EncodeToUtf8 : Span&lt;byte&gt; -&gt; int" Usage="rune.EncodeToUtf8 destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="7b217-275">UTF-8 ã¨ã—ã¦ã€ã“ã®å€¤ã®æ›¸ãè¾¼ã¿å…ˆã¨ãªã‚‹ãƒãƒƒãƒ•ã‚¡ãƒ¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-275">The buffer to which to write this value as UTF-8.</span></span></param>
        <summary><span data-ttu-id="7b217-276">ã“ã® <see cref="T:System.Text.Rune" /> ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã€UTF-8 ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ ãƒãƒƒãƒ•ã‚¡ãƒ¼ã«æ›¸ãè¾¼ã¿ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-276">Encodes this <see cref="T:System.Text.Rune" /> to a UTF-8 destination buffer.</span></span></summary>
        <returns><span data-ttu-id="7b217-277"><paramref name="destination" /> ã«æ›¸ãè¾¼ã¾ã‚ŒãŸ <see cref="T:System.Byte" /> å€¤ã®æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-277">The number of <see cref="T:System.Byte" /> values written to <paramref name="destination" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7b217-278"><paramref name="destination" /> ã¯å‡ºåŠ›ã‚’ä¿æŒã§ãã‚‹ã»ã©å¤§ããã‚ã‚Šã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-278"><paramref name="destination" /> is not large enough to hold the output.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="rune.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="7b217-279">ç¾åœ¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨æ¯”è¼ƒã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-279">The object to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="7b217-280">ç¾åœ¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã€æŒ‡å®šã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç­‰ã—ã„ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-280">Returns a value that indicates whether the current instance and a specified object are equal.</span></span></summary>
        <returns><span data-ttu-id="7b217-281"><paramref name="obj" /> ã®å‹ãŒ <see cref="T:System.Text.Rune" /> ã§ã€ç¾åœ¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ç­‰ã—ã‘ã‚Œã° <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€<see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-281"><see langword="true" /> if <paramref name="obj" /> is of type <see cref="T:System.Text.Rune" /> and is equal to the current instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.Rune other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Text.Rune other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.Equals(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Text::Rune other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.Rune -&gt; bool" Usage="rune.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="7b217-282">ç¾åœ¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨æ¯”è¼ƒã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-282">The object to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="7b217-283">ç¾åœ¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨æŒ‡å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ãŒç­‰ã—ã„ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-283">Returns a value that indicates whether the current instance and a specified rune are equal.</span></span></summary>
        <returns><span data-ttu-id="7b217-284">ç¾åœ¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ <paramref name="other" /> ãŒç­‰ã—ã„å ´åˆã¯ <see langword="true" />ã€ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-284"><see langword="true" /> if the current instance and <paramref name="other" /> are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="rune.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7b217-285">ã“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒãƒƒã‚·ãƒ¥ ã‚³ãƒ¼ãƒ‰ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-285">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="7b217-286">å¯¾è±¡ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒãƒƒã‚·ãƒ¥ ã‚³ãƒ¼ãƒ‰ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-286">The hash code for this instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetNumericValue(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (value As Rune) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member GetNumericValue : System.Text.Rune -&gt; double" Usage="System.Text.Rune.GetNumericValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-287">æ•°å€¤ã‚’å–å¾—ã™ã‚‹å¯¾è±¡ã®ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-287">The rune for which to get the numeric value.</span></span></param>
        <summary><span data-ttu-id="7b217-288">æŒ‡å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹æ•°å€¤ã‚’å–å¾—ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-288">Gets the numeric value associated with the specified rune.</span></span></summary>
        <returns><span data-ttu-id="7b217-289"><paramref name="value" /> ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹æ•°å€¤ã€‚ã¾ãŸã¯ã€<paramref name="value" /> ãŒæ•°å­—ã‚’è¡¨ã—ã¦ã„ãªã„å ´åˆã¯ -1ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-289">The numeric value associated with <paramref name="value" />, or -1 if <paramref name="value" /> doesn't represent a numeric character.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-290">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯ã€<xref:System.Globalization.CharUnicodeInfo.GetNumericValue%2A?displayProperty=nameWithType>ã¨åŒã˜å‹•ä½œãŒã‚ã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-290">This method has behavior equivalent to <xref:System.Globalization.CharUnicodeInfo.GetNumericValue%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7b217-291">è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã“ã¡ã‚‰ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-291">Refer to that documentation for more information.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRuneAt">
      <MemberSignature Language="C#" Value="public static System.Text.Rune GetRuneAt (string input, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune GetRuneAt(string input, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetRuneAt(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRuneAt (input As String, index As Integer) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune GetRuneAt(System::String ^ input, int index);" />
      <MemberSignature Language="F#" Value="static member GetRuneAt : string * int -&gt; System.Text.Rune" Usage="System.Text.Rune.GetRuneAt (input, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="7b217-292">ãƒ«ãƒ¼ãƒ³ä½œæˆã®å…ƒã«ãªã‚‹æ–‡å­—åˆ—ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-292">The string from which to create the rune.</span></span></param>
        <param name="index"><span data-ttu-id="7b217-293"><paramref name="input" /> ã«ãŠã„ã¦ã€ãƒ«ãƒ¼ãƒ³ã®ä½œæˆã‚’é–‹å§‹ã™ã‚‹ä½ç½®ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-293">The starting position in <paramref name="input" /> at which to create the rune.</span></span></param>
        <summary><span data-ttu-id="7b217-294">æ–‡å­—åˆ—ã«ãŠã„ã¦æŒ‡å®šã•ã‚ŒãŸä½ç½®ã‹ã‚‰å§‹ã¾ã‚‹ <see cref="T:System.Text.Rune" /> ã‚’å–å¾—ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-294">Gets the <see cref="T:System.Text.Rune" /> that begins at a specified position in a string.</span></span></summary>
        <returns><span data-ttu-id="7b217-295">æŒ‡å®šã•ã‚ŒãŸ <paramref name="index" /> ã«ã‚ã‚‹ <paramref name="input" /> ã‹ã‚‰å–å¾—ã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-295">The rune obtained from <paramref name="input" /> at the specified <paramref name="index" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7b217-296"><paramref name="input" /> ãŒ <see langword="null" />ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-296"><paramref name="input" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7b217-297"><paramref name="index" /> ã¯ã€<paramref name="input" /> ã«ãŠã„ã¦ã€æœ‰åŠ¹ãªã‚¹ã‚«ãƒ©ãƒ¼å€¤ã®é–‹å§‹ã‚’å‚ç…§ã—ã¾ã›ã‚“ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-297"><paramref name="index" /> does not reference the start of a valid scalar value in <paramref name="input" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7b217-298"><paramref name="index" /> ãŒ <paramref name="input" /> ã®ç¯„å›²ã®å¤–ã«ã‚ã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-298"><paramref name="index" /> is outside the range of <paramref name="input" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (value As Rune) As UnicodeCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member GetUnicodeCategory : System.Text.Rune -&gt; System.Globalization.UnicodeCategory" Usage="System.Text.Rune.GetUnicodeCategory value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-299">Unicode ã‚«ãƒ†ã‚´ãƒªã‚’å–å¾—ã™ã‚‹å¯¾è±¡ã®ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-299">The rune for which to get the Unicode category.</span></span></param>
        <summary><span data-ttu-id="7b217-300">æŒ‡å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ Unicode ã‚«ãƒ†ã‚´ãƒªã‚’å–å¾—ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-300">Gets the Unicode category associated with the specified rune.</span></span></summary>
        <returns><span data-ttu-id="7b217-301"><paramref name="value" /> ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ Unicode ã‚«ãƒ†ã‚´ãƒªã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-301">The Unicode category associated with <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-302">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã¯ã€<xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>ã¨åŒã˜å‹•ä½œãŒã‚ã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-302">This method has behavior equivalent to <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7b217-303">è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã“ã¡ã‚‰ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-303">Refer to that documentation for more information.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAscii">
      <MemberSignature Language="C#" Value="public bool IsAscii { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAscii" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.IsAscii" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAscii As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAscii { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAscii : bool" Usage="System.Text.Rune.IsAscii" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7b217-304">ã“ã® <see cref="T:System.Text.Rune" /> ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã‚¹ã‚«ãƒ©ãƒ¼å€¤ãŒ ASCII ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ç¯„å›²å†…ã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’å–å¾—ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-304">Gets a value that indicates whether the scalar value associated with this <see cref="T:System.Text.Rune" /> is within the ASCII encoding range.</span></span></summary>
        <value><span data-ttu-id="7b217-305">é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã‚¹ã‚«ãƒ©ãƒ¼å€¤ãŒ ASCII ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ç¯„å›² ([U + 0000.. U + 007F]) å†…ã«ã‚ã‚Šã€1ã¤ã® UTF-8 ã‚³ãƒ¼ãƒ‰å˜ä½ã§è¡¨ç¾å¯èƒ½ãªå ´åˆã¯ã€<see langword="true" /> ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€<see langword="false" />ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-305"><see langword="true" /> if the scalar value associated is within the ASCII encoding range ([ U+0000..U+007F ]) and therefore representable by a single UTF-8 code unit; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBmp">
      <MemberSignature Language="C#" Value="public bool IsBmp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBmp" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.IsBmp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBmp As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBmp { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBmp : bool" Usage="System.Text.Rune.IsBmp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7b217-306">ã“ã® <see cref="T:System.Text.Rune" /> ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã‚¹ã‚«ãƒ©ãƒ¼å€¤ãŒ BMP ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ç¯„å›²å†…ã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’å–å¾—ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-306">Gets a value that indicates whether the scalar value associated with this <see cref="T:System.Text.Rune" /> is within the BMP encoding range.</span></span></summary>
        <value><span data-ttu-id="7b217-307">é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã‚¹ã‚«ãƒ©ãƒ¼å€¤ãŒ BMP ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ç¯„å›² ([U + 0000.. U + FFFF]) å†…ã«ã‚ã‚Šã€1ã¤ã® UTF-16 ã‚³ãƒ¼ãƒ‰å˜ä½ã§è¡¨ç¾å¯èƒ½ãªå ´åˆã¯ <see langword="true" /> ã—ã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€<see langword="false" />ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-307"><see langword="true" /> if the scalar value associated is within the BMP encoding range ([ U+0000..U+FFFF ]) and therefore representable by a single UTF-16 code unit; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsControl(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsControl : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsControl value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-308">è©•ä¾¡ã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-308">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="7b217-309">æŒ‡å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ãŒåˆ¶å¾¡æ–‡å­—ã¨ã—ã¦åˆ†é¡ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-309">Returns a value that indicates whether the specified rune is categorized as a control character.</span></span></summary>
        <returns><span data-ttu-id="7b217-310"><paramref name="value" /> ãŒåˆ¶å¾¡æ–‡å­—ã§ã‚ã‚‹å ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-310"><see langword="true" /> if <paramref name="value" /> is a control character; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-311">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ã«å¯¾ã—ã¦ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ã€çµæœã‚’ <xref:System.Globalization.UnicodeCategory.Control>ã¨æ¯”è¼ƒã™ã‚‹ã“ã¨ã¨åŒã˜ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-311">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against <xref:System.Globalization.UnicodeCategory.Control>.</span></span>

<span data-ttu-id="7b217-312">[Unicode ã®å®‰å®šæ€§ãƒãƒªã‚·ãƒ¼](https://www.unicode.org/policies/stability_policy.html)ã”ã¨ã«ã€åˆ¶å¾¡æ–‡å­—ã®ã‚»ãƒƒãƒˆã¯ `[ U+0000..U+001F ]` ã¨ `[ U+007F..U+009F ]`ã®å’Œé›†åˆã¨ã—ã¦æ°¸ç¶šçš„ã«å›ºå®šã•ã‚Œã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-312">Per [Unicode stability policies](https://www.unicode.org/policies/stability_policy.html), the set of control characters is permanently fixed to be the union of `[ U+0000..U+001F ]` and `[ U+007F..U+009F ]`.</span></span>

<span data-ttu-id="7b217-313">è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã€Œ<xref:System.Char.IsControl%2A?displayProperty=nameWithType>ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-313">For more information, see <xref:System.Char.IsControl%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsDigit(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsDigit : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsDigit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-314">è©•ä¾¡ã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-314">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="7b217-315">æŒ‡å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ãŒ 10 é€²æ•°ã®æ•°å­—ã¨ã—ã¦åˆ†é¡ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-315">Returns a value that indicates whether the specified rune is categorized as a decimal digit.</span></span></summary>
        <returns><span data-ttu-id="7b217-316"><see langword="true" /> ãŒ 10 é€²æ•°ã®æ•°å­—ã®å ´åˆã¯ <paramref name="value" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-316"><see langword="true" /> if <paramref name="value" /> is a decimal digit; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-317">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ã«å¯¾ã—ã¦ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ã€çµæœã‚’ <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>ã¨æ¯”è¼ƒã™ã‚‹ã“ã¨ã¨åŒã˜ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-317">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>.</span></span>

<span data-ttu-id="7b217-318">è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã€Œ<xref:System.Char.IsDigit%2A?displayProperty=nameWithType>ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-318">For more information, see <xref:System.Char.IsDigit%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsLetter(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsLetter : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsLetter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-319">è©•ä¾¡ã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-319">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="7b217-320">æŒ‡å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ãŒæ–‡å­—ã¨ã—ã¦åˆ†é¡ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-320">Returns a value that indicates whether the specified rune is categorized as a letter.</span></span></summary>
        <returns><span data-ttu-id="7b217-321"><see langword="true" /> ãŒæ–‡å­—ã§ã‚ã‚‹å ´åˆã¯ <paramref name="value" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-321"><see langword="true" /> if <paramref name="value" /> is a letter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-322">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ã«å¯¾ã—ã¦ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ã€ãã®çµæœã‚’ <xref:System.Globalization.UnicodeCategory.UppercaseLetter>ã€<xref:System.Globalization.UnicodeCategory.LowercaseLetter>ã€<xref:System.Globalization.UnicodeCategory.TitlecaseLetter>ã€<xref:System.Globalization.UnicodeCategory.ModifierLetter>ã€<xref:System.Globalization.UnicodeCategory.OtherLetter>ã®ã„ãšã‚Œã‹ã®å€¤ã¨æ¯”è¼ƒã™ã‚‹ã“ã¨ã¨åŒã˜ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-322">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.UppercaseLetter>, <xref:System.Globalization.UnicodeCategory.LowercaseLetter>, <xref:System.Globalization.UnicodeCategory.TitlecaseLetter>, <xref:System.Globalization.UnicodeCategory.ModifierLetter>, and <xref:System.Globalization.UnicodeCategory.OtherLetter>.</span></span>

<span data-ttu-id="7b217-323">è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã€Œ<xref:System.Char.IsLetter%2A?displayProperty=nameWithType>ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-323">For more information, see <xref:System.Char.IsLetter%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsLetterOrDigit(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsLetterOrDigit : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsLetterOrDigit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-324">è©•ä¾¡ã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-324">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="7b217-325">æŒ‡å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ãŒæ–‡å­—ã¾ãŸã¯ 10 é€²æ•°ã®æ•°å­—ã¨ã—ã¦åˆ†é¡ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-325">Returns a value that indicates whether the specified rune is categorized as a letter or a decimal digit.</span></span></summary>
        <returns><span data-ttu-id="7b217-326"><see langword="true" /> ãŒæ–‡å­—ã¾ãŸã¯ 10 é€²æ•°ã®æ•°å­—ã®å ´åˆã¯ <paramref name="value" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-326"><see langword="true" /> if <paramref name="value" /> is a letter or a decimal digit; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-327">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ã«å¯¾ã—ã¦ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ã€ãã®çµæœã‚’ <xref:System.Globalization.UnicodeCategory.UppercaseLetter>ã€<xref:System.Globalization.UnicodeCategory.LowercaseLetter>ã€<xref:System.Globalization.UnicodeCategory.TitlecaseLetter>ã€<xref:System.Globalization.UnicodeCategory.ModifierLetter>ã€<xref:System.Globalization.UnicodeCategory.OtherLetter>ã€ãŠã‚ˆã³ <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>ã®å€¤ã¨æ¯”è¼ƒã™ã‚‹ã“ã¨ã¨åŒã˜ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-327">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.UppercaseLetter>, <xref:System.Globalization.UnicodeCategory.LowercaseLetter>, <xref:System.Globalization.UnicodeCategory.TitlecaseLetter>, <xref:System.Globalization.UnicodeCategory.ModifierLetter>, <xref:System.Globalization.UnicodeCategory.OtherLetter>, and <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>.</span></span>

<span data-ttu-id="7b217-328">è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã€Œ<xref:System.Char.IsLetterOrDigit%2A?displayProperty=nameWithType>ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-328">For more information, see <xref:System.Char.IsLetterOrDigit%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsLower(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsLower : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsLower value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-329">è©•ä¾¡ã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-329">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="7b217-330">æŒ‡å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ãŒå°æ–‡å­—ã¨ã—ã¦åˆ†é¡ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-330">Returns a value that indicates whether the specified rune is categorized as a lowercase letter.</span></span></summary>
        <returns><span data-ttu-id="7b217-331"><paramref name="value" /> ãŒå°æ–‡å­—ã®å ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-331"><see langword="true" /> if <paramref name="value" /> is a lowercase letter; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-332">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ã«å¯¾ã—ã¦ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ã€çµæœã‚’ <xref:System.Globalization.UnicodeCategory.LowercaseLetter>ã¨æ¯”è¼ƒã™ã‚‹ã“ã¨ã¨åŒã˜ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-332">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against <xref:System.Globalization.UnicodeCategory.LowercaseLetter>.</span></span>

<span data-ttu-id="7b217-333">è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã€Œ<xref:System.Char.IsLower%2A?displayProperty=nameWithType>ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-333">For more information, see <xref:System.Char.IsLower%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsNumber(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsNumber : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsNumber value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-334">è©•ä¾¡ã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-334">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="7b217-335">æŒ‡å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ãŒæ•°å­—ã¨ã—ã¦åˆ†é¡ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-335">Returns a value that indicates whether the specified rune is categorized as a number.</span></span></summary>
        <returns><span data-ttu-id="7b217-336"><see langword="true" /> ãŒæ•°å­—ã§ã‚ã‚‹å ´åˆã¯ <paramref name="value" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-336"><see langword="true" /> if <paramref name="value" /> is a number; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-337">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ã«å¯¾ã—ã¦ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ã€ãã®çµæœã‚’ <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>ã€<xref:System.Globalization.UnicodeCategory.LetterNumber>ã€ãŠã‚ˆã³ <xref:System.Globalization.UnicodeCategory.OtherNumber>ã®ã„ãšã‚Œã‹ã®å€¤ã¨æ¯”è¼ƒã™ã‚‹ã“ã¨ã¨åŒã˜ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-337">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber>, <xref:System.Globalization.UnicodeCategory.LetterNumber>, and <xref:System.Globalization.UnicodeCategory.OtherNumber>.</span></span>

<span data-ttu-id="7b217-338">è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã€Œ<xref:System.Char.IsNumber%2A?displayProperty=nameWithType>ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-338">For more information, see <xref:System.Char.IsNumber%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsPunctuation(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsPunctuation : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsPunctuation value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-339">è©•ä¾¡ã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-339">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="7b217-340">æŒ‡å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ãŒåŒºåˆ‡ã‚Šè¨˜å·ã¨ã—ã¦åˆ†é¡ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-340">Returns a value that indicates whether the specified rune is categorized as a punctuation mark.</span></span></summary>
        <returns><span data-ttu-id="7b217-341"><see langword="true" /> ãŒåŒºåˆ‡ã‚Šè¨˜å·ã®å ´åˆã¯ <paramref name="value" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-341"><see langword="true" /> if <paramref name="value" /> is a punctuation mark; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-342">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ã«å¯¾ã—ã¦ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ã€çµæœã‚’ <xref:System.Globalization.UnicodeCategory.ConnectorPunctuation>ã€<xref:System.Globalization.UnicodeCategory.DashPunctuation>ã€<xref:System.Globalization.UnicodeCategory.OpenPunctuation>ã€<xref:System.Globalization.UnicodeCategory.ClosePunctuation>ã€<xref:System.Globalization.UnicodeCategory.InitialQuotePunctuation>ã€<xref:System.Globalization.UnicodeCategory.FinalQuotePunctuation>ã€<xref:System.Globalization.UnicodeCategory.OtherPunctuation>ã®ã„ãšã‚Œã‹ã®å€¤ã¨æ¯”è¼ƒã™ã‚‹ã“ã¨ã¨åŒã˜ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-342">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.ConnectorPunctuation>, <xref:System.Globalization.UnicodeCategory.DashPunctuation>, <xref:System.Globalization.UnicodeCategory.OpenPunctuation>, <xref:System.Globalization.UnicodeCategory.ClosePunctuation>, <xref:System.Globalization.UnicodeCategory.InitialQuotePunctuation>, <xref:System.Globalization.UnicodeCategory.FinalQuotePunctuation>, and <xref:System.Globalization.UnicodeCategory.OtherPunctuation>.</span></span>

<span data-ttu-id="7b217-343">è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã€Œ<xref:System.Char.IsPunctuation%2A?displayProperty=nameWithType>ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-343">For more information, see <xref:System.Char.IsPunctuation%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsSeparator(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsSeparator : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsSeparator value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-344">è©•ä¾¡ã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-344">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="7b217-345">æŒ‡å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ãŒåŒºåˆ‡ã‚Šæ–‡å­—ã¨ã—ã¦åˆ†é¡ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-345">Returns a value that indicates whether the specified rune is categorized as a separator character.</span></span></summary>
        <returns><span data-ttu-id="7b217-346"><see langword="true" /> ãŒåŒºåˆ‡ã‚Šæ–‡å­—ã§ã‚ã‚‹å ´åˆã¯ <paramref name="value" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-346"><see langword="true" /> if <paramref name="value" /> is a separator character; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-347">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ã«å¯¾ã—ã¦ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ã€ãã®çµæœã‚’ <xref:System.Globalization.UnicodeCategory.SpaceSeparator>ã€<xref:System.Globalization.UnicodeCategory.LineSeparator>ã€ãŠã‚ˆã³ <xref:System.Globalization.UnicodeCategory.ParagraphSeparator>ã®ã„ãšã‚Œã‹ã®å€¤ã¨æ¯”è¼ƒã™ã‚‹ã“ã¨ã¨åŒã˜ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-347">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.SpaceSeparator>, <xref:System.Globalization.UnicodeCategory.LineSeparator>, and <xref:System.Globalization.UnicodeCategory.ParagraphSeparator>.</span></span>

<span data-ttu-id="7b217-348">è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã€Œ<xref:System.Char.IsSeparator%2A?displayProperty=nameWithType>ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-348">For more information, see <xref:System.Char.IsSeparator%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsSymbol(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsSymbol : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsSymbol value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-349">è©•ä¾¡ã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-349">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="7b217-350">æŒ‡å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ãŒè¨˜å·ã¨ã—ã¦åˆ†é¡ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-350">Returns a value that indicates whether the specified rune is categorized as a symbol character.</span></span></summary>
        <returns><span data-ttu-id="7b217-351"><paramref name="value" /> ãŒè¨˜å·ã§ã‚ã‚‹å ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-351"><see langword="true" /> if <paramref name="value" /> is a symbol character; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-352">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ã«å¯¾ã—ã¦ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ã€ãã®çµæœã‚’ <xref:System.Globalization.UnicodeCategory.MathSymbol>ã€<xref:System.Globalization.UnicodeCategory.CurrencySymbol>ã€<xref:System.Globalization.UnicodeCategory.ModifierSymbol>ã€ãŠã‚ˆã³ <xref:System.Globalization.UnicodeCategory.OtherSymbol>ã®ã„ãšã‚Œã‹ã®å€¤ã¨æ¯”è¼ƒã™ã‚‹ã“ã¨ã¨åŒã˜ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-352">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.MathSymbol>, <xref:System.Globalization.UnicodeCategory.CurrencySymbol>, <xref:System.Globalization.UnicodeCategory.ModifierSymbol>, and <xref:System.Globalization.UnicodeCategory.OtherSymbol>.</span></span>

<span data-ttu-id="7b217-353">è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã€Œ<xref:System.Char.IsSymbol%2A?displayProperty=nameWithType>ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-353">For more information, see <xref:System.Char.IsSymbol%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsUpper(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsUpper : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsUpper value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-354">è©•ä¾¡ã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-354">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="7b217-355">æŒ‡å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ãŒå¤§æ–‡å­—ã¨ã—ã¦åˆ†é¡ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-355">Returns a value that indicates whether the specified rune is categorized as an uppercase letter.</span></span></summary>
        <returns><span data-ttu-id="7b217-356"><paramref name="value" /> ãŒå¤§æ–‡å­—ã§ã‚ã‚‹å ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-356"><see langword="true" /> if <paramref name="value" /> is an uppercase letter; otherwise,<see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-357">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€<xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ã«å¯¾ã—ã¦ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ã€çµæœã‚’ <xref:System.Globalization.UnicodeCategory.UppercaseLetter>ã¨æ¯”è¼ƒã™ã‚‹ã“ã¨ã¨åŒã˜ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-357">This method is equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against <xref:System.Globalization.UnicodeCategory.UppercaseLetter>.</span></span>

<span data-ttu-id="7b217-358">è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã€Œ<xref:System.Char.IsUpper%2A?displayProperty=nameWithType>ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-358">For more information, see <xref:System.Char.IsUpper%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public static bool IsValid (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValid(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsValid(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValid (value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValid(int value);" />
      <MemberSignature Language="F#" Value="static member IsValid : int -&gt; bool" Usage="System.Text.Rune.IsValid value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-359">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-359">The Unicode scalar value.</span></span></param>
        <summary><span data-ttu-id="7b217-360">32 ãƒ“ãƒƒãƒˆã®ç¬¦å·ä»˜ãæ•´æ•°ãŒæœ‰åŠ¹ãª Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã€ã™ãªã‚ã¡ã€[ U+0000..U+D7FF ] (æœ€åˆã¨æœ€å¾Œã®è¦ç´ ã‚’å«ã‚€) ã¾ãŸã¯ [ U+E000..U+10FFFF ] (æœ€åˆã¨æœ€å¾Œã®è¦ç´ ã‚’å«ã‚€) ã¨ã„ã†ç¯„å›²å†…ã«ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-360">Returns a value that indicates whether a 32-bit signed integer represents a valid Unicode scalar value; that is, it is in the range [ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive.</span></span></summary>
        <returns><span data-ttu-id="7b217-361"><paramref name="value" /> ãŒæœ‰åŠ¹ãª Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã®å ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-361"><see langword="true" /> if <paramref name="value" /> is a valid Unicode scalar value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public static bool IsValid (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsValid(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsValid(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsValid (value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsValid(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member IsValid : uint32 -&gt; bool" Usage="System.Text.Rune.IsValid value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-362">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-362">The Unicode scalar value.</span></span></param>
        <summary><span data-ttu-id="7b217-363">32 ãƒ“ãƒƒãƒˆã®ç¬¦å·ãªã—æ•´æ•°ãŒæœ‰åŠ¹ãª Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã€ã™ãªã‚ã¡ã€[ U+0000..U+D7FF ] (æœ€åˆã¨æœ€å¾Œã®è¦ç´ ã‚’å«ã‚€) ã¾ãŸã¯ [ U+E000..U+10FFFF ] (æœ€åˆã¨æœ€å¾Œã®è¦ç´ ã‚’å«ã‚€) ã¨ã„ã†ç¯„å›²å†…ã«ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-363">Returns a value that indicates whether a 32-bit unsigned integer represents a valid Unicode scalar value; that is, it is in the range [ U+0000..U+D7FF ], inclusive, or [ U+E000..U+10FFFF ], inclusive.</span></span></summary>
        <returns><span data-ttu-id="7b217-364"><paramref name="value" /> ãŒæœ‰åŠ¹ãª Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã®å ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-364"><see langword="true" /> if <paramref name="value" /> is a valid Unicode scalar value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.IsWhiteSpace(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : System.Text.Rune -&gt; bool" Usage="System.Text.Rune.IsWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-365">è©•ä¾¡ã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-365">The rune to evaluate.</span></span></param>
        <summary><span data-ttu-id="7b217-366">æŒ‡å®šã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ãŒç©ºç™½æ–‡å­—ã¨ã—ã¦åˆ†é¡ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-366">Returns a value that indicates whether the specified rune is categorized as a white space character.</span></span></summary>
        <returns><span data-ttu-id="7b217-367"><paramref name="value" /> ãŒç©ºç™½æ–‡å­—ã®å ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-367"><see langword="true" /> if <paramref name="value" /> is a white space character; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-368">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€é€šå¸¸ã€<xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> ã«å¯¾ã—ã¦ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ã€ãã®çµæœã‚’ <xref:System.Globalization.UnicodeCategory.SpaceSeparator>ã€<xref:System.Globalization.UnicodeCategory.LineSeparator>ã€ãŠã‚ˆã³ <xref:System.Globalization.UnicodeCategory.ParagraphSeparator>ã®ã„ãšã‚Œã‹ã®å€¤ã¨æ¯”è¼ƒã™ã‚‹ã“ã¨ã¨åŒã˜ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-368">This method is generally equivalent to querying <xref:System.Text.Rune.GetUnicodeCategory(System.Text.Rune)> and comparing the result against any of the values <xref:System.Globalization.UnicodeCategory.SpaceSeparator>, <xref:System.Globalization.UnicodeCategory.LineSeparator>, and <xref:System.Globalization.UnicodeCategory.ParagraphSeparator>.</span></span> <span data-ttu-id="7b217-369">ãŸã ã—ã€<xref:System.Globalization.UnicodeCategory.Control> ã‚«ãƒ†ã‚´ãƒªã«ã¯ã„ãã¤ã‹ã® <xref:System.Text.Rune>ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ç©ºç™½æ–‡å­—ã¨ã—ã¦ã‚‚åˆ†é¡ã•ã‚Œã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã“ã‚Œã‚‰ã®å€¤ã«å¯¾ã—ã¦ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’æŒã¡ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-369">However, there are some <xref:System.Text.Rune>s in the <xref:System.Globalization.UnicodeCategory.Control> category which are also classified as white space characters, and this method accounts for those values.</span></span>

<span data-ttu-id="7b217-370">è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã€Œ<xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-370">For more information, see <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Equality(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7b217-371">æ¯”è¼ƒã™ã‚‹æœ€åˆã®å€¤ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-371">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="7b217-372">æ¯”è¼ƒã™ã‚‹ 2 ç•ªç›®ã®å€¤ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-372">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="7b217-373">2 ã¤ã® <see cref="T:System.Text.Rune" /> ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒç­‰ã—ã„ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-373">Returns a value that indicates whether two <see cref="T:System.Text.Rune" /> instances are equal.</span></span></summary>
        <returns><span data-ttu-id="7b217-374"><paramref name="left" /> ã¨ <paramref name="right" /> ãŒç­‰ã—ã„å ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-374"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Text.Rune (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Text.Rune op_Explicit(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Explicit(System.Char)~System.Text.Rune" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (ch As Char) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Text::Rune(char ch);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : char -&gt; System.Text.Rune" Usage="System.Text.Rune.op_Explicit ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch"><span data-ttu-id="7b217-375">å¤‰æ›ã™ã‚‹ 16 ãƒ“ãƒƒãƒˆã® Unicode æ–‡å­—ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-375">The 16-bit Unicode character to convert.</span></span></param>
        <summary><span data-ttu-id="7b217-376">16 ãƒ“ãƒƒãƒˆã® Unicode æ–‡å­—ã® <see cref="T:System.Text.Rune" /> ã¸ã®æ˜ç¤ºçš„ãªå¤‰æ›ã‚’å®šç¾©ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-376">Defines an explicit conversion of a 16-bit Unicode character to a <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="7b217-377">32 ãƒ“ãƒƒãƒˆã® Unicode æ–‡å­—ã¨ã—ã¦ã® <paramref name="ch" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-377"><paramref name="ch" /> as a 32-bit Unicode character.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7b217-378"><paramref name="ch" /> ã¯ã€ã‚µãƒ­ã‚²ãƒ¼ãƒˆ ã‚³ãƒ¼ãƒ‰ ãƒã‚¤ãƒ³ãƒˆã‚’è¡¨ã™ Unicode ã‚¹ã‚«ãƒ©ãƒ¼ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-378"><paramref name="ch" /> is a Unicode scalar that represents a surrogate code point.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Text.Rune (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Text.Rune op_Explicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Explicit(System.Int32)~System.Text.Rune" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Integer) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Text::Rune(int value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : int -&gt; System.Text.Rune" Usage="System.Text.Rune.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-379">å¤‰æ›ã™ã‚‹ 32 ãƒ“ãƒƒãƒˆç¬¦å·ä»˜ãæ•´æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-379">The 32-bit signed integer to convert.</span></span></param>
        <summary><span data-ttu-id="7b217-380">32 ãƒ“ãƒƒãƒˆç¬¦å·ä»˜ãæ•´æ•°ã® <see cref="T:System.Text.Rune" /> ã¸ã®æ˜ç¤ºçš„ãªå¤‰æ›ã‚’å®šç¾©ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-380">Defines an explicit conversion of a 32-bit signed integer to a <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="7b217-381">32 ãƒ“ãƒƒãƒˆã® Unicode æ–‡å­—ã¨ã—ã¦ã® <paramref name="value" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-381"><paramref name="value" /> as a 32-bit Unicode character.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7b217-382"><paramref name="value" /> ã¯ç„¡åŠ¹ãª Unicode ã‚¹ã‚«ãƒ©ãƒ¼ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-382"><paramref name="value" /> is an invalid Unicode scalar.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Text.Rune (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Text.Rune op_Explicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Explicit(System.UInt32)~System.Text.Rune" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInteger) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Text::Rune(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : uint32 -&gt; System.Text.Rune" Usage="System.Text.Rune.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-383">å¤‰æ›ã™ã‚‹ 32 ãƒ“ãƒƒãƒˆç¬¦å·ä»˜ãæ•´æ•°ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-383">The 32-bit signed integer to convert.</span></span></param>
        <summary><span data-ttu-id="7b217-384">32 ãƒ“ãƒƒãƒˆç¬¦å·ãªã—æ•´æ•°ã® <see cref="T:System.Text.Rune" /> ã¸ã®æ˜ç¤ºçš„ãªå¤‰æ›ã‚’å®šç¾©ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-384">Defines an explicit conversion of a 32-bit unsigned integer to a <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="7b217-385">32 ãƒ“ãƒƒãƒˆã® Unicode æ–‡å­—ã¨ã—ã¦ã® <paramref name="value" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-385"><paramref name="value" /> as a 32-bit Unicode character.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7b217-386"><paramref name="value" /> ã¯ç„¡åŠ¹ãª Unicode ã‚¹ã‚«ãƒ©ãƒ¼ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-386"><paramref name="value" /> is an invalid Unicode scalar.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_GreaterThan(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7b217-387">æ¯”è¼ƒã™ã‚‹æœ€åˆã®å€¤ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-387">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="7b217-388">æ¯”è¼ƒã™ã‚‹ 2 ç•ªç›®ã®å€¤ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-388">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="7b217-389">æŒ‡å®šã—ãŸ <see cref="T:System.Text.Rune" /> ãŒã€æŒ‡å®šã—ãŸåˆ¥ã® <see cref="T:System.Text.Rune" /> ã‚ˆã‚Šå¤§ãã„ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-389">Returns a value indicating whether a specified <see cref="T:System.Text.Rune" /> is greater than another specified <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="7b217-390"><paramref name="left" /> ãŒ <paramref name="right" /> ã‚ˆã‚Šå¤§ãã„å ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-390"><see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_GreaterThanOrEqual(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7b217-391">æ¯”è¼ƒã™ã‚‹æœ€åˆã®å€¤ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-391">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="7b217-392">æ¯”è¼ƒã™ã‚‹ 2 ç•ªç›®ã®å€¤ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-392">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="7b217-393">æŒ‡å®šã—ãŸ <see cref="T:System.Text.Rune" /> ãŒã€æŒ‡å®šã—ãŸåˆ¥ã® <see cref="T:System.Text.Rune" /> ä»¥ä¸Šã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-393">Returns a value indicating whether a specified <see cref="T:System.Text.Rune" /> is greater than or equal to another specified <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="7b217-394"><paramref name="left" /> ãŒ <paramref name="right" /> ä»¥ä¸Šã®å ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-394"><see langword="true" /> if <paramref name="left" /> is greater than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_Inequality(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="System.Text.Rune.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7b217-395">æ¯”è¼ƒã™ã‚‹æœ€åˆã®å€¤ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-395">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="7b217-396">æ¯”è¼ƒã™ã‚‹ 2 ç•ªç›®ã®å€¤ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-396">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="7b217-397">2 ã¤ã® <see cref="T:System.Text.Rune" /> ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å€¤ãŒç•°ãªã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-397">Returns a value that indicates whether two <see cref="T:System.Text.Rune" /> instances have different values.</span></span></summary>
        <returns><span data-ttu-id="7b217-398"><paramref name="left" /> ã¨ <paramref name="right" /> ãŒç­‰ã—ããªã„å ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-398"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_LessThan(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7b217-399">æ¯”è¼ƒã™ã‚‹æœ€åˆã®å€¤ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-399">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="7b217-400">æ¯”è¼ƒã™ã‚‹ 2 ç•ªç›®ã®å€¤ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-400">the second value to compare.</span></span></param>
        <summary><span data-ttu-id="7b217-401">æŒ‡å®šã—ãŸ <see cref="T:System.Text.Rune" /> ãŒã€æŒ‡å®šã—ãŸåˆ¥ã® <see cref="T:System.Text.Rune" /> ã‚ˆã‚Šå°ã•ã„ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-401">Returns a value indicating whether a specified <see cref="T:System.Text.Rune" /> is less than another specified <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="7b217-402"><paramref name="left" /> ãŒ <paramref name="right" /> ã‚ˆã‚Šå°ã•ã„å ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-402"><see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Text.Rune left, System.Text.Rune right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Text.Rune left, valuetype System.Text.Rune right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.op_LessThanOrEqual(System.Text.Rune,System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Rune, right As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Text::Rune left, System::Text::Rune right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Text.Rune * System.Text.Rune -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Text.Rune" />
        <Parameter Name="right" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="7b217-403">æ¯”è¼ƒã™ã‚‹æœ€åˆã®å€¤ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-403">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="7b217-404">æ¯”è¼ƒã™ã‚‹ 2 ç•ªç›®ã®å€¤ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-404">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="7b217-405">æŒ‡å®šã—ãŸ <see cref="T:System.Text.Rune" /> ãŒã€æŒ‡å®šã—ãŸã‚‚ã† 1 ã¤ã® <see cref="T:System.Text.Rune" /> ä»¥ä¸‹ã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-405">Returns a value indicating whether a specified <see cref="T:System.Text.Rune" /> is less than or equal to another specified <see cref="T:System.Text.Rune" />.</span></span></summary>
        <returns><span data-ttu-id="7b217-406"><paramref name="left" /> ãŒ <paramref name="right" /> ä»¥ä¸‹ã®å ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-406"><see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Plane">
      <MemberSignature Language="C#" Value="public int Plane { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Plane" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Plane" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Plane As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Plane { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Plane : int" Usage="System.Text.Rune.Plane" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7b217-407">ã“ã®ã‚¹ã‚«ãƒ©ãƒ¼ã‚’å«ã‚€ Unicode å¹³é¢ (0 ã‹ã‚‰ 16 ã¾ã§ã€0 ã¨ 16 ã‚’å«ã‚€) ã‚’å–å¾—ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-407">Gets the Unicode plane (0 to 16, inclusive) that contains this scalar.</span></span></summary>
        <value><span data-ttu-id="7b217-408">ã“ã®ã‚¹ã‚«ãƒ©ãƒ¼ã‚’å«ã‚€ Unicode å¹³é¢ (0 ~ 16)ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-408">The Unicode plane (0 to 16, inclusive) that contains this scalar.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplacementChar">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ReplacementChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Text.Rune ReplacementChar" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.ReplacementChar" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ReplacementChar As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Rune ReplacementChar { System::Text::Rune get(); };" />
      <MemberSignature Language="F#" Value="member this.ReplacementChar : System.Text.Rune" Usage="System.Text.Rune.ReplacementChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7b217-409">Unicode ç½®æ›æ–‡å­— U+FFFD ã‚’è¡¨ã™ <see cref="T:System.Text.Rune" /> ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-409">Gets a <see cref="T:System.Text.Rune" /> instance that represents the Unicode replacement character U+FFFD.</span></span></summary>
        <value><span data-ttu-id="7b217-410">Unicode ç½®æ›æ–‡å­— U+FFFD ã‚’è¡¨ã™ <see cref="T:System.Text.Rune" /> ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-410">A <see cref="T:System.Text.Rune" /> instance that represents the Unicode replacement character U+FFFD.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToLower (System.Text.Rune value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToLower(valuetype System.Text.Rune value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToLower(System.Text.Rune,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (value As Rune, culture As CultureInfo) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToLower(System::Text::Rune value, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToLower : System.Text.Rune * System.Globalization.CultureInfo -&gt; System.Text.Rune" Usage="System.Text.Rune.ToLower (value, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-411">å¤‰æ›ã™ã‚‹ 32 ãƒ“ãƒƒãƒˆã® Unicode æ–‡å­—ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-411">The 32-bit Unicode character to convert.</span></span></param>
        <param name="culture"><span data-ttu-id="7b217-412">ã‚«ãƒ«ãƒãƒ£å›ºæœ‰ã®å¤§æ–‡å­—ã¨å°æ–‡å­—ã®è¦å‰‡ã‚’æä¾›ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-412">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="7b217-413">æŒ‡å®šã•ã‚ŒãŸã‚«ãƒ«ãƒãƒ£ã®å¤§æ–‡å­—ã¨å°æ–‡å­—ã®è¦å‰‡ã‚’ä½¿ç”¨ã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸ <see cref="T:System.Text.Rune" /> ã®ã‚³ãƒ”ãƒ¼ã‚’å°æ–‡å­—ã«å¤‰æ›ã—ã¦è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-413">Returns a copy of the specified <see cref="T:System.Text.Rune" /> converted to lowercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="7b217-414"><paramref name="value" /> ã®å°æ–‡å­—è¡¨ç¾ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-414">The lowercase equivalent of <paramref name="value" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToLowerInvariant (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToLowerInvariant(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToLowerInvariant(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLowerInvariant (value As Rune) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToLowerInvariant(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member ToLowerInvariant : System.Text.Rune -&gt; System.Text.Rune" Usage="System.Text.Rune.ToLowerInvariant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-415">å¤‰æ›ã™ã‚‹ 32 ãƒ“ãƒƒãƒˆã® Unicode æ–‡å­—ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-415">The 32-bit Unicode character to convert.</span></span></param>
        <summary><span data-ttu-id="7b217-416">ã‚¤ãƒ³ãƒãƒªã‚¢ãƒ³ãƒˆ ã‚«ãƒ«ãƒãƒ£ã®å¤§æ–‡å­—ã¨å°æ–‡å­—ã®è¦å‰‡ã‚’ä½¿ç”¨ã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸ <see cref="T:System.Text.Rune" /> ã®ã‚³ãƒ”ãƒ¼ã‚’å°æ–‡å­—ã«å¤‰æ›ã—ã¦è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-416">Returns a copy of the specified <see cref="T:System.Text.Rune" /> converted to lowercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="7b217-417"><paramref name="value" /> ã®å°æ–‡å­—è¡¨ç¾ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-417">The lowercase equivalent of <paramref name="value" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="rune.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7b217-418">ã“ã® <see cref="T:System.Text.Rune" /> ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ–‡å­—åˆ—è¡¨ç¾ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-418">Returns the string representation of this <see cref="T:System.Text.Rune" /> instance.</span></span></summary>
        <returns><span data-ttu-id="7b217-419">ã“ã®ãƒ«ãƒ¼ãƒ³ã®æ–‡å­—åˆ—å½¢å¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-419">The string representation of this rune.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToUpper (System.Text.Rune value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToUpper(valuetype System.Text.Rune value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToUpper(System.Text.Rune,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (value As Rune, culture As CultureInfo) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToUpper(System::Text::Rune value, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToUpper : System.Text.Rune * System.Globalization.CultureInfo -&gt; System.Text.Rune" Usage="System.Text.Rune.ToUpper (value, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-420">å¤‰æ›ã™ã‚‹ 32 ãƒ“ãƒƒãƒˆã® Unicode æ–‡å­—ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-420">The 32-bit Unicode character to convert.</span></span></param>
        <param name="culture"><span data-ttu-id="7b217-421">ã‚«ãƒ«ãƒãƒ£å›ºæœ‰ã®å¤§æ–‡å­—ã¨å°æ–‡å­—ã®è¦å‰‡ã‚’æä¾›ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-421">An object that supplies culture-specific casing rules.</span></span></param>
        <summary><span data-ttu-id="7b217-422">æŒ‡å®šã•ã‚ŒãŸã‚«ãƒ«ãƒãƒ£ã®å¤§æ–‡å­—ã¨å°æ–‡å­—ã®è¦å‰‡ã‚’ä½¿ç”¨ã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸ <see cref="T:System.Text.Rune" /> ã®ã‚³ãƒ”ãƒ¼ã‚’å¤§æ–‡å­—ã«å¤‰æ›ã—ã¦è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-422">Returns a copy of the specified <see cref="T:System.Text.Rune" /> converted to uppercase, using the casing rules of the specified culture.</span></span></summary>
        <returns><span data-ttu-id="7b217-423"><paramref name="value" /> ã®å¤§æ–‡å­—è¡¨ç¾ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-423">The uppercase equivalent of <paramref name="value" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public static System.Text.Rune ToUpperInvariant (System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Rune ToUpperInvariant(valuetype System.Text.Rune value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.ToUpperInvariant(System.Text.Rune)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpperInvariant (value As Rune) As Rune" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Rune ToUpperInvariant(System::Text::Rune value);" />
      <MemberSignature Language="F#" Value="static member ToUpperInvariant : System.Text.Rune -&gt; System.Text.Rune" Usage="System.Text.Rune.ToUpperInvariant value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Rune</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.Rune" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-424">å¤‰æ›ã™ã‚‹ 32 ãƒ“ãƒƒãƒˆã® Unicode æ–‡å­—ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-424">The 32-bit Unicode character to convert.</span></span></param>
        <summary><span data-ttu-id="7b217-425">ã‚¤ãƒ³ãƒãƒªã‚¢ãƒ³ãƒˆ ã‚«ãƒ«ãƒãƒ£ã®å¤§æ–‡å­—ã¨å°æ–‡å­—ã®è¦å‰‡ã‚’ä½¿ç”¨ã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸ <see cref="T:System.Text.Rune" /> ã®ã‚³ãƒ”ãƒ¼ã‚’å¤§æ–‡å­—ã«å¤‰æ›ã—ã¦è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-425">Returns a copy of the specified <see cref="T:System.Text.Rune" /> converted to uppercase using the casing rules of the invariant culture.</span></span></summary>
        <returns><span data-ttu-id="7b217-426"><paramref name="value" /> ã®å¤§æ–‡å­—è¡¨ç¾ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-426">The uppercase equivalent of <paramref name="value" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (char ch, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(char ch, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.Char,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (ch As Char, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(char ch, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : char * Rune -&gt; bool" Usage="System.Text.Rune.TryCreate (ch, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ch"><span data-ttu-id="7b217-427">ãƒ«ãƒ¼ãƒ³ä½œæˆã®å…ƒã«ãªã‚‹æ–‡å­—ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-427">The character from which to create the rune.</span></span></param>
        <param name="result"><span data-ttu-id="7b217-428">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰åˆ¶å¾¡ãŒæˆ»ã‚‹ã¨ãã«ã€<paramref name="ch" /> ã«å¯¾å¿œã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-428">When this method returns, the rune that corresponds to <paramref name="ch" />.</span></span></param>
        <summary><span data-ttu-id="7b217-429">æŒ‡å®šã•ã‚ŒãŸæ–‡å­—ã‹ã‚‰ <see cref="T:System.Text.Rune" /> ã®ä½œæˆã‚’è©¦ã—ã€æ“ä½œãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-429">Attempts to create a <see cref="T:System.Text.Rune" /> from a specified character and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="7b217-430">ãƒ¡ã‚½ãƒƒãƒ‰ãŒæˆåŠŸã—ãŸå ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-430"><see langword="true" /> if the method succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (int value, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(int32 value, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.Int32,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (value As Integer, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(int value, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : int * Rune -&gt; bool" Usage="System.Text.Rune.TryCreate (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-431">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-431">The Unicode scalar value.</span></span></param>
        <param name="result"><span data-ttu-id="7b217-432">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰åˆ¶å¾¡ãŒæˆ»ã‚‹ã¨ãã«ã€<paramref name="value" /> ã«å¯¾å¿œã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-432">When this method returns, the rune that corresponds to <paramref name="value" />.</span></span></param>
        <summary><span data-ttu-id="7b217-433">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¡¨ã™æŒ‡å®šã•ã‚ŒãŸç¬¦å·ä»˜ãæ•´æ•°ã‹ã‚‰ <see cref="T:System.Text.Rune" /> ã®ä½œæˆã‚’è©¦ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-433">Attempts to create a <see cref="T:System.Text.Rune" /> from a specified signed integer that represents a Unicode scalar value.</span></span></summary>
        <returns><span data-ttu-id="7b217-434">ãƒ¡ã‚½ãƒƒãƒ‰ãŒæˆåŠŸã—ãŸå ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-434"><see langword="true" /> if the method succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (uint value, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(unsigned int32 value, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.UInt32,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (value As UInteger, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::UInt32 value, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : uint32 * Rune -&gt; bool" Usage="System.Text.Rune.TryCreate (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="7b217-435">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-435">The Unicode scalar value.</span></span></param>
        <param name="result"><span data-ttu-id="7b217-436">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰åˆ¶å¾¡ãŒæˆ»ã‚‹ã¨ãã«ã€<paramref name="value" /> ã«å¯¾å¿œã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-436">When this method returns, the rune that corresponds to <paramref name="value" />.</span></span></param>
        <summary><span data-ttu-id="7b217-437">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¡¨ã™ã€æŒ‡å®šã•ã‚ŒãŸç¬¦å·ä»˜ã 32 ãƒ“ãƒƒãƒˆæ•´æ•°ã‹ã‚‰ <see cref="T:System.Text.Rune" /> ã®ä½œæˆã‚’è©¦ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-437">Attempts to create a <see cref="T:System.Text.Rune" /> from the specified 32-bit unsigned integer that represents a Unicode scalar value.</span></span></summary>
        <returns><span data-ttu-id="7b217-438">ãƒ¡ã‚½ãƒƒãƒ‰ãŒæˆåŠŸã—ãŸå ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-438"><see langword="true" /> if the method succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (char highSurrogate, char lowSurrogate, out System.Text.Rune result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(char highSurrogate, char lowSurrogate, [out] valuetype System.Text.Rune&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryCreate(System.Char,System.Char,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (highSurrogate As Char, lowSurrogate As Char, ByRef result As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(char highSurrogate, char lowSurrogate, [Runtime::InteropServices::Out] System::Text::Rune % result);" />
      <MemberSignature Language="F#" Value="static member TryCreate : char * char * Rune -&gt; bool" Usage="System.Text.Rune.TryCreate (highSurrogate, lowSurrogate, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
        <Parameter Name="result" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="highSurrogate"><span data-ttu-id="7b217-439">ã‚µãƒ­ã‚²ãƒ¼ãƒˆ ãƒšã‚¢ã®ä¸Šä½ã‚µãƒ­ã‚²ãƒ¼ãƒˆã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-439">The high surrogate of the surrogate pair.</span></span></param>
        <param name="lowSurrogate"><span data-ttu-id="7b217-440">ã‚µãƒ­ã‚²ãƒ¼ãƒˆ ãƒšã‚¢ã®ä¸‹ä½ã‚µãƒ­ã‚²ãƒ¼ãƒˆã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-440">The low surrogate of the surrogate pair.</span></span></param>
        <param name="result"><span data-ttu-id="7b217-441">æŒ‡å®šã®ã‚µãƒ­ã‚²ãƒ¼ãƒˆ ãƒšã‚¢ã«å¯¾å¿œã™ã‚‹ãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-441">The rune that corresponds to the specified surrogate pair.</span></span></param>
        <summary><span data-ttu-id="7b217-442">æŒ‡å®šã•ã‚ŒãŸ UTF-16 ã‚µãƒ­ã‚²ãƒ¼ãƒˆ ãƒšã‚¢ã‹ã‚‰ <see cref="T:System.Text.Rune" /> ã®ä½œæˆã‚’è©¦ã—ã€æ“ä½œãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-442">Attempts to create a <see cref="T:System.Text.Rune" /> from the specified UTF-16 surrogate pair and returns a value that indicates whether the operation was successful.</span></span></summary>
        <returns><span data-ttu-id="7b217-443">æ“ä½œãŒæˆåŠŸã—ãŸå ´åˆã¯ <see langword="true" />ã€‚å…¥åŠ›å€¤ãŒå½¢å¼ã®æ­£ã—ã„ UTF-16 ã‚µãƒ­ã‚²ãƒ¼ãƒˆ ãƒšã‚¢ã‚’è¡¨ã•ãªã„å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-443"><see langword="true" /> if the operation succeeded; <see langword="false" /> if the input values don't represent a well-formed UTF-16 surrogate pair.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEncodeToUtf16">
      <MemberSignature Language="C#" Value="public bool TryEncodeToUtf16 (Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEncodeToUtf16(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryEncodeToUtf16(System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEncodeToUtf16 (destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEncodeToUtf16(Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="member this.TryEncodeToUtf16 : Span&lt;char&gt; * int -&gt; bool" Usage="rune.TryEncodeToUtf16 (destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="7b217-444">UTF-16 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸå€¤ã¨ã—ã¦ã€ã“ã®å€¤ã®æ›¸ãè¾¼ã¿å…ˆã¨ãªã‚‹ãƒãƒƒãƒ•ã‚¡ãƒ¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-444">The buffer to which to write this value as UTF-16 encoded value.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="7b217-445"><paramref name="destination" /> ã«æ›¸ãè¾¼ã¾ã‚ŒãŸ <see cref="T:System.Char" /> å€¤ã®æ•°ã€‚ã‚ã‚‹ã„ã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ ãƒãƒƒãƒ•ã‚¡ãƒ¼ã«å‡ºåŠ›ã‚’å…¥ã‚Œã‚‹å¤§ãã•ãŒãªã„å ´åˆã¯ 0ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-445">The number of <see cref="T:System.Char" /> values written to <paramref name="destination" />, or 0 if the destination buffer is not large enough to contain the output.</span></span></param>
        <summary><span data-ttu-id="7b217-446">ã“ã® <see cref="T:System.Text.Rune" /> ã‚’ã€UTF-16 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸã‚¿ãƒ¼ã‚²ãƒƒãƒˆ ãƒãƒƒãƒ•ã‚¡ãƒ¼ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-446">Encodes this <see cref="T:System.Text.Rune" /> to a UTF-16 encoded destination buffer.</span></span></summary>
        <returns><span data-ttu-id="7b217-447">å€¤ãŒãƒãƒƒãƒ•ã‚¡ãƒ¼ã«æ›¸ãè¾¼ã¾ã‚ŒãŸå ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-447"><see langword="true" /> if the value was written to the buffer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks

<span data-ttu-id="7b217-448"><xref:System.Text.Rune.Utf16SequenceLength> ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ã€`destination` ãƒãƒƒãƒ•ã‚¡ãƒ¼ã«å¿…è¦ãªã‚µã‚¤ã‚ºã‚’æ±ºå®šã™ã‚‹ãŸã‚ã«äº‹å‰ã«ç…§ä¼šã§ãã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-448">The <xref:System.Text.Rune.Utf16SequenceLength> property can be queried ahead of time to determine the required size of the `destination` buffer.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEncodeToUtf8">
      <MemberSignature Language="C#" Value="public bool TryEncodeToUtf8 (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEncodeToUtf8(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryEncodeToUtf8(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEncodeToUtf8 (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEncodeToUtf8(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryEncodeToUtf8 : Span&lt;byte&gt; * int -&gt; bool" Usage="rune.TryEncodeToUtf8 (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="7b217-449">UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸå€¤ã®æ›¸ãè¾¼ã¿å…ˆã¨ãªã‚‹ãƒãƒƒãƒ•ã‚¡ãƒ¼ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-449">The buffer to which to write the UTF-8 encoded value.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="7b217-450"><paramref name="destination" /> ã«æ›¸ãè¾¼ã¾ã‚ŒãŸ <see cref="T:System.Byte" /> å€¤ã®æ•°ã€‚ã‚ã‚‹ã„ã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ ãƒãƒƒãƒ•ã‚¡ãƒ¼ã«å‡ºåŠ›ã‚’å…¥ã‚Œã‚‹å¤§ãã•ãŒãªã„å ´åˆã¯ 0ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-450">The number of <see cref="T:System.Byte" /> values written to <paramref name="destination" />, or 0 if the destination buffer is not large enough to contain the output.</span></span></param>
        <summary><span data-ttu-id="7b217-451">ã“ã® <see cref="T:System.Text.Rune" /> ã‚’ã€UTF-8 ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸã‚¿ãƒ¼ã‚²ãƒƒãƒˆ ãƒãƒƒãƒ•ã‚¡ãƒ¼ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-451">Encodes this <see cref="T:System.Text.Rune" /> to a UTF-8 encoded destination buffer.</span></span></summary>
        <returns><span data-ttu-id="7b217-452">å€¤ãŒãƒãƒƒãƒ•ã‚¡ãƒ¼ã«æ›¸ãè¾¼ã¾ã‚ŒãŸå ´åˆã¯ <see langword="true" />ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-452"><see langword="true" /> if the value was written to the buffer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks

<span data-ttu-id="7b217-453"><xref:System.Text.Rune.Utf8SequenceLength> ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ã€`destination` ãƒãƒƒãƒ•ã‚¡ãƒ¼ã«å¿…è¦ãªã‚µã‚¤ã‚ºã‚’æ±ºå®šã™ã‚‹ãŸã‚ã«äº‹å‰ã«ç…§ä¼šã§ãã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-453">The <xref:System.Text.Rune.Utf8SequenceLength> property can be queried ahead of time to determine the required size of the `destination` buffer.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetRuneAt">
      <MemberSignature Language="C#" Value="public static bool TryGetRuneAt (string input, int index, out System.Text.Rune value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetRuneAt(string input, int32 index, [out] valuetype System.Text.Rune&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Rune.TryGetRuneAt(System.String,System.Int32,System.Text.Rune@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetRuneAt (input As String, index As Integer, ByRef value As Rune) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetRuneAt(System::String ^ input, int index, [Runtime::InteropServices::Out] System::Text::Rune % value);" />
      <MemberSignature Language="F#" Value="static member TryGetRuneAt : string * int * Rune -&gt; bool" Usage="System.Text.Rune.TryGetRuneAt (input, index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Text.Rune" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="7b217-454">ãƒ«ãƒ¼ãƒ³ã‚’æŠ½å‡ºã™ã‚‹æ–‡å­—åˆ—ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-454">The string from which to extract the rune.</span></span></param>
        <param name="index"><span data-ttu-id="7b217-455">ãƒ«ãƒ¼ãƒ³ã®æŠ½å‡ºå…ƒã¨ãªã‚‹ã€0 ã‹ã‚‰å§‹ã¾ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-455">The zero-based index from which to extract the rune.</span></span></param>
        <param name="value"><span data-ttu-id="7b217-456">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰åˆ¶å¾¡ãŒæˆ»ã‚‹ã¨ãã«ã€ãƒ‡ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ«ãƒ¼ãƒ³ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-456">When this method returns, the decoded rune.</span></span></param>
        <summary><span data-ttu-id="7b217-457">æ–‡å­—åˆ—ã«ãŠã„ã¦æŒ‡å®šã•ã‚ŒãŸä½ç½®ã‹ã‚‰å§‹ã¾ã‚‹ <see cref="T:System.Text.Rune" /> ã®å–å¾—ã‚’è©¦ã—ã€æ“ä½œãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã‚’è¿”ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-457">Attempts to get the <see cref="T:System.Text.Rune" /> that begins at a specified position in a string, and return a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="7b217-458">ã‚¹ã‚«ãƒ©ãƒ¼å€¤ãŒæŒ‡å®šã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰æ­£å¸¸ã«æŠ½å‡ºã•ã‚ŒãŸå ´åˆã¯ <see langword="true" />ã€‚ãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ãªãŸã‚ã€å€¤ã‚’æŠ½å‡ºã§ããªã‹ã£ãŸå ´åˆã¯ <see langword="false" />ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-458"><see langword="true" /> if a scalar value was successfully extracted from the specified index; <see langword="false" /> if a value could not be extracted because of invalid data.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7b217-459"><paramref name="input" /> ãŒ <see langword="null" />ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-459"><paramref name="input" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7b217-460"><paramref name="index" /> ã¯ <paramref name="input" /> ã®ç¯„å›²å¤–ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-460"><paramref name="index" /> is out of the range of <paramref name="input" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Utf16SequenceLength">
      <MemberSignature Language="C#" Value="public int Utf16SequenceLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Utf16SequenceLength" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Utf16SequenceLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Utf16SequenceLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Utf16SequenceLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Utf16SequenceLength : int" Usage="System.Text.Rune.Utf16SequenceLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7b217-461">ã“ã®ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¡¨ã™ãŸã‚ã«å¿…è¦ãª UTF-16 ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ¼ãƒ‰å˜ä½ (<see cref="T:System.Char" />) ã®é•·ã•ã‚’å–å¾—ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-461">Gets the length in code units (<see cref="T:System.Char" />) of the UTF-16 sequence required to represent this scalar value.</span></span></summary>
        <value><span data-ttu-id="7b217-462">ã“ã®ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¡¨ã™ãŸã‚ã«å¿…è¦ãª UTF-16 ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ¼ãƒ‰å˜ä½ (<see cref="T:System.Char" />) ã®é•·ã•ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-462">The length in code units (<see cref="T:System.Char" />) of the UTF-16 sequence required to represent this scalar value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-463">æˆ»ã‚Šå€¤ã¯1ã¾ãŸã¯2ã«ãªã‚Šã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-463">The return value will be 1 or 2.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Utf8SequenceLength">
      <MemberSignature Language="C#" Value="public int Utf8SequenceLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Utf8SequenceLength" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Utf8SequenceLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Utf8SequenceLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Utf8SequenceLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Utf8SequenceLength : int" Usage="System.Text.Rune.Utf8SequenceLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7b217-464">ã“ã®ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¡¨ã™ãŸã‚ã«å¿…è¦ãª UTF-8 ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ¼ãƒ‰å˜ä½ã®é•·ã•ã‚’å–å¾—ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-464">Gets the length in code units of the UTF-8 sequence required to represent this scalar value.</span></span></summary>
        <value><span data-ttu-id="7b217-465">ã“ã®ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¡¨ã™ãŸã‚ã«å¿…è¦ãª UTF-8 ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®ã‚³ãƒ¼ãƒ‰å˜ä½ã®é•·ã•ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-465">The length in code units of the UTF-8 sequence required to represent this scalar value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="7b217-466">æˆ»ã‚Šå€¤ã¯ 1 ~ 4 ã®ç¯„å›²ã§ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-466">The return value will be 1 through 4, inclusive.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public int Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Value" />
      <MemberSignature Language="DocId" Value="P:System.Text.Rune.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Value { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : int" Usage="System.Text.Rune.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="7b217-467">Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’æ•´æ•°ã¨ã—ã¦å–å¾—ã—ã¾ã™ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-467">Gets the Unicode scalar value as an integer.</span></span></summary>
        <value><span data-ttu-id="7b217-468">æ•´æ•°ã¨ã—ã¦ã® Unicode ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã€‚</span><span class="sxs-lookup"><span data-stu-id="7b217-468">The Unicode scalar value as an integer.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
