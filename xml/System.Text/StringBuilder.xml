<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fceeb096e3831bbdc326359702c1f7724fe1af63" /><Meta Name="ms.sourcegitcommit" Value="6c0b6310824199ff476e4a9eec6e9ed0bd1a51c9" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/06/2019" /><Meta Name="ms.locfileid" Value="74154537" /></Metadata><TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>可変型の文字列を表します。 このクラスは継承できません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 このクラスは、値が変更可能な一連の文字である文字列に似たオブジェクトを表します。

 このセクションの内容:

-   [String 型と StringBuilder 型](#StringAndSB)

-   [StringBuilder の動作](#HowWorks)

-   [メモリの割り当て](#Memory)

-   [StringBuilder オブジェクトのインスタンス化](#Instantiating)

-   [StringBuilder メソッドの呼び出し](#Calling)

-   [StringBuilder 操作の実行](#Operations)

    -   [StringBuilder 文字の反復処理](#Iterating)

    -   [StringBuilder オブジェクトへのテキストの追加](#Adding)

    -   [StringBuilder オブジェクトからのテキストの削除](#Deleting)

    -   [StringBuilder オブジェクト内のテキストの変更](#Modifying)

-   [StringBuilder オブジェクト内のテキストの検索](#Searching)

-   [StringBuilder オブジェクトを文字列に変換する](#Converting)

<a name="StringAndSB"></a>
## <a name="the-string-and-stringbuilder-types"></a>String 型と StringBuilder 型
 <xref:System.Text.StringBuilder> と <xref:System.String> は両方とも文字のシーケンスを表しますが、それぞれ異なる方法で実装されます。 <xref:System.String> は変更できない型です。 つまり、<xref:System.String> オブジェクトを変更するように表示される各操作では、実際に新しい文字列が作成されます。

 たとえば、次C#の例の <xref:System.String.Concat%2A?displayProperty=nameWithType> メソッドを呼び出すと、`value`という名前の文字列変数の値が変更されます。 実際、<xref:System.String.Concat%2A> メソッドは、メソッドに渡された `value` オブジェクトとは異なる値とアドレスを持つ `value` オブジェクトを返します。 この例は、`/unsafe` コンパイラオプションを使用してコンパイルする必要があることに注意してください。

 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]

 多数の文字列操作 (ループ内の文字列を何度も変更するアプリなど) を実行するルーチンでは、文字列を繰り返し変更すると、パフォーマンスが大幅に低下する可能性があります。 代替手段は、変更可能な文字列クラスである <xref:System.Text.StringBuilder>を使用することです。 変更可能性とは、クラスのインスタンスが作成された後に、そのインスタンスを追加、削除、置換、または挿入することによって変更できることを意味します。 <xref:System.Text.StringBuilder> オブジェクトは、文字列への展開に対応するバッファーを保持します。 空き領域がある場合は、新しいデータがバッファーに追加されます。それ以外の場合は、新しい大きなバッファーが割り当てられ、元のバッファーのデータが新しいバッファーにコピーされます。その後、新しいデータが新しいバッファーに追加されます。

> [!IMPORTANT]
>  一般に、<xref:System.Text.StringBuilder> クラスは <xref:System.String> クラスより優れたパフォーマンスを提供しますが、文字列を操作するときは常に <xref:System.String> を <xref:System.Text.StringBuilder> に自動的に置き換えないようにしてください。 パフォーマンスは、文字列のサイズ、新しい文字列に割り当てられるメモリの量、アプリが実行されているシステム、および操作の種類によって異なります。 <xref:System.Text.StringBuilder> 実際に大幅なパフォーマンス向上が実現されているかどうかを判断するために、アプリをテストする準備を整える必要があります。

 次の条件下では、<xref:System.String> クラスの使用を検討してください。

-   アプリが文字列に対して行う変更の数が少ない場合。 このような場合、<xref:System.Text.StringBuilder> では、<xref:System.String>よりもわずかにパフォーマンスが向上しないことがあります。

-   特に文字列リテラルを使用して、固定された数の連結演算を実行する場合。 この場合、コンパイラは連結操作を1つの操作に結合することがあります。

-   文字列を構築するときに、広範な検索操作を実行する必要がある場合。 <xref:System.Text.StringBuilder> クラスには、`IndexOf` や `StartsWith`などの検索メソッドがありません。 これらの操作のために <xref:System.Text.StringBuilder> オブジェクトを <xref:System.String> に変換する必要があります。これにより <xref:System.Text.StringBuilder>を使用した場合のパフォーマンスの利点が損なわれる可能性があります。 詳細については、「 [StringBuilder オブジェクト内のテキストの検索](#Searching)」セクションを参照してください。

 次の条件下では、<xref:System.Text.StringBuilder> クラスの使用を検討してください。

-   アプリケーションで、デザイン時に文字列に対して不明な数の変更を加えることが予想される場合 (たとえば、ユーザー入力を含む文字列の数を連結するためにループを使用する場合など)。

-   アプリが文字列に大幅な変更を加えることが予想される場合。

<a name="HowWorks"></a>
## <a name="how-stringbuilder-works"></a>StringBuilder の動作
 <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> プロパティは、<xref:System.Text.StringBuilder> オブジェクトに現在格納されている文字数を示します。 <xref:System.Text.StringBuilder> オブジェクトに文字を追加した場合、その長さは、オブジェクトに含めることができる文字数を定義する <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> プロパティのサイズと等しくなるまで増加します。 追加された文字数によって <xref:System.Text.StringBuilder> オブジェクトの長さが現在の容量を超えると、新しいメモリが割り当てられ、<xref:System.Text.StringBuilder.Capacity%2A> プロパティの値が2倍になり、新しい文字が <xref:System.Text.StringBuilder> オブジェクトに追加され、その <xref:System.Text.StringBuilder.Length%2A> プロパティが調整されます。 <xref:System.Text.StringBuilder> オブジェクトの追加メモリは、<xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> プロパティによって定義された値に達するまで、動的に割り当てられます。 最大容量に達すると、<xref:System.Text.StringBuilder> オブジェクトに対してそれ以上のメモリを割り当てることができなくなり、文字を追加したり、最大容量を超えて拡張しようとしたりすると、<xref:System.ArgumentOutOfRangeException> または <xref:System.OutOfMemoryException> 例外がスローされます。

 次の例は、オブジェクトに割り当てられた文字列が拡張されると、<xref:System.Text.StringBuilder> オブジェクトが新しいメモリを割り当て、容量を動的に増やす方法を示しています。 このコードでは、既定の (パラメーターなしの) コンストラクターを呼び出すことによって <xref:System.Text.StringBuilder> オブジェクトを作成します。 このオブジェクトの既定の容量は16文字で、最大容量は20億文字を超えています。 "This is a 文." という文字列を追加します。 文字列の長さ (19 文字) が <xref:System.Text.StringBuilder> オブジェクトの既定の容量を超えているため、新しいメモリが割り当てられます。 オブジェクトの容量が2倍32になると、新しい文字列が追加され、オブジェクトの長さは19文字になります。 このコードでは、"This は追加の文です。" という文字列を追加します。 <xref:System.Text.StringBuilder> オブジェクトの値を11回に指定します。 追加操作によって <xref:System.Text.StringBuilder> オブジェクトの長さがその容量を超えた場合、既存の容量が2倍になり、<xref:System.Text.StringBuilder.Append%2A> 操作が成功します。

 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]

<a name="Memory"></a>
## <a name="memory-allocation"></a>メモリ割り当て
 <xref:System.Text.StringBuilder> オブジェクトの既定の容量は16文字で、既定の最大容量は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。 これらの既定値は、<xref:System.Text.StringBuilder.%23ctor> コンストラクターと <xref:System.Text.StringBuilder.%23ctor%28System.String%29> コンストラクターを呼び出す場合に使用されます。

 <xref:System.Text.StringBuilder> オブジェクトの初期容量は、次の方法で明示的に定義できます。

-   オブジェクトを作成するときに、`capacity` パラメーターを含む <xref:System.Text.StringBuilder> コンストラクターのいずれかを呼び出します。

-   新しい値を <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> プロパティに明示的に代入して、既存の <xref:System.Text.StringBuilder> オブジェクトを展開する。 新しい容量が既存の容量より小さい場合、または <xref:System.Text.StringBuilder> オブジェクトの最大容量より大きい場合、プロパティは例外をスローすることに注意してください。

-   新しい容量で <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> メソッドを呼び出します。 新しい容量は、<xref:System.Text.StringBuilder> オブジェクトの最大容量を超えないようにする必要があります。 ただし、<xref:System.Text.StringBuilder.Capacity%2A> プロパティへの割り当てとは異なり、必要な新しい容量が既存の容量よりも少ない場合、<xref:System.Text.StringBuilder.EnsureCapacity%2A> は例外をスローしません。この場合、メソッドの呼び出しは無効です。

 コンストラクター呼び出しの <xref:System.Text.StringBuilder> オブジェクトに割り当てられた文字列の長さが、既定の容量または指定された容量のいずれかを超えた場合、<xref:System.Text.StringBuilder.Capacity%2A> プロパティは `value` パラメーターで指定された文字列の長さに設定されます。

 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> コンストラクターを呼び出すことによって、<xref:System.Text.StringBuilder> オブジェクトの最大容量を明示的に定義できます。 <xref:System.Text.StringBuilder.MaxCapacity%2A> プロパティに新しい値を割り当てることによって最大容量を変更することはできません。これは読み取り専用であるためです。

 前のセクションで示したように、既存の容量が不十分な場合は、追加のメモリが割り当てられ、<xref:System.Text.StringBuilder> オブジェクトの容量が <xref:System.Text.StringBuilder.MaxCapacity%2A> プロパティで定義されている値まで倍増します。

 一般に、既定の容量と最大容量は、ほとんどのアプリに適しています。 次の条件に該当する場合は、これらの値を設定することを検討してください。

-   <xref:System.Text.StringBuilder> オブジェクトの最終的なサイズが非常に大きくなる可能性が高い場合、通常は数 mb を超えています。 この場合、初期の <xref:System.Text.StringBuilder.Capacity%2A> プロパティを非常に大きな値に設定すると、メモリの再割り当て回数が多すぎる必要がなくなるため、パフォーマンスが向上する可能性があります。

-   アプリがメモリが限られているシステムで実行されている場合。 この場合、メモリの制約がある環境で実行される可能性のある大きな文字列をアプリが処理している場合は、<xref:System.Text.StringBuilder.MaxCapacity%2A> プロパティを <xref:System.Int32.MaxValue?displayProperty=nameWithType> より小さい値に設定することを検討してください。

<a name="Instantiating"></a>
## <a name="instantiating-a-stringbuilder-object"></a>StringBuilder オブジェクトのインスタンス化
 次の表に示すように、6つのオーバーロードされたクラスコンストラクターのいずれかを呼び出すことによって、<xref:System.Text.StringBuilder> オブジェクトをインスタンス化します。 3つのコンストラクターは、値が空の文字列である <xref:System.Text.StringBuilder> オブジェクトをインスタンス化しますが、その <xref:System.Text.StringBuilder.Capacity%2A> と <xref:System.Text.StringBuilder.MaxCapacity%2A> 値は異なる方法で設定します。 残りの3つのコンストラクターは、特定の文字列値と容量を持つ <xref:System.Text.StringBuilder> オブジェクトを定義します。 3つのコンストラクターのうち2つは <xref:System.Int32.MaxValue?displayProperty=nameWithType>の既定の最大容量を使用し、3番目のコンストラクターでは最大容量を設定できます。

|コンストラクター|文字列値|容量|最大容量|
|-----------------|------------------|--------------|----------------------|
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|`capacity` パラメーターによって定義されます。|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|`capacity` パラメーターによって定義されます。|`maxCapacity` パラメーターによって定義されます。|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|`value` パラメーターによって定義されます。|16または `value`。 <xref:System.String.Length%2A>のいずれか大きい方|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|`value` パラメーターによって定義されます。|`capacity` パラメーターまたは `value`によって定義されます。 <xref:System.String.Length%2A>のいずれか大きい方。|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|`value` によって定義されます。 <xref:System.String.Substring%2A>(`startIndex`, `length`)|`capacity` パラメーターまたは `value`によって定義されます。 <xref:System.String.Length%2A>のいずれか大きい方。|`maxCapacity` パラメーターによって定義されます。|

 次の例では、これらのコンストラクターの3つのオーバーロードを使用して、<xref:System.Text.StringBuilder> オブジェクトをインスタンス化します。

 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]

<a name="Calling"></a>
## <a name="calling-stringbuilder-methods"></a>StringBuilder メソッドの呼び出し
 <xref:System.Text.StringBuilder> インスタンスの文字列を変更するメソッドのほとんどは、その同じインスタンスへの参照を返します。 これにより、次の2つの方法で <xref:System.Text.StringBuilder> メソッドを呼び出すことができます。

-   次の例に示すように、個々のメソッドを呼び出し、戻り値を無視することができます。

     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]

-   1つのステートメントで一連のメソッド呼び出しを行うことができます。 これは、連続する操作を連結する1つのステートメントを記述する場合に便利です。 次の例では、前の例の3つのメソッド呼び出しを1行のコードに統合しています。

     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]

<a name="Operations"></a>
## <a name="performing-stringbuilder-operations"></a>StringBuilder 操作の実行
 <xref:System.Text.StringBuilder> クラスのメソッドを使用して、<xref:System.Text.StringBuilder> オブジェクト内の文字の反復、追加、削除、または変更を行うことができます。

<a name="Iterating"></a>
### <a name="iterating-stringbuilder-characters"></a>StringBuilder 文字の反復処理
 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> プロパティを使用して、<xref:System.Text.StringBuilder> オブジェクト内の文字にアクセスできます。 でC#は、<xref:System.Text.StringBuilder.Chars%2A> はインデクサーです。Visual Basic では、これは <xref:System.Text.StringBuilder> クラスの既定のプロパティです。 これにより、<xref:System.Text.StringBuilder.Chars%2A> プロパティを明示的に参照せずに、インデックスのみを使用して個々の文字を設定または取得することができます。 <xref:System.Text.StringBuilder> オブジェクト内の文字は、インデックス 0 (ゼロ) から開始し、<xref:System.Text.StringBuilder.Length%2A>-1 のインデックス作成を続行します。

 次の例は、<xref:System.Text.StringBuilder.Chars%2A> プロパティを示しています。 <xref:System.Text.StringBuilder> オブジェクトに10個の乱数を追加し、各文字を反復処理します。 文字の Unicode カテゴリが <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>場合は、数値を1つ減らします (または、値が0の場合は、数値を9に変更します)。 この例では、個々の文字の値が変更された前と後の両方で、<xref:System.Text.StringBuilder> オブジェクトの内容が表示されます。

 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

<a name="Adding"></a>
### <a name="adding-text-to-a-stringbuilder-object"></a>StringBuilder オブジェクトへのテキストの追加
 <xref:System.Text.StringBuilder> クラスには、<xref:System.Text.StringBuilder> オブジェクトの内容を拡張するための次のメソッドが含まれています。

-   <xref:System.Text.StringBuilder.Append%2A> メソッドは、文字列、部分文字列、文字配列、文字配列の一部、複数回繰り返される1文字、またはプリミティブデータ型の文字列形式を <xref:System.Text.StringBuilder> オブジェクトに追加します。

-   <xref:System.Text.StringBuilder.AppendLine%2A> メソッドは、行終端記号または文字列を行終端記号と共に <xref:System.Text.StringBuilder> オブジェクトに追加します。

-   <xref:System.Text.StringBuilder.AppendFormat%2A> メソッドは、<xref:System.Text.StringBuilder> オブジェクトに[複合書式指定文字列](~/docs/standard/base-types/composite-formatting.md)を追加します。 結果文字列に含まれるオブジェクトの文字列形式は、現在のシステムカルチャまたは指定されたカルチャの書式指定規則を反映できます。

-   <xref:System.Text.StringBuilder.Insert%2A> メソッドは、文字列、部分文字列、複数回の文字列の繰り返し、文字配列、文字配列の一部、または <xref:System.Text.StringBuilder> オブジェクト内の指定位置にあるプリミティブデータ型の文字列形式を挿入します。 位置は、0から始まるインデックスによって定義されます。

 次の例では、<xref:System.Text.StringBuilder.Append%2A>、<xref:System.Text.StringBuilder.AppendLine%2A>、<xref:System.Text.StringBuilder.AppendFormat%2A>、および <xref:System.Text.StringBuilder.Insert%2A> の各メソッドを使用して、<xref:System.Text.StringBuilder> オブジェクトのテキストを展開します。

 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]

<a name="Deleting"></a>
### <a name="deleting-text-from-a-stringbuilder-object"></a>StringBuilder オブジェクトからのテキストの削除
 <xref:System.Text.StringBuilder> クラスには、現在の <xref:System.Text.StringBuilder> インスタンスのサイズを縮小できるメソッドが含まれています。 <xref:System.Text.StringBuilder.Clear%2A> メソッドは、すべての文字を削除し、<xref:System.Text.StringBuilder.Length%2A> プロパティを0に設定します。 <xref:System.Text.StringBuilder.Remove%2A> メソッドは、特定のインデックス位置から指定された数の文字を削除します。 また、<xref:System.Text.StringBuilder.Length%2A> プロパティを現在のインスタンスの長さよりも小さい値に設定することにより、<xref:System.Text.StringBuilder> オブジェクトの末尾から文字を削除できます。

 次の例では、<xref:System.Text.StringBuilder> オブジェクトから一部のテキストを削除し、その結果の容量、最大容量、および長さのプロパティ値を表示した後、<xref:System.Text.StringBuilder.Clear%2A> メソッドを呼び出して、<xref:System.Text.StringBuilder> オブジェクトからすべての文字を削除します。

 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]

<a name="Modifying"></a>
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>StringBuilder オブジェクト内のテキストの変更
 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> メソッドは、<xref:System.Text.StringBuilder> オブジェクト全体または特定の文字範囲内の文字または文字列のすべての出現箇所を置き換えます。 次の例では、<xref:System.Text.StringBuilder.Replace%2A> メソッドを使用して、<xref:System.Text.StringBuilder> オブジェクト内のすべての感嘆符 (!) を疑問符 (?) に置き換えます。

 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]

<a name="Searching"></a>
## <a name="searching-the-text-in-a-stringbuilder-object"></a>StringBuilder オブジェクト内のテキストの検索
 <xref:System.Text.StringBuilder> クラスには、オブジェクト内で特定の文字または部分文字列を検索できるようにするために、<xref:System.String> クラスによって提供される <xref:System.String.Contains%2A?displayProperty=nameWithType>、<xref:System.String.IndexOf%2A?displayProperty=nameWithType>、および <xref:System.String.StartsWith%2A?displayProperty=nameWithType> メソッドと同様のメソッドは含まれません。 部分文字列の存在または開始文字の位置を特定するには、文字列検索メソッドまたは正規表現メソッドのいずれかを使用して <xref:System.String> 値を検索する必要があります。 このような検索を実装するには、次の表に示すように4つの方法があります。

|手法|プロフェッショナル|マイナス|
|---------------|----------|----------|
|文字列値を <xref:System.Text.StringBuilder> オブジェクトに追加する前に検索します。|部分文字列が存在するかどうかを判断する場合に便利です。|は、部分文字列のインデックス位置が重要な場合は使用できません。|
|<xref:System.Text.StringBuilder.ToString%2A> を呼び出し、返された <xref:System.String> オブジェクトを検索します。|すべてのテキストを <xref:System.Text.StringBuilder> オブジェクトに割り当ててから、その変更を開始する場合は、簡単に使用できます。|すべてのテキストを <xref:System.Text.StringBuilder> オブジェクトに追加する前に変更を行う必要がある場合は、<xref:System.Text.StringBuilder.ToString%2A> を繰り返し呼び出すのが面倒です。<br /><br /> 変更を行う場合は、<xref:System.Text.StringBuilder> オブジェクトのテキストの末尾から作業することを忘れないでください。|
|<xref:System.Text.StringBuilder.Chars%2A> プロパティを使用して、文字の範囲を順番に検索します。|個々の文字または小さい部分文字列に関心がある場合に便利です。|検索する文字数が多い場合、または検索ロジックが複雑な場合には煩雑です。<br /><br />メソッドの呼び出しを繰り返すことによって非常に大きな増加したオブジェクトのパフォーマンスが非常に低下します。  |
|<xref:System.Text.StringBuilder> オブジェクトを <xref:System.String> オブジェクトに変換し、<xref:System.String> オブジェクトに対して変更を実行します。|変更の数が少ない場合に便利です。|変更の数が多い場合は、<xref:System.Text.StringBuilder> クラスのパフォーマンス上の利点を否定します。|

 これらの手法についてさらに詳しく説明します。

-   検索の目的が特定の部分文字列が存在するかどうかを判断する場合 (つまり、部分文字列の位置に関心がない場合) は、文字列を <xref:System.Text.StringBuilder> オブジェクトに格納する前に検索できます。 次の例では、考えられる1つの実装を示します。 また、<xref:System.Text.StringBuilder> オブジェクトへの参照と、文字列内で検索する部分文字列をコンストラクターに渡す `StringBuilderFinder` クラスを定義します。 この例では、記録された気温が華氏と摂氏のどちらであるかを判断し、<xref:System.Text.StringBuilder> オブジェクトの先頭に適切な紹介文を追加します。 ランダムな数値ジェネレーターを使用して、摂氏または華氏でデータを含む配列を選択します。

     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]

-   <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> メソッドを呼び出して、<xref:System.Text.StringBuilder> オブジェクトを <xref:System.String> オブジェクトに変換します。 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> や <xref:System.String.StartsWith%2A?displayProperty=nameWithType>などのメソッドを使用して文字列を検索することも、正規表現と <xref:System.Text.RegularExpressions.Regex> クラスを使用してパターンを検索することもできます。 <xref:System.Text.StringBuilder> と <xref:System.String> の両方のオブジェクトが文字を格納するために UTF-16 エンコードを使用するため、文字、部分文字列、および正規表現の一致のインデックス位置は、両方のオブジェクトで同じになります。 これにより、<xref:System.Text.StringBuilder> メソッドを使用して、<xref:System.String> オブジェクト内のそのテキストと同じ位置で変更を加えることができます。

    > [!NOTE]
    >  この方法を採用する場合は、<xref:System.Text.StringBuilder> オブジェクトを文字列に繰り返し変換する必要がないように、<xref:System.Text.StringBuilder> オブジェクトの末尾から先頭に作業する必要があります。

     このアプローチの例を次に示します。 <xref:System.Text.StringBuilder> オブジェクトに、英語のアルファベットの各文字の4回の出現を格納します。 次に、テキストを <xref:System.String> オブジェクトに変換し、正規表現を使用して各4文字のシーケンスの開始位置を識別します。 最後に、最初のシーケンスを除く4文字の各シーケンスの前にアンダースコアを追加し、シーケンスの最初の文字を大文字に変換します。

     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]

-   <xref:System.Text.StringBuilder> オブジェクト内の文字の範囲を順番に検索するには、<xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> プロパティを使用します。 検索対象の文字数が多い場合や検索ロジックが特に複雑な場合、この方法は実用的ではない可能性があります。 非常に大きい、チャンク化された <xref:System.Text.StringBuilder> オブジェクトに対する文字単位のインデックスベースのアクセスのパフォーマンスへの影響については、<xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> プロパティのドキュメントを参照してください。

     次の例は、前の例と同じ機能ですが、実装によって異なります。 また、<xref:System.Text.StringBuilder.Chars%2A> プロパティを使用して、文字値がいつ変更されたかを検出し、その位置にアンダースコアを挿入し、新しいシーケンスの最初の文字を大文字に変換します。

     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]

-   未変更のテキストをすべて <xref:System.Text.StringBuilder> オブジェクトに格納し、<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> メソッドを呼び出して <xref:System.Text.StringBuilder> オブジェクトを <xref:System.String> オブジェクトに変換し、<xref:System.String> オブジェクトに対して変更を実行します。 いくつかの変更がある場合は、この方法を使用できます。そうしないと、変更できない文字列を操作するコストが、<xref:System.Text.StringBuilder> オブジェクトを使用した場合のパフォーマンス上の利点を否定する可能性があります。

     次の例は、前の2つの例と同じ機能を備えていますが、実装によって異なります。 <xref:System.Text.StringBuilder> オブジェクトを作成し、それを <xref:System.String> オブジェクトに変換した後、正規表現を使用して、文字列に対する残りのすべての変更を実行します。 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> メソッドは、ラムダ式を使用して、一致するたびに置換を実行します。

     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]

<a name="Converting"></a>
## <a name="converting-the-stringbuilder-object-to-a-string"></a>StringBuilder オブジェクトを文字列に変換する
 <xref:System.Text.StringBuilder> オブジェクトで表される文字列を <xref:System.String> パラメーターを持つメソッドに渡すかそれをユーザー インターフェイスに表示するには、事前に <xref:System.Text.StringBuilder> オブジェクトを <xref:System.String> オブジェクトに変換する必要があります。 この変換を実行するには、<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> メソッドを呼び出します。 図については、前の例を参照してください。この例では、<xref:System.Text.StringBuilder.ToString%2A> メソッドを呼び出して、<xref:System.Text.StringBuilder> オブジェクトを文字列に変換し、正規表現メソッドに渡すことができるようにしています。



## Examples
 次の例では、<xref:System.Text.StringBuilder> クラスで定義されている多くのメソッドを呼び出す方法を示します。

 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]

 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このインスタンスの文字列値は <xref:System.String.Empty?displayProperty=nameWithType>に設定され、容量は実装固有の既定の容量に設定されます。



## Examples
 次の例は、パラメーターを使用せずに <xref:System.Text.StringBuilder.%23ctor%2A> コンストラクターを呼び出す方法を示しています。

 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">このインスタンスの推奨される開始サイズ。</param>
        <summary>指定した容量を使用して、<see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `capacity` パラメーターは、現在のインスタンスによって割り当てられたメモリに格納できる最大文字数を定義します。 この値は <xref:System.Text.StringBuilder.Capacity%2A> プロパティに割り当てられます。 現在のインスタンスに格納されている文字数がこの `capacity` 値を超える場合、<xref:System.Text.StringBuilder> オブジェクトは、それを格納するために追加のメモリを割り当てます。

 このインスタンスの文字列値が <xref:System.String.Empty?displayProperty=nameWithType>に設定されています。 `capacity` がゼロの場合は、実装固有の既定の容量が使用されます。



## Examples
 次の例は、指定された容量で <xref:System.Text.StringBuilder.%23ctor%2A> コンストラクターを呼び出す方法を示しています。

 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> が 0 未満です。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">インスタンスの値を初期化するために使用される文字列。 <paramref name="value" /> が <see langword="null" /> の場合、新しい <see cref="T:System.Text.StringBuilder" /> は空の文字列、つまり、<see cref="F:System.String.Empty" /> を含みます。</param>
        <summary>指定した文字列を使用して、<see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `value` が `null` の場合、新しい <xref:System.Text.StringBuilder> は空の文字列、つまり、<xref:System.String.Empty> を含みます。



## Examples
 次の例は、指定された文字列を使用して <xref:System.Text.StringBuilder.%23ctor%2A> コンストラクターを呼び出す方法を示しています。

 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> の推奨される開始サイズ。</param>
        <param name="maxCapacity">現在の文字列が含むことができる最大文字数。</param>
        <summary>指定した容量で始まり、指定した最大容量まで大きくなる <see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `capacity` パラメーターは、現在のインスタンスによって割り当てられたメモリに格納できる最大文字数を定義します。 この値は <xref:System.Text.StringBuilder.Capacity%2A> プロパティに割り当てられます。 現在のインスタンスに格納されている文字数がこの `capacity` 値を超える場合、<xref:System.Text.StringBuilder> オブジェクトは、それを格納するために追加のメモリを割り当てます。

 `capacity` がゼロの場合は、実装固有の既定の容量が使用されます。

 `maxCapacity` プロパティは、現在のインスタンスが保持できる最大文字数を定義します。 この値は <xref:System.Text.StringBuilder.MaxCapacity%2A> プロパティに割り当てられます。 現在のインスタンスに格納される文字数がこの `maxCapacity` 値を超える場合、<xref:System.Text.StringBuilder> オブジェクトは追加のメモリを割り当てませんが、代わりに例外がスローされます。



## Examples
 次の例は、指定された容量と最大容量を使用して <xref:System.Text.StringBuilder.%23ctor%2A> コンストラクターを呼び出す方法を示しています。

 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxCapacity" /> が 1 未満か、<paramref name="capacity" /> が 0 未満か、<paramref name="capacity" /> が <paramref name="maxCapacity" /> より大きいです。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">インスタンスの値を初期化するために使用される文字列。 <paramref name="value" /> が <see langword="null" /> の場合、新しい <see cref="T:System.Text.StringBuilder" /> は空の文字列、つまり、<see cref="F:System.String.Empty" /> を含みます。</param>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> の推奨される開始サイズ。</param>
        <summary>指定した文字列および容量を使用して、<see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `capacity` パラメーターは、現在のインスタンスによって割り当てられたメモリに格納できる最大文字数を定義します。 この値は <xref:System.Text.StringBuilder.Capacity%2A> プロパティに割り当てられます。 現在のインスタンスに格納されている文字数がこの `capacity` 値を超える場合、<xref:System.Text.StringBuilder> オブジェクトは、それを格納するために追加のメモリを割り当てます。

 `capacity` がゼロの場合は、実装固有の既定の容量が使用されます。



## Examples
 次の例は、初期文字列と指定された容量を使用して <xref:System.Text.StringBuilder.%23ctor%2A> コンストラクターを呼び出す方法を示しています。

 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> が 0 未満です。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">このインスタンスの値を初期化するために使用される部分文字列を含む文字列。 <paramref name="value" /> が <see langword="null" /> の場合、新しい <see cref="T:System.Text.StringBuilder" /> は空の文字列、つまり、<see cref="F:System.String.Empty" /> を含みます。</param>
        <param name="startIndex"><paramref name="value" /> における部分文字列の開始位置。</param>
        <param name="length">部分文字列の文字数。</param>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> の推奨される開始サイズ。</param>
        <summary>指定した部分文字列および容量から <see cref="T:System.Text.StringBuilder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `capacity` パラメーターは、現在のインスタンスによって割り当てられたメモリに格納できる最大文字数を定義します。 この値は <xref:System.Text.StringBuilder.Capacity%2A> プロパティに割り当てられます。 現在のインスタンスに格納されている文字数がこの `capacity` 値を超える場合、<xref:System.Text.StringBuilder> オブジェクトは、それを格納するために追加のメモリを割り当てます。

 `capacity` がゼロの場合は、実装固有の既定の容量が使用されます。



## Examples
 次の例は、指定された文字列を使用して <xref:System.Text.StringBuilder.%23ctor%2A> コンストラクターを呼び出す方法を示しています。

 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> が 0 未満です。

- または -

 <paramref name="startIndex" /> に <paramref name="length" /> を加算した値が <paramref name="value" /> 内の位置にありません。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したオブジェクトの文字列形式をこのインスタンスに追加します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">追加するブール値。</param>
        <summary>指定した Boolean 値の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]

 <xref:System.Text.StringBuilder.Append%28System.Boolean%29> メソッドは、<xref:System.Boolean.ToString?displayProperty=nameWithType> メソッドを呼び出して、`value`の文字列形式を取得します。 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 8 ビット符号なし整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Byte%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]

 <xref:System.Text.StringBuilder.Append%28System.Byte%29> メソッドは、<xref:System.Byte.ToString%28System.IFormatProvider%29> メソッドを呼び出して、現在のカルチャの `value` の文字列形式を取得します。 `value`の書式設定を制御するには、<xref:System.Text.StringBuilder.AppendFormat%2A> メソッドを呼び出します。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">追加する UTF-16 でエンコードされたコード単位。</param>
        <summary>指定した <see cref="T:System.Char" /> オブジェクトの文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Char%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">追加する文字の配列。</param>
        <summary>指定した配列内の Unicode 文字の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、指定した配列内のすべての文字を `value`に表示される順序と同じ順序で現在のインスタンスに追加します。 `value` が `null`場合、変更は行われません。

 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 10 進数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]

 <xref:System.Text.StringBuilder.Append%28System.Decimal%29> メソッドは、<xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出して、現在のカルチャの `value` の文字列形式を取得します。 `value`の書式設定を制御するには、<xref:System.Text.StringBuilder.AppendFormat%2A> メソッドを呼び出します。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した倍精度浮動小数点数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Double%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]

 <xref:System.Text.StringBuilder.Append%28System.Double%29> メソッドは、<xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出して、現在のカルチャの `value` の文字列形式を取得します。 `value`の書式設定を制御するには、<xref:System.Text.StringBuilder.AppendFormat%2A> メソッドを呼び出します。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 16 ビット符号付き整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Int16%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]

 <xref:System.Text.StringBuilder.Append%28System.Int16%29> メソッドは、<xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出して、現在のカルチャの `value` の文字列形式を取得します。 `value`の書式設定を制御するには、<xref:System.Text.StringBuilder.AppendFormat%2A> メソッドを呼び出します。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 32 ビット符号付き整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Int32%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]

 <xref:System.Text.StringBuilder.Append%28System.Int32%29> メソッドは、<xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出して、現在のカルチャの `value` の文字列形式を取得します。 `value`の書式設定を制御するには、<xref:System.Text.StringBuilder.AppendFormat%2A> メソッドを呼び出します。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 64 ビット符号付き整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Int64%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]

 <xref:System.Text.StringBuilder.Append%28System.Int64%29> メソッドは、<xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> を呼び出して、現在のカルチャの `value` の文字列形式を取得します。 `value`の書式設定を制御するには、<xref:System.Text.StringBuilder.AppendFormat%2A> メソッドを呼び出します。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">追加するオブジェクト。</param>
        <summary>指定したオブジェクトの文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Object%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。 これは `Dog` クラスを定義し、`Dog` オブジェクトを作成し、<xref:System.Text.StringBuilder.Append%2A> メソッドを3回呼び出して、dog の名前と組み合わせを含む文字列を作成します。

 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]

 <xref:System.Text.StringBuilder.Append%28System.Object%29> メソッドは、<xref:System.Object.ToString%2A?displayProperty=nameWithType> メソッドを呼び出して、`value`の文字列形式を取得します。 `value` が `null`場合、<xref:System.Text.StringBuilder> オブジェクトに変更は加えられません。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlyMemory`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlyMemory(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlyMemory&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlyMemory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">追加する読み取り専用文字メモリ領域。</param>
        <summary>指定された読み取り専用文字メモリ領域の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">追加する読み取り専用文字スパン。</param>
        <summary>指定された読み取り専用文字スパンの文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 8 ビット符号付き整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.SByte%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]

 <xref:System.Text.StringBuilder.Append%28System.SByte%29> メソッドは、<xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出して、現在のカルチャの `value` の文字列形式を取得します。 `value`の書式設定を制御するには、<xref:System.Text.StringBuilder.AppendFormat%2A> メソッドを呼び出します。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した単精度浮動小数点数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Single%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]

 <xref:System.Text.StringBuilder.Append%28System.Single%29> メソッドは、<xref:System.Single.ToString%2A?displayProperty=nameWithType> メソッドを呼び出して、現在のカルチャの `value` の文字列形式を取得します。 `value`の書式設定を制御するには、<xref:System.Text.StringBuilder.AppendFormat%2A> メソッドを呼び出します。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">追加する文字列。</param>
        <summary>指定した文字列のコピーをこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.String%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]

 `value` が `null`場合、変更は行われません。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">追加する文字列ビルダー。</param>
        <summary>指定された文字列ビルダーの文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 16 ビット符号なし整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]

 <xref:System.Text.StringBuilder.Append%28System.UInt16%29> メソッドは、<xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出して、`value`の文字列形式を取得します。 `value`の書式設定を制御するには、<xref:System.Text.StringBuilder.AppendFormat%2A> メソッドを呼び出します。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定された 32 ビット符号なし整数の文字列表記をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]

 <xref:System.Text.StringBuilder.Append%28System.UInt32%29> は、<xref:System.UInt32.ToString%2A?displayProperty=nameWithType> メソッドを呼び出して、現在のカルチャの `value` の文字列形式を取得します。 `value`の書式設定を制御するには、<xref:System.Text.StringBuilder.AppendFormat%2A> メソッドを呼び出します。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">追加する値。</param>
        <summary>指定した 64 ビット符号なし整数の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]

 <xref:System.Text.StringBuilder.Append%28System.UInt64%29> メソッドは、<xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> メソッドを呼び出して、現在のカルチャの `value` の文字列形式を取得します。 `value`の書式設定を制御するには、<xref:System.Text.StringBuilder.AppendFormat%2A> メソッドを呼び出します。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">追加する文字。</param>
        <param name="repeatCount"><paramref name="value" /> を追加する回数。</param>
        <summary>Unicode 文字の文字列形式の、指定した数のコピーをこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount" /> が 0 未満です。

- または -

このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しています。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">文字の配列を指すポインター。</param>
        <param name="valueCount">配列の文字数。</param>
        <summary>指定したアドレスで始まる Unicode 文字の配列をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、アドレス `value` で始まる `valueCount` 文字を現在のインスタンスに追加します。

 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="valueCount" /> が 0 未満です。

- または -

このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> が null ポインターです。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">文字配列。</param>
        <param name="startIndex"><paramref name="value" /> 内の開始位置。</param>
        <param name="charCount">追加する文字数。</param>
        <summary>Unicode 文字の指定した部分配列の文字列形式をこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、`value` 内の指定された範囲の文字を現在のインスタンスに追加します。 `value` が `null`、`startIndex` と `count` が両方とも0の場合、変更は行われません。

 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> で、<paramref name="startIndex" /> と <paramref name="charCount" /> が 0 ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> が 0 未満です。

- または -

 <paramref name="startIndex" /> が 0 未満です。

- または -

 <paramref name="startIndex" /> + <paramref name="charCount" /> が <paramref name="value" /> の長さを超えています。

- または -

このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">追加する部分文字列を含む文字列。</param>
        <param name="startIndex"><paramref name="value" /> 内の部分文字列の開始位置。</param>
        <param name="count"><paramref name="value" /> 内の追加する文字数。</param>
        <summary>指定した部分文字列のコピーをこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、`value` 内の指定された範囲の文字を現在のインスタンスに追加します。 `value` が `null`、`startIndex` と `count` が両方とも0の場合、変更は行われません。

 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> メソッドは、このクラスの既存のインスタンスを変更します。新しいクラスのインスタンスは返されません。 このため、次の例に示すように、既存の参照に対してメソッドまたはプロパティを呼び出すことができ、<xref:System.Text.StringBuilder> オブジェクトに戻り値を割り当てる必要はありません。

 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> で、<paramref name="startIndex" /> と <paramref name="count" /> が 0 ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">0 より小さい<paramref name="count" /> 。

- または -

 0 より小さい <paramref name="startIndex" />。

- または -

 <paramref name="startIndex" /> + <paramref name="count" /> が <paramref name="value" /> の長さを超えています。

- または -

このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">追加する部分文字列を含む文字列ビルダー。</param>
        <param name="startIndex"><paramref name="value" /> 内の部分文字列の開始位置。</param>
        <param name="count"><paramref name="value" /> 内の追加する文字数。</param>
        <summary>指定された文字列ビルダー内の部分文字列のコピーをこのインスタンスに追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに追加します。 各書式項目は、対応するオブジェクト引数の文字列形式に置換されます。</summary>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">複合書式設定文字列。</param>
        <param name="arg0">書式指定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに追加します。 各書式項目は、単一の引数の文字列表記に置換されます。</summary>
        <returns><paramref name="format" /> が追加されたこのインスタンスへの参照。 <paramref name="format" /> の各書式指定項目は、<paramref name="arg0" /> の文字列表記に置換されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、.NET Framework の[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、オブジェクトの値をテキスト表現に変換し、その表現を現在の <xref:System.Text.StringBuilder> オブジェクトに埋め込みます。

 `format` パラメーターは、書式指定項目と呼ばれる0個以上のインデックス付きプレースホルダーと共に、0個以上のテキストの実行で構成されます。 書式項目のインデックスは、このメソッドのパラメーターリスト内の1つのオブジェクト `arg0`に対応する0にする必要があります。 書式設定のプロセスでは、各書式項目が `arg0`の文字列形式に置き換えられます。

 書式指定項目の構文は次のとおりです。

 {*index*[,*length*] [:*formatString*]}

 角かっこ内の要素は省略可能です。 次の表は、それぞれの要素の説明です。

|要素|説明|
|-------------|-----------------|
|*index*|書式設定するオブジェクトのパラメーターリスト内の0から始まる位置。 *Index*で指定されたオブジェクトが `null`場合、書式項目は <xref:System.String.Empty?displayProperty=nameWithType>に置き換えられます。 *インデックス*位置にパラメーターがない場合は、<xref:System.FormatException> がスローされます。|
|、*length*|パラメーターの文字列形式の最小文字数。 正の場合、パラメーターは右上にあります。負の場合は、左揃えになります。|
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|

> [!NOTE]
>  日付と時刻の値と共に使用される標準およびカスタム書式指定文字列については、「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください。 数値で使用される標準およびカスタム書式指定文字列については、「[標準の数値書式](~/docs/standard/base-types/standard-numeric-format-strings.md)指定文字列」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。 列挙体で使用される標準書式指定文字列については、「[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)」を参照してください。

 `arg0` は、書式設定するオブジェクトを表します。 `format` 内の各書式指定項目は、`arg0`の文字列形式に置き換えられます。 書式指定項目に `formatString` が含まれており、`arg0` <xref:System.IFormattable> インターフェイスが実装されている場合、`arg0.ToString(formatString, null)` は書式設定を定義します。 それ以外の場合は、`arg0.ToString()` によって書式設定が定義されます。

 `format` に割り当てられた文字列が "{0: # # # #} の食料を慈善団体に寄付しようとしています" という内容の場合は、 また `arg0` は値が10の整数です。この戻り値は、"私たちの慈善団体に対して10人の食べ物を寄付したとしていただき、ありがとうございました" となります。



## Examples
 <xref:System.Text.StringBuilder.AppendFormat%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。

- または -

書式項目のインデックスが 0 (ゼロ) 未満か、1 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">複合書式設定文字列。</param>
        <param name="args">書式指定するオブジェクトの配列。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに追加します。 各書式項目は、パラメーター配列内の対応する引数の文字列形式に置換されます。</summary>
        <returns><paramref name="format" /> が追加されたこのインスタンスへの参照。 <paramref name="format" /> の各書式項目は、対応するオブジェクト引数の文字列形式に置換されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、.NET Framework の[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、オブジェクトの値をテキスト表現に変換し、その表現を現在の <xref:System.Text.StringBuilder> オブジェクトに埋め込みます。

 `format` パラメーターは、このメソッドのパラメーターリスト内のオブジェクトに対応する0個以上のインデックス付きプレースホルダー (書式項目と呼ばれます) と共に、0個以上のテキストの実行で構成されます。 書式設定のプロセスでは、各書式項目が対応するオブジェクトの文字列形式に置き換えられます。

 書式指定項目の構文は次のとおりです。

 {*index*[,*length*] [:*formatString*]}

 角かっこ内の要素は省略可能です。 次の表は、それぞれの要素の説明です。

|要素|説明|
|-------------|-----------------|
|*index*|書式設定するオブジェクトのパラメーターリスト内の0から始まる位置。 *Index*で指定されたオブジェクトが `null`場合、書式項目は <xref:System.String.Empty?displayProperty=nameWithType>に置き換えられます。 *インデックス*位置にパラメーターがない場合は、<xref:System.FormatException> がスローされます。|
|、*length*|パラメーターの文字列形式の最小文字数。 正の場合、パラメーターは右上にあります。負の場合は、左揃えになります。|
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|

> [!NOTE]
>  日付と時刻の値と共に使用される標準およびカスタム書式指定文字列については、「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください。 数値で使用される標準およびカスタム書式指定文字列については、「[標準の数値書式](~/docs/standard/base-types/standard-numeric-format-strings.md)指定文字列」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。 列挙体で使用される標準書式指定文字列については、「[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)」を参照してください。

 `args` は、書式設定するオブジェクトを表します。 `format` 内の各書式指定項目は、`args`内の対応するオブジェクトの文字列形式に置き換えられます。 書式指定項目に `formatString` が含まれており、`args` 内の対応するオブジェクトが <xref:System.IFormattable> インターフェイスを実装している場合、`args[index].ToString(formatString, provider)` は書式設定を定義します。 それ以外の場合は、`args[index].ToString()` によって書式設定が定義されます。

 `format` に割り当てられた文字列が "{0: # # # #} の食料を慈善団体に寄付しようとしています" という内容の場合は、 また `arg0` は値が10の整数です。この戻り値は、"私たちの慈善団体に対して10人の食べ物を寄付したとしていただき、ありがとうございました" となります。



## Examples
 <xref:System.Text.StringBuilder.AppendFormat%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> または <paramref name="args" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。

- または -

書式項目のインデックスが 0 (ゼロ) 未満であるか、<paramref name="args" /> 配列の長さ以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">複合書式設定文字列。</param>
        <param name="arg0">書式指定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに追加します。 各書式指定項目は、指定された書式プロバイダーを使用して単一の引数の文字列形式に置換されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。 追加操作の完了後、このインスタンスには、操作前に存在していたデータの末尾に <paramref name="format" /> のコピーが付加されたものが含まれます。このコピーでは、書式指定が、<paramref name="arg0" /> の文字列形式に置換されています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、.NET Framework の[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して `arg0` の値をそのテキスト形式に変換し、その表現を現在の <xref:System.Text.StringBuilder> オブジェクトに埋め込みます。

 `format` パラメーターは、書式指定項目と呼ばれる0個以上のインデックス付きプレースホルダーと共に、0個以上のテキストの実行で構成されます。 各書式指定項目のインデックスはゼロ (0) である必要があります。このメソッドには1つの引数を持つ引数リストが含まれているためです。 書式設定のプロセスでは、各書式項目が `arg0`の文字列形式に置き換えられます。

 書式指定項目の構文は次のとおりです。

 {*index*[,*length*] [:*formatString*]}

 角かっこ内の要素は省略可能です。 次の表は、それぞれの要素の説明です。

|要素|説明|
|-------------|-----------------|
|*index*|書式設定するオブジェクトのパラメーターリスト内の0から始まる位置。 *Index*で指定されたオブジェクトが `null`場合、書式項目は <xref:System.String.Empty?displayProperty=nameWithType>に置き換えられます。 この場合、<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> メソッドの引数リストには1つの引数があるため、 *index*の値は常に0である必要があります。 そうでない場合は、<xref:System.FormatException> がスローされます。|
|、*length*|パラメーターの文字列形式の最小文字数。 正の場合、パラメーターは右上にあります。負の場合は、左揃えになります。|
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|

> [!NOTE]
>  日付と時刻の値と共に使用される標準およびカスタム書式指定文字列については、「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください。 数値で使用される標準およびカスタム書式指定文字列については、「[標準の数値書式](~/docs/standard/base-types/standard-numeric-format-strings.md)指定文字列」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。 列挙体で使用される標準書式指定文字列については、「[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)」を参照してください。

 `provider` パラメーターは `args`内のオブジェクトの書式設定情報を提供できる <xref:System.IFormatProvider> の実装を指定します。 `provider` は、次のいずれかになります。

-   カルチャ固有の書式情報を提供する <xref:System.Globalization.CultureInfo> オブジェクト。

-   数値の場合、`arg0` にカルチャ固有の書式情報を提供する <xref:System.Globalization.NumberFormatInfo> オブジェクト。

-   日付と時刻の値の場合に、`arg0` のカルチャ固有の書式情報を提供する <xref:System.Globalization.DateTimeFormatInfo> オブジェクト。

-   `arg0`の書式設定情報を提供するカスタム <xref:System.IFormatProvider> 実装。 通常、このような実装では、<xref:System.ICustomFormatter> インターフェイスも実装します。

 `provider` パラメーターが `null`場合、書式設定情報は現在のカルチャから取得されます。

 `arg0` は、書式設定するオブジェクトを表します。 `format` 内の各書式指定項目は、`arg0`の文字列形式に置き換えられます。 書式指定項目に `formatString` が含まれており、`arg0` <xref:System.IFormattable> インターフェイスが実装されている場合、`arg0.ToString(formatString, provider)` は書式設定を定義します。 それ以外の場合は、`arg0.ToString()` によって書式設定が定義されます。



## Examples
 <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> メソッドの2つの呼び出しを次に示します。 どちらも、英語版の英国 (en-us) カルチャの書式指定規則を使用します。 最初のは、<xref:System.Decimal> 値の通貨の文字列形式を結果の文字列に挿入します。 2番目の方法では、結果文字列の2つの場所に <xref:System.DateTime> 値が挿入されます。最初の位置には短い日付文字列と短い時刻文字列のみが含まれます。

 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。

- または -

書式項目のインデックスが 0 (ゼロ) より小さいか、または 1 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">方法 : カスタム数値書式プロバイダーを定義して使用する</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">複合書式設定文字列。</param>
        <param name="args">書式指定するオブジェクトの配列。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに追加します。 各書式項目は、指定された書式プロバイダーを使用した、パラメーター配列内の対応する引数の文字列形式に置換されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。 追加操作の完了後、このインスタンスには、操作前に存在していたデータの末尾に <paramref name="format" /> のコピーが付加されたものが含まれます。このコピーでは、書式指定が、対応するオブジェクト引数の文字列形式に置換されています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、.NET Framework の[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、オブジェクトの値をテキスト表現に変換し、その表現を現在の <xref:System.Text.StringBuilder> オブジェクトに埋め込みます。

 `format` パラメーターは、このメソッドのパラメーターリスト内のオブジェクトに対応する0個以上のインデックス付きプレースホルダー (書式項目と呼ばれます) と共に、0個以上のテキストの実行で構成されます。 書式設定のプロセスでは、各書式項目が対応するオブジェクトの文字列形式に置き換えられます。

 書式指定項目の構文は次のとおりです。

 {*index*[,*length*] [:*formatString*]}

 角かっこ内の要素は省略可能です。 次の表は、それぞれの要素の説明です。

|要素|説明|
|-------------|-----------------|
|*index*|書式設定するオブジェクトのパラメーターリスト内の0から始まる位置。 *Index*で指定されたオブジェクトが `null`場合、書式項目は <xref:System.String.Empty?displayProperty=nameWithType>に置き換えられます。 *インデックス*位置にパラメーターがない場合は、<xref:System.FormatException> がスローされます。|
|、*length*|パラメーターの文字列形式の最小文字数。 正の場合、パラメーターは右上にあります。負の場合は、左揃えになります。|
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|

> [!NOTE]
>  日付と時刻の値と共に使用される標準およびカスタム書式指定文字列については、「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください。 数値で使用される標準およびカスタム書式指定文字列については、「[標準の数値書式](~/docs/standard/base-types/standard-numeric-format-strings.md)指定文字列」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。 列挙体で使用される標準書式指定文字列については、「[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)」を参照してください。

 `provider` パラメーターは `args`内のオブジェクトの書式設定情報を提供できる <xref:System.IFormatProvider> の実装を指定します。 `provider` は、次のいずれかになります。

-   カルチャ固有の書式情報を提供する <xref:System.Globalization.CultureInfo> オブジェクト。

-   `args`の数値にカルチャ固有の書式情報を提供する <xref:System.Globalization.NumberFormatInfo> オブジェクト。

-   `args`の日付と時刻の値にカルチャ固有の書式情報を提供する <xref:System.Globalization.DateTimeFormatInfo> オブジェクト。

-   `args`内の1つ以上のオブジェクトの書式設定情報を提供するカスタム <xref:System.IFormatProvider> 実装。 通常、このような実装では、<xref:System.ICustomFormatter> インターフェイスも実装します。 次のセクションの2番目の例では、カスタム <xref:System.IFormatProvider> 実装を使用した <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> メソッド呼び出しについて説明します。

 `provider` パラメーターが `null`の場合、書式プロバイダー情報は現在のカルチャから取得されます。

 `args` は、書式設定するオブジェクトを表します。 `format` 内の各書式指定項目は、`args`内の対応するオブジェクトの文字列形式に置き換えられます。 書式指定項目に `formatString` が含まれており、`args` 内の対応するオブジェクトが <xref:System.IFormattable> インターフェイスを実装している場合、`args[index].ToString(formatString, provider)` は書式設定を定義します。 それ以外の場合は、`args[index].ToString()` によって書式設定が定義されます。



## Examples
 <xref:System.Text.StringBuilder.AppendFormat%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 次の例では、4桁と7桁のハイフンを使用して10桁の顧客番号を書式設定する `CustomerFormatter` という名前のカスタム <xref:System.IFormatProvider> 実装を定義します。 これは、書式設定された顧客番号と顧客名を含む文字列を作成するために、<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> メソッドに渡されます。

 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。

- または -

書式項目のインデックスが 0 (ゼロ) 未満であるか、<paramref name="args" /> 配列の長さ以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">方法 : カスタム数値書式プロバイダーを定義して使用する</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">複合書式設定文字列。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに追加します。 各書式項目は、2 つの引数のどちらかの文字列形式に置換されます。</summary>
        <returns><paramref name="format" /> が追加されたこのインスタンスへの参照。 <paramref name="format" /> の各書式項目は、対応するオブジェクト引数の文字列形式に置換されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、.NET Framework の[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、オブジェクトの値をテキスト表現に変換し、その表現を現在の <xref:System.Text.StringBuilder> オブジェクトに埋め込みます。

 `format` パラメーターは、このメソッドのパラメーターリストに含まれる2つのオブジェクトの `arg0` と `arg1`に対応する書式項目と呼ばれる0個以上のインデックス付きプレースホルダーと共に、0個以上のテキストの実行で構成されます。 書式設定のプロセスでは、各書式項目が対応するオブジェクトの文字列形式に置き換えられます。

 書式指定項目の構文は次のとおりです。

 {*index*[,*length*] [:*formatString*]}

 角かっこ内の要素は省略可能です。 次の表は、それぞれの要素の説明です。

|要素|説明|
|-------------|-----------------|
|*index*|書式設定するオブジェクトのパラメーターリスト内の0から始まる位置。 *Index*で指定されたオブジェクトが `null`場合、書式項目は <xref:System.String.Empty?displayProperty=nameWithType>に置き換えられます。 *インデックス*位置にパラメーターがない場合は、<xref:System.FormatException> がスローされます。|
|、*length*|パラメーターの文字列形式の最小文字数。 正の場合、パラメーターは右上にあります。負の場合は、左揃えになります。|
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|

> [!NOTE]
>  日付と時刻の値と共に使用される標準およびカスタム書式指定文字列については、「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください。 数値で使用される標準およびカスタム書式指定文字列については、「[標準の数値書式](~/docs/standard/base-types/standard-numeric-format-strings.md)指定文字列」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。 列挙体で使用される標準書式指定文字列については、「[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)」を参照してください。

 `arg0` と `arg1` は、書式設定するオブジェクトを表します。 `format` 内の各書式指定項目は、`arg0` または `arg1`の文字列形式に置き換えられます。 書式指定項目に `formatString` が含まれており、対応するオブジェクトが <xref:System.IFormattable> インターフェイスを実装している場合、`arg`*x*`.ToString(formatString, provider)` は書式を定義します。ここで、 *x*は引数のインデックスです。 それ以外の場合は、`arg`*x*`.ToString()` によって書式設定が定義されます。

 `format` に割り当てられた文字列が "{0: # # # #} の食料を慈善団体に寄付しようとしています" という内容の場合は、 また `arg0` は値が10の整数です。この戻り値は、"私たちの慈善団体に対して10人の食べ物を寄付したとしていただき、ありがとうございました" となります。



## Examples
 <xref:System.Text.StringBuilder.AppendFormat%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。

- または -

書式項目のインデックスが 0 (ゼロ) 未満か、または 2 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">複合書式設定文字列。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに追加します。 各書式項目は、指定された書式プロバイダーを使用して 2 つの引数のいずれかの文字列形式に置換されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。 追加操作の完了後、このインスタンスには、操作前に存在していたデータの末尾に <paramref name="format" /> のコピーが付加されたものが含まれます。このコピーでは、書式指定が、対応するオブジェクト引数の文字列形式に置換されています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、.NET Framework の[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、オブジェクトの値をテキスト表現に変換し、その表現を現在の <xref:System.Text.StringBuilder> オブジェクトに埋め込みます。

 `format` パラメーターは、このメソッドのパラメーターリスト内のオブジェクトに対応する0個以上のインデックス付きプレースホルダー (書式項目と呼ばれます) と共に、0個以上のテキストの実行で構成されます。 書式設定のプロセスでは、各書式項目が対応するオブジェクトの文字列形式に置き換えられます。

 書式指定項目の構文は次のとおりです。

 {*index*[,*length*] [:*formatString*]}

 角かっこ内の要素は省略可能です。 次の表は、それぞれの要素の説明です。

|要素|説明|
|-------------|-----------------|
|*index*|書式設定するオブジェクトのパラメーターリスト内の0から始まる位置。 *Index*で指定されたオブジェクトが `null`場合、書式項目は <xref:System.String.Empty?displayProperty=nameWithType>に置き換えられます。 *インデックス*位置にパラメーターがない場合は、<xref:System.FormatException> がスローされます。|
|、*length*|パラメーターの文字列形式の最小文字数。 正の場合、パラメーターは右上にあります。負の場合は、左揃えになります。|
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|

> [!NOTE]
>  日付と時刻の値と共に使用される標準およびカスタム書式指定文字列については、「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください。 数値で使用される標準およびカスタム書式指定文字列については、「[標準の数値書式](~/docs/standard/base-types/standard-numeric-format-strings.md)指定文字列」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。 列挙体で使用される標準書式指定文字列については、「[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)」を参照してください。

 `provider` パラメーターは、`arg0` と `arg1`の書式設定情報を提供できる <xref:System.IFormatProvider> の実装を指定します。 `provider` は、次のいずれかになります。

-   カルチャ固有の書式情報を提供する <xref:System.Globalization.CultureInfo> オブジェクト。

-   数値の場合、`arg0` または `arg1` にカルチャ固有の書式情報を提供する <xref:System.Globalization.NumberFormatInfo> オブジェクト。

-   日付と時刻の値の場合、`arg0` または `arg1` にカルチャ固有の書式情報を提供する <xref:System.Globalization.DateTimeFormatInfo> オブジェクト。

-   `arg0` および `arg1`の書式設定情報を提供するカスタム <xref:System.IFormatProvider> 実装。 通常、このような実装では、<xref:System.ICustomFormatter> インターフェイスも実装します。

 `provider` パラメーターが `null`の場合、書式プロバイダー情報は現在のカルチャから取得されます。

 `arg0` と `arg1` は、書式設定するオブジェクトを表します。 `format` 内の各書式指定項目は、対応するインデックスを持つオブジェクトの文字列形式に置き換えられます。 書式指定項目に `formatString` が含まれていて、対応する引数が <xref:System.IFormattable> インターフェイスを実装している場合は、引数の `ToString(formatString, provider)` メソッドによって書式設定が定義されます。 それ以外の場合は、引数の `ToString()` メソッドによって書式設定が定義されます。



## Examples
 次の例では、<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> メソッドを使用して、ジェネリック <xref:System.Collections.Generic.Dictionary%602> オブジェクトに格納されている時間と気温のデータを表示します。 書式指定文字列には、書式設定するオブジェクトだけではなく、3つの書式項目があることに注意してください。 これは、リスト内の最初のオブジェクト (日付と時刻の値) が2つの書式指定項目によって使用されるためです。最初の書式項目は時刻を表示し、2番目のオブジェクトは日付を表示します。

 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。

- または -

書式項目のインデックスが 0 (ゼロ) 未満か、または 2 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>プロファイリング .NET Core と .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超える可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">方法 : カスタム数値書式プロバイダーを定義して使用する</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">複合書式設定文字列。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <param name="arg2">3 番目に書式設定するオブジェクト。3 番目に書式設定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに追加します。 各書式項目は、3 つの引数のいずれかの文字列形式に置換されます。</summary>
        <returns><paramref name="format" /> が追加されたこのインスタンスへの参照。 <paramref name="format" /> の各書式項目は、対応するオブジェクト引数の文字列形式に置換されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、.NET Framework の[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、オブジェクトの値をテキスト表現に変換し、その表現を現在の <xref:System.Text.StringBuilder> オブジェクトに埋め込みます。

 `format` パラメーターは、書式指定項目と呼ばれる0個以上のインデックス付きプレースホルダーと共に、0個以上のテキストの実行で構成されます。これは、このメソッドのパラメーターリスト内のオブジェクト `arg2`によって `arg0` に対応します。 書式設定のプロセスでは、各書式項目が対応するオブジェクトの文字列形式に置き換えられます。

 書式指定項目の構文は次のとおりです。

 {*index*[,*length*] [:*formatString*]}

 角かっこ内の要素は省略可能です。 次の表は、それぞれの要素の説明です。

|要素|説明|
|-------------|-----------------|
|*index*|書式設定するオブジェクトのパラメーターリスト内の0から始まる位置。 *Index*で指定されたオブジェクトが `null`場合、書式項目は <xref:System.String.Empty?displayProperty=nameWithType>に置き換えられます。 *インデックス*位置にパラメーターがない場合は、<xref:System.FormatException> がスローされます。|
|、*length*|パラメーターの文字列形式の最小文字数。 正の場合、パラメーターは右上にあります。負の場合は、左揃えになります。|
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|

> [!NOTE]
>  日付と時刻の値と共に使用される標準およびカスタム書式指定文字列については、「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください。 数値で使用される標準およびカスタム書式指定文字列については、「[標準の数値書式](~/docs/standard/base-types/standard-numeric-format-strings.md)指定文字列」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。 列挙体で使用される標準書式指定文字列については、「[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)」を参照してください。

 `arg0`、`arg1`、および `arg2` は、書式設定するオブジェクトを表します。 `format` の各書式指定項目は、書式項目のインデックスに応じて、`arg0`、`arg1`、または `arg2`のいずれかの文字列形式に置き換えられます。 書式指定項目に `formatString` が含まれており、`args` 内の対応するオブジェクトが <xref:System.IFormattable> インターフェイスを実装している場合、`arg`*x*`.ToString(formatString, null)` は書式を定義します。ここで、 *x*は引数のインデックスです。 それ以外の場合は、`arg`*x*`.ToString()` によって書式設定が定義されます。

 `format` に割り当てられた文字列が "{0: # # # #} の食料を慈善団体に寄付しようとしています" という内容の場合は、 また `arg0` は値が10の整数です。この戻り値は、"私たちの慈善団体に対して10人の食べ物を寄付したとしていただき、ありがとうございました" となります。



## Examples
 <xref:System.Text.StringBuilder.AppendFormat%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。

- または -

書式項目のインデックスが 0 (ゼロ) 未満か、または 3 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">カルチャ固有の書式情報を提供するオブジェクト。</param>
        <param name="format">複合書式設定文字列。</param>
        <param name="arg0">1 番目に書式設定するオブジェクト。</param>
        <param name="arg1">2 番目に書式設定するオブジェクト。</param>
        <param name="arg2">3 番目に書式設定するオブジェクト。3 番目に書式設定するオブジェクト。</param>
        <summary>0 個以上の書式項目を含んでいる複合書式指定文字列を処理することで返される文字列を、このインスタンスに追加します。 各書式項目は、指定された書式プロバイダーを使用して 3 つの引数のいずれかの文字列形式に置換されます。各書式項目は、指定された書式プロバイダーを使用して 3 つの引数のいずれかの文字列形式に置換されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。 追加操作の完了後、このインスタンスには、操作前に存在していたデータの末尾に <paramref name="format" /> のコピーが付加されたものが含まれます。このコピーでは、書式指定が、対応するオブジェクト引数の文字列形式に置換されています。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、.NET Framework の[複合書式指定機能](~/docs/standard/base-types/composite-formatting.md)を使用して、オブジェクトの値をテキスト表現に変換し、その表現を現在の <xref:System.Text.StringBuilder> オブジェクトに埋め込みます。

 `format` パラメーターは、このメソッドのパラメーターリスト内のオブジェクトに対応する0個以上のインデックス付きプレースホルダー (書式項目と呼ばれます) と共に、0個以上のテキストの実行で構成されます。 書式設定のプロセスでは、各書式項目が対応するオブジェクトの文字列形式に置き換えられます。

 書式指定項目の構文は次のとおりです。

 {*index*[,*length*] [:*formatString*]}

 角かっこ内の要素は省略可能です。 次の表は、それぞれの要素の説明です。

|要素|説明|
|-------------|-----------------|
|*index*|書式設定するオブジェクトのパラメーターリスト内の0から始まる位置。 *Index*で指定されたオブジェクトが `null`場合、書式項目は <xref:System.String.Empty?displayProperty=nameWithType>に置き換えられます。 *インデックス*位置にパラメーターがない場合は、<xref:System.FormatException> がスローされます。|
|、*length*|パラメーターの文字列形式の最小文字数。 正の場合、パラメーターは右上にあります。負の場合は、左揃えになります。|
|:*formatString*|パラメーターでサポートされている標準またはカスタムの書式指定文字列。|

> [!NOTE]
>  日付と時刻の値と共に使用される標準およびカスタム書式指定文字列については、「[標準の日付と時刻の書式指定文字列](~/docs/standard/base-types/standard-date-and-time-format-strings.md)」および「[カスタム日時書式指定文字列](~/docs/standard/base-types/custom-date-and-time-format-strings.md)」を参照してください。 数値で使用される標準およびカスタム書式指定文字列については、「[標準の数値書式](~/docs/standard/base-types/standard-numeric-format-strings.md)指定文字列」および「[カスタム数値書式指定文字列](~/docs/standard/base-types/custom-numeric-format-strings.md)」を参照してください。 列挙体で使用される標準書式指定文字列については、「[列挙型書式指定文字列](~/docs/standard/base-types/enumeration-format-strings.md)」を参照してください。

 `provider` パラメーターは、`arg0` と `arg1`の書式設定情報を提供できる <xref:System.IFormatProvider> の実装を指定します。 `provider` は、次のいずれかになります。

-   カルチャ固有の書式情報を提供する <xref:System.Globalization.CultureInfo> オブジェクト。

-   数値の場合、`arg0` または `arg1` にカルチャ固有の書式情報を提供する <xref:System.Globalization.NumberFormatInfo> オブジェクト。

-   `arg0`、`arg1`、または `arg2` の日付と時刻の値である場合に、カルチャ固有の書式情報を提供する <xref:System.Globalization.DateTimeFormatInfo> オブジェクト。

-   `arg0`、`arg1`、および `arg2`の書式設定情報を提供するカスタム <xref:System.IFormatProvider> 実装。 通常、このような実装では、<xref:System.ICustomFormatter> インターフェイスも実装します。

 `provider` パラメーターが `null`の場合、書式プロバイダー情報は現在のカルチャから取得されます。

 `arg0`、`arg1`、および `arg2` は、書式設定するオブジェクトを表します。 `format` 内の各書式指定項目は、対応するインデックスを持つオブジェクトの文字列形式に置き換えられます。 書式指定項目に `formatString` が含まれていて、対応する引数が <xref:System.IFormattable> インターフェイスを実装している場合は、引数の `ToString(formatString, provider)` メソッドによって書式設定が定義されます。 それ以外の場合は、引数の `ToString()` メソッドによって書式設定が定義されます。



## Examples
 次の例では、<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> メソッドを使用して、整数値を持つブール `And` 演算の結果を示します。 書式指定文字列には6つの書式項目が含まれていますが、各項目は2つの異なる方法で書式設定されるため、メソッドの引数リストには3つの項目しかありません。

 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> が無効です。

- または -

書式項目のインデックスが 0 (ゼロ) 未満か、3 以上です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">拡張された文字列の長さが <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">.NET での型の書式設定</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">複合書式指定</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">方法 : カスタム数値書式プロバイダーを定義して使用する</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">標準の数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">カスタム数値形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">標準の日時形式文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">カスタム日時書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">標準 TimeSpan 書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">カスタム時間間隔書式指定文字列</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">列挙型書式指定文字列</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字。 <paramref name="separator" /> が 2 つ以上の要素を含む場合のみ、結合された文字列に <paramref name="values" /> は含まれます。</param>
        <param name="values">連結して文字列ビルダーの現在のインスタンスに追加する文字列が格納されている配列。</param>
        <summary>指定したオブジェクト配列内の要素の文字列表現を連結します。各メンバー間には、指定した区切り文字が使用され、その結果は文字列ビルダーの現在のインスタンスに追加されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字。 <paramref name="separator" /> が 2 つ以上の要素を含む場合のみ、結合された文字列に <paramref name="values" /> は含まれます。</param>
        <param name="values">連結して文字列ビルダーの現在のインスタンスに追加する文字列が格納されている配列。</param>
        <summary>指定した配列の文字列を連結します。各文字列間には、指定した区切り文字が使用され、その結果は文字列ビルダーの現在のインスタンスに追加されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。 <paramref name="separator" /> が 2 つ以上の要素を含む場合のみ、結合された文字列に <paramref name="values" /> は含まれます。</param>
        <param name="values">連結して文字列ビルダーの現在のインスタンスに追加する文字列が格納されている配列。</param>
        <summary>指定したオブジェクト配列内の要素の文字列表現を連結します。各メンバー間には、指定した区切り記号が使用され、その結果は文字列ビルダーの現在のインスタンスに追加されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">区切り記号として使用する文字列。 <paramref name="separator" /> が 2 つ以上の要素を含む場合のみ、結合された文字列に <paramref name="values" /> は含まれます。</param>
        <param name="values">連結して文字列ビルダーの現在のインスタンスに追加する文字列が格納されている配列。</param>
        <summary>指定した配列の文字列を連結します。各文字列間には、指定した区切り記号が使用され、その結果は文字列ビルダーの現在のインスタンスに追加されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="values" /> のメンバーの型。</typeparam>
        <param name="separator">区切り記号として使用する文字。 <paramref name="separator" /> が 2 つ以上の要素を含む場合のみ、連結および追加された文字列に <paramref name="values" /> は含まれます。</param>
        <param name="values">連結して文字列ビルダーの現在のインスタンスに追加するオブジェクトが格納されているコレクション。</param>
        <summary>コレクションのメンバーを連結および追加します。各メンバー間には、指定した区切り文字が使用されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T"><paramref name="values" /> のメンバーの型。</typeparam>
        <param name="separator">区切り記号として使用する文字列。 <paramref name="separator" /> が 2 つ以上の要素を含む場合のみ、連結および追加された文字列に <paramref name="values" /> は含まれます。</param>
        <param name="values">連結して文字列ビルダーの現在のインスタンスに追加するオブジェクトが格納されているコレクション。</param>
        <summary>コレクションのメンバーを連結および追加します。各メンバー間には、指定した区切り記号が使用されます。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既定の行終端記号、または指定した文字列のコピーと既定の行終端記号を、このインスタンスの末尾に追加します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定の行終端記号を現在の <see cref="T:System.Text.StringBuilder" /> オブジェクトの末尾に追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 既定の行終端記号は、<xref:System.Environment.NewLine%2A?displayProperty=nameWithType> プロパティの現在の値です。

 このインスタンスの容量は、必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.AppendLine%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">追加する文字列。</param>
        <summary>指定した文字列のコピーと既定の行終端記号を、現在の <see cref="T:System.Text.StringBuilder" /> オブジェクトの末尾に追加します。</summary>
        <returns>追加操作が完了した後のこのインスタンスへの参照。追加操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 既定の行終端記号は、<xref:System.Environment.NewLine%2A?displayProperty=nameWithType> プロパティの現在の値です。

 このインスタンスの容量は、必要に応じて調整されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>.NET Core および .NET Framework 4.0 以降のバージョンでは、<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> コンストラクターを呼び出すことによって <see cref="T:System.Text.StringBuilder" /> オブジェクトをインスタンス化すると、<see cref="T:System.Text.StringBuilder" /> インスタンスの長さと容量の両方が、その <see cref="P:System.Text.StringBuilder.MaxCapacity" /> プロパティの値を超えて拡張される可能性があります。 これは、<see cref="M:System.Text.StringBuilder.Append(System.String)" /> と <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のインスタンスによって割り当てられたメモリに格納できる最大文字数を取得または設定します。</summary>
        <value>現在のインスタンスによって割り当てられたメモリに格納できる最大文字数。 この値の範囲は <see cref="P:System.Text.StringBuilder.Length" /> ～ <see cref="P:System.Text.StringBuilder.MaxCapacity" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.Capacity%2A> は、現在のインスタンスの文字列値には影響しません。 <xref:System.Text.StringBuilder.Capacity%2A> が <xref:System.Text.StringBuilder.Length%2A>未満である限り、減らすことができます。

 <xref:System.Text.StringBuilder> は、必要なときにより多くの領域を動的に割り当て、それに応じて <xref:System.Text.StringBuilder.Capacity%2A> を増やします。 パフォーマンス上の理由から、<xref:System.Text.StringBuilder> では必要以上に多くのメモリが割り当てられる可能性があります。 割り当てられるメモリの量は、実装固有です。



## Examples
 <xref:System.Text.StringBuilder.Capacity%2A>プロパティの例を次に示します。

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作に指定された値は、このインスタンスの現在の長さより小さい値です。

 - または -

 設定操作に指定された値は、最大容量を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">文字の位置。</param>
        <summary>このインスタンス内の指定した文字位置の文字を取得または設定します。</summary>
        <value><paramref name="index" /> 位置の Unicode 文字。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `index` パラメーターは、<xref:System.Text.StringBuilder>内の文字の位置です。 文字列の最初の文字は、インデックス0の位置にあります。 文字列の長さは、文字列に含まれる文字数です。 <xref:System.Text.StringBuilder> インスタンスの最後にアクセスできる文字は、インデックス <xref:System.Text.StringBuilder.Length%2A>-1 です。

 <xref:System.Text.StringBuilder.Chars%2A> は、<xref:System.Text.StringBuilder> クラスの既定のプロパティです。 でC#は、これはインデクサーです。 これは、次の例に示すように、<xref:System.Text.StringBuilder.Chars%2A> プロパティから個々の文字を取得できることを意味します。この例では、文字列内の英字、空白、および句読点の数をカウントします。

 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]

### <a name="performance-and-character-based-indexing"></a>パフォーマンスと文字ベースのインデックス作成

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">文字の設定において、<paramref name="index" /> がこのインスタンスの境界外です。</exception>
        <exception cref="T:System.IndexOutOfRangeException">文字の取得において、<paramref name="index" /> がこのインスタンスの境界外です。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Text.StringBuilder" /> インスタンスからすべての文字を削除します。</summary>
        <returns><see cref="P:System.Text.StringBuilder.Length" /> が 0 (ゼロ) であるオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<xref:System.Text.StringBuilder.Clear%2A> は、現在のインスタンスの <xref:System.Text.StringBuilder.Length%2A> プロパティを 0 (ゼロ) に設定するのと同じ便利な方法です。

## Examples

次の例では、文字列を使用して <xref:System.Text.StringBuilder> オブジェクトをインスタンス化し、<xref:System.Text.StringBuilder.Clear%2A> メソッドを呼び出して、新しい文字列を追加します。

[!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
[!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">このインスタンスにおける文字のコピーの開始位置。 インデックスの値は、0 から始まります。</param>
        <param name="destination">文字のコピー先となる書き込み可能なスパン。</param>
        <param name="count">コピーする文字数。</param>
        <summary>文字をこのインスタンスの指定したセグメントから目的の <see cref="T:System.Char" /> のスパンにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.CopyTo%2A> メソッドは、<xref:System.Text.StringBuilder> オブジェクトの連続するセクションをスパンに効率的にコピーする必要があるまれな状況で使用することを目的としています。

 たとえば、アプリケーションで大量の文字を含む <xref:System.Text.StringBuilder> オブジェクトを設定した後、<xref:System.Text.StringBuilder.CopyTo%2A> メソッドを使用して、<xref:System.Text.StringBuilder> オブジェクトの小さい部分を、その部分が処理されるスパンにコピーできます。 <xref:System.Text.StringBuilder> オブジェクト内のすべてのデータが処理されると、<xref:System.Text.StringBuilder> オブジェクトのサイズが0に設定され、サイクルが繰り返されます。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.Char[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">このインスタンスにおける文字のコピーの開始位置。 インデックスの値は、0 から始まります。</param>
        <param name="destination">文字のコピー先となる配列。</param>
        <param name="destinationIndex"><paramref name="destination" /> における文字のコピーの開始位置。 インデックスの値は、0 から始まります。</param>
        <param name="count">コピーする文字数。</param>
        <summary>このインスタンスの指定したセグメントにある文字を、目的の <see cref="T:System.Char" /> 配列の指定したセグメントにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder.CopyTo%2A> メソッドは、<xref:System.Text.StringBuilder> オブジェクトの連続するセクションを配列に効率的にコピーする必要があるまれな状況で使用することを目的としています。 配列は固定サイズ、事前に割り当てられ、再利用可能で、場合によってはグローバルにアクセス可能である必要があります。

 たとえば、アプリケーションで多数の文字を含む <xref:System.Text.StringBuilder> オブジェクトを設定した後、<xref:System.Text.StringBuilder.CopyTo%2A> メソッドを使用して、<xref:System.Text.StringBuilder> オブジェクトの小さい部分を、その部分が処理される配列にコピーできます。 <xref:System.Text.StringBuilder> オブジェクト内のすべてのデータが処理されると、<xref:System.Text.StringBuilder> オブジェクトのサイズが0に設定され、サイクルが繰り返されます。



## Examples
 <xref:System.Text.StringBuilder.CopyTo%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />、<paramref name="destinationIndex" /> または <paramref name="count" /> が 0 より小さい値です。

- または -

 <paramref name="sourceIndex" /> はこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> + <paramref name="count" /> がこのインスタンスの長さを超えています。

- または -

 <paramref name="destinationIndex" /> + <paramref name="count" /> が <paramref name="destination" /> の長さを超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">必要な最小容量。</param>
        <summary>このインスタンスの <see cref="T:System.Text.StringBuilder" /> の容量が、指定した値以上になるようにします。</summary>
        <returns>このインスタンスの新しい容量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 現在の容量が `capacity` パラメーターよりも小さい場合、このインスタンスのメモリは少なくとも `capacity` の文字数を保持するように再割り当てされます。それ以外の場合、メモリは変更されません。



## Examples
 <xref:System.Text.StringBuilder.EnsureCapacity%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> が 0 未満です。

- または -

このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="span">現在のインスタンスと比較する文字範囲。</param>
        <summary>このインスタンスの文字が、指定された読み取り専用の文字範囲内の文字と同じであるかどうかを示す値を返します。</summary>
        <returns>このインスタンスの文字と <paramref name="span" /> が同じである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

`Equals` メソッドは、序数に基づく比較を実行して、現在のインスタンスと `span` の文字が等しいかどうかを判断します。

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">対象のインスタンスと比較する対象のオブジェクト、または <see langword="null" />。</param>
        <summary>このインスタンスが指定されたオブジェクトに等しいかどうかを示す値を返します。</summary>
        <returns>このインスタンスと <paramref name="sb" /> が同じ文字列、<see cref="P:System.Text.StringBuilder.Capacity" /> 値、および <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 値を保持している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

**.NET Framework および .Net Core 2.2 以前のバージョン:** 現在のインスタンスと `sb` は、文字列、<xref:System.Text.StringBuilder.Capacity>、および <xref:System.Text.StringBuilder.MaxCapacity> 値が等しい場合に等しいと見なされます。 `Equals` メソッドは、序数に基づく比較を使用して、文字列が等しいかどうかを判断します。

**.Net Core 3.0 以降のバージョン:** 現在のインスタンスと `sb` は、両方の <xref:System.Text.StringBuilder> オブジェクトに割り当てられた文字列が同じである場合に等しくなります。  等しいかどうかを判断するために、`Equals` メソッドでは序数による比較を使用します。 <xref:System.Text.StringBuilder.Capacity> と <xref:System.Text.StringBuilder.MaxCapacity> のプロパティ値は、比較では使用されません。

## Examples
 次のコードでは、<xref:System.Text.StringBuilder.Equals%2A> メソッドを使用して、2つの <xref:System.Text.StringBuilder> オブジェクトが等しいかどうかを確認します。 各オブジェクトに小さな変更が加えられると、メソッドが繰り返し呼び出され、結果がコンソールに表示されます。

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChunks">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder.ChunkEnumerator GetChunks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringBuilder/ChunkEnumerator GetChunks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.GetChunks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChunks () As StringBuilder.ChunkEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder::ChunkEnumerator GetChunks();" />
      <MemberSignature Language="F#" Value="member this.GetChunks : unit -&gt; System.Text.StringBuilder.ChunkEnumerator" Usage="stringBuilder.GetChunks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder+ChunkEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Text.StringBuilder" /> インスタンスから作成された <see langword="ReadOnlyMemory&lt;Char&gt;" /> で表される文字のチャンクを反復処理する目的で利用できるオブジェクトを返します。</summary>
        <returns><see langword="ReadOnlyMemory&lt;Char&gt;" /> のチャンクの列挙子。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

次のようなコードを使用して、メモリ範囲内のチャンクを反復処理できます。

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
    foreach(char ch in chunk.Span)
        { /* operations on ch */ }
```

このメソッドの目的は、*定数*<xref:System.Text.StringBuilder>のデータを効率的に抽出することです。 チャンクの列挙が不完全なときに <xref:System.Text.StringBuilder> が変更された場合、結果は未定義になります。 <xref:System.Text.StringBuilder> もスレッドセーフではないため、同時実行スレッドでの操作は無効です。

返された <xref:System.ReadOnlyMemory%601> チャンクは、<xref:System.Text.StringBuilder> が変更されても変更されないとは限りません。そのため、後で使用できるようにキャッシュしないでください。

前の例の <xref:System.ReadOnlyMemory%601.Span?displayProperty=nameWithType> メソッドと同様に <xref:System.ReadOnlyMemory%601> から <xref:System.ReadOnlySpan%601> を作成すると、コストが高くなります。そのため、入れ子になった `for` ステートメントで使用する必要がある場合は、スパンのローカル変数を作成します。 次に例を示します。

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
{
    var span = chunk.Span;
    for(int i = 0; i < span.Length; i++)
    {
        /* operations on span[i] */
    }
}
```

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定されたオブジェクトの文字列表記をこのインスタンスの指定された文字位置に挿入します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>Boolean 値の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> は、`value`の文字列表現を取得するために使用されます。 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 容量は必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 以前のバージョンでは、<paramref name="value" /> を挿入するとオブジェクトの合計長が <see cref="P:System.Text.StringBuilder.MaxCapacity" />を超える場合、このメソッドの呼び出しによって <see cref="T:System.ArgumentOutOfRangeException" /> がスローされました。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、メソッドによって <see cref="T:System.OutOfMemoryException" />がスローされます。</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した 8 ビット符号なし整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> は、`value`の文字列表現を取得するために使用されます。 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 以前のバージョンでは、<paramref name="value" /> を挿入するとオブジェクトの合計長が <see cref="P:System.Text.StringBuilder.MaxCapacity" />を超える場合、このメソッドの呼び出しによって <see cref="T:System.ArgumentOutOfRangeException" /> がスローされました。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、メソッドによって <see cref="T:System.OutOfMemoryException" />がスローされます。</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した Unicode 文字の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> は、`value`の文字列表現を取得するために使用されます。 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。

- または -

このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する文字配列。</param>
        <summary>指定した Unicode 文字の配列の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。

 `value` が `null`場合、<xref:System.Text.StringBuilder> は変更されません。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。

- または -

このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>10 進数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> は、`value`の文字列表現を取得するために使用されます。 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 以前のバージョンでは、<paramref name="value" /> を挿入するとオブジェクトの合計長が <see cref="P:System.Text.StringBuilder.MaxCapacity" />を超える場合、このメソッドの呼び出しによって <see cref="T:System.ArgumentOutOfRangeException" /> がスローされました。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、メソッドによって <see cref="T:System.OutOfMemoryException" />がスローされます。</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>倍精度浮動小数点数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> は、`value`の文字列表現を取得するために使用されます。 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 以前のバージョンでは、<paramref name="value" /> を挿入するとオブジェクトの合計長が <see cref="P:System.Text.StringBuilder.MaxCapacity" />を超える場合、このメソッドの呼び出しによって <see cref="T:System.ArgumentOutOfRangeException" /> がスローされました。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、メソッドによって <see cref="T:System.OutOfMemoryException" />がスローされます。</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した 16 ビット符号付き整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> は、`value`の文字列表現を取得するために使用されます。 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 以前のバージョンでは、<paramref name="value" /> を挿入するとオブジェクトの合計長が <see cref="P:System.Text.StringBuilder.MaxCapacity" />を超える場合、このメソッドの呼び出しによって <see cref="T:System.ArgumentOutOfRangeException" /> がスローされました。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、メソッドによって <see cref="T:System.OutOfMemoryException" />がスローされます。</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した 32 ビット符号付き整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> は、`value`の文字列表現を取得するために使用されます。 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 以前のバージョンでは、<paramref name="value" /> を挿入するとオブジェクトの合計長が <see cref="P:System.Text.StringBuilder.MaxCapacity" />を超える場合、このメソッドの呼び出しによって <see cref="T:System.ArgumentOutOfRangeException" /> がスローされました。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、メソッドによって <see cref="T:System.OutOfMemoryException" />がスローされます。</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>64 ビット符号付き整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> は、`value`の文字列表現を取得するために使用されます。 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 以前のバージョンでは、<paramref name="value" /> を挿入するとオブジェクトの合計長が <see cref="P:System.Text.StringBuilder.MaxCapacity" />を超える場合、このメソッドの呼び出しによって <see cref="T:System.ArgumentOutOfRangeException" /> がスローされました。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、メソッドによって <see cref="T:System.OutOfMemoryException" />がスローされます。</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入するオブジェクト、または <see langword="null" />。</param>
        <summary>オブジェクトの文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> は、`value`の文字列表現を取得するために使用されます。 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。

 `value` が `null`場合、このインスタンスの値は変更されません。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 以前のバージョンでは、<paramref name="value" /> を挿入するとオブジェクトの合計長が <see cref="P:System.Text.StringBuilder.MaxCapacity" />を超える場合、このメソッドの呼び出しによって <see cref="T:System.ArgumentOutOfRangeException" /> がスローされました。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、メソッドによって <see cref="T:System.OutOfMemoryException" />がスローされます。</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する文字スパン。</param>
        <summary>文字のシーケンスをこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

既存の文字をシフトして、`value` 内の文字シーケンスを挿入するための領域を確保します。 容量は必要に応じて調整されます。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>指定した 8 ビット符号付き整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> は、`value`の文字列表現を取得するために使用されます。 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 容量は必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 以前のバージョンでは、<paramref name="value" /> を挿入するとオブジェクトの合計長が <see cref="P:System.Text.StringBuilder.MaxCapacity" />を超える場合、このメソッドの呼び出しによって <see cref="T:System.ArgumentOutOfRangeException" /> がスローされました。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、メソッドによって <see cref="T:System.OutOfMemoryException" />がスローされます。</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>単精度浮動小数点数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> は、`value`の文字列表現を取得するために使用されます。 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 以前のバージョンでは、<paramref name="value" /> を挿入するとオブジェクトの合計長が <see cref="P:System.Text.StringBuilder.MaxCapacity" />を超える場合、このメソッドの呼び出しによって <see cref="T:System.ArgumentOutOfRangeException" /> がスローされました。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、メソッドによって <see cref="T:System.OutOfMemoryException" />がスローされます。</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する文字列。</param>
        <summary>文字列をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 容量は必要に応じて調整されます。

 `value` が `null`の場合、または `value` が `null` ではなく長さが0の場合、この <xref:System.Text.StringBuilder> のインスタンスは変更されません。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの現在の長さを超えています。

- または -

この <see cref="T:System.Text.StringBuilder" /> オブジェクトの現在の長さに <paramref name="value" /> の長さを加算した結果が、<see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えています。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>16 ビット符号なし整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> は、`value`の文字列表現を取得するために使用されます。 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 以前のバージョンでは、<paramref name="value" /> を挿入するとオブジェクトの合計長が <see cref="P:System.Text.StringBuilder.MaxCapacity" />を超える場合、このメソッドの呼び出しによって <see cref="T:System.ArgumentOutOfRangeException" /> がスローされました。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、メソッドによって <see cref="T:System.OutOfMemoryException" />がスローされます。</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>32 ビット符号なし整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> は、`value`の文字列表現を取得するために使用されます。 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 以前のバージョンでは、<paramref name="value" /> を挿入するとオブジェクトの合計長が <see cref="P:System.Text.StringBuilder.MaxCapacity" />を超える場合、このメソッドの呼び出しによって <see cref="T:System.ArgumentOutOfRangeException" /> がスローされました。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、メソッドによって <see cref="T:System.OutOfMemoryException" />がスローされます。</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する値。</param>
        <summary>64 ビット符号なし整数の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> は、`value`の文字列表現を取得するために使用されます。 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの長さを超えています。</exception>
        <exception cref="T:System.OutOfMemoryException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <block subset="none" type="usage"><para>[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 以前のバージョンでは、<paramref name="value" /> を挿入するとオブジェクトの合計長が <see cref="P:System.Text.StringBuilder.MaxCapacity" />を超える場合、このメソッドの呼び出しによって <see cref="T:System.ArgumentOutOfRangeException" /> がスローされました。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]以降では、メソッドによって <see cref="T:System.OutOfMemoryException" />がスローされます。</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">挿入する文字列。</param>
        <param name="count"><paramref name="value" /> を挿入する回数。</param>
        <summary>指定した文字列の 1 つ以上のコピーをこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。

 この <xref:System.Text.StringBuilder> オブジェクトは、`value` が `null`、`value` が `null` ではなく、長さが0である、または `count` が0の場合は変更されません。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> が、0 未満か、またはこのインスタンスの現在の長さを超えています。

- または -

 <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.OutOfMemoryException">この <see cref="T:System.Text.StringBuilder" /> オブジェクトの現在の長さに <paramref name="value" /> の長さを <paramref name="count" /> 倍した値を加算した結果が、<see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えています。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">このインスタンスにおける挿入の開始位置。</param>
        <param name="value">文字配列。</param>
        <param name="startIndex"><paramref name="value" /> 内の開始インデックス。</param>
        <param name="charCount">挿入する文字数。</param>
        <summary>Unicode 文字の指定した部分配列の文字列形式をこのインスタンスの指定した文字位置に挿入します。</summary>
        <returns>挿入操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 新しいテキスト用の領域を確保するために、既存の文字がシフトされます。 このインスタンスの容量は、必要に応じて調整されます。



## Examples
 <xref:System.Text.StringBuilder.Insert%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> が <see langword="null" /> で、<paramref name="startIndex" /> と <paramref name="charCount" /> が 0 ではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />、<paramref name="startIndex" />、または <paramref name="charCount" /> が 0 未満です。

- または -

 <paramref name="index" /> はこのインスタンスの長さを超えています。

- または -

 <paramref name="startIndex" /> に <paramref name="charCount" /> を加算した値が <paramref name="value" /> 内の位置にありません。

- または -

このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Text.StringBuilder" /> オブジェクトの長さを取得または設定します。</summary>
        <value>このインスタンスの長さ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder> オブジェクトの長さは、<xref:System.Char> オブジェクトの数によって定義されます。

 <xref:System.String.Length%2A?displayProperty=nameWithType> プロパティと同様に、<xref:System.Text.StringBuilder.Length%2A> プロパティは、現在の文字列オブジェクトの長さを示します。 読み取り専用の <xref:System.String.Length%2A?displayProperty=nameWithType> プロパティとは異なり、<xref:System.Text.StringBuilder.Length%2A> プロパティを使用すると、<xref:System.Text.StringBuilder> オブジェクトに格納されている文字列の長さを変更できます。

 指定した長さが現在の長さよりも小さい場合は、現在の <xref:System.Text.StringBuilder> オブジェクトが、指定された長さに切り詰められます。 指定された長さが現在の長さよりも大きい場合、現在の <xref:System.Text.StringBuilder> オブジェクトの文字列値の末尾に、Unicode の NULL 文字 (U + 0000) が埋め込まれます。

 指定された長さが現在の容量を超えている場合は、指定された長さ以上になるように <xref:System.Text.StringBuilder.Capacity%2A> が増加します。



## Examples
 <xref:System.Text.StringBuilder.Length%2A>プロパティの例を次に示します。

 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作で指定された値は、0 より小さい値か、<see cref="P:System.Text.StringBuilder.MaxCapacity" /> より大きい値になります。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このインスタンスの最大容量を取得します。</summary>
        <value>このインスタンスが保持できる最大文字数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 この実装の最大容量は <xref:System.Int32.MaxValue?displayProperty=nameWithType>です。 ただし、この値は実装固有であり、その他の実装では異なる場合があります。 <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> コンストラクターを呼び出すことによって、<xref:System.Text.StringBuilder> オブジェクトの最大容量を明示的に設定できます。

.NET Core および .NET Framework 4.0 以降のバージョンでは、<xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)> コンストラクターを呼び出すことによって <xref:System.Text.StringBuilder> オブジェクトをインスタンス化すると、<xref:System.Text.StringBuilder> インスタンスの長さと容量の両方が、その <xref:System.Text.StringBuilder.MaxCapacity> プロパティの値を超えて拡張される可能性があります。 これは、<xref:System.Text.StringBuilder.Append(System.String)> と <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> メソッドを呼び出して小さい文字列を追加する場合に特に発生します。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンスにおける 0 から始まる削除の開始位置。</param>
        <param name="length">削除する文字数。</param>
        <summary>このインスタンスから、指定した範囲の文字を削除します。</summary>
        <returns>削除操作が完了した後のこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 現在のメソッドは、現在のインスタンスから指定された範囲の文字を削除します。 (`startIndex` + `length`) の文字は `startIndex`に移動され、現在のインスタンスの文字列値は `length`によって短縮されます。 現在のインスタンスの容量は影響を受けません。

> [!NOTE]
>  <xref:System.Text.StringBuilder.Remove%2A> メソッドは、現在の <xref:System.Text.StringBuilder> インスタンスの値を変更し、そのインスタンスを返します。 新しい <xref:System.Text.StringBuilder> オブジェクトは作成されず、返されません。



## Examples
 <xref:System.Text.StringBuilder.Remove%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="length" /> が 0 未満か、<paramref name="startIndex" /> + <paramref name="length" /> がこのインスタンスの長さを超えています。</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスに出現する指定文字または指定文字列をすべて、別に指定した文字または文字列に置換します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">置換する文字。</param>
        <param name="newChar"><paramref name="oldChar" /> を置換する文字。</param>
        <summary>このインスタンスに出現する指定文字をすべて、別に指定した文字に置換します。</summary>
        <returns><paramref name="oldChar" /> が <paramref name="newChar" /> に置換されたこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、大文字と小文字を区別した序数の比較を実行して、現在のインスタンスでの `oldChar` の出現を識別します。 現在の <xref:System.Text.StringBuilder> インスタンスのサイズは、置換後も変更されません。



## Examples
 <xref:System.Text.StringBuilder.Replace%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">置換する文字列。</param>
        <param name="newValue"><paramref name="oldValue" /> を置換する文字列、または <see langword="null" />。</param>
        <summary>このインスタンスに出現するすべての指定した文字列を、別の指定した文字列に置換します。</summary>
        <returns><paramref name="oldValue" /> のすべてのインスタンスが <paramref name="newValue" /> に置換されたこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、大文字と小文字を区別した序数の比較を実行して、現在のインスタンスでの `oldValue` の出現を識別します。 `newValue` が `null` または <xref:System.String.Empty?displayProperty=nameWithType>の場合、すべての `oldValue` が削除されます。



## Examples
 <xref:System.Text.StringBuilder.Replace%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">置換する文字。</param>
        <param name="newChar"><paramref name="oldChar" /> を置換する文字。</param>
        <param name="startIndex">このインスタンスにおける部分文字列の開始位置。</param>
        <param name="count">部分文字列の長さ。</param>
        <summary>このインスタンスの部分文字列に出現するすべての指定した文字を、別の指定した文字に置換します。</summary>
        <returns><paramref name="startIndex" /> から <paramref name="startIndex" /> + <paramref name="count" /> -1 までの範囲内で、<paramref name="oldChar" /> が <paramref name="newChar" /> に置換されたこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、大文字と小文字を区別した序数の比較を実行して、現在のインスタンスでの `oldChar` の出現を識別します。 現在の <xref:System.Text.StringBuilder> オブジェクトのサイズは、置換後も変更されません。



## Examples
 <xref:System.Text.StringBuilder.Replace%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> + <paramref name="count" />このインスタンスの値の長さを超えています。

- または -

 <paramref name="startIndex" /> または <paramref name="count" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">置換する文字列。</param>
        <param name="newValue"><paramref name="oldValue" /> を置換する文字列、または <see langword="null" />。</param>
        <param name="startIndex">このインスタンスにおける部分文字列の開始位置。</param>
        <param name="count">部分文字列の長さ。</param>
        <summary>このインスタンスの部分文字列に出現するすべての指定した文字列を、別の指定した文字列に置換します。</summary>
        <returns><paramref name="startIndex" /> から <paramref name="startIndex" /> + <paramref name="count" /> 1 までの範囲内で、<paramref name="oldValue" /> のすべてのインスタンスが <paramref name="newValue" /> に置換されたこのインスタンスへの参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、大文字と小文字を区別した序数の比較を実行して、指定した部分文字列に含まれる `oldValue` の出現を識別します。 `newValue` が `null` または <xref:System.String.Empty?displayProperty=nameWithType>の場合、すべての `oldValue` が削除されます。



## Examples
 <xref:System.Text.StringBuilder.Replace%2A>メソッドの例を次に示します。

 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="count" /> が 0 未満です。

- または -

 <paramref name="startIndex" /> に<paramref name="count" /> を加算した値はこのインスタンスの範囲外の文字位置を示します。

- または -

このインスタンスの値を増やすと <see cref="P:System.Text.StringBuilder.MaxCapacity" /> を超えます。</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">シリアル化情報が設定されるオブジェクト。</param>
        <param name="context">シリアル化データを格納および取得する場所。 将来使用するために予約されています。</param>
        <summary><see cref="T:System.Runtime.Serialization.SerializationInfo" /> オブジェクトに、現在の <see cref="T:System.Text.StringBuilder" /> オブジェクトの逆シリアル化に必要なデータを入力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `context` パラメーターは将来の使用のために予約されているため、この操作には参加しません。

 詳細については、<xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType> メソッドを参照してください。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Text.StringBuilder" /> の値を <see cref="T:System.String" /> に変換します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスの値を <see cref="T:System.String" /> に変換します。</summary>
        <returns>このインスタンスと同じ値の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder> オブジェクトによって表される文字列を <xref:System.String> パラメーターを持つメソッドに渡したり、ユーザーインターフェイスに表示したりするには、<xref:System.Text.StringBuilder.ToString%2A> メソッドを呼び出して、<xref:System.Text.StringBuilder> オブジェクトを <xref:System.String> オブジェクトに変換する必要があります。



## Examples
 次の例では、<xref:System.Text.StringBuilder.ToString%2A> メソッドを呼び出す方法を示しています。 この例は、<xref:System.Text.StringBuilder> クラス用に用意されている大規模な例の一部です。

 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">このインスタンス内の部分文字列の開始位置。</param>
        <param name="length">部分文字列の長さ。</param>
        <summary>このインスタンスの部分文字列の値を <see cref="T:System.String" /> に変換します。</summary>
        <returns>このインスタンスの指定した部分文字列と同じ値の文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.StringBuilder> オブジェクトによって表される文字列を <xref:System.String> パラメーターを持つメソッドに渡したり、ユーザーインターフェイスに表示したりするには、<xref:System.Text.StringBuilder.ToString%2A> メソッドを呼び出して、<xref:System.Text.StringBuilder> オブジェクトを <xref:System.String> オブジェクトに変換する必要があります。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> または <paramref name="length" /> が 0 未満です。

- または -

<paramref name="startIndex" /> と <paramref name="length" /> の合計が、現在のインスタンスの長さより大きくなっています。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
