<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cb2af3514ed6614dd09636d8392e10eb7db5cc05" /><Meta Name="ms.sourcegitcommit" Value="a8ff98b48bda124cfcb2605f5da9b21bc6dcd791" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="02/14/2020" /><Meta Name="ms.locfileid" Value="77238897" /></Metadata><TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="c3040-101">文字エンコーディングを表します。</span><span class="sxs-lookup"><span data-stu-id="c3040-101">Represents a character encoding.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-102">エンコーディングは、Unicode 文字のセットをバイト シーケンスに変換するプロセスです。</span><span class="sxs-lookup"><span data-stu-id="c3040-102">Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</span></span> <span data-ttu-id="c3040-103">これに対して、デコードは、エンコードされたバイトシーケンスを Unicode 文字のセットに変換するプロセスです。</span><span class="sxs-lookup"><span data-stu-id="c3040-103">In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</span></span> <span data-ttu-id="c3040-104">Unicode 変換形式 (UTFs) と、<xref:System.Text.Encoding>でサポートされているその他のエンコーディングについては、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-104">For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <xref:System.Text.Encoding>, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>

 <span data-ttu-id="c3040-105"><xref:System.Text.Encoding> は、バイト配列などの任意のバイナリデータではなく Unicode 文字を操作することを意図しています。</span><span class="sxs-lookup"><span data-stu-id="c3040-105">Note that <xref:System.Text.Encoding> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="c3040-106">任意のバイナリデータをテキストにエンコードする必要がある場合は、uuencode などのプロトコルを使用する必要があります。これは、<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>などのメソッドによって実装されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-106">If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="c3040-107">.NET には、現在の Unicode エンコーディングとその他のエンコーディングをサポートするために、<xref:System.Text.Encoding> クラスの次の実装が用意されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-107">.NET provides the following implementations of the <xref:System.Text.Encoding> class to support current Unicode encodings and other encodings:</span></span>

-   <span data-ttu-id="c3040-108"><xref:System.Text.ASCIIEncoding> は、Unicode 文字を1つの7ビット ASCII 文字としてエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-108"><xref:System.Text.ASCIIEncoding> encodes Unicode characters as single 7-bit ASCII characters.</span></span> <span data-ttu-id="c3040-109">このエンコーディングでは、U + 0000 と U + 007F の間の文字値のみがサポートされます。</span><span class="sxs-lookup"><span data-stu-id="c3040-109">This encoding only supports character values between U+0000 and U+007F.</span></span> <span data-ttu-id="c3040-110">コードページ20127。</span><span class="sxs-lookup"><span data-stu-id="c3040-110">Code page 20127.</span></span> <span data-ttu-id="c3040-111"><xref:System.Text.Encoding.ASCII%2A> プロパティを通じて使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-111">Also available through the <xref:System.Text.Encoding.ASCII%2A> property.</span></span>

-   <span data-ttu-id="c3040-112"><xref:System.Text.UTF7Encoding> は、UTF-8 エンコーディングを使用して Unicode 文字をエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-112"><xref:System.Text.UTF7Encoding> encodes Unicode characters using the UTF-7 encoding.</span></span> <span data-ttu-id="c3040-113">このエンコーディングでは、すべての Unicode 文字値がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="c3040-113">This encoding supports all Unicode character values.</span></span> <span data-ttu-id="c3040-114">コードページ65000。</span><span class="sxs-lookup"><span data-stu-id="c3040-114">Code page 65000.</span></span> <span data-ttu-id="c3040-115"><xref:System.Text.Encoding.UTF7%2A> プロパティを通じて使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-115">Also available through the <xref:System.Text.Encoding.UTF7%2A> property.</span></span>

-   <span data-ttu-id="c3040-116"><xref:System.Text.UTF8Encoding> は、UTF-8 エンコーディングを使用して Unicode 文字をエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-116"><xref:System.Text.UTF8Encoding> encodes Unicode characters using the UTF-8 encoding.</span></span> <span data-ttu-id="c3040-117">このエンコーディングでは、すべての Unicode 文字値がサポートされます。</span><span class="sxs-lookup"><span data-stu-id="c3040-117">This encoding supports all Unicode character values.</span></span> <span data-ttu-id="c3040-118">コードページ65001。</span><span class="sxs-lookup"><span data-stu-id="c3040-118">Code page 65001.</span></span> <span data-ttu-id="c3040-119"><xref:System.Text.Encoding.UTF8%2A> プロパティを通じて使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-119">Also available through the <xref:System.Text.Encoding.UTF8%2A> property.</span></span>

-   <span data-ttu-id="c3040-120"><xref:System.Text.UnicodeEncoding> UTF-16 エンコーディングを使用して Unicode 文字をエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-120"><xref:System.Text.UnicodeEncoding> encodes Unicode characters using the UTF-16 encoding.</span></span> <span data-ttu-id="c3040-121">リトルエンディアンとビッグエンディアンの両方のバイト順がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-121">Both little endian and big endian byte orders are supported.</span></span> <span data-ttu-id="c3040-122"><xref:System.Text.Encoding.Unicode%2A> プロパティおよび <xref:System.Text.Encoding.BigEndianUnicode%2A> プロパティを通じて使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-122">Also available through the <xref:System.Text.Encoding.Unicode%2A> property and the <xref:System.Text.Encoding.BigEndianUnicode%2A> property.</span></span>

-   <span data-ttu-id="c3040-123"><xref:System.Text.UTF32Encoding> は、32 UTF-8 エンコーディングを使用して Unicode 文字をエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-123"><xref:System.Text.UTF32Encoding> encodes Unicode characters using the UTF-32 encoding.</span></span> <span data-ttu-id="c3040-124">リトルエンディアン (コードページ 12000) とビッグエンディアン (コードページ 12001) バイトの順序の両方がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-124">Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported.</span></span> <span data-ttu-id="c3040-125"><xref:System.Text.Encoding.UTF32%2A> プロパティを通じて使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-125">Also available through the <xref:System.Text.Encoding.UTF32%2A> property.</span></span>

 <span data-ttu-id="c3040-126"><xref:System.Text.Encoding> クラスは、主に異なるエンコーディングと Unicode の間で変換を行うことを目的としています。</span><span class="sxs-lookup"><span data-stu-id="c3040-126">The <xref:System.Text.Encoding> class is primarily intended to convert between different encodings and Unicode.</span></span> <span data-ttu-id="c3040-127">多くの場合、派生 Unicode クラスの1つは、アプリに適した選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-127">Often one of the derived Unicode classes is the correct choice for your app.</span></span>

 <span data-ttu-id="c3040-128"><xref:System.Text.Encoding.GetEncoding%2A> メソッドを使用して他のエンコーディングを取得し、<xref:System.Text.Encoding.GetEncodings%2A> メソッドを呼び出してすべてのエンコーディングの一覧を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-128">Use the <xref:System.Text.Encoding.GetEncoding%2A> method to obtain other encodings, and call the <xref:System.Text.Encoding.GetEncodings%2A> method to get a list of all encodings.</span></span>

 <span data-ttu-id="c3040-129">次の表に、.NET Framework と .NET Core でサポートされているエンコーディングを示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-129">The following table lists the encodings supported by .NET Framework and .NET Core.</span></span> <span data-ttu-id="c3040-130">各エンコーディングのコードページ番号と、エンコードの <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> と <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> プロパティの値が一覧表示されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-130">It lists each encoding's code page number and the values of the encoding's <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> and <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="c3040-131">**.NET Framework サポート**と **.net Core サポート**列のチェックマークは、基になるプラットフォームに関係なく、その .net 実装によってコードページがネイティブでサポートされていることを示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-131">A check mark in the **.NET Framework support** and **.NET Core support** columns indicates that the code page is natively supported by that .NET implementation, regardless of the underlying platform.</span></span> <span data-ttu-id="c3040-132">.NET Framework の場合、表に記載されている他のエンコーディングが使用できるかどうかは、オペレーティングシステムによって異なります。</span><span class="sxs-lookup"><span data-stu-id="c3040-132">For .NET Framework, the availability of other encodings listed in the table depends on the operating system.</span></span> <span data-ttu-id="c3040-133">.NET Core では、<xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> クラスを使用するか、<xref:System.Text.EncodingProvider?displayProperty=nameWithType> クラスから派生させることによって、他のエンコーディングを使用できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-133">For .NET Core, other encodings are available by using the <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> class or by deriving from the <xref:System.Text.EncodingProvider?displayProperty=nameWithType> class.</span></span>

> [!NOTE]
> <span data-ttu-id="c3040-134"><xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> プロパティが国際標準に対応するコードページは、必ずしもその標準に準拠しているとは限りません。</span><span class="sxs-lookup"><span data-stu-id="c3040-134">Code pages whose <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> property corresponds to an international standard do not necessarily comply in full with that standard.</span></span>

|<span data-ttu-id="c3040-135">コード ページ</span><span class="sxs-lookup"><span data-stu-id="c3040-135">Code page</span></span>|<span data-ttu-id="c3040-136">Name</span><span class="sxs-lookup"><span data-stu-id="c3040-136">Name</span></span>|<span data-ttu-id="c3040-137">Display name</span><span class="sxs-lookup"><span data-stu-id="c3040-137">Display name</span></span>|<span data-ttu-id="c3040-138">.NET Framework サポート</span><span class="sxs-lookup"><span data-stu-id="c3040-138">.NET Framework support</span></span>| <span data-ttu-id="c3040-139">.NET Core サポート</span><span class="sxs-lookup"><span data-stu-id="c3040-139">.NET Core support</span></span> |
|---------|----|------------|----------------------|-------------------|
|<span data-ttu-id="c3040-140">37</span><span class="sxs-lookup"><span data-stu-id="c3040-140">37</span></span>|<span data-ttu-id="c3040-141">IBM037</span><span class="sxs-lookup"><span data-stu-id="c3040-141">IBM037</span></span>|<span data-ttu-id="c3040-142">IBM EBCDIC (米国-カナダ)</span><span class="sxs-lookup"><span data-stu-id="c3040-142">IBM EBCDIC (US-Canada)</span></span>|||
|<span data-ttu-id="c3040-143">437</span><span class="sxs-lookup"><span data-stu-id="c3040-143">437</span></span>|<span data-ttu-id="c3040-144">IBM437</span><span class="sxs-lookup"><span data-stu-id="c3040-144">IBM437</span></span>|<span data-ttu-id="c3040-145">OEM 米国</span><span class="sxs-lookup"><span data-stu-id="c3040-145">OEM United States</span></span>|||
|<span data-ttu-id="c3040-146">500</span><span class="sxs-lookup"><span data-stu-id="c3040-146">500</span></span>|<span data-ttu-id="c3040-147">IBM500</span><span class="sxs-lookup"><span data-stu-id="c3040-147">IBM500</span></span>|<span data-ttu-id="c3040-148">IBM EBCDIC (インターナショナル)</span><span class="sxs-lookup"><span data-stu-id="c3040-148">IBM EBCDIC (International)</span></span>|||
|<span data-ttu-id="c3040-149">708</span><span class="sxs-lookup"><span data-stu-id="c3040-149">708</span></span>|<span data-ttu-id="c3040-150">ASMO-708</span><span class="sxs-lookup"><span data-stu-id="c3040-150">ASMO-708</span></span>|<span data-ttu-id="c3040-151">アラビア語 (ASMO 708)</span><span class="sxs-lookup"><span data-stu-id="c3040-151">Arabic (ASMO 708)</span></span>|||
|<span data-ttu-id="c3040-152">720</span><span class="sxs-lookup"><span data-stu-id="c3040-152">720</span></span>|<span data-ttu-id="c3040-153">DOS-720</span><span class="sxs-lookup"><span data-stu-id="c3040-153">DOS-720</span></span>|<span data-ttu-id="c3040-154">アラビア語 (DOS)</span><span class="sxs-lookup"><span data-stu-id="c3040-154">Arabic (DOS)</span></span>|||
|<span data-ttu-id="c3040-155">737</span><span class="sxs-lookup"><span data-stu-id="c3040-155">737</span></span>|<span data-ttu-id="c3040-156">ibm737</span><span class="sxs-lookup"><span data-stu-id="c3040-156">ibm737</span></span>|<span data-ttu-id="c3040-157">ギリシャ語 (DOS)</span><span class="sxs-lookup"><span data-stu-id="c3040-157">Greek (DOS)</span></span>|||
|<span data-ttu-id="c3040-158">775</span><span class="sxs-lookup"><span data-stu-id="c3040-158">775</span></span>|<span data-ttu-id="c3040-159">ibm775</span><span class="sxs-lookup"><span data-stu-id="c3040-159">ibm775</span></span>|<span data-ttu-id="c3040-160">バルト語 (DOS)</span><span class="sxs-lookup"><span data-stu-id="c3040-160">Baltic (DOS)</span></span>|||
|<span data-ttu-id="c3040-161">850</span><span class="sxs-lookup"><span data-stu-id="c3040-161">850</span></span>|<span data-ttu-id="c3040-162">ibm850</span><span class="sxs-lookup"><span data-stu-id="c3040-162">ibm850</span></span>|<span data-ttu-id="c3040-163">西ヨーロッパ言語 (DOS)</span><span class="sxs-lookup"><span data-stu-id="c3040-163">Western European (DOS)</span></span>|||
|<span data-ttu-id="c3040-164">852</span><span class="sxs-lookup"><span data-stu-id="c3040-164">852</span></span>|<span data-ttu-id="c3040-165">ibm852</span><span class="sxs-lookup"><span data-stu-id="c3040-165">ibm852</span></span>|<span data-ttu-id="c3040-166">中央ヨーロッパ言語 (DOS)</span><span class="sxs-lookup"><span data-stu-id="c3040-166">Central European (DOS)</span></span>|||
|<span data-ttu-id="c3040-167">855</span><span class="sxs-lookup"><span data-stu-id="c3040-167">855</span></span>|<span data-ttu-id="c3040-168">IBM855</span><span class="sxs-lookup"><span data-stu-id="c3040-168">IBM855</span></span>|<span data-ttu-id="c3040-169">OEM キリル文字</span><span class="sxs-lookup"><span data-stu-id="c3040-169">OEM Cyrillic</span></span>|||
|<span data-ttu-id="c3040-170">857</span><span class="sxs-lookup"><span data-stu-id="c3040-170">857</span></span>|<span data-ttu-id="c3040-171">ibm857</span><span class="sxs-lookup"><span data-stu-id="c3040-171">ibm857</span></span>|<span data-ttu-id="c3040-172">トルコ語 (DOS)</span><span class="sxs-lookup"><span data-stu-id="c3040-172">Turkish (DOS)</span></span>|||
|<span data-ttu-id="c3040-173">858</span><span class="sxs-lookup"><span data-stu-id="c3040-173">858</span></span>|<span data-ttu-id="c3040-174">IBM00858</span><span class="sxs-lookup"><span data-stu-id="c3040-174">IBM00858</span></span>|<span data-ttu-id="c3040-175">OEM 多言語ラテン I</span><span class="sxs-lookup"><span data-stu-id="c3040-175">OEM Multilingual Latin I</span></span>|||
|<span data-ttu-id="c3040-176">860</span><span class="sxs-lookup"><span data-stu-id="c3040-176">860</span></span>|<span data-ttu-id="c3040-177">IBM860</span><span class="sxs-lookup"><span data-stu-id="c3040-177">IBM860</span></span>|<span data-ttu-id="c3040-178">ポルトガル語 (DOS)</span><span class="sxs-lookup"><span data-stu-id="c3040-178">Portuguese (DOS)</span></span>|||
|<span data-ttu-id="c3040-179">861</span><span class="sxs-lookup"><span data-stu-id="c3040-179">861</span></span>|<span data-ttu-id="c3040-180">ibm861</span><span class="sxs-lookup"><span data-stu-id="c3040-180">ibm861</span></span>|<span data-ttu-id="c3040-181">アイスランド語 (DOS)</span><span class="sxs-lookup"><span data-stu-id="c3040-181">Icelandic (DOS)</span></span>|||
|<span data-ttu-id="c3040-182">862</span><span class="sxs-lookup"><span data-stu-id="c3040-182">862</span></span>|<span data-ttu-id="c3040-183">DOS-862</span><span class="sxs-lookup"><span data-stu-id="c3040-183">DOS-862</span></span>|<span data-ttu-id="c3040-184">ヘブライ語 (DOS)</span><span class="sxs-lookup"><span data-stu-id="c3040-184">Hebrew (DOS)</span></span>|||
|<span data-ttu-id="c3040-185">863</span><span class="sxs-lookup"><span data-stu-id="c3040-185">863</span></span>|<span data-ttu-id="c3040-186">IBM863</span><span class="sxs-lookup"><span data-stu-id="c3040-186">IBM863</span></span>|<span data-ttu-id="c3040-187">フランス語 (カナダ) (DOS)</span><span class="sxs-lookup"><span data-stu-id="c3040-187">French Canadian (DOS)</span></span>|||
|<span data-ttu-id="c3040-188">864</span><span class="sxs-lookup"><span data-stu-id="c3040-188">864</span></span>|<span data-ttu-id="c3040-189">IBM864</span><span class="sxs-lookup"><span data-stu-id="c3040-189">IBM864</span></span>|<span data-ttu-id="c3040-190">アラビア語 (864)</span><span class="sxs-lookup"><span data-stu-id="c3040-190">Arabic (864)</span></span>|||
|<span data-ttu-id="c3040-191">865</span><span class="sxs-lookup"><span data-stu-id="c3040-191">865</span></span>|<span data-ttu-id="c3040-192">IBM865</span><span class="sxs-lookup"><span data-stu-id="c3040-192">IBM865</span></span>|<span data-ttu-id="c3040-193">北欧 (DOS)</span><span class="sxs-lookup"><span data-stu-id="c3040-193">Nordic (DOS)</span></span>|||
|<span data-ttu-id="c3040-194">866</span><span class="sxs-lookup"><span data-stu-id="c3040-194">866</span></span>|<span data-ttu-id="c3040-195">cp866</span><span class="sxs-lookup"><span data-stu-id="c3040-195">cp866</span></span>|<span data-ttu-id="c3040-196">キリル語 (DOS)</span><span class="sxs-lookup"><span data-stu-id="c3040-196">Cyrillic (DOS)</span></span>|||
|<span data-ttu-id="c3040-197">869</span><span class="sxs-lookup"><span data-stu-id="c3040-197">869</span></span>|<span data-ttu-id="c3040-198">ibm869</span><span class="sxs-lookup"><span data-stu-id="c3040-198">ibm869</span></span>|<span data-ttu-id="c3040-199">ギリシャ語、モダン (DOS)</span><span class="sxs-lookup"><span data-stu-id="c3040-199">Greek, Modern (DOS)</span></span>|||
|<span data-ttu-id="c3040-200">870</span><span class="sxs-lookup"><span data-stu-id="c3040-200">870</span></span>|<span data-ttu-id="c3040-201">IBM870</span><span class="sxs-lookup"><span data-stu-id="c3040-201">IBM870</span></span>|<span data-ttu-id="c3040-202">IBM EBCDIC (多言語ラテン-2)</span><span class="sxs-lookup"><span data-stu-id="c3040-202">IBM EBCDIC (Multilingual Latin-2)</span></span>|||
|<span data-ttu-id="c3040-203">874</span><span class="sxs-lookup"><span data-stu-id="c3040-203">874</span></span>|<span data-ttu-id="c3040-204">windows-874</span><span class="sxs-lookup"><span data-stu-id="c3040-204">windows-874</span></span>|<span data-ttu-id="c3040-205">タイ語 (Windows)</span><span class="sxs-lookup"><span data-stu-id="c3040-205">Thai (Windows)</span></span>|||
|<span data-ttu-id="c3040-206">875</span><span class="sxs-lookup"><span data-stu-id="c3040-206">875</span></span>|<span data-ttu-id="c3040-207">cp875</span><span class="sxs-lookup"><span data-stu-id="c3040-207">cp875</span></span>|<span data-ttu-id="c3040-208">IBM EBCDIC (ギリシャ語モダン)</span><span class="sxs-lookup"><span data-stu-id="c3040-208">IBM EBCDIC (Greek Modern)</span></span>|||
|<span data-ttu-id="c3040-209">932</span><span class="sxs-lookup"><span data-stu-id="c3040-209">932</span></span>|<span data-ttu-id="c3040-210">shift_jis</span><span class="sxs-lookup"><span data-stu-id="c3040-210">shift_jis</span></span>|<span data-ttu-id="c3040-211">日本語 (Shift-JIS)</span><span class="sxs-lookup"><span data-stu-id="c3040-211">Japanese (Shift-JIS)</span></span>|||
|<span data-ttu-id="c3040-212">936</span><span class="sxs-lookup"><span data-stu-id="c3040-212">936</span></span>|<span data-ttu-id="c3040-213">gb2312</span><span class="sxs-lookup"><span data-stu-id="c3040-213">gb2312</span></span>|<span data-ttu-id="c3040-214">簡体字中国語 (GB2312)</span><span class="sxs-lookup"><span data-stu-id="c3040-214">Chinese Simplified (GB2312)</span></span>|<span data-ttu-id="c3040-215">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-215">✓</span></span>||
|<span data-ttu-id="c3040-216">949</span><span class="sxs-lookup"><span data-stu-id="c3040-216">949</span></span>|<span data-ttu-id="c3040-217">ks_c_5601-1987</span><span class="sxs-lookup"><span data-stu-id="c3040-217">ks_c_5601-1987</span></span>|<span data-ttu-id="c3040-218">Korean</span><span class="sxs-lookup"><span data-stu-id="c3040-218">Korean</span></span>|||
|<span data-ttu-id="c3040-219">950</span><span class="sxs-lookup"><span data-stu-id="c3040-219">950</span></span>|<span data-ttu-id="c3040-220">big5</span><span class="sxs-lookup"><span data-stu-id="c3040-220">big5</span></span>|<span data-ttu-id="c3040-221">繁体字中国語 (Big5)</span><span class="sxs-lookup"><span data-stu-id="c3040-221">Chinese Traditional (Big5)</span></span>|||
|<span data-ttu-id="c3040-222">1026</span><span class="sxs-lookup"><span data-stu-id="c3040-222">1026</span></span>|<span data-ttu-id="c3040-223">IBM1026</span><span class="sxs-lookup"><span data-stu-id="c3040-223">IBM1026</span></span>|<span data-ttu-id="c3040-224">IBM EBCDIC (トルコ語ラテン-5)</span><span class="sxs-lookup"><span data-stu-id="c3040-224">IBM EBCDIC (Turkish Latin-5)</span></span>|||
|<span data-ttu-id="c3040-225">1047</span><span class="sxs-lookup"><span data-stu-id="c3040-225">1047</span></span>|<span data-ttu-id="c3040-226">IBM01047</span><span class="sxs-lookup"><span data-stu-id="c3040-226">IBM01047</span></span>|<span data-ttu-id="c3040-227">IBM ラテン-1</span><span class="sxs-lookup"><span data-stu-id="c3040-227">IBM Latin-1</span></span>|||
|<span data-ttu-id="c3040-228">1140</span><span class="sxs-lookup"><span data-stu-id="c3040-228">1140</span></span>|<span data-ttu-id="c3040-229">IBM01140</span><span class="sxs-lookup"><span data-stu-id="c3040-229">IBM01140</span></span>|<span data-ttu-id="c3040-230">IBM EBCDIC (米国-カナダ-ヨーロッパ)</span><span class="sxs-lookup"><span data-stu-id="c3040-230">IBM EBCDIC (US-Canada-Euro)</span></span>|||
|<span data-ttu-id="c3040-231">1141</span><span class="sxs-lookup"><span data-stu-id="c3040-231">1141</span></span>|<span data-ttu-id="c3040-232">IBM01141</span><span class="sxs-lookup"><span data-stu-id="c3040-232">IBM01141</span></span>|<span data-ttu-id="c3040-233">IBM EBCDIC (ドイツ-ヨーロッパ)</span><span class="sxs-lookup"><span data-stu-id="c3040-233">IBM EBCDIC (Germany-Euro)</span></span>|||
|<span data-ttu-id="c3040-234">1142</span><span class="sxs-lookup"><span data-stu-id="c3040-234">1142</span></span>|<span data-ttu-id="c3040-235">IBM01142</span><span class="sxs-lookup"><span data-stu-id="c3040-235">IBM01142</span></span>|<span data-ttu-id="c3040-236">IBM EBCDIC (デンマーク-ノルウェー-ヨーロッパ)</span><span class="sxs-lookup"><span data-stu-id="c3040-236">IBM EBCDIC (Denmark-Norway-Euro)</span></span>|||
|<span data-ttu-id="c3040-237">1143</span><span class="sxs-lookup"><span data-stu-id="c3040-237">1143</span></span>|<span data-ttu-id="c3040-238">IBM01143</span><span class="sxs-lookup"><span data-stu-id="c3040-238">IBM01143</span></span>|<span data-ttu-id="c3040-239">IBM EBCDIC (フィンランド-スウェーデン-ヨーロッパ)</span><span class="sxs-lookup"><span data-stu-id="c3040-239">IBM EBCDIC (Finland-Sweden-Euro)</span></span>|||
|<span data-ttu-id="c3040-240">1144</span><span class="sxs-lookup"><span data-stu-id="c3040-240">1144</span></span>|<span data-ttu-id="c3040-241">IBM01144</span><span class="sxs-lookup"><span data-stu-id="c3040-241">IBM01144</span></span>|<span data-ttu-id="c3040-242">IBM EBCDIC (イタリア-ヨーロッパ)</span><span class="sxs-lookup"><span data-stu-id="c3040-242">IBM EBCDIC (Italy-Euro)</span></span>|||
|<span data-ttu-id="c3040-243">1145</span><span class="sxs-lookup"><span data-stu-id="c3040-243">1145</span></span>|<span data-ttu-id="c3040-244">IBM01145</span><span class="sxs-lookup"><span data-stu-id="c3040-244">IBM01145</span></span>|<span data-ttu-id="c3040-245">IBM EBCDIC (スペイン-ヨーロッパ)</span><span class="sxs-lookup"><span data-stu-id="c3040-245">IBM EBCDIC (Spain-Euro)</span></span>|||
|<span data-ttu-id="c3040-246">1146</span><span class="sxs-lookup"><span data-stu-id="c3040-246">1146</span></span>|<span data-ttu-id="c3040-247">IBM01146</span><span class="sxs-lookup"><span data-stu-id="c3040-247">IBM01146</span></span>|<span data-ttu-id="c3040-248">IBM EBCDIC (UK-ヨーロッパ)</span><span class="sxs-lookup"><span data-stu-id="c3040-248">IBM EBCDIC (UK-Euro)</span></span>|||
|<span data-ttu-id="c3040-249">1147</span><span class="sxs-lookup"><span data-stu-id="c3040-249">1147</span></span>|<span data-ttu-id="c3040-250">IBM01147</span><span class="sxs-lookup"><span data-stu-id="c3040-250">IBM01147</span></span>|<span data-ttu-id="c3040-251">IBM EBCDIC (フランス-ヨーロッパ)</span><span class="sxs-lookup"><span data-stu-id="c3040-251">IBM EBCDIC (France-Euro)</span></span>|||
|<span data-ttu-id="c3040-252">1148</span><span class="sxs-lookup"><span data-stu-id="c3040-252">1148</span></span>|<span data-ttu-id="c3040-253">IBM01148</span><span class="sxs-lookup"><span data-stu-id="c3040-253">IBM01148</span></span>|<span data-ttu-id="c3040-254">IBM EBCDIC (国際対応-ヨーロッパ)</span><span class="sxs-lookup"><span data-stu-id="c3040-254">IBM EBCDIC (International-Euro)</span></span>|||
|<span data-ttu-id="c3040-255">1149</span><span class="sxs-lookup"><span data-stu-id="c3040-255">1149</span></span>|<span data-ttu-id="c3040-256">IBM01149</span><span class="sxs-lookup"><span data-stu-id="c3040-256">IBM01149</span></span>|<span data-ttu-id="c3040-257">IBM EBCDIC (アイスランド語-ヨーロッパ)</span><span class="sxs-lookup"><span data-stu-id="c3040-257">IBM EBCDIC (Icelandic-Euro)</span></span>|||
|<span data-ttu-id="c3040-258">1200</span><span class="sxs-lookup"><span data-stu-id="c3040-258">1200</span></span>|<span data-ttu-id="c3040-259">utf-16</span><span class="sxs-lookup"><span data-stu-id="c3040-259">utf-16</span></span>|<span data-ttu-id="c3040-260">Unicode</span><span class="sxs-lookup"><span data-stu-id="c3040-260">Unicode</span></span>|<span data-ttu-id="c3040-261">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-261">✓</span></span>|<span data-ttu-id="c3040-262">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-262">✓</span></span>|
|<span data-ttu-id="c3040-263">1201</span><span class="sxs-lookup"><span data-stu-id="c3040-263">1201</span></span>|<span data-ttu-id="c3040-264">unicodeFFFE</span><span class="sxs-lookup"><span data-stu-id="c3040-264">unicodeFFFE</span></span>|<span data-ttu-id="c3040-265">Unicode (ビッグエンディアン)</span><span class="sxs-lookup"><span data-stu-id="c3040-265">Unicode (Big endian)</span></span>|<span data-ttu-id="c3040-266">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-266">✓</span></span>|<span data-ttu-id="c3040-267">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-267">✓</span></span>|
|<span data-ttu-id="c3040-268">1250</span><span class="sxs-lookup"><span data-stu-id="c3040-268">1250</span></span>|<span data-ttu-id="c3040-269">windows-1250</span><span class="sxs-lookup"><span data-stu-id="c3040-269">windows-1250</span></span>|<span data-ttu-id="c3040-270">中央ヨーロッパ言語 (Windows)</span><span class="sxs-lookup"><span data-stu-id="c3040-270">Central European (Windows)</span></span>|||
|<span data-ttu-id="c3040-271">1251</span><span class="sxs-lookup"><span data-stu-id="c3040-271">1251</span></span>|<span data-ttu-id="c3040-272">windows-1251</span><span class="sxs-lookup"><span data-stu-id="c3040-272">windows-1251</span></span>|<span data-ttu-id="c3040-273">キリル語 (Windows)</span><span class="sxs-lookup"><span data-stu-id="c3040-273">Cyrillic (Windows)</span></span>|||
|<span data-ttu-id="c3040-274">1252</span><span class="sxs-lookup"><span data-stu-id="c3040-274">1252</span></span>|<span data-ttu-id="c3040-275">utf-8</span><span class="sxs-lookup"><span data-stu-id="c3040-275">Windows-1252</span></span>|<span data-ttu-id="c3040-276">西ヨーロッパ言語 (Windows)</span><span class="sxs-lookup"><span data-stu-id="c3040-276">Western European (Windows)</span></span>|<span data-ttu-id="c3040-277">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-277">✓</span></span>||
|<span data-ttu-id="c3040-278">1253</span><span class="sxs-lookup"><span data-stu-id="c3040-278">1253</span></span>|<span data-ttu-id="c3040-279">windows-1253</span><span class="sxs-lookup"><span data-stu-id="c3040-279">windows-1253</span></span>|<span data-ttu-id="c3040-280">ギリシャ語 (Windows)</span><span class="sxs-lookup"><span data-stu-id="c3040-280">Greek (Windows)</span></span>|||
|<span data-ttu-id="c3040-281">1254</span><span class="sxs-lookup"><span data-stu-id="c3040-281">1254</span></span>|<span data-ttu-id="c3040-282">windows-1254</span><span class="sxs-lookup"><span data-stu-id="c3040-282">windows-1254</span></span>|<span data-ttu-id="c3040-283">トルコ語 (Windows)</span><span class="sxs-lookup"><span data-stu-id="c3040-283">Turkish (Windows)</span></span>|||
|<span data-ttu-id="c3040-284">1255</span><span class="sxs-lookup"><span data-stu-id="c3040-284">1255</span></span>|<span data-ttu-id="c3040-285">windows-1255</span><span class="sxs-lookup"><span data-stu-id="c3040-285">windows-1255</span></span>|<span data-ttu-id="c3040-286">ヘブライ語 (Windows)</span><span class="sxs-lookup"><span data-stu-id="c3040-286">Hebrew (Windows)</span></span>|||
|<span data-ttu-id="c3040-287">1256</span><span class="sxs-lookup"><span data-stu-id="c3040-287">1256</span></span>|<span data-ttu-id="c3040-288">windows-1256</span><span class="sxs-lookup"><span data-stu-id="c3040-288">windows-1256</span></span>|<span data-ttu-id="c3040-289">アラビア語 (Windows)</span><span class="sxs-lookup"><span data-stu-id="c3040-289">Arabic (Windows)</span></span>|||
|<span data-ttu-id="c3040-290">1257</span><span class="sxs-lookup"><span data-stu-id="c3040-290">1257</span></span>|<span data-ttu-id="c3040-291">windows-1257</span><span class="sxs-lookup"><span data-stu-id="c3040-291">windows-1257</span></span>|<span data-ttu-id="c3040-292">バルト語 (Windows)</span><span class="sxs-lookup"><span data-stu-id="c3040-292">Baltic (Windows)</span></span>|||
|<span data-ttu-id="c3040-293">1258</span><span class="sxs-lookup"><span data-stu-id="c3040-293">1258</span></span>|<span data-ttu-id="c3040-294">windows-1258</span><span class="sxs-lookup"><span data-stu-id="c3040-294">windows-1258</span></span>|<span data-ttu-id="c3040-295">ベトナム語 (Windows)</span><span class="sxs-lookup"><span data-stu-id="c3040-295">Vietnamese (Windows)</span></span>|||
|<span data-ttu-id="c3040-296">1361</span><span class="sxs-lookup"><span data-stu-id="c3040-296">1361</span></span>|<span data-ttu-id="c3040-297">Johab</span><span class="sxs-lookup"><span data-stu-id="c3040-297">Johab</span></span>|<span data-ttu-id="c3040-298">韓国語 (Johab)</span><span class="sxs-lookup"><span data-stu-id="c3040-298">Korean (Johab)</span></span>|||
|<span data-ttu-id="c3040-299">10000</span><span class="sxs-lookup"><span data-stu-id="c3040-299">10000</span></span>|<span data-ttu-id="c3040-300">macintosh</span><span class="sxs-lookup"><span data-stu-id="c3040-300">macintosh</span></span>|<span data-ttu-id="c3040-301">西ヨーロッパ言語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-301">Western European (Mac)</span></span>|||
|<span data-ttu-id="c3040-302">10001</span><span class="sxs-lookup"><span data-stu-id="c3040-302">10001</span></span>|<span data-ttu-id="c3040-303">x-mac-日本語</span><span class="sxs-lookup"><span data-stu-id="c3040-303">x-mac-japanese</span></span>|<span data-ttu-id="c3040-304">日本語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-304">Japanese (Mac)</span></span>|||
|<span data-ttu-id="c3040-305">10002</span><span class="sxs-lookup"><span data-stu-id="c3040-305">10002</span></span>|<span data-ttu-id="c3040-306">x-mac-chinesetrad</span><span class="sxs-lookup"><span data-stu-id="c3040-306">x-mac-chinesetrad</span></span>|<span data-ttu-id="c3040-307">繁体字中国語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-307">Chinese Traditional (Mac)</span></span>|||
|<span data-ttu-id="c3040-308">10003</span><span class="sxs-lookup"><span data-stu-id="c3040-308">10003</span></span>|<span data-ttu-id="c3040-309">x-mac-korean</span><span class="sxs-lookup"><span data-stu-id="c3040-309">x-mac-korean</span></span>|<span data-ttu-id="c3040-310">韓国語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-310">Korean (Mac)</span></span>|<span data-ttu-id="c3040-311">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-311">✓</span></span>||
|<span data-ttu-id="c3040-312">10004</span><span class="sxs-lookup"><span data-stu-id="c3040-312">10004</span></span>|<span data-ttu-id="c3040-313">x-mac-arabic</span><span class="sxs-lookup"><span data-stu-id="c3040-313">x-mac-arabic</span></span>|<span data-ttu-id="c3040-314">アラビア語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-314">Arabic (Mac)</span></span>|||
|<span data-ttu-id="c3040-315">10005</span><span class="sxs-lookup"><span data-stu-id="c3040-315">10005</span></span>|<span data-ttu-id="c3040-316">x-mac-hebrew</span><span class="sxs-lookup"><span data-stu-id="c3040-316">x-mac-hebrew</span></span>|<span data-ttu-id="c3040-317">ヘブライ語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-317">Hebrew (Mac)</span></span>|||
|<span data-ttu-id="c3040-318">10006</span><span class="sxs-lookup"><span data-stu-id="c3040-318">10006</span></span>|<span data-ttu-id="c3040-319">x-mac-greek</span><span class="sxs-lookup"><span data-stu-id="c3040-319">x-mac-greek</span></span>|<span data-ttu-id="c3040-320">ギリシャ語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-320">Greek (Mac)</span></span>|||
|<span data-ttu-id="c3040-321">10007</span><span class="sxs-lookup"><span data-stu-id="c3040-321">10007</span></span>|<span data-ttu-id="c3040-322">x-mac-キリル文字</span><span class="sxs-lookup"><span data-stu-id="c3040-322">x-mac-cyrillic</span></span>|<span data-ttu-id="c3040-323">キリル語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-323">Cyrillic (Mac)</span></span>|||
|<span data-ttu-id="c3040-324">10008</span><span class="sxs-lookup"><span data-stu-id="c3040-324">10008</span></span>|<span data-ttu-id="c3040-325">x-mac-chinesesimp</span><span class="sxs-lookup"><span data-stu-id="c3040-325">x-mac-chinesesimp</span></span>|<span data-ttu-id="c3040-326">簡体字中国語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-326">Chinese Simplified (Mac)</span></span>|<span data-ttu-id="c3040-327">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-327">✓</span></span>||
|<span data-ttu-id="c3040-328">10010</span><span class="sxs-lookup"><span data-stu-id="c3040-328">10010</span></span>|<span data-ttu-id="c3040-329">x-mac-ルーマニア語</span><span class="sxs-lookup"><span data-stu-id="c3040-329">x-mac-romanian</span></span>|<span data-ttu-id="c3040-330">ルーマニア語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-330">Romanian (Mac)</span></span>|||
|<span data-ttu-id="c3040-331">10017</span><span class="sxs-lookup"><span data-stu-id="c3040-331">10017</span></span>|<span data-ttu-id="c3040-332">x-mac-ukrainian</span><span class="sxs-lookup"><span data-stu-id="c3040-332">x-mac-ukrainian</span></span>|<span data-ttu-id="c3040-333">ウクライナ語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-333">Ukrainian (Mac)</span></span>|||
|<span data-ttu-id="c3040-334">10021</span><span class="sxs-lookup"><span data-stu-id="c3040-334">10021</span></span>|<span data-ttu-id="c3040-335">x-mac-thai</span><span class="sxs-lookup"><span data-stu-id="c3040-335">x-mac-thai</span></span>|<span data-ttu-id="c3040-336">タイ語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-336">Thai (Mac)</span></span>|||
|<span data-ttu-id="c3040-337">10029</span><span class="sxs-lookup"><span data-stu-id="c3040-337">10029</span></span>|<span data-ttu-id="c3040-338">x-mac-ce</span><span class="sxs-lookup"><span data-stu-id="c3040-338">x-mac-ce</span></span>|<span data-ttu-id="c3040-339">中央ヨーロッパ言語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-339">Central European (Mac)</span></span>|||
|<span data-ttu-id="c3040-340">10079</span><span class="sxs-lookup"><span data-stu-id="c3040-340">10079</span></span>|<span data-ttu-id="c3040-341">x-mac-アイスランド語</span><span class="sxs-lookup"><span data-stu-id="c3040-341">x-mac-icelandic</span></span>|<span data-ttu-id="c3040-342">アイスランド語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-342">Icelandic (Mac)</span></span>|||
|<span data-ttu-id="c3040-343">10081</span><span class="sxs-lookup"><span data-stu-id="c3040-343">10081</span></span>|<span data-ttu-id="c3040-344">x-mac-turkish</span><span class="sxs-lookup"><span data-stu-id="c3040-344">x-mac-turkish</span></span>|<span data-ttu-id="c3040-345">トルコ語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-345">Turkish (Mac)</span></span>|||
|<span data-ttu-id="c3040-346">10082</span><span class="sxs-lookup"><span data-stu-id="c3040-346">10082</span></span>|<span data-ttu-id="c3040-347">x-mac-クロアチア語</span><span class="sxs-lookup"><span data-stu-id="c3040-347">x-mac-croatian</span></span>|<span data-ttu-id="c3040-348">クロアチア語 (Mac)</span><span class="sxs-lookup"><span data-stu-id="c3040-348">Croatian (Mac)</span></span>|||
|<span data-ttu-id="c3040-349">12000</span><span class="sxs-lookup"><span data-stu-id="c3040-349">12000</span></span>|<span data-ttu-id="c3040-350">utf-32</span><span class="sxs-lookup"><span data-stu-id="c3040-350">utf-32</span></span>|<span data-ttu-id="c3040-351">Unicode (UTF-32)</span><span class="sxs-lookup"><span data-stu-id="c3040-351">Unicode (UTF-32)</span></span>|<span data-ttu-id="c3040-352">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-352">✓</span></span>|<span data-ttu-id="c3040-353">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-353">✓</span></span>|
|<span data-ttu-id="c3040-354">12001</span><span class="sxs-lookup"><span data-stu-id="c3040-354">12001</span></span>|<span data-ttu-id="c3040-355">utf-32</span><span class="sxs-lookup"><span data-stu-id="c3040-355">utf-32BE</span></span>|<span data-ttu-id="c3040-356">Unicode (UTF-32 ビッグエンディアン)</span><span class="sxs-lookup"><span data-stu-id="c3040-356">Unicode (UTF-32 Big endian)</span></span>|<span data-ttu-id="c3040-357">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-357">✓</span></span>|<span data-ttu-id="c3040-358">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-358">✓</span></span>|
|<span data-ttu-id="c3040-359">20000</span><span class="sxs-lookup"><span data-stu-id="c3040-359">20000</span></span>|<span data-ttu-id="c3040-360">x-中国語-CN</span><span class="sxs-lookup"><span data-stu-id="c3040-360">x-Chinese-CNS</span></span>|<span data-ttu-id="c3040-361">繁体字中国語 (CNS)</span><span class="sxs-lookup"><span data-stu-id="c3040-361">Chinese Traditional (CNS)</span></span>|||
|<span data-ttu-id="c3040-362">20001</span><span class="sxs-lookup"><span data-stu-id="c3040-362">20001</span></span>|<span data-ttu-id="c3040-363">x-cp20001</span><span class="sxs-lookup"><span data-stu-id="c3040-363">x-cp20001</span></span>|<span data-ttu-id="c3040-364">TCA 台湾</span><span class="sxs-lookup"><span data-stu-id="c3040-364">TCA Taiwan</span></span>|||
|<span data-ttu-id="c3040-365">20002</span><span class="sxs-lookup"><span data-stu-id="c3040-365">20002</span></span>|<span data-ttu-id="c3040-366">x-Eten</span><span class="sxs-lookup"><span data-stu-id="c3040-366">x-Chinese-Eten</span></span>|<span data-ttu-id="c3040-367">繁体字中国語 (Eten)</span><span class="sxs-lookup"><span data-stu-id="c3040-367">Chinese Traditional (Eten)</span></span>|||
|<span data-ttu-id="c3040-368">20003</span><span class="sxs-lookup"><span data-stu-id="c3040-368">20003</span></span>|<span data-ttu-id="c3040-369">x-cp20003</span><span class="sxs-lookup"><span data-stu-id="c3040-369">x-cp20003</span></span>|<span data-ttu-id="c3040-370">IBM5550 台湾</span><span class="sxs-lookup"><span data-stu-id="c3040-370">IBM5550 Taiwan</span></span>|||
|<span data-ttu-id="c3040-371">20004</span><span class="sxs-lookup"><span data-stu-id="c3040-371">20004</span></span>|<span data-ttu-id="c3040-372">x-cp20004</span><span class="sxs-lookup"><span data-stu-id="c3040-372">x-cp20004</span></span>|<span data-ttu-id="c3040-373">文字放送 (台湾)</span><span class="sxs-lookup"><span data-stu-id="c3040-373">TeleText Taiwan</span></span>|||
|<span data-ttu-id="c3040-374">20005</span><span class="sxs-lookup"><span data-stu-id="c3040-374">20005</span></span>|<span data-ttu-id="c3040-375">x-cp20005</span><span class="sxs-lookup"><span data-stu-id="c3040-375">x-cp20005</span></span>|<span data-ttu-id="c3040-376">Wang 台湾</span><span class="sxs-lookup"><span data-stu-id="c3040-376">Wang Taiwan</span></span>|||
|<span data-ttu-id="c3040-377">20105</span><span class="sxs-lookup"><span data-stu-id="c3040-377">20105</span></span>|<span data-ttu-id="c3040-378">x-IA5</span><span class="sxs-lookup"><span data-stu-id="c3040-378">x-IA5</span></span>|<span data-ttu-id="c3040-379">西ヨーロッパ言語 (IA5)</span><span class="sxs-lookup"><span data-stu-id="c3040-379">Western European (IA5)</span></span>|||
|<span data-ttu-id="c3040-380">20106</span><span class="sxs-lookup"><span data-stu-id="c3040-380">20106</span></span>|<span data-ttu-id="c3040-381">x-IA5-ドイツ語</span><span class="sxs-lookup"><span data-stu-id="c3040-381">x-IA5-German</span></span>|<span data-ttu-id="c3040-382">ドイツ語 (IA5)</span><span class="sxs-lookup"><span data-stu-id="c3040-382">German (IA5)</span></span>|||
|<span data-ttu-id="c3040-383">20107</span><span class="sxs-lookup"><span data-stu-id="c3040-383">20107</span></span>|<span data-ttu-id="c3040-384">x-IA5-スウェーデン語</span><span class="sxs-lookup"><span data-stu-id="c3040-384">x-IA5-Swedish</span></span>|<span data-ttu-id="c3040-385">スウェーデン語 (IA5)</span><span class="sxs-lookup"><span data-stu-id="c3040-385">Swedish (IA5)</span></span>|||
|<span data-ttu-id="c3040-386">20108</span><span class="sxs-lookup"><span data-stu-id="c3040-386">20108</span></span>|<span data-ttu-id="c3040-387">x-IA5-ノルウェー語</span><span class="sxs-lookup"><span data-stu-id="c3040-387">x-IA5-Norwegian</span></span>|<span data-ttu-id="c3040-388">ノルウェー語 (IA5)</span><span class="sxs-lookup"><span data-stu-id="c3040-388">Norwegian (IA5)</span></span>|||
|<span data-ttu-id="c3040-389">20127</span><span class="sxs-lookup"><span data-stu-id="c3040-389">20127</span></span>|<span data-ttu-id="c3040-390">us-ascii</span><span class="sxs-lookup"><span data-stu-id="c3040-390">us-ascii</span></span>|<span data-ttu-id="c3040-391">US-ASCII</span><span class="sxs-lookup"><span data-stu-id="c3040-391">US-ASCII</span></span>|<span data-ttu-id="c3040-392">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-392">✓</span></span>|<span data-ttu-id="c3040-393">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-393">✓</span></span>|
|<span data-ttu-id="c3040-394">20261</span><span class="sxs-lookup"><span data-stu-id="c3040-394">20261</span></span>|<span data-ttu-id="c3040-395">x-cp20261</span><span class="sxs-lookup"><span data-stu-id="c3040-395">x-cp20261</span></span>|<span data-ttu-id="c3040-396">T.61</span><span class="sxs-lookup"><span data-stu-id="c3040-396">T.61</span></span>|||
|<span data-ttu-id="c3040-397">20269</span><span class="sxs-lookup"><span data-stu-id="c3040-397">20269</span></span>|<span data-ttu-id="c3040-398">x-cp20269</span><span class="sxs-lookup"><span data-stu-id="c3040-398">x-cp20269</span></span>|<span data-ttu-id="c3040-399">ISO-6937</span><span class="sxs-lookup"><span data-stu-id="c3040-399">ISO-6937</span></span>|||
|<span data-ttu-id="c3040-400">20273</span><span class="sxs-lookup"><span data-stu-id="c3040-400">20273</span></span>|<span data-ttu-id="c3040-401">IBM273</span><span class="sxs-lookup"><span data-stu-id="c3040-401">IBM273</span></span>|<span data-ttu-id="c3040-402">IBM EBCDIC (ドイツ)</span><span class="sxs-lookup"><span data-stu-id="c3040-402">IBM EBCDIC (Germany)</span></span>|||
|<span data-ttu-id="c3040-403">20277</span><span class="sxs-lookup"><span data-stu-id="c3040-403">20277</span></span>|<span data-ttu-id="c3040-404">IBM277</span><span class="sxs-lookup"><span data-stu-id="c3040-404">IBM277</span></span>|<span data-ttu-id="c3040-405">IBM EBCDIC (デンマーク-ノルウェー)</span><span class="sxs-lookup"><span data-stu-id="c3040-405">IBM EBCDIC (Denmark-Norway)</span></span>|||
|<span data-ttu-id="c3040-406">20278</span><span class="sxs-lookup"><span data-stu-id="c3040-406">20278</span></span>|<span data-ttu-id="c3040-407">IBM278</span><span class="sxs-lookup"><span data-stu-id="c3040-407">IBM278</span></span>|<span data-ttu-id="c3040-408">IBM EBCDIC (フィンランド-スウェーデン)</span><span class="sxs-lookup"><span data-stu-id="c3040-408">IBM EBCDIC (Finland-Sweden)</span></span>|||
|<span data-ttu-id="c3040-409">20280</span><span class="sxs-lookup"><span data-stu-id="c3040-409">20280</span></span>|<span data-ttu-id="c3040-410">IBM280</span><span class="sxs-lookup"><span data-stu-id="c3040-410">IBM280</span></span>|<span data-ttu-id="c3040-411">IBM EBCDIC (イタリア)</span><span class="sxs-lookup"><span data-stu-id="c3040-411">IBM EBCDIC (Italy)</span></span>|||
|<span data-ttu-id="c3040-412">20284</span><span class="sxs-lookup"><span data-stu-id="c3040-412">20284</span></span>|<span data-ttu-id="c3040-413">IBM284</span><span class="sxs-lookup"><span data-stu-id="c3040-413">IBM284</span></span>|<span data-ttu-id="c3040-414">IBM EBCDIC (スペイン)</span><span class="sxs-lookup"><span data-stu-id="c3040-414">IBM EBCDIC (Spain)</span></span>|||
|<span data-ttu-id="c3040-415">20285</span><span class="sxs-lookup"><span data-stu-id="c3040-415">20285</span></span>|<span data-ttu-id="c3040-416">IBM285</span><span class="sxs-lookup"><span data-stu-id="c3040-416">IBM285</span></span>|<span data-ttu-id="c3040-417">IBM EBCDIC (UK)</span><span class="sxs-lookup"><span data-stu-id="c3040-417">IBM EBCDIC (UK)</span></span>|||
|<span data-ttu-id="c3040-418">20290</span><span class="sxs-lookup"><span data-stu-id="c3040-418">20290</span></span>|<span data-ttu-id="c3040-419">IBM290</span><span class="sxs-lookup"><span data-stu-id="c3040-419">IBM290</span></span>|<span data-ttu-id="c3040-420">IBM EBCDIC (日本語カタカナ)</span><span class="sxs-lookup"><span data-stu-id="c3040-420">IBM EBCDIC (Japanese katakana)</span></span>|||
|<span data-ttu-id="c3040-421">20297</span><span class="sxs-lookup"><span data-stu-id="c3040-421">20297</span></span>|<span data-ttu-id="c3040-422">IBM297</span><span class="sxs-lookup"><span data-stu-id="c3040-422">IBM297</span></span>|<span data-ttu-id="c3040-423">IBM EBCDIC (フランス)</span><span class="sxs-lookup"><span data-stu-id="c3040-423">IBM EBCDIC (France)</span></span>|||
|<span data-ttu-id="c3040-424">20420</span><span class="sxs-lookup"><span data-stu-id="c3040-424">20420</span></span>|<span data-ttu-id="c3040-425">IBM420</span><span class="sxs-lookup"><span data-stu-id="c3040-425">IBM420</span></span>|<span data-ttu-id="c3040-426">IBM EBCDIC (アラビア語)</span><span class="sxs-lookup"><span data-stu-id="c3040-426">IBM EBCDIC (Arabic)</span></span>|||
|<span data-ttu-id="c3040-427">20423</span><span class="sxs-lookup"><span data-stu-id="c3040-427">20423</span></span>|<span data-ttu-id="c3040-428">IBM423</span><span class="sxs-lookup"><span data-stu-id="c3040-428">IBM423</span></span>|<span data-ttu-id="c3040-429">IBM EBCDIC (ギリシャ語)</span><span class="sxs-lookup"><span data-stu-id="c3040-429">IBM EBCDIC (Greek)</span></span>|||
|<span data-ttu-id="c3040-430">20424</span><span class="sxs-lookup"><span data-stu-id="c3040-430">20424</span></span>|<span data-ttu-id="c3040-431">IBM424</span><span class="sxs-lookup"><span data-stu-id="c3040-431">IBM424</span></span>|<span data-ttu-id="c3040-432">IBM EBCDIC (ヘブライ語)</span><span class="sxs-lookup"><span data-stu-id="c3040-432">IBM EBCDIC (Hebrew)</span></span>|||
|<span data-ttu-id="c3040-433">20833</span><span class="sxs-lookup"><span data-stu-id="c3040-433">20833</span></span>|<span data-ttu-id="c3040-434">x-EBCDIC-KoreanExtended</span><span class="sxs-lookup"><span data-stu-id="c3040-434">x-EBCDIC-KoreanExtended</span></span>|<span data-ttu-id="c3040-435">IBM EBCDIC (韓国語拡張)</span><span class="sxs-lookup"><span data-stu-id="c3040-435">IBM EBCDIC (Korean Extended)</span></span>|||
|<span data-ttu-id="c3040-436">20838</span><span class="sxs-lookup"><span data-stu-id="c3040-436">20838</span></span>|<span data-ttu-id="c3040-437">IBM-タイ語</span><span class="sxs-lookup"><span data-stu-id="c3040-437">IBM-Thai</span></span>|<span data-ttu-id="c3040-438">IBM EBCDIC (タイ語)</span><span class="sxs-lookup"><span data-stu-id="c3040-438">IBM EBCDIC (Thai)</span></span>|||
|<span data-ttu-id="c3040-439">20866</span><span class="sxs-lookup"><span data-stu-id="c3040-439">20866</span></span>|<span data-ttu-id="c3040-440">koi8-r</span><span class="sxs-lookup"><span data-stu-id="c3040-440">koi8-r</span></span>|<span data-ttu-id="c3040-441">キリル語 (KOI8-R)</span><span class="sxs-lookup"><span data-stu-id="c3040-441">Cyrillic (KOI8-R)</span></span>|||
|<span data-ttu-id="c3040-442">20871</span><span class="sxs-lookup"><span data-stu-id="c3040-442">20871</span></span>|<span data-ttu-id="c3040-443">IBM871</span><span class="sxs-lookup"><span data-stu-id="c3040-443">IBM871</span></span>|<span data-ttu-id="c3040-444">IBM EBCDIC (アイスランド語)</span><span class="sxs-lookup"><span data-stu-id="c3040-444">IBM EBCDIC (Icelandic)</span></span>|||
|<span data-ttu-id="c3040-445">20880</span><span class="sxs-lookup"><span data-stu-id="c3040-445">20880</span></span>|<span data-ttu-id="c3040-446">IBM880</span><span class="sxs-lookup"><span data-stu-id="c3040-446">IBM880</span></span>|<span data-ttu-id="c3040-447">IBM EBCDIC (キリル文字ロシア語)</span><span class="sxs-lookup"><span data-stu-id="c3040-447">IBM EBCDIC (Cyrillic Russian)</span></span>|||
|<span data-ttu-id="c3040-448">20905</span><span class="sxs-lookup"><span data-stu-id="c3040-448">20905</span></span>|<span data-ttu-id="c3040-449">IBM905</span><span class="sxs-lookup"><span data-stu-id="c3040-449">IBM905</span></span>|<span data-ttu-id="c3040-450">IBM EBCDIC (トルコ語)</span><span class="sxs-lookup"><span data-stu-id="c3040-450">IBM EBCDIC (Turkish)</span></span>|||
|<span data-ttu-id="c3040-451">20924</span><span class="sxs-lookup"><span data-stu-id="c3040-451">20924</span></span>|<span data-ttu-id="c3040-452">IBM00924</span><span class="sxs-lookup"><span data-stu-id="c3040-452">IBM00924</span></span>|<span data-ttu-id="c3040-453">IBM ラテン-1</span><span class="sxs-lookup"><span data-stu-id="c3040-453">IBM Latin-1</span></span>|||
|<span data-ttu-id="c3040-454">20932</span><span class="sxs-lookup"><span data-stu-id="c3040-454">20932</span></span>|<span data-ttu-id="c3040-455">EUC-JP</span><span class="sxs-lookup"><span data-stu-id="c3040-455">EUC-JP</span></span>|<span data-ttu-id="c3040-456">日本語 (JIS 0208-1990 および 0212-1990)</span><span class="sxs-lookup"><span data-stu-id="c3040-456">Japanese (JIS 0208-1990 and 0212-1990)</span></span>|||
|<span data-ttu-id="c3040-457">20936</span><span class="sxs-lookup"><span data-stu-id="c3040-457">20936</span></span>|<span data-ttu-id="c3040-458">x-cp20936</span><span class="sxs-lookup"><span data-stu-id="c3040-458">x-cp20936</span></span>|<span data-ttu-id="c3040-459">簡体字中国語 (GB2312-80)</span><span class="sxs-lookup"><span data-stu-id="c3040-459">Chinese Simplified (GB2312-80)</span></span>|<span data-ttu-id="c3040-460">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-460">✓</span></span>||
|<span data-ttu-id="c3040-461">20949</span><span class="sxs-lookup"><span data-stu-id="c3040-461">20949</span></span>|<span data-ttu-id="c3040-462">x-cp20949</span><span class="sxs-lookup"><span data-stu-id="c3040-462">x-cp20949</span></span>|<span data-ttu-id="c3040-463">韓国 Korean-wansung-unicode</span><span class="sxs-lookup"><span data-stu-id="c3040-463">Korean Wansung</span></span>|<span data-ttu-id="c3040-464">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-464">✓</span></span>||
|<span data-ttu-id="c3040-465">21025</span><span class="sxs-lookup"><span data-stu-id="c3040-465">21025</span></span>|<span data-ttu-id="c3040-466">cp1025</span><span class="sxs-lookup"><span data-stu-id="c3040-466">cp1025</span></span>|<span data-ttu-id="c3040-467">IBM EBCDIC (キリル語セルビア-ブルガリア)</span><span class="sxs-lookup"><span data-stu-id="c3040-467">IBM EBCDIC (Cyrillic Serbian-Bulgarian)</span></span>|||
|<span data-ttu-id="c3040-468">21866</span><span class="sxs-lookup"><span data-stu-id="c3040-468">21866</span></span>|<span data-ttu-id="c3040-469">koi8-u</span><span class="sxs-lookup"><span data-stu-id="c3040-469">koi8-u</span></span>|<span data-ttu-id="c3040-470">キリル語 (KOI8-U)</span><span class="sxs-lookup"><span data-stu-id="c3040-470">Cyrillic (KOI8-U)</span></span>|||
|<span data-ttu-id="c3040-471">28591</span><span class="sxs-lookup"><span data-stu-id="c3040-471">28591</span></span>|<span data-ttu-id="c3040-472">iso-8859-1</span><span class="sxs-lookup"><span data-stu-id="c3040-472">iso-8859-1</span></span>|<span data-ttu-id="c3040-473">西ヨーロッパ言語 (ISO)</span><span class="sxs-lookup"><span data-stu-id="c3040-473">Western European (ISO)</span></span>|<span data-ttu-id="c3040-474">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-474">✓</span></span>|<span data-ttu-id="c3040-475">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-475">✓</span></span>|
|<span data-ttu-id="c3040-476">28592</span><span class="sxs-lookup"><span data-stu-id="c3040-476">28592</span></span>|<span data-ttu-id="c3040-477">iso-8859-2</span><span class="sxs-lookup"><span data-stu-id="c3040-477">iso-8859-2</span></span>|<span data-ttu-id="c3040-478">中央ヨーロッパ言語 (ISO)</span><span class="sxs-lookup"><span data-stu-id="c3040-478">Central European (ISO)</span></span>|||
|<span data-ttu-id="c3040-479">28593</span><span class="sxs-lookup"><span data-stu-id="c3040-479">28593</span></span>|<span data-ttu-id="c3040-480">iso-8859-3</span><span class="sxs-lookup"><span data-stu-id="c3040-480">iso-8859-3</span></span>|<span data-ttu-id="c3040-481">ラテン 3 (ISO)</span><span class="sxs-lookup"><span data-stu-id="c3040-481">Latin 3 (ISO)</span></span>|||
|<span data-ttu-id="c3040-482">28594</span><span class="sxs-lookup"><span data-stu-id="c3040-482">28594</span></span>|<span data-ttu-id="c3040-483">iso-8859-4</span><span class="sxs-lookup"><span data-stu-id="c3040-483">iso-8859-4</span></span>|<span data-ttu-id="c3040-484">バルト語 (ISO)</span><span class="sxs-lookup"><span data-stu-id="c3040-484">Baltic (ISO)</span></span>|||
|<span data-ttu-id="c3040-485">28595</span><span class="sxs-lookup"><span data-stu-id="c3040-485">28595</span></span>|<span data-ttu-id="c3040-486">iso-8859-5</span><span class="sxs-lookup"><span data-stu-id="c3040-486">iso-8859-5</span></span>|<span data-ttu-id="c3040-487">キリル語 (ISO)</span><span class="sxs-lookup"><span data-stu-id="c3040-487">Cyrillic (ISO)</span></span>|||
|<span data-ttu-id="c3040-488">28596</span><span class="sxs-lookup"><span data-stu-id="c3040-488">28596</span></span>|<span data-ttu-id="c3040-489">iso-8859-6</span><span class="sxs-lookup"><span data-stu-id="c3040-489">iso-8859-6</span></span>|<span data-ttu-id="c3040-490">アラビア語 (ISO)</span><span class="sxs-lookup"><span data-stu-id="c3040-490">Arabic (ISO)</span></span>|||
|<span data-ttu-id="c3040-491">28597</span><span class="sxs-lookup"><span data-stu-id="c3040-491">28597</span></span>|<span data-ttu-id="c3040-492">iso-8859-7</span><span class="sxs-lookup"><span data-stu-id="c3040-492">iso-8859-7</span></span>|<span data-ttu-id="c3040-493">ギリシャ語 (ISO)</span><span class="sxs-lookup"><span data-stu-id="c3040-493">Greek (ISO)</span></span>|||
|<span data-ttu-id="c3040-494">28598</span><span class="sxs-lookup"><span data-stu-id="c3040-494">28598</span></span>|<span data-ttu-id="c3040-495">iso-8859-8</span><span class="sxs-lookup"><span data-stu-id="c3040-495">iso-8859-8</span></span>|<span data-ttu-id="c3040-496">ヘブライ語 (ISO-Visual)</span><span class="sxs-lookup"><span data-stu-id="c3040-496">Hebrew (ISO-Visual)</span></span>|<span data-ttu-id="c3040-497">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-497">✓</span></span>||
|<span data-ttu-id="c3040-498">28599</span><span class="sxs-lookup"><span data-stu-id="c3040-498">28599</span></span>|<span data-ttu-id="c3040-499">iso-8859-9</span><span class="sxs-lookup"><span data-stu-id="c3040-499">iso-8859-9</span></span>|<span data-ttu-id="c3040-500">トルコ語 (ISO)</span><span class="sxs-lookup"><span data-stu-id="c3040-500">Turkish (ISO)</span></span>|||
|<span data-ttu-id="c3040-501">28603</span><span class="sxs-lookup"><span data-stu-id="c3040-501">28603</span></span>|<span data-ttu-id="c3040-502">iso-8859-13</span><span class="sxs-lookup"><span data-stu-id="c3040-502">iso-8859-13</span></span>|<span data-ttu-id="c3040-503">エストニア語 (ISO)</span><span class="sxs-lookup"><span data-stu-id="c3040-503">Estonian (ISO)</span></span>|||
|<span data-ttu-id="c3040-504">28605</span><span class="sxs-lookup"><span data-stu-id="c3040-504">28605</span></span>|<span data-ttu-id="c3040-505">iso-8859-15</span><span class="sxs-lookup"><span data-stu-id="c3040-505">iso-8859-15</span></span>|<span data-ttu-id="c3040-506">ラテン 9 (ISO)</span><span class="sxs-lookup"><span data-stu-id="c3040-506">Latin 9 (ISO)</span></span>|||
|<span data-ttu-id="c3040-507">29001</span><span class="sxs-lookup"><span data-stu-id="c3040-507">29001</span></span>|<span data-ttu-id="c3040-508">x-Europa</span><span class="sxs-lookup"><span data-stu-id="c3040-508">x-Europa</span></span>|<span data-ttu-id="c3040-509">Europa</span><span class="sxs-lookup"><span data-stu-id="c3040-509">Europa</span></span>|||
|<span data-ttu-id="c3040-510">38598</span><span class="sxs-lookup"><span data-stu-id="c3040-510">38598</span></span>|<span data-ttu-id="c3040-511">iso-8859-8-i</span><span class="sxs-lookup"><span data-stu-id="c3040-511">iso-8859-8-i</span></span>|<span data-ttu-id="c3040-512">ヘブライ語 (ISO-論理)</span><span class="sxs-lookup"><span data-stu-id="c3040-512">Hebrew (ISO-Logical)</span></span>|<span data-ttu-id="c3040-513">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-513">✓</span></span>||
|<span data-ttu-id="c3040-514">50220</span><span class="sxs-lookup"><span data-stu-id="c3040-514">50220</span></span>|<span data-ttu-id="c3040-515">iso-2022-jp</span><span class="sxs-lookup"><span data-stu-id="c3040-515">iso-2022-jp</span></span>|<span data-ttu-id="c3040-516">日本語 (JIS)</span><span class="sxs-lookup"><span data-stu-id="c3040-516">Japanese (JIS)</span></span>|<span data-ttu-id="c3040-517">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-517">✓</span></span>||
|<span data-ttu-id="c3040-518">50221</span><span class="sxs-lookup"><span data-stu-id="c3040-518">50221</span></span>|<span data-ttu-id="c3040-519">csISO2022JP</span><span class="sxs-lookup"><span data-stu-id="c3040-519">csISO2022JP</span></span>|<span data-ttu-id="c3040-520">日本語 (JIS-1 バイトカタカナを許可)</span><span class="sxs-lookup"><span data-stu-id="c3040-520">Japanese (JIS-Allow 1 byte Kana)</span></span>|<span data-ttu-id="c3040-521">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-521">✓</span></span>||
|<span data-ttu-id="c3040-522">50222</span><span class="sxs-lookup"><span data-stu-id="c3040-522">50222</span></span>|<span data-ttu-id="c3040-523">iso-2022-jp</span><span class="sxs-lookup"><span data-stu-id="c3040-523">iso-2022-jp</span></span>|<span data-ttu-id="c3040-524">日本語 (JIS-1 バイトカタカナを許可する-SO/SI)</span><span class="sxs-lookup"><span data-stu-id="c3040-524">Japanese (JIS-Allow 1 byte Kana - SO/SI)</span></span>|<span data-ttu-id="c3040-525">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-525">✓</span></span>||
|<span data-ttu-id="c3040-526">50225</span><span class="sxs-lookup"><span data-stu-id="c3040-526">50225</span></span>|<span data-ttu-id="c3040-527">iso-2022-韓国</span><span class="sxs-lookup"><span data-stu-id="c3040-527">iso-2022-kr</span></span>|<span data-ttu-id="c3040-528">韓国語 (ISO)</span><span class="sxs-lookup"><span data-stu-id="c3040-528">Korean (ISO)</span></span>|<span data-ttu-id="c3040-529">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-529">✓</span></span>||
|<span data-ttu-id="c3040-530">50227</span><span class="sxs-lookup"><span data-stu-id="c3040-530">50227</span></span>|<span data-ttu-id="c3040-531">x-cp50227</span><span class="sxs-lookup"><span data-stu-id="c3040-531">x-cp50227</span></span>|<span data-ttu-id="c3040-532">簡体字中国語 (ISO-2022)</span><span class="sxs-lookup"><span data-stu-id="c3040-532">Chinese Simplified (ISO-2022)</span></span>|<span data-ttu-id="c3040-533">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-533">✓</span></span>||
|<span data-ttu-id="c3040-534">51932</span><span class="sxs-lookup"><span data-stu-id="c3040-534">51932</span></span>|<span data-ttu-id="c3040-535">euc-jp</span><span class="sxs-lookup"><span data-stu-id="c3040-535">euc-jp</span></span>|<span data-ttu-id="c3040-536">日本語 (EUC)</span><span class="sxs-lookup"><span data-stu-id="c3040-536">Japanese (EUC)</span></span>|<span data-ttu-id="c3040-537">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-537">✓</span></span>||
|<span data-ttu-id="c3040-538">51936</span><span class="sxs-lookup"><span data-stu-id="c3040-538">51936</span></span>|<span data-ttu-id="c3040-539">EUC-CN</span><span class="sxs-lookup"><span data-stu-id="c3040-539">EUC-CN</span></span>|<span data-ttu-id="c3040-540">簡体字中国語 (EUC)</span><span class="sxs-lookup"><span data-stu-id="c3040-540">Chinese Simplified (EUC)</span></span>|<span data-ttu-id="c3040-541">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-541">✓</span></span>||
|<span data-ttu-id="c3040-542">51949</span><span class="sxs-lookup"><span data-stu-id="c3040-542">51949</span></span>|<span data-ttu-id="c3040-543">euc-韓国</span><span class="sxs-lookup"><span data-stu-id="c3040-543">euc-kr</span></span>|<span data-ttu-id="c3040-544">韓国語 (EUC)</span><span class="sxs-lookup"><span data-stu-id="c3040-544">Korean (EUC)</span></span>|<span data-ttu-id="c3040-545">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-545">✓</span></span>||
|<span data-ttu-id="c3040-546">52936</span><span class="sxs-lookup"><span data-stu-id="c3040-546">52936</span></span>|<span data-ttu-id="c3040-547">hz-gb-2312</span><span class="sxs-lookup"><span data-stu-id="c3040-547">hz-gb-2312</span></span>|<span data-ttu-id="c3040-548">簡体字中国語 (HZ)</span><span class="sxs-lookup"><span data-stu-id="c3040-548">Chinese Simplified (HZ)</span></span>|<span data-ttu-id="c3040-549">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-549">✓</span></span>||
|<span data-ttu-id="c3040-550">54936</span><span class="sxs-lookup"><span data-stu-id="c3040-550">54936</span></span>|<span data-ttu-id="c3040-551">GB18030</span><span class="sxs-lookup"><span data-stu-id="c3040-551">GB18030</span></span>|<span data-ttu-id="c3040-552">簡体字中国語 (GB18030)</span><span class="sxs-lookup"><span data-stu-id="c3040-552">Chinese Simplified (GB18030)</span></span>|<span data-ttu-id="c3040-553">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-553">✓</span></span>||
|<span data-ttu-id="c3040-554">57002</span><span class="sxs-lookup"><span data-stu-id="c3040-554">57002</span></span>|<span data-ttu-id="c3040-555">x-iscii-de</span><span class="sxs-lookup"><span data-stu-id="c3040-555">x-iscii-de</span></span>|<span data-ttu-id="c3040-556">ISCII デバナガリ文字</span><span class="sxs-lookup"><span data-stu-id="c3040-556">ISCII Devanagari</span></span>|<span data-ttu-id="c3040-557">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-557">✓</span></span>||
|<span data-ttu-id="c3040-558">57003</span><span class="sxs-lookup"><span data-stu-id="c3040-558">57003</span></span>|<span data-ttu-id="c3040-559">x-iscii-be</span><span class="sxs-lookup"><span data-stu-id="c3040-559">x-iscii-be</span></span>|<span data-ttu-id="c3040-560">ISCII ベンガル語</span><span class="sxs-lookup"><span data-stu-id="c3040-560">ISCII Bengali</span></span>|<span data-ttu-id="c3040-561">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-561">✓</span></span>||
|<span data-ttu-id="c3040-562">57004</span><span class="sxs-lookup"><span data-stu-id="c3040-562">57004</span></span>|<span data-ttu-id="c3040-563">x-iscii-ta</span><span class="sxs-lookup"><span data-stu-id="c3040-563">x-iscii-ta</span></span>|<span data-ttu-id="c3040-564">ISCII タミール語</span><span class="sxs-lookup"><span data-stu-id="c3040-564">ISCII Tamil</span></span>|<span data-ttu-id="c3040-565">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-565">✓</span></span>||
|<span data-ttu-id="c3040-566">57005</span><span class="sxs-lookup"><span data-stu-id="c3040-566">57005</span></span>|<span data-ttu-id="c3040-567">x-iscii-te</span><span class="sxs-lookup"><span data-stu-id="c3040-567">x-iscii-te</span></span>|<span data-ttu-id="c3040-568">ISCII テルグ語</span><span class="sxs-lookup"><span data-stu-id="c3040-568">ISCII Telugu</span></span>|<span data-ttu-id="c3040-569">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-569">✓</span></span>||
|<span data-ttu-id="c3040-570">57006</span><span class="sxs-lookup"><span data-stu-id="c3040-570">57006</span></span>|<span data-ttu-id="c3040-571">x-iscii-as</span><span class="sxs-lookup"><span data-stu-id="c3040-571">x-iscii-as</span></span>|<span data-ttu-id="c3040-572">ISCII アッサム語</span><span class="sxs-lookup"><span data-stu-id="c3040-572">ISCII Assamese</span></span>|<span data-ttu-id="c3040-573">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-573">✓</span></span>||
|<span data-ttu-id="c3040-574">57007</span><span class="sxs-lookup"><span data-stu-id="c3040-574">57007</span></span>|<span data-ttu-id="c3040-575">x-iscii-または</span><span class="sxs-lookup"><span data-stu-id="c3040-575">x-iscii-or</span></span>|<span data-ttu-id="c3040-576">ISCII オリヤー語</span><span class="sxs-lookup"><span data-stu-id="c3040-576">ISCII Oriya</span></span>|<span data-ttu-id="c3040-577">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-577">✓</span></span>||
|<span data-ttu-id="c3040-578">57008</span><span class="sxs-lookup"><span data-stu-id="c3040-578">57008</span></span>|<span data-ttu-id="c3040-579">x-iscii-ka</span><span class="sxs-lookup"><span data-stu-id="c3040-579">x-iscii-ka</span></span>|<span data-ttu-id="c3040-580">ISCII カンナダ語</span><span class="sxs-lookup"><span data-stu-id="c3040-580">ISCII Kannada</span></span>|<span data-ttu-id="c3040-581">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-581">✓</span></span>||
|<span data-ttu-id="c3040-582">57009</span><span class="sxs-lookup"><span data-stu-id="c3040-582">57009</span></span>|<span data-ttu-id="c3040-583">x-iscii-ma</span><span class="sxs-lookup"><span data-stu-id="c3040-583">x-iscii-ma</span></span>|<span data-ttu-id="c3040-584">ISCII マラヤーラム語</span><span class="sxs-lookup"><span data-stu-id="c3040-584">ISCII Malayalam</span></span>|<span data-ttu-id="c3040-585">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-585">✓</span></span>||
|<span data-ttu-id="c3040-586">57010</span><span class="sxs-lookup"><span data-stu-id="c3040-586">57010</span></span>|<span data-ttu-id="c3040-587">x-iscii-gu</span><span class="sxs-lookup"><span data-stu-id="c3040-587">x-iscii-gu</span></span>|<span data-ttu-id="c3040-588">ISCII グジャラート語</span><span class="sxs-lookup"><span data-stu-id="c3040-588">ISCII Gujarati</span></span>|<span data-ttu-id="c3040-589">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-589">✓</span></span>||
|<span data-ttu-id="c3040-590">57011</span><span class="sxs-lookup"><span data-stu-id="c3040-590">57011</span></span>|<span data-ttu-id="c3040-591">x-iscii-pa</span><span class="sxs-lookup"><span data-stu-id="c3040-591">x-iscii-pa</span></span>|<span data-ttu-id="c3040-592">ISCII パンジャブ語</span><span class="sxs-lookup"><span data-stu-id="c3040-592">ISCII Punjabi</span></span>|<span data-ttu-id="c3040-593">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-593">✓</span></span>||
|<span data-ttu-id="c3040-594">65000</span><span class="sxs-lookup"><span data-stu-id="c3040-594">65000</span></span>|<span data-ttu-id="c3040-595">utf-7</span><span class="sxs-lookup"><span data-stu-id="c3040-595">utf-7</span></span>|<span data-ttu-id="c3040-596">Unicode (UTF-7)</span><span class="sxs-lookup"><span data-stu-id="c3040-596">Unicode (UTF-7)</span></span>|<span data-ttu-id="c3040-597">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-597">✓</span></span>|<span data-ttu-id="c3040-598">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-598">✓</span></span>|
|<span data-ttu-id="c3040-599">65001</span><span class="sxs-lookup"><span data-stu-id="c3040-599">65001</span></span>|<span data-ttu-id="c3040-600">utf-8</span><span class="sxs-lookup"><span data-stu-id="c3040-600">utf-8</span></span>|<span data-ttu-id="c3040-601">Unicode (UTF-8)</span><span class="sxs-lookup"><span data-stu-id="c3040-601">Unicode (UTF-8)</span></span>|<span data-ttu-id="c3040-602">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-602">✓</span></span>|<span data-ttu-id="c3040-603">✓</span><span class="sxs-lookup"><span data-stu-id="c3040-603">✓</span></span>|

 <span data-ttu-id="c3040-604">次の例では、<xref:System.Text.Encoding.GetEncoding%28System.Int32%29> および <xref:System.Text.Encoding.GetEncoding%28System.String%29> メソッドを呼び出して、ギリシャ語 (Windows) のコードページエンコーディングを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-604">The following example calls the <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> and <xref:System.Text.Encoding.GetEncoding%28System.String%29> methods to get the Greek (Windows) code page encoding.</span></span> <span data-ttu-id="c3040-605">メソッド呼び出しによって返された <xref:System.Text.Encoding> オブジェクトを比較して、それらが等しいことを示します。その後、マップされたオブジェクトは、ギリシャ語アルファベットの各文字について、Unicode コードポイントとそれに対応するコードページ値を表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-605">It compares the <xref:System.Text.Encoding> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet.</span></span>

 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]

 <span data-ttu-id="c3040-606">変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-606">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-607">UTF-16 および 32 UTF-8 エンコーダーでは、ビッグエンディアンバイト順 (最初に最上位バイト) またはリトルエンディアンバイト順 (最初に最下位バイト) を使用できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-607">The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first).</span></span> <span data-ttu-id="c3040-608">たとえば、ラテン文字の A (U + 0041 という) は、次のようにシリアル化されます (16 進数)。</span><span class="sxs-lookup"><span data-stu-id="c3040-608">For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal):</span></span>

-   <span data-ttu-id="c3040-609">UTF-16 ビッグエンディアンバイト順:00 41</span><span class="sxs-lookup"><span data-stu-id="c3040-609">UTF-16 big endian byte order: 00 41</span></span>

-   <span data-ttu-id="c3040-610">UTF-16 リトルエンディアンバイト順:41 00</span><span class="sxs-lookup"><span data-stu-id="c3040-610">UTF-16 little endian byte order: 41 00</span></span>

-   <span data-ttu-id="c3040-611">32 UTF-8 ビッグエンディアンバイト順:00 00 00 41</span><span class="sxs-lookup"><span data-stu-id="c3040-611">UTF-32 big endian byte order: 00 00 00 41</span></span>

-   <span data-ttu-id="c3040-612">32 UTF-8 リトルエンディアンバイト順:41 00 00 00</span><span class="sxs-lookup"><span data-stu-id="c3040-612">UTF-32 little endian byte order: 41 00 00 00</span></span>

 <span data-ttu-id="c3040-613">一般に、ネイティブバイト順序を使用して Unicode 文字を格納する方が効率的です。</span><span class="sxs-lookup"><span data-stu-id="c3040-613">It is generally more efficient to store Unicode characters using the native byte order.</span></span> <span data-ttu-id="c3040-614">たとえば、Intel コンピューターなどのリトルエンディアンプラットフォームでは、リトルエンディアンのバイト順を使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-614">For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</span></span>

 <span data-ttu-id="c3040-615"><xref:System.Text.Encoding.GetPreamble%2A> メソッドは、バイトオーダーマーク (BOM) を含むバイト配列を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-615">The <xref:System.Text.Encoding.GetPreamble%2A> method retrieves an array of bytes that includes the byte order mark (BOM).</span></span> <span data-ttu-id="c3040-616">このバイト配列の先頭にエンコード済みストリームがある場合は、デコーダーが使用するエンコード形式を識別するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="c3040-616">If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.</span></span>

 <span data-ttu-id="c3040-617">バイト順とバイト順マークの詳細については、unicode[ホームページ](https://go.microsoft.com/fwlink/?LinkId=37123)の unicode 標準を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-617">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).</span></span>

 <span data-ttu-id="c3040-618">エンコーディングクラスでは、次のようなエラーが発生することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-618">Note that the encoding classes allow errors to:</span></span>

-   <span data-ttu-id="c3040-619">"?" 文字に自動的に変更されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-619">Silently change to a "?" character.</span></span>

-   <span data-ttu-id="c3040-620">"最適" の文字を使用します。</span><span class="sxs-lookup"><span data-stu-id="c3040-620">Use a "best fit" character.</span></span>

-   <span data-ttu-id="c3040-621">U + FFFD Unicode の置換文字で <xref:System.Text.EncoderFallback> クラスと <xref:System.Text.DecoderFallback> クラスを使用して、アプリケーション固有の動作に変更します。</span><span class="sxs-lookup"><span data-stu-id="c3040-621">Change to an application-specific behavior through use of the <xref:System.Text.EncoderFallback> and <xref:System.Text.DecoderFallback> classes with the U+FFFD Unicode replacement character.</span></span>

 <span data-ttu-id="c3040-622">データストリームエラーが発生した場合は、例外をスローする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-622">You should throw an exception on any data stream error.</span></span> <span data-ttu-id="c3040-623">アプリは、該当する場合に "throwonerror" フラグを使用するか、<xref:System.Text.EncoderExceptionFallback> クラスと <xref:System.Text.DecoderExceptionFallback> クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3040-623">An app either uses a "throwonerror" flag when applicable or uses the <xref:System.Text.EncoderExceptionFallback> and <xref:System.Text.DecoderExceptionFallback> classes.</span></span> <span data-ttu-id="c3040-624">ベストフィットフォールバックは、データの損失や混乱を招く可能性があり、単純な文字交換よりも低速になる可能性があるため、推奨されません。</span><span class="sxs-lookup"><span data-stu-id="c3040-624">Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements.</span></span> <span data-ttu-id="c3040-625">ANSI エンコーディングの場合、最適な動作は既定値です。</span><span class="sxs-lookup"><span data-stu-id="c3040-625">For ANSI encodings, the best fit behavior is the default.</span></span>



## Examples
 <span data-ttu-id="c3040-626">次の例では、あるエンコードから別のエンコーディングに文字列を変換します。</span><span class="sxs-lookup"><span data-stu-id="c3040-626">The following example converts a string from one encoding to another.</span></span>

> [!NOTE]
>  <span data-ttu-id="c3040-627">Byte [] 配列は、エンコードされたデータを含むこの例の唯一の型です。</span><span class="sxs-lookup"><span data-stu-id="c3040-627">The byte[] array is the only type in this example that contains the encoded data.</span></span> <span data-ttu-id="c3040-628">.NET の Char 型と String 型はそれ自体が Unicode であるため、<xref:System.Text.Encoding.GetChars%2A> の呼び出しによってデータが Unicode にデコードされます。</span><span class="sxs-lookup"><span data-stu-id="c3040-628">The .NET Char and String types are themselves Unicode, so the <xref:System.Text.Encoding.GetChars%2A> call decodes the data back to Unicode.</span></span>

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-629">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-629">Understanding Encodings</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c3040-630"><see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="c3040-630">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c3040-631"><see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="c3040-631">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-632">派生クラスは、このコンストラクターをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="c3040-632">Derived classes override this constructor.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage"><span data-ttu-id="c3040-633">使用するエンコーディングのコード ページ ID。</span><span class="sxs-lookup"><span data-stu-id="c3040-633">The code page identifier of the preferred encoding.</span></span>

 <span data-ttu-id="c3040-634">または</span><span class="sxs-lookup"><span data-stu-id="c3040-634">-or-</span></span>

 <span data-ttu-id="c3040-635">既定のエンコーディングを使用する場合は 0。</span><span class="sxs-lookup"><span data-stu-id="c3040-635">0, to use the default encoding.</span></span></param>
        <summary><span data-ttu-id="c3040-636">指定したコード ページに対応する <see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="c3040-636">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-637">派生クラスは、このコンストラクターをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="c3040-637">Derived classes override this constructor.</span></span>

 <span data-ttu-id="c3040-638">派生クラスからこのコンストラクターを呼び出すと、エンコード操作とデコード操作の両方に最適フォールバックを使用する <xref:System.Text.Encoding> オブジェクトが作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-638">Calls to this constructor from a derived class create an <xref:System.Text.Encoding> object that uses best-fit fallback for both encoding and decoding operations.</span></span> <span data-ttu-id="c3040-639"><xref:System.Text.Encoding.DecoderFallback%2A> と <xref:System.Text.Encoding.EncoderFallback%2A> の両方のプロパティは読み取り専用であり、変更することはできません。</span><span class="sxs-lookup"><span data-stu-id="c3040-639">Both the <xref:System.Text.Encoding.DecoderFallback%2A> and <xref:System.Text.Encoding.EncoderFallback%2A> properties are read-only and cannot be modified.</span></span> <span data-ttu-id="c3040-640"><xref:System.Text.Encoding>から派生したクラスのフォールバックストラテジを制御するには、<xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> コンストラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-640">To control the fallback strategy for a class derived from <xref:System.Text.Encoding>, call the <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructor.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-641"><paramref name="codePage" /> に 0 より小さい値が指定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-641"><paramref name="codePage" /> is less than zero.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage"><span data-ttu-id="c3040-642">エンコーディングのコード ページ ID。</span><span class="sxs-lookup"><span data-stu-id="c3040-642">The encoding code page identifier.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="c3040-643">現在のエンコーディングで文字をエンコードできない場合にエラー処理プロシージャを提供するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="c3040-643">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="c3040-644">現在のエンコーディングでバイト シーケンスをデコードできない場合にエラー処理プロシージャを提供するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="c3040-644">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="c3040-645">指定したコード ページに対応する <see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを、指定したエンコーダーとデコーダーのフォールバック方法を使用して初期化します。</span><span class="sxs-lookup"><span data-stu-id="c3040-645">Initializes a new instance of the <see cref="T:System.Text.Encoding" /> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-646">このコンストラクターは `protected`です。派生クラスはこれをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="c3040-646">This constructor is `protected`; derived classes override it.</span></span>

 <span data-ttu-id="c3040-647">派生クラスからこのコンストラクターを呼び出して、フォールバックエンコードおよびデコード戦略を制御します。</span><span class="sxs-lookup"><span data-stu-id="c3040-647">You call this constructor from a derived class to control the fallback encoding and decoding strategies.</span></span> <span data-ttu-id="c3040-648"><xref:System.Text.Encoding> クラスのコンストラクターは、オブジェクトの作成後にエンコーダーまたはデコーダーのフォールバックを設定できない読み取り専用のエンコーディングオブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="c3040-648">The <xref:System.Text.Encoding> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created.</span></span>

 <span data-ttu-id="c3040-649">`encoderFallback` または `decoderFallback` のいずれかが null の場合は、対応するフォールバックストラテジとして最適フォールバックが使用されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-649">If either `encoderFallback` or `decoderFallback` is null, best-fit fallback is used as the corresponding fallback strategy.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-650"><paramref name="codePage" /> に 0 より小さい値が指定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-650"><paramref name="codePage" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-651">ASCII (7 ビット) 文字セットのエンコーディングを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-651">Gets an encoding for the ASCII (7-bit) character set.</span></span></summary>
        <value><span data-ttu-id="c3040-652">ASCII (7 ビット) 文字セットのエンコーディング。</span><span class="sxs-lookup"><span data-stu-id="c3040-652">An  encoding for the ASCII (7-bit) character set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-653">ASCII 文字は、U + 0000 から U + 007F までの 128 Unicode 文字に制限されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-653">ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.</span></span>

 <span data-ttu-id="c3040-654">アプリの ASCII エンコードを選択するときは、次の点を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-654">When selecting the ASCII encoding for your app, consider the following:</span></span>

-   <span data-ttu-id="c3040-655">Ascii エンコーディングは、通常、ASCII を必要とするプロトコルに適しています。</span><span class="sxs-lookup"><span data-stu-id="c3040-655">The ASCII encoding is usually appropriate for protocols that require ASCII.</span></span>

-   <span data-ttu-id="c3040-656">8ビットエンコード (誤って "ASCII" と呼ばれることもあります) が必要な場合は、ASCII エンコーディングより UTF-8 エンコードを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-656">If you requires 8-bit encoding (which is sometimes incorrectly referred to as "ASCII"), the UTF-8 encoding is recommended over the ASCII encoding.</span></span> <span data-ttu-id="c3040-657">文字が 0-7F の場合、結果は同じですが、UTF-8 を使用すると、表現可能なすべての Unicode 文字を表現できるため、データ損失を回避できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-657">For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable.</span></span> <span data-ttu-id="c3040-658">ASCII エンコーディングには、悪意のある使用を許可する8ビットのあいまいさがあることに注意してください。ただし、UTF-8 エンコーディングでは、8番目のビットのあいまいさが解消されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-658">Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.</span></span>

-   <span data-ttu-id="c3040-659">.NET Framework バージョン2.0 より前では、8番目のビットを無視することで、.NET Framework スプーフィングを許可しています。</span><span class="sxs-lookup"><span data-stu-id="c3040-659">Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit.</span></span> <span data-ttu-id="c3040-660">.NET Framework 2.0 以降では、デコード中に非 ASCII コードポイントがフォールバックします。</span><span class="sxs-lookup"><span data-stu-id="c3040-660">Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.</span></span>

 <span data-ttu-id="c3040-661">このプロパティによって返される <xref:System.Text.ASCIIEncoding> オブジェクトは、アプリに適した動作を持たない場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-661">The <xref:System.Text.ASCIIEncoding> object that is returned by this property might not have the appropriate behavior for your app.</span></span> <span data-ttu-id="c3040-662">この例では、置換フォールバックを使用して、エンコードできない各文字列と、デコードできない各バイトを疑問符 ("?") 文字で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="c3040-662">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="c3040-663">代わりに、次の例に示すように、<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> メソッドを呼び出して、フォールバックが <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>のいずれかである <xref:System.Text.ASCIIEncoding> オブジェクトをインスタンス化することができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-663">Instead, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> method to instantiate an <xref:System.Text.ASCIIEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]



## Examples
 <span data-ttu-id="c3040-664">次の例は、ascii の範囲外にある文字に対する ASCII エンコーディングの効果を示しています。</span><span class="sxs-lookup"><span data-stu-id="c3040-664">The following example demonstrates the effect of the ASCII encoding on characters that are outside the ASCII range.</span></span>

 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-665">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-665">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-666">ビッグ エンディアンのバイト順を使用する UTF-16 形式のエンコーディングを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-666">Gets an encoding for the UTF-16 format that uses the big endian byte order.</span></span></summary>
        <value><span data-ttu-id="c3040-667">ビッグ エンディアンのバイト順を使用する UTF-16 形式のエンコーディング オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="c3040-667">An encoding object for the UTF-16 format that uses the big endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-668">このプロパティによって返される <xref:System.Text.UnicodeEncoding> オブジェクトは、アプリに対して適切な動作を持つことはできません。</span><span class="sxs-lookup"><span data-stu-id="c3040-668">The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="c3040-669">この例では、置換フォールバックを使用して、エンコードできない各文字列と、デコードできない各バイトを疑問符 ("?") 文字で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="c3040-669">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="c3040-670">代わりに、次の例に示すように、<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> コンストラクターを呼び出して、フォールバックが <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>のいずれかであるビッグエンディアン <xref:System.Text.UnicodeEncoding> オブジェクトをインスタンス化することができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-670">Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a big endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]

 <span data-ttu-id="c3040-671">返される <xref:System.Text.UnicodeEncoding> オブジェクトには、<xref:System.Text.Encoding.BodyName%2A>、<xref:System.Text.Encoding.HeaderName%2A>、および <xref:System.Text.Encoding.WebName%2A> プロパティがあり、"unicodeFFFE" という名前が生成されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-671">The returned <xref:System.Text.UnicodeEncoding> object has <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, and <xref:System.Text.Encoding.WebName%2A> properties, which yield the name "unicodeFFFE".</span></span> <span data-ttu-id="c3040-672">UTF-16 ビッグエンディアンバイト順マークは16進 FEFF ですが、"unicodeFFFE" という名前が選択されました。これは、バイト順マークがリトルエンディアン Windows コンピューター上の16進 FFFE として表示されるためです。</span><span class="sxs-lookup"><span data-stu-id="c3040-672">Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name "unicodeFFFE" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.</span></span>



## Examples
 <span data-ttu-id="c3040-673">次の例では、ビッグエンディアンのバイト順を使用して、UTF-16 エンコードを使用してテキストファイルを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="c3040-673">The following example reads a text file with a UTF-16 encoding using the big endian byte order.</span></span>

 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]

 <span data-ttu-id="c3040-674">次の例では、文字配列をエンコードし、文字をエンコードし、結果のバイトを表示するために必要なバイト数を決定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-674">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-675">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-675">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-676">派生クラスでオーバーライドされた場合、メール エージェントの Body タグと共に使用できる現在のエンコーディングの名前を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-676">When overridden in a derived class, gets a name for the current encoding that can be used with mail agent body tags.</span></span></summary>
        <value><span data-ttu-id="c3040-677">メール エージェントの Body タグと共に使用できる、現在の <see cref="T:System.Text.Encoding" /> の名前。</span><span class="sxs-lookup"><span data-stu-id="c3040-677">A name for the current <see cref="T:System.Text.Encoding" /> that can be used with mail agent body tags.</span></span>

<span data-ttu-id="c3040-678">または</span><span class="sxs-lookup"><span data-stu-id="c3040-678">-or-</span></span>

<span data-ttu-id="c3040-679">現在の <see cref="T:System.Text.Encoding" /> が使用できない場合は、空の文字列 ("")。</span><span class="sxs-lookup"><span data-stu-id="c3040-679">An empty string (""), if the current <see cref="T:System.Text.Encoding" /> cannot be used.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-680">本文名のエンコーディングが必要な場合は、<xref:System.Text.Encoding.BodyName%2A> プロパティを使用して <xref:System.Text.Encoding.GetEncoding%2A> を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-680">If you need an encoding for a body name, you should call <xref:System.Text.Encoding.GetEncoding%2A> with the <xref:System.Text.Encoding.BodyName%2A> property.</span></span> <span data-ttu-id="c3040-681">多くの場合、メソッドは、呼び出しに含まれるテストエンコーディングから別のエンコーディングを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-681">Often the method retrieves a different encoding from the test encoding furnished in the call.</span></span> <span data-ttu-id="c3040-682">通常、電子メールアプリケーションのみが、このようなエンコードを取得する必要があります。エンコードを記述する必要があるその他のほとんどのアプリケーションでは、その <xref:System.Text.Encoding.WebName%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-682">Generally only email applications need to retrieve such an encoding; most other applications that need to describe an encoding should use its <xref:System.Text.Encoding.WebName%2A>.</span></span>

 <span data-ttu-id="c3040-683">場合によっては、<xref:System.Text.Encoding.BodyName%2A> プロパティの値は、そのエンコーディングを定義する国際標準に対応します。</span><span class="sxs-lookup"><span data-stu-id="c3040-683">In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding.</span></span> <span data-ttu-id="c3040-684">これは、実装がその標準で完全に準拠しているという意味ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3040-684">This doesn't mean that the implementation complies in full with that standard.</span></span>



## Examples
 <span data-ttu-id="c3040-685">次の例では、各エンコードの異なる名前を取得し、<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>とは異なる1つ以上の名前のエンコーディングを表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-685">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3040-686"><xref:System.Text.Encoding.EncodingName%2A> が表示されますが、比較は行われません。</span><span class="sxs-lookup"><span data-stu-id="c3040-686">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c3040-687">派生クラスでオーバーライドされた場合、現在の <see cref="T:System.Text.Encoding" /> オブジェクトの簡易コピーを作成します。</span><span class="sxs-lookup"><span data-stu-id="c3040-687">When overridden in a derived class, creates a shallow copy of the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <returns><span data-ttu-id="c3040-688">現在の <see cref="T:System.Text.Encoding" /> オブジェクトのコピー。</span><span class="sxs-lookup"><span data-stu-id="c3040-688">A copy of the current <see cref="T:System.Text.Encoding" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-689">元の <xref:System.Text.Encoding> オブジェクトが読み取り専用の場合でも、複製は書き込み可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-689">The clone is writable even if the original <xref:System.Text.Encoding> object is read-only.</span></span> <span data-ttu-id="c3040-690">そのため、複製のプロパティは変更できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-690">Therefore, the properties of the clone can be modified.</span></span>

 <span data-ttu-id="c3040-691">オブジェクトの簡易コピーは、オブジェクトのコピーにすぎません。</span><span class="sxs-lookup"><span data-stu-id="c3040-691">A shallow copy of an object is a copy of the object only.</span></span> <span data-ttu-id="c3040-692">オブジェクトに他のオブジェクトへの参照が含まれている場合、シャローコピーは参照されるオブジェクトのコピーを作成しません。</span><span class="sxs-lookup"><span data-stu-id="c3040-692">If the object contains references to other objects, the shallow copy does not create copies of the referred objects.</span></span> <span data-ttu-id="c3040-693">代わりに、元のオブジェクトを参照します。</span><span class="sxs-lookup"><span data-stu-id="c3040-693">It refers to the original objects instead.</span></span> <span data-ttu-id="c3040-694">これに対し、オブジェクトの詳細コピーでは、オブジェクトのコピーと、そのオブジェクトによって直接または間接的に参照されるすべてのもののコピーが作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-694">In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-695">派生クラスでオーバーライドされた場合、現在の <see cref="T:System.Text.Encoding" /> のコード ページ ID を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-695">When overridden in a derived class, gets the code page identifier of the current <see cref="T:System.Text.Encoding" />.</span></span></summary>
        <value><span data-ttu-id="c3040-696">現在の <see cref="T:System.Text.Encoding" /> のコード ページ ID。</span><span class="sxs-lookup"><span data-stu-id="c3040-696">The code page identifier of the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="c3040-697">次の例では、各エンコードの異なる名前を取得し、<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>とは異なる1つ以上の名前のエンコーディングを表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-697">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3040-698"><xref:System.Text.Encoding.EncodingName%2A> が表示されますが、比較は行われません。</span><span class="sxs-lookup"><span data-stu-id="c3040-698">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c3040-699">バイト配列を、あるエンコーディングから別のエンコーディングに変換します。</span><span class="sxs-lookup"><span data-stu-id="c3040-699">Converts a byte array from one encoding to another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding"><span data-ttu-id="c3040-700"><paramref name="bytes" /> のエンコーディング形式。</span><span class="sxs-lookup"><span data-stu-id="c3040-700">The encoding format of <paramref name="bytes" />.</span></span></param>
        <param name="dstEncoding"><span data-ttu-id="c3040-701">変換後のエンコーディング形式。</span><span class="sxs-lookup"><span data-stu-id="c3040-701">The target encoding format.</span></span></param>
        <param name="bytes"><span data-ttu-id="c3040-702">変換対象のバイト。</span><span class="sxs-lookup"><span data-stu-id="c3040-702">The bytes to convert.</span></span></param>
        <summary><span data-ttu-id="c3040-703">バイト配列全体を、あるエンコーディングから別のエンコーディングに変換します。</span><span class="sxs-lookup"><span data-stu-id="c3040-703">Converts an entire byte array from one encoding to another.</span></span></summary>
        <returns><span data-ttu-id="c3040-704"><see cref="T:System.Byte" /> を <paramref name="bytes" /> から <paramref name="srcEncoding" /> へ変換した結果を格納する <paramref name="dstEncoding" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-704">An array of type <see cref="T:System.Byte" /> containing the results of converting <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="c3040-705">次の例では、Unicode でエンコードされた文字列を ASCII エンコードされた文字列に変換します。</span><span class="sxs-lookup"><span data-stu-id="c3040-705">The following example converts a Unicode-encoded string to an ASCII-encoded string.</span></span> <span data-ttu-id="c3040-706"><xref:System.Text.Encoding.ASCII%2A> プロパティによって返される ASCII エンコードオブジェクトが置換フォールバックを使用し、Pi 文字が ASCII 文字セットの一部ではないため、例の出力が示すように、Pi 文字は疑問符で置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="c3040-706">Because the ASCII encoding object returned by the <xref:System.Text.Encoding.ASCII%2A> property uses replacement fallback and the Pi character is not part of the ASCII character set, the Pi character is replaced with a question mark, as the output from the example shows.</span></span>

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-707"><paramref name="srcEncoding" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-707"><paramref name="srcEncoding" /> is <see langword="null" />.</span></span>

<span data-ttu-id="c3040-708">または</span><span class="sxs-lookup"><span data-stu-id="c3040-708">-or-</span></span>

 <span data-ttu-id="c3040-709"><paramref name="dstEncoding" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-709"><paramref name="dstEncoding" /> is <see langword="null" />.</span></span>

<span data-ttu-id="c3040-710">または</span><span class="sxs-lookup"><span data-stu-id="c3040-710">-or-</span></span>

 <span data-ttu-id="c3040-711"><paramref name="bytes" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-711"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="c3040-712">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-712">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-713">および</span><span class="sxs-lookup"><span data-stu-id="c3040-713">-and-</span></span>

 <span data-ttu-id="c3040-714">**srcEncoding です。**</span><span class="sxs-lookup"><span data-stu-id="c3040-714">**srcEncoding.**</span></span> <span data-ttu-id="c3040-715"><see cref="P:System.Text.Encoding.DecoderFallback" /> は <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-715"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="c3040-716">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-716">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-717">および</span><span class="sxs-lookup"><span data-stu-id="c3040-717">-and-</span></span>

 <span data-ttu-id="c3040-718">**dstEncoding です。**</span><span class="sxs-lookup"><span data-stu-id="c3040-718">**dstEncoding.**</span></span> <span data-ttu-id="c3040-719"><see cref="P:System.Text.Encoding.EncoderFallback" /> は <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-719"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding"><span data-ttu-id="c3040-720">変換前の配列 <paramref name="bytes" /> のエンコーディング。</span><span class="sxs-lookup"><span data-stu-id="c3040-720">The encoding of the source array, <paramref name="bytes" />.</span></span></param>
        <param name="dstEncoding"><span data-ttu-id="c3040-721">変換後の配列のエンコーディング。</span><span class="sxs-lookup"><span data-stu-id="c3040-721">The encoding of the output array.</span></span></param>
        <param name="bytes"><span data-ttu-id="c3040-722">変換対象のバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-722">The array of bytes to convert.</span></span></param>
        <param name="index"><span data-ttu-id="c3040-723">変換対象の <paramref name="bytes" /> の最初の要素を示すインデックス。</span><span class="sxs-lookup"><span data-stu-id="c3040-723">The index of the first element of <paramref name="bytes" /> to convert.</span></span></param>
        <param name="count"><span data-ttu-id="c3040-724">変換するバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-724">The number of bytes to convert.</span></span></param>
        <summary><span data-ttu-id="c3040-725">バイト配列内のバイトの範囲を、あるエンコーディングから別のエンコーディングに変換します。</span><span class="sxs-lookup"><span data-stu-id="c3040-725">Converts a range of bytes in a byte array from one encoding to another.</span></span></summary>
        <returns><span data-ttu-id="c3040-726"><see cref="T:System.Byte" /> に含まれる特定の範囲のバイトを <paramref name="bytes" /> から <paramref name="srcEncoding" /> へ変換した結果が格納されている <paramref name="dstEncoding" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-726">An array of type <see cref="T:System.Byte" /> containing the result of converting a range of bytes in <paramref name="bytes" /> from <paramref name="srcEncoding" /> to <paramref name="dstEncoding" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-727"><paramref name="srcEncoding" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-727"><paramref name="srcEncoding" /> is <see langword="null" />.</span></span>

<span data-ttu-id="c3040-728">または</span><span class="sxs-lookup"><span data-stu-id="c3040-728">-or-</span></span>

 <span data-ttu-id="c3040-729"><paramref name="dstEncoding" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-729"><paramref name="dstEncoding" /> is <see langword="null" />.</span></span>

<span data-ttu-id="c3040-730">または</span><span class="sxs-lookup"><span data-stu-id="c3040-730">-or-</span></span>

 <span data-ttu-id="c3040-731"><paramref name="bytes" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-731"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-732"><paramref name="index" /> および <paramref name="count" /> がバイト配列内の有効範囲を指定していません。</span><span class="sxs-lookup"><span data-stu-id="c3040-732"><paramref name="index" /> and <paramref name="count" /> do not specify a valid range in the byte array.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="c3040-733">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-733">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-734">および</span><span class="sxs-lookup"><span data-stu-id="c3040-734">-and-</span></span>

 <span data-ttu-id="c3040-735">**srcEncoding です。**</span><span class="sxs-lookup"><span data-stu-id="c3040-735">**srcEncoding.**</span></span> <span data-ttu-id="c3040-736"><see cref="P:System.Text.Encoding.DecoderFallback" /> は <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-736"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="c3040-737">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-737">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-738">および</span><span class="sxs-lookup"><span data-stu-id="c3040-738">-and-</span></span>

 <span data-ttu-id="c3040-739">**dstEncoding です。**</span><span class="sxs-lookup"><span data-stu-id="c3040-739">**dstEncoding.**</span></span> <span data-ttu-id="c3040-740"><see cref="P:System.Text.Encoding.EncoderFallback" /> は <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-740"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DecoderFallback As DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-741">現在の <see cref="T:System.Text.DecoderFallback" /> オブジェクトの <see cref="T:System.Text.Encoding" /> オブジェクトを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-741">Gets or sets the <see cref="T:System.Text.DecoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <value><span data-ttu-id="c3040-742">現在の <see cref="T:System.Text.Encoding" /> オブジェクトのデコーダー フォールバック オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="c3040-742">The decoder fallback object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-743"><xref:System.Text.DecoderFallback> オブジェクトは、エンコードされたバイトシーケンスを文字にデコードできない場合に呼び出されるエラーハンドラーを表します。</span><span class="sxs-lookup"><span data-stu-id="c3040-743">The <xref:System.Text.DecoderFallback> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character.</span></span> <span data-ttu-id="c3040-744">次のいずれかのハンドラーの種類がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-744">Any one of the following handler types is supported:</span></span>

-   <span data-ttu-id="c3040-745">最適フォールバックハンドラー。これは、適切な置換文字でデコードできないバイトを置き換えます。</span><span class="sxs-lookup"><span data-stu-id="c3040-745">A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.</span></span>

-   <span data-ttu-id="c3040-746">置換代替ハンドラー。これは、任意の置換文字でデコードできないバイトを置き換えます。</span><span class="sxs-lookup"><span data-stu-id="c3040-746">A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character.</span></span> <span data-ttu-id="c3040-747">.NET には、置換フォールバックハンドラー <xref:System.Text.DecoderFallback>が1つ含まれています。このハンドラーは、既定で、疑問符 ("?") 文字でデコードできないバイトを置き換えます。</span><span class="sxs-lookup"><span data-stu-id="c3040-747">.NET includes one replacement fallback handler, <xref:System.Text.DecoderFallback>, which by default replaces bytes that cannot be decoded with a question mark ("?") character.</span></span>

-   <span data-ttu-id="c3040-748">例外フォールバックハンドラー。バイトをデコードできない場合に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-748">An exception fallback handler, which throws an exception when bytes cannot be decoded.</span></span> <span data-ttu-id="c3040-749">.NET には、1つの例外フォールバックハンドラー <xref:System.Text.DecoderExceptionFallback>が含まれています。これは、バイトをデコードできない場合に <xref:System.Text.DecoderFallbackException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-749">.NET includes one exception fallback handler, <xref:System.Text.DecoderExceptionFallback>, which throws a <xref:System.Text.DecoderFallbackException> when bytes cannot be decoded.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-750">設定操作の値が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-750">The value in a set operation is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c3040-751">現在の <see cref="T:System.Text.Encoding" /> オブジェクトが読み取り専用であるため、値を設定操作に割り当てることができません。</span><span class="sxs-lookup"><span data-stu-id="c3040-751">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</span></span></exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-752">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-752">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-753">この .NET 実装の既定のエンコードを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-753">Gets the default encoding for this .NET implementation.</span></span></summary>
        <value><span data-ttu-id="c3040-754">この .NET 実装の既定のエンコーディング。</span><span class="sxs-lookup"><span data-stu-id="c3040-754">The default encoding for this .NET implementation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!WARNING]
>  <span data-ttu-id="c3040-755">既定では、コンピューターごとに異なるエンコードを使用できます。また、既定のエンコードは、1台のコンピューターで変更できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-755">Different computers can use different encodings as the default, and the default encoding can change on a single computer.</span></span> <span data-ttu-id="c3040-756"><xref:System.Text.Encoding.Default%2A> エンコーディングを使用して、コンピューター間でストリーミングされるデータをエンコードおよびデコードしたり、同じコンピューターで異なる時刻に取得したりすると、そのデータが誤って変換される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-756">If you use the <xref:System.Text.Encoding.Default%2A> encoding to encode and decode data streamed between computers or retrieved at different times on the same computer, it may translate that data incorrectly.</span></span> <span data-ttu-id="c3040-757">また、<xref:System.Text.Encoding.Default%2A> プロパティによって返されるエンコーディングは、最適フォールバックを使用して、サポートされていない文字をコードページでサポートされる文字にマップします。</span><span class="sxs-lookup"><span data-stu-id="c3040-757">In addition, the encoding returned by the <xref:System.Text.Encoding.Default%2A> property uses best-fit fallback to map unsupported characters to characters supported by the code page.</span></span> <span data-ttu-id="c3040-758">このような理由から、既定のエンコードを使用することはお勧めしません。</span><span class="sxs-lookup"><span data-stu-id="c3040-758">For these reasons, using the default encoding is not recommended.</span></span> <span data-ttu-id="c3040-759">エンコードされたバイトが正しくデコードされるようにするには、<xref:System.Text.UTF8Encoding> や <xref:System.Text.UnicodeEncoding>などの Unicode エンコーディングを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-759">To ensure that encoded bytes are decoded properly, you should use a Unicode encoding, such as <xref:System.Text.UTF8Encoding> or <xref:System.Text.UnicodeEncoding>.</span></span> <span data-ttu-id="c3040-760">また、より高いレベルのプロトコルを使用して、エンコードとデコードに同じ形式が使用されるようにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-760">You could also use a higher-level protocol to ensure that the same format is used for encoding and decoding.</span></span>

### <a name="the-default-property-in-the-net-framework"></a><span data-ttu-id="c3040-761">.NET Framework の既定のプロパティ</span><span class="sxs-lookup"><span data-stu-id="c3040-761">The Default property in the .NET Framework</span></span>

<span data-ttu-id="c3040-762">Windows デスクトップの .NET Framework では、<xref:System.Text.Encoding.Default%2A> プロパティは常にシステムのアクティブなコードページを取得し、それに対応する <xref:System.Text.Encoding> オブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="c3040-762">In the .NET Framework on the Windows desktop, the <xref:System.Text.Encoding.Default%2A> property always gets the system's active code page and creates a <xref:System.Text.Encoding> object that corresponds to it.</span></span> <span data-ttu-id="c3040-763">アクティブなコードページには、ASCII 文字セットと、コードページによって異なる追加の文字が含まれる ANSI コードページがあります。</span><span class="sxs-lookup"><span data-stu-id="c3040-763">The active code page may be an ANSI code page, which includes the ASCII character set along with additional characters that vary by code page.</span></span> <span data-ttu-id="c3040-764">ANSI コードページに基づくすべての <xref:System.Text.Encoding.Default%2A> エンコーディングはデータを失うため、代わりに <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> エンコーディングを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-764">Because all <xref:System.Text.Encoding.Default%2A> encodings based on ANSI code pages lose data, consider using the <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> encoding instead.</span></span> <span data-ttu-id="c3040-765">UTF-8 は、多くの場合、U + 00 から U + 7F の範囲で同一ですが、ASCII 範囲外の文字を文字エンコードすることはできません。</span><span class="sxs-lookup"><span data-stu-id="c3040-765">UTF-8 is often identical in the U+00 to U+7F range, but can encode characters outside the ASCII range without loss.</span></span>

## <a name="the-default-property-on-net-core"></a><span data-ttu-id="c3040-766">.NET Core の既定のプロパティ</span><span class="sxs-lookup"><span data-stu-id="c3040-766">The Default property on .NET Core</span></span>

<span data-ttu-id="c3040-767">.NET Core では、<xref:System.Text.Encoding.Default%2A> プロパティは常に <xref:System.Text.UTF8Encoding>を返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-767">On .NET Core, the <xref:System.Text.Encoding.Default%2A> property always returns the <xref:System.Text.UTF8Encoding>.</span></span> <span data-ttu-id="c3040-768">UTF-8 は、.NET Core アプリケーションを実行するすべてのオペレーティングシステム (Windows、Linux、および最大 OS X) でサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-768">UTF-8 is supported on all the operating systems (Windows, Linux, and Max OS X) on which .NET Core applications run.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EncoderFallback As EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-769">現在の <see cref="T:System.Text.EncoderFallback" /> オブジェクトの <see cref="T:System.Text.Encoding" /> オブジェクトを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-769">Gets or sets the <see cref="T:System.Text.EncoderFallback" /> object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></summary>
        <value><span data-ttu-id="c3040-770">現在の <see cref="T:System.Text.Encoding" /> オブジェクトのエンコーダー フォールバック オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="c3040-770">The encoder fallback object for the current <see cref="T:System.Text.Encoding" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-771"><xref:System.Text.EncoderFallback> オブジェクトは、文字をエンコード済みバイトシーケンスに変換できない場合に呼び出されるエラーハンドラーを表します。</span><span class="sxs-lookup"><span data-stu-id="c3040-771">The <xref:System.Text.EncoderFallback> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence.</span></span> <span data-ttu-id="c3040-772">次のいずれかのハンドラーの種類がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-772">Any one of the following handler types is supported:</span></span>

-   <span data-ttu-id="c3040-773">最適フォールバックハンドラー。適切な置換文字でエンコードできない文字を置き換えます。</span><span class="sxs-lookup"><span data-stu-id="c3040-773">A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.</span></span>

-   <span data-ttu-id="c3040-774">置換代替ハンドラー。これは、任意の置換文字でエンコードできない文字を置換します。</span><span class="sxs-lookup"><span data-stu-id="c3040-774">A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character.</span></span> <span data-ttu-id="c3040-775">.NET には、置換フォールバックハンドラー <xref:System.Text.EncoderFallback>が1つ含まれています。これは、既定では、疑問符 ("?") 文字でエンコードできない文字を置換します。</span><span class="sxs-lookup"><span data-stu-id="c3040-775">.NET includes one replacement fallback handler, <xref:System.Text.EncoderFallback>, which by default replaces characters that cannot be encoded with a question mark ("?") character.</span></span>

-   <span data-ttu-id="c3040-776">例外フォールバックハンドラー。文字をエンコードできない場合に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-776">An exception fallback handler, which throws an exception when characters cannot be encoded.</span></span> <span data-ttu-id="c3040-777">.NET には、1つの例外フォールバックハンドラー <xref:System.Text.EncoderExceptionFallback>が含まれています。これは、文字をデコードできない場合に <xref:System.Text.EncoderFallbackException> をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-777">.NET includes one exception fallback handler, <xref:System.Text.EncoderExceptionFallback>, which throws an <xref:System.Text.EncoderFallbackException> when characters cannot be decoded.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-778">設定操作の値が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-778">The value in a set operation is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c3040-779">現在の <see cref="T:System.Text.Encoding" /> オブジェクトが読み取り専用であるため、値を設定操作に割り当てることができません。</span><span class="sxs-lookup"><span data-stu-id="c3040-779">A value cannot be assigned in a set operation because the current <see cref="T:System.Text.Encoding" /> object is read-only.</span></span></exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-780">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-780">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-781">派生クラスでオーバーライドされた場合、現在のエンコーディングについての記述を、ユーザーが判読できる形式で取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-781">When overridden in a derived class, gets the human-readable description of the current encoding.</span></span></summary>
        <value><span data-ttu-id="c3040-782">ユーザーが判読できる形式の、現在の <see cref="T:System.Text.Encoding" /> の記述。</span><span class="sxs-lookup"><span data-stu-id="c3040-782">The human-readable description of the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-783"><xref:System.Text.Encoding.EncodingName%2A> プロパティは、表示を目的としています。</span><span class="sxs-lookup"><span data-stu-id="c3040-783">The <xref:System.Text.Encoding.EncodingName%2A> property is intended for display.</span></span> <span data-ttu-id="c3040-784"><xref:System.Text.Encoding.GetEncoding%2A> メソッドに渡すことができる名前を検索するには、<xref:System.Text.Encoding.WebName%2A> プロパティを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3040-784">To find a name that can be passed to the <xref:System.Text.Encoding.GetEncoding%2A> method, use the <xref:System.Text.Encoding.WebName%2A> property.</span></span>



## Examples
 <span data-ttu-id="c3040-785">次の例では、各エンコードの異なる名前を取得し、<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>とは異なる1つ以上の名前のエンコーディングを表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-785">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3040-786"><xref:System.Text.Encoding.EncodingName%2A> が表示されますが、比較は行われません。</span><span class="sxs-lookup"><span data-stu-id="c3040-786">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c3040-787">現在のインスタンスと比較する <see cref="T:System.Object" />。</span><span class="sxs-lookup"><span data-stu-id="c3040-787">The <see cref="T:System.Object" /> to compare with the current instance.</span></span></param>
        <summary><span data-ttu-id="c3040-788">指定した <see cref="T:System.Object" /> が、現在のインスタンスと等しいかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="c3040-788">Determines whether the specified <see cref="T:System.Object" /> is equal to the current instance.</span></span></summary>
        <returns><span data-ttu-id="c3040-789"><see langword="true" /> が <paramref name="value" /> のインスタンスで、現在のインスタンスと等しい場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c3040-789"><see langword="true" /> if <paramref name="value" /> is an instance of <see cref="T:System.Text.Encoding" /> and is equal to the current instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-790"><xref:System.Text.Encoding> の2つのインスタンスが同じコードページに対応しており、その `EncoderFallback` と `DecoderFallback` オブジェクトが等しい場合は、等しいと見なされます。</span><span class="sxs-lookup"><span data-stu-id="c3040-790">Two instances of <xref:System.Text.Encoding> are considered equal if they correspond to the same code page and their `EncoderFallback` and `DecoderFallback` objects are equal.</span></span> <span data-ttu-id="c3040-791">特に、派生コードページのコードページはすべて0で、フォールバックは通常 `null` (Visual Basic .NET では`Nothing`) です。</span><span class="sxs-lookup"><span data-stu-id="c3040-791">In particular, derived code pages all have a code page of 0 and their fallbacks are normally `null` (`Nothing` in Visual Basic .NET).</span></span> <span data-ttu-id="c3040-792">そのため、これらはすべて相互に一致していると見なされます。</span><span class="sxs-lookup"><span data-stu-id="c3040-792">Thus they are all considered equal to one another.</span></span> <span data-ttu-id="c3040-793">結果として、<xref:System.Text.Encoding.Equals%2A> を使用してハッシュテーブルを設定すると、すべての派生エンコーディングが等しいと見なされ、同じハッシュテーブルスロットに分類されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-793">One consequence is that when <xref:System.Text.Encoding.Equals%2A> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.</span></span>



## Examples
 <span data-ttu-id="c3040-794">次の例では、同じエンコードの2つのインスタンス (コードページと名前によって1つ) を取得し、それらが等しいかどうかをチェックします。</span><span class="sxs-lookup"><span data-stu-id="c3040-794">The following example gets two instances of the same encoding (one by codepage and another by name), and checks their equality.</span></span>

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c3040-795">派生クラスでオーバーライドされた場合、文字のセットをエンコードすることによって生成されるバイト数を計算します。</span><span class="sxs-lookup"><span data-stu-id="c3040-795">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="c3040-796">エンコード対象の文字を格納している文字配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-796">The character array containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="c3040-797">派生クラスでオーバーライドされた場合、指定した文字配列に格納されているすべての文字をエンコードすることによって生成されるバイト数を計算します。</span><span class="sxs-lookup"><span data-stu-id="c3040-797">When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.</span></span></summary>
        <returns><span data-ttu-id="c3040-798">指定した文字配列に格納されているすべての文字をエンコードすることによって生成されるバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-798">The number of bytes produced by encoding all the characters in the specified character array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-799"><xref:System.Text.Encoding.GetBytes%2A> が結果のバイトを格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-799">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="c3040-800">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-800">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="c3040-801"><xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-801">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-802"><xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-802">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="c3040-803"><xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-803">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="c3040-804"><xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-804">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="c3040-805">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-805">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-806">アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-806">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="c3040-807">この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-807">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="c3040-808">アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A> メソッドの文字列バージョンを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-808">If your app handles string inputs, you should use the string versions of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>

-   <span data-ttu-id="c3040-809"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-809">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="c3040-810">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-810">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-811">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-811">If your app must convert a large amount of data, you should reuse the output buffer.</span></span> <span data-ttu-id="c3040-812">この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-812">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="c3040-813"><xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-813">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="c3040-814">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-814">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-815">ストリームを連続エンコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-815">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="c3040-816">次の例では、文字配列をエンコードし、文字をエンコードし、結果のバイトを表示するために必要なバイト数を決定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-816">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-817"><paramref name="chars" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-817"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="c3040-818">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-818">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-819">および</span><span class="sxs-lookup"><span data-stu-id="c3040-819">-and-</span></span>

 <span data-ttu-id="c3040-820"><see cref="P:System.Text.Encoding.EncoderFallback" /> は <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-820"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="c3040-821">エンコードする文字のスパン。</span><span class="sxs-lookup"><span data-stu-id="c3040-821">The span of characters to encode.</span></span></param>
        <summary><span data-ttu-id="c3040-822">派生クラスでオーバーライドされた場合、指定した文字スパンに格納されている文字をエンコードすることによって生成されるバイト数を計算します。</span><span class="sxs-lookup"><span data-stu-id="c3040-822">When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified character span.</span></span></summary>
        <returns><span data-ttu-id="c3040-823">指定された文字スパンをエンコードすることによって生成されるバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-823">The number of bytes produced by encoding the specified character span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-824">結果のバイトを格納するために <xref:System.Text.Encoding.GetBytes%2A> で必要とされる正確なスパンサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-824">To calculate the exact span size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="c3040-825">最大スパンサイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-825">To calculate the maximum span size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="c3040-826"><xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-826">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-827"><xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-827">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="c3040-828"><xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-828">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="c3040-829"><xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-829">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="c3040-830">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-830">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-831">アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-831">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="c3040-832">この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-832">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="c3040-833">アプリが文字範囲の入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A> のスパンバージョンを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-833">If your app handles span of characters inputs, the span version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>

-   <span data-ttu-id="c3040-834"><xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-834">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="c3040-835">変換メソッドは、可能な限り多くのデータを変換し、出力スパンバッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-835">The conversion method converts as much data as possible, and does throw an exception if the output span buffer is too small.</span></span> <span data-ttu-id="c3040-836">ストリームを連続エンコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-836">For continuous encoding of a stream, this method is often the best choice.</span></span>
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="c3040-837">エンコード対象の文字のセットを格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="c3040-837">The string containing the set of characters to encode.</span></span></param>
        <summary><span data-ttu-id="c3040-838">派生クラスでオーバーライドされた場合、指定した文字列に含まれる文字をエンコードすることによって生成されるバイト数を計算します。</span><span class="sxs-lookup"><span data-stu-id="c3040-838">When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.</span></span></summary>
        <returns><span data-ttu-id="c3040-839">指定した文字をエンコードすることによって生成されるバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-839">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-840"><xref:System.Text.Encoding.GetBytes%2A> が結果のバイトを格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-840">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="c3040-841">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-841">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="c3040-842"><xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-842">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-843"><xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-843">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="c3040-844"><xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-844">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="c3040-845"><xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-845">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="c3040-846">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-846">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-847">アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-847">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="c3040-848">この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-848">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="c3040-849">アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A> の文字列バージョンを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-849">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>

-   <span data-ttu-id="c3040-850"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-850">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="c3040-851">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-851">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-852">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-852">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-853">この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-853">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="c3040-854"><xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-854">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="c3040-855">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-855">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-856">ストリームを連続エンコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-856">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="c3040-857">次の例では、文字列または文字列の範囲をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-857">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-858"><paramref name="s" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-858"><paramref name="s" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="c3040-859">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-859">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-860">および</span><span class="sxs-lookup"><span data-stu-id="c3040-860">-and-</span></span>

 <span data-ttu-id="c3040-861"><see cref="P:System.Text.Encoding.EncoderFallback" /> は <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-861"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="c3040-862">エンコードする最初の文字へのポインター。</span><span class="sxs-lookup"><span data-stu-id="c3040-862">A pointer to the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="c3040-863">エンコードする文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-863">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="c3040-864">派生クラスでオーバーライドされた場合、指定した文字ポインターから始まる文字のセットをエンコードすることによって生成されるバイト数を計算します。</span><span class="sxs-lookup"><span data-stu-id="c3040-864">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</span></span></summary>
        <returns><span data-ttu-id="c3040-865">指定した文字をエンコードすることによって生成されるバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-865">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-866">結果のバイトを格納するために <xref:System.Text.Encoding.GetBytes%2A> が必要とする配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-866">To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="c3040-867">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-867">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="c3040-868"><xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-868">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-869"><xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> メソッドは実際のエンコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-869">The <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> method performs the actual encoding.</span></span> <span data-ttu-id="c3040-870"><xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-870">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="c3040-871"><xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-871">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="c3040-872">これらのメソッドを使用する際の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-872">The following are some considerations for using these methods:</span></span>

-   <span data-ttu-id="c3040-873">アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-873">Your app may need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="c3040-874">この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-874">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="c3040-875">アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A> メソッドの文字列バージョンを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-875">If your app handles string inputs, you should use the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>

-   <span data-ttu-id="c3040-876"><xref:System.Text.Encoding.GetBytes%2A> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-876">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%2A> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="c3040-877">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-877">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-878">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-878">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-879">この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-879">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="c3040-880"><xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-880">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="c3040-881">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-881">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-882">ストリームを連続エンコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-882">For continuous encoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-883"><paramref name="chars" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-883"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-884"><paramref name="count" /> に 0 より小さい値が指定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-884"><paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="c3040-885">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-885">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-886">および</span><span class="sxs-lookup"><span data-stu-id="c3040-886">-and-</span></span>

 <span data-ttu-id="c3040-887"><see cref="P:System.Text.Encoding.EncoderFallback" /> は <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-887"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="c3040-888">エンコード対象の文字のセットを格納している文字配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-888">The character array containing the set of characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="c3040-889">エンコードする最初の文字のインデックス。</span><span class="sxs-lookup"><span data-stu-id="c3040-889">The index of the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="c3040-890">エンコードする文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-890">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="c3040-891">派生クラスでオーバーライドされた場合、指定した文字配列に格納されている文字のセットをエンコードすることによって生成されるバイト数を計算します。</span><span class="sxs-lookup"><span data-stu-id="c3040-891">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</span></span></summary>
        <returns><span data-ttu-id="c3040-892">指定した文字をエンコードすることによって生成されるバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-892">The number of bytes produced by encoding the specified characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-893"><xref:System.Text.Encoding.GetBytes%2A> が結果のバイトを格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-893">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="c3040-894">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-894">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="c3040-895"><xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-895">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-896"><xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-896">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="c3040-897"><xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-897">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="c3040-898"><xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-898">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="c3040-899">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-899">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-900">アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-900">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="c3040-901">この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-901">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="c3040-902">アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A> の文字列バージョンを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-902">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>

-   <span data-ttu-id="c3040-903"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-903">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="c3040-904">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-904">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-905">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-905">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-906">この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-906">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="c3040-907"><xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-907">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="c3040-908">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-908">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-909">ストリームを連続エンコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-909">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="c3040-910">次の例では、文字配列から3文字をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-910">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-911"><paramref name="chars" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-911"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-912"><paramref name="index" /> または <paramref name="count" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="c3040-912"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="c3040-913">または</span><span class="sxs-lookup"><span data-stu-id="c3040-913">-or-</span></span>

 <span data-ttu-id="c3040-914"><paramref name="index" /> および <paramref name="count" /> は <paramref name="chars" /> において有効な範囲を表していません。</span><span class="sxs-lookup"><span data-stu-id="c3040-914"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="c3040-915">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-915">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-916">および</span><span class="sxs-lookup"><span data-stu-id="c3040-916">-and-</span></span>

 <span data-ttu-id="c3040-917"><see cref="P:System.Text.Encoding.EncoderFallback" /> は <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-917"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="c3040-918">エンコード対象の文字のセットを格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="c3040-918">The string containing the set of characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="c3040-919">エンコードする最初の文字のインデックス。</span><span class="sxs-lookup"><span data-stu-id="c3040-919">The index of the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="c3040-920">エンコードする文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-920">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="c3040-921">派生クラスでオーバーライドされた場合、指定した文字列の文字のセットをエンコードすることによって生成されるバイト数を計算します。</span><span class="sxs-lookup"><span data-stu-id="c3040-921">When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified string.</span></span></summary>
        <returns><span data-ttu-id="c3040-922">文字列をエンコードすることによって生成されるバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-922">The number of bytes produced by encoding the string.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-923"><xref:System.Text.Encoding.GetBytes%2A> が結果のバイトを格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-923">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="c3040-924">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-924">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="c3040-925"><xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-925">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-926"><xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-926">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="c3040-927"><xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-927">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="c3040-928"><xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-928">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="c3040-929">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-929">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-930">アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-930">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="c3040-931">この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-931">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span>

-   <span data-ttu-id="c3040-932">アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A> の文字列バージョンを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-932">If your app handles string inputs, the string version of <xref:System.Text.Encoding.GetBytes%2A> is recommended.</span></span>

-   <span data-ttu-id="c3040-933"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-933">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="c3040-934">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-934">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-935">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-935">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-936">この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-936">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="c3040-937"><xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-937">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="c3040-938">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-938">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-939">ストリームを連続エンコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-939">For continuous encoding of a stream, this method is often the best choice.</span></span>


## Examples
 <span data-ttu-id="c3040-940">次の例では、文字配列から3文字をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-940">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c3040-941">派生クラスでオーバーライドされた場合、文字のセットをバイト シーケンスにエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-941">When overridden in a derived class, encodes a set of characters into a sequence of bytes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="c3040-942">エンコード対象の文字を格納している文字配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-942">The character array containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="c3040-943">派生クラスでオーバーライドされた場合、指定した文字配列に格納されているすべての文字をバイト シーケンスにエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-943">When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="c3040-944">指定した文字のセットをエンコードした結果を格納しているバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-944">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-945">変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-945">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-946"><xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-946">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="c3040-947"><xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-947">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="c3040-948"><xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-948">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="c3040-949">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-949">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-950">アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-950">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="c3040-951">この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-951">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="c3040-952">(たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-952">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="c3040-953"><xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-953">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="c3040-954"><xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。</span><span class="sxs-lookup"><span data-stu-id="c3040-954"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="c3040-955">アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A> メソッドの文字列バージョンを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-955">If your app handles string inputs, you should call the string version of the <xref:System.Text.Encoding.GetBytes%2A> method.</span></span>

-   <span data-ttu-id="c3040-956"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-956">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="c3040-957">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-957">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-958">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-958">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-959">この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-959">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="c3040-960"><xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-960">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="c3040-961">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-961">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-962">ストリームを連続エンコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-962">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="c3040-963">次の例では、文字配列をエンコードし、文字をエンコードし、結果のバイトを表示するために必要なバイト数を決定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-963">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-964"><paramref name="chars" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-964"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="c3040-965">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-965">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-966">および</span><span class="sxs-lookup"><span data-stu-id="c3040-966">-and-</span></span>

 <span data-ttu-id="c3040-967"><see cref="P:System.Text.Encoding.EncoderFallback" /> は <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-967"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="c3040-968">エンコードする文字を含む文字列。</span><span class="sxs-lookup"><span data-stu-id="c3040-968">The string containing the characters to encode.</span></span></param>
        <summary><span data-ttu-id="c3040-969">派生クラスでオーバーライドされた場合、指定した文字列に含まれるすべての文字をバイト シーケンスにエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-969">When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="c3040-970">指定した文字のセットをエンコードした結果を格納しているバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-970">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-971">変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-971">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-972"><xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-972">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="c3040-973"><xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-973">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="c3040-974"><xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-974">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="c3040-975">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-975">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-976">アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-976">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="c3040-977">この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-977">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="c3040-978">(たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-978">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="c3040-979"><xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-979">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="c3040-980"><xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。</span><span class="sxs-lookup"><span data-stu-id="c3040-980"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="c3040-981">アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A>の文字列バージョンを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-981">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="c3040-982"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-982">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="c3040-983">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-983">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-984">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-984">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-985">この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-985">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="c3040-986"><xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-986">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="c3040-987">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-987">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-988">ストリームを連続エンコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-988">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="c3040-989">次の例では、文字列または文字列の範囲をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-989">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-990"><paramref name="s" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-990"><paramref name="s" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="c3040-991">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-991">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-992">および</span><span class="sxs-lookup"><span data-stu-id="c3040-992">-and-</span></span>

 <span data-ttu-id="c3040-993"><see cref="P:System.Text.Encoding.EncoderFallback" /> は <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-993"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="c3040-994">エンコード対象の文字のセットを格納しているスパン。</span><span class="sxs-lookup"><span data-stu-id="c3040-994">The span containing the set of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="c3040-995">エンコードされたバイトを格納するバイト スパン。</span><span class="sxs-lookup"><span data-stu-id="c3040-995">The byte span to hold the encoded bytes.</span></span></param>
        <summary><span data-ttu-id="c3040-996">派生クラスでオーバーライドされた場合、指定した読み取り専用スパンに格納されている文字のセットをバイトのスパンにエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-996">When overridden in a derived class, encodes into a span of bytes a set of characters from the specified read-only span.</span></span></summary>
        <returns><span data-ttu-id="c3040-997">エンコードされたバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-997">The number of encoded bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-998">変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-998">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-999"><xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-999">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="c3040-1000"><xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1000">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="c3040-1001"><xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1001">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="c3040-1002">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1002">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1003">アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1003">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="c3040-1004">この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1004">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="c3040-1005">(たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1005">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="c3040-1006"><xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1006">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="c3040-1007"><xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1007"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="c3040-1008">アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A>の文字列バージョンを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1008">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="c3040-1009">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1009">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1010">この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1010">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="c3040-1011"><xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1011">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="c3040-1012">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1012">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1013">ストリームを連続エンコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1013">For continuous encoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="c3040-1014">エンコード対象の文字のセットを格納している文字配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1014">The character array containing the set of characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="c3040-1015">エンコードする最初の文字のインデックス。</span><span class="sxs-lookup"><span data-stu-id="c3040-1015">The index of the first character to encode.</span></span></param>
        <param name="count"><span data-ttu-id="c3040-1016">エンコードする文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1016">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="c3040-1017">派生クラスでオーバーライドされた場合、指定した文字配列に格納されている文字のセットをバイト シーケンスにエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1017">When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="c3040-1018">指定した文字のセットをエンコードした結果を格納しているバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1018">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1019">変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1019">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-1020"><xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1020">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="c3040-1021"><xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1021">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="c3040-1022"><xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1022">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="c3040-1023">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1023">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1024">アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1024">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="c3040-1025">この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1025">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="c3040-1026">(たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1026">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="c3040-1027"><xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1027">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="c3040-1028"><xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1028"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="c3040-1029">アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A>の文字列バージョンを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1029">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="c3040-1030"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1030">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="c3040-1031">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1031">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-1032">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1032">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1033">この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1033">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="c3040-1034"><xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1034">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="c3040-1035">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1035">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1036">ストリームを連続エンコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1036">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="c3040-1037">次の例では、文字配列から3文字をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1037">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1038"><paramref name="chars" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1038"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1039"><paramref name="index" /> または <paramref name="count" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1039"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="c3040-1040">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1040">-or-</span></span>

 <span data-ttu-id="c3040-1041"><paramref name="index" /> および <paramref name="count" /> は <paramref name="chars" /> において有効な範囲を表していません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1041"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="c3040-1042">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1042">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1043">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1043">-and-</span></span>

 <span data-ttu-id="c3040-1044"><see cref="P:System.Text.Encoding.EncoderFallback" /> は <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1044"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="c3040-1045">エンコードする文字を含む文字列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1045">The string containing the characters to encode.</span></span></param>
        <param name="index"><span data-ttu-id="c3040-1046">エンコードを開始する文字列内のインデックス。</span><span class="sxs-lookup"><span data-stu-id="c3040-1046">The index inside the string to start the encoding from.</span></span></param>
        <param name="count"><span data-ttu-id="c3040-1047">エンコードする文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1047">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="c3040-1048">派生クラスでオーバーライドされた場合、指定した文字列内の <paramref name="count" /> で指定した数の文字を、指定した <paramref name="index" /> からバイト配列にエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1048">When overridden in a derived class, encodes into an array of bytes the number of characters specified by <paramref name="count" /> in the specified string, starting from the specified <paramref name="index" />.</span></span></summary>
        <returns><span data-ttu-id="c3040-1049">指定した文字のセットをエンコードした結果を格納しているバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1049">A byte array containing the results of encoding the specified set of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1050">変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1050">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-1051"><xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1051">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="c3040-1052"><xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1052">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="c3040-1053"><xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1053">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="c3040-1054">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1054">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1055">アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1055">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="c3040-1056">この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1056">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="c3040-1057">(たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1057">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="c3040-1058"><xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1058">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="c3040-1059"><xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1059"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="c3040-1060">アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A>の文字列バージョンを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1060">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="c3040-1061"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1061">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="c3040-1062">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1062">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-1063">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1063">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1064">この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1064">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="c3040-1065"><xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1065">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="c3040-1066">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1066">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1067">ストリームを連続エンコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1067">For continuous encoding of a stream, this method is often the best choice.</span></span>


## Examples
 <span data-ttu-id="c3040-1068">次の例では、文字列または文字列の範囲をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1068">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="c3040-1069">エンコードする最初の文字へのポインター。</span><span class="sxs-lookup"><span data-stu-id="c3040-1069">A pointer to the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="c3040-1070">エンコードする文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1070">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="c3040-1071">結果のバイト シーケンスの書き込みを開始する位置へのポインター。</span><span class="sxs-lookup"><span data-stu-id="c3040-1071">A pointer to the location at which to start writing the resulting sequence of bytes.</span></span></param>
        <param name="byteCount"><span data-ttu-id="c3040-1072">書き込む最大バイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1072">The maximum number of bytes to write.</span></span></param>
        <summary><span data-ttu-id="c3040-1073">派生クラスでオーバーライドされた場合、指定した文字ポインターで始まる文字のセットを、指定したバイト ポインターを開始位置として格納されるバイト シーケンスにエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1073">When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</span></span></summary>
        <returns><span data-ttu-id="c3040-1074"><paramref name="bytes" /> パラメーターによって示される位置に書き込む実際のバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1074">The actual number of bytes written at the location indicated by the <paramref name="bytes" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1075">結果のバイトを格納するために <xref:System.Text.Encoding.GetBytes%2A> が必要とする正確な配列サイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1075">To calculate the exact array size that <xref:System.Text.Encoding.GetBytes%2A> requires to store the resulting bytes, call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="c3040-1076">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1076">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="c3040-1077"><xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1077">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-1078">変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>オブジェクト、によって提供される<xref:System.Text.Encoding.GetDecoder%2A>または<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1078">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-1079"><xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1079">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="c3040-1080"><xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1080">The <xref:System.Text.Encoding.GetBytes%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="c3040-1081"><xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1081">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="c3040-1082">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1082">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1083">アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1083">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="c3040-1084">この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1084">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="c3040-1085">(たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1085">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="c3040-1086"><xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1086">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="c3040-1087"><xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1087"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="c3040-1088">アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A>の文字列バージョンを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1088">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="c3040-1089"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1089">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="c3040-1090">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1090">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-1091">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1091">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1092">この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1092">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="c3040-1093"><xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1093">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="c3040-1094">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1094">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1095">ストリームを連続エンコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1095">For continuous encoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1096"><paramref name="chars" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1096"><paramref name="chars" /> is <see langword="null" />.</span></span>

<span data-ttu-id="c3040-1097">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1097">-or-</span></span>

 <span data-ttu-id="c3040-1098"><paramref name="bytes" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1098"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1099"><paramref name="charCount" /> または <paramref name="byteCount" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1099"><paramref name="charCount" /> or <paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c3040-1100"><paramref name="byteCount" /> が結果のバイト数より少なくなっています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1100"><paramref name="byteCount" /> is less than the resulting number of bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="c3040-1101">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1101">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1102">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1102">-and-</span></span>

 <span data-ttu-id="c3040-1103"><see cref="P:System.Text.Encoding.EncoderFallback" /> は <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1103"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars"><span data-ttu-id="c3040-1104">エンコード対象の文字のセットを格納している文字配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1104">The character array containing the set of characters to encode.</span></span></param>
        <param name="charIndex"><span data-ttu-id="c3040-1105">エンコードする最初の文字のインデックス。</span><span class="sxs-lookup"><span data-stu-id="c3040-1105">The index of the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="c3040-1106">エンコードする文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1106">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="c3040-1107">結果のバイト シーケンスを格納するバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1107">The byte array to contain the resulting sequence of bytes.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="c3040-1108">結果のバイト シーケンスを書き込む開始位置のインデックス。</span><span class="sxs-lookup"><span data-stu-id="c3040-1108">The index at which to start writing the resulting sequence of bytes.</span></span></param>
        <summary><span data-ttu-id="c3040-1109">派生クラスでオーバーライドされた場合、指定した文字配列に格納されている文字のセットを、指定したバイト配列にエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1109">When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="c3040-1110"><paramref name="bytes" /> に書き込まれた実際のバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1110">The actual number of bytes written into <paramref name="bytes" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1111"><xref:System.Text.Encoding.GetBytes%2A> が結果のバイトを格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1111">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="c3040-1112">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1112">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="c3040-1113"><xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1113">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-1114">変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1114">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-1115"><xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1115">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="c3040-1116"><xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1116">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="c3040-1117"><xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1117">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="c3040-1118">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1118">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1119">アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1119">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="c3040-1120">この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1120">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="c3040-1121">(たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1121">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="c3040-1122"><xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1122">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="c3040-1123"><xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1123"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="c3040-1124">アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A>の文字列バージョンを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1124">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="c3040-1125"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1125">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="c3040-1126">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1126">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-1127">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1127">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1128">この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1128">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="c3040-1129"><xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1129">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="c3040-1130">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1130">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1131">ストリームを連続エンコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1131">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="c3040-1132">次の例では、文字配列から3文字をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1132">The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1133"><paramref name="chars" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1133"><paramref name="chars" /> is <see langword="null" />.</span></span>

<span data-ttu-id="c3040-1134">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1134">-or-</span></span>

 <span data-ttu-id="c3040-1135"><paramref name="bytes" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1135"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1136"><paramref name="charIndex" />、<paramref name="charCount" />、または <paramref name="byteIndex" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1136"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span></span>

<span data-ttu-id="c3040-1137">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1137">-or-</span></span>

 <span data-ttu-id="c3040-1138"><paramref name="charIndex" /> および <paramref name="charCount" /> は <paramref name="chars" /> において有効な範囲を表していません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1138"><paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span></span>

<span data-ttu-id="c3040-1139">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1139">-or-</span></span>

 <span data-ttu-id="c3040-1140"><paramref name="byteIndex" /> が <paramref name="bytes" /> の有効なインデックスではありません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1140"><paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c3040-1141"><paramref name="bytes" /> には、<paramref name="byteIndex" /> から配列の末尾までに十分なサイズがなく、結果のバイトを格納できません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1141"><paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="c3040-1142">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1142">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1143">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1143">-and-</span></span>

 <span data-ttu-id="c3040-1144"><see cref="P:System.Text.Encoding.EncoderFallback" /> は <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1144"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s"><span data-ttu-id="c3040-1145">エンコード対象の文字のセットを格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1145">The string containing the set of characters to encode.</span></span></param>
        <param name="charIndex"><span data-ttu-id="c3040-1146">エンコードする最初の文字のインデックス。</span><span class="sxs-lookup"><span data-stu-id="c3040-1146">The index of the first character to encode.</span></span></param>
        <param name="charCount"><span data-ttu-id="c3040-1147">エンコードする文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1147">The number of characters to encode.</span></span></param>
        <param name="bytes"><span data-ttu-id="c3040-1148">結果のバイト シーケンスを格納するバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1148">The byte array to contain the resulting sequence of bytes.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="c3040-1149">結果のバイト シーケンスを書き込む開始位置のインデックス。</span><span class="sxs-lookup"><span data-stu-id="c3040-1149">The index at which to start writing the resulting sequence of bytes.</span></span></param>
        <summary><span data-ttu-id="c3040-1150">派生クラスでオーバーライドされた場合、指定した文字列に含まれる文字のセットを、指定したバイト配列にエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1150">When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="c3040-1151"><paramref name="bytes" /> に書き込まれた実際のバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1151">The actual number of bytes written into <paramref name="bytes" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1152"><xref:System.Text.Encoding.GetBytes%2A> が結果のバイトを格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1152">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should call the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="c3040-1153">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1153">To calculate the maximum array size, call the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="c3040-1154"><xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1154">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-1155">変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1155">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-1156"><xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1156">The <xref:System.Text.Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.Encoding.GetBytes%2A> method performs the actual encoding.</span></span> <span data-ttu-id="c3040-1157"><xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1157">The <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method, which handles multiple conversions on a single input stream.</span></span>

 <span data-ttu-id="c3040-1158"><xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1158">Several versions of <xref:System.Text.Encoding.GetByteCount%2A> and <xref:System.Text.Encoding.GetBytes%2A> are supported.</span></span> <span data-ttu-id="c3040-1159">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1159">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1160">アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1160">Your app might need to encode many input characters to a code page and process the characters using multiple calls.</span></span> <span data-ttu-id="c3040-1161">この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1161">In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref:System.Text.Encoder> object being used.</span></span> <span data-ttu-id="c3040-1162">(たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1162">(For example, a character sequence that includes surrogate pairs might end with a high surrogate.</span></span> <span data-ttu-id="c3040-1163"><xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1163">The <xref:System.Text.Encoder> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call.</span></span> <span data-ttu-id="c3040-1164"><xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1164"><xref:System.Text.Encoding> won't be able to maintain the state, so the character will be sent to the <xref:System.Text.EncoderFallback>.)</span></span>

-   <span data-ttu-id="c3040-1165">アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A>の文字列バージョンを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1165">If your app handles string inputs, you should use the string version of <xref:System.Text.Encoding.GetBytes%2A>.</span></span>

-   <span data-ttu-id="c3040-1166"><xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1166">The Unicode character buffer version of <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls using the <xref:System.Text.Encoder> object or inserting into existing buffers.</span></span> <span data-ttu-id="c3040-1167">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1167">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-1168">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1168">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1169">この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1169">In this case, the <xref:System.Text.Encoding.GetBytes%2A> version that supports byte arrays is the best choice.</span></span>

-   <span data-ttu-id="c3040-1170"><xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1170">Consider using the <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetByteCount%2A>.</span></span> <span data-ttu-id="c3040-1171">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1171">The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1172">ストリームを連続エンコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1172">For continuous encoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="c3040-1173">次の例では、文字列または文字列の範囲をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1173">The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1174"><paramref name="s" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1174"><paramref name="s" /> is <see langword="null" />.</span></span>

<span data-ttu-id="c3040-1175">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1175">-or-</span></span>

 <span data-ttu-id="c3040-1176"><paramref name="bytes" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1176"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1177"><paramref name="charIndex" />、<paramref name="charCount" />、または <paramref name="byteIndex" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1177"><paramref name="charIndex" /> or <paramref name="charCount" /> or <paramref name="byteIndex" /> is less than zero.</span></span>

<span data-ttu-id="c3040-1178">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1178">-or-</span></span>

 <span data-ttu-id="c3040-1179"><paramref name="charIndex" /> および <paramref name="charCount" /> は <paramref name="chars" /> において有効な範囲を表していません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1179"><paramref name="charIndex" /> and <paramref name="charCount" /> do not denote a valid range in <paramref name="chars" />.</span></span>

<span data-ttu-id="c3040-1180">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1180">-or-</span></span>

 <span data-ttu-id="c3040-1181"><paramref name="byteIndex" /> が <paramref name="bytes" /> の有効なインデックスではありません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1181"><paramref name="byteIndex" /> is not a valid index in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c3040-1182"><paramref name="bytes" /> には、<paramref name="byteIndex" /> から配列の末尾までに十分なサイズがなく、結果のバイトを格納できません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1182"><paramref name="bytes" /> does not have enough capacity from <paramref name="byteIndex" /> to the end of the array to accommodate the resulting bytes.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="c3040-1183">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1183">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1184">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1184">-and-</span></span>

 <span data-ttu-id="c3040-1185"><see cref="P:System.Text.Encoding.EncoderFallback" /> は <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1185"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c3040-1186">派生クラスでオーバーライドされた場合、バイト シーケンスをデコードすることによって生成される文字数を計算します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1186">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="c3040-1187">デコード対象のバイト シーケンスが格納されたバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1187">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="c3040-1188">派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているすべてのバイトをデコードすることによって生成される文字数を計算します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1188">When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="c3040-1189">指定したバイト シーケンスをデコードすることによって生成される文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1189">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1190"><xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> が結果の文字を格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> メソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1190">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method.</span></span> <span data-ttu-id="c3040-1191">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> メソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1191">To calculate the maximum array size, you should use the <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> method.</span></span> <span data-ttu-id="c3040-1192"><xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1192">The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-1193"><xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> メソッドは実際のデコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1193">The <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> method determines how many characters result in decoding a sequence of bytes, and the  <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> method performs the actual decoding.</span></span> <span data-ttu-id="c3040-1194"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1194">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="c3040-1195"><xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1195">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="c3040-1196">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1196">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1197">アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1197">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="c3040-1198">この場合、呼び出しの間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1198">In this case, you probably need to maintain state between calls.</span></span>

-   <span data-ttu-id="c3040-1199">アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1199">If your app handles string outputs, you should use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="c3040-1200">このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1200">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="c3040-1201"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1201">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="c3040-1202">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1202">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-1203">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1203">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1204">この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1204">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="c3040-1205"><xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1205">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="c3040-1206">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1206">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1207">ストリームを連続してデコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1207">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="c3040-1208">次の例では、文字列をバイト配列にエンコードし、バイトを文字配列にデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1208">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1209"><paramref name="bytes" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1209"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="c3040-1210">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1210">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1211">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1211">-and-</span></span>

 <span data-ttu-id="c3040-1212"><see cref="P:System.Text.Encoding.DecoderFallback" /> は <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1212"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="c3040-1213">デコードする読み取り専用バイト スパン。</span><span class="sxs-lookup"><span data-stu-id="c3040-1213">A read-only byte span to decode.</span></span></param>
        <summary><span data-ttu-id="c3040-1214">派生クラスでオーバーライドされた場合、指定した読み取り専用バイト スパンをデコードすることによって生成される文字数を計算します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1214">When overridden in a derived class, calculates the number of characters produced by decoding the provided read-only byte span.</span></span></summary>
        <returns><span data-ttu-id="c3040-1215">バイト スパンをデコードすることによって生成される文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1215">The number of characters produced by decoding the byte span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1216">結果の文字を格納するために <xref:System.Text.Encoding.GetChars%2A> が必要とする正確な配列サイズを計算するには、<xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1216">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="c3040-1217">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1217">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="c3040-1218"><xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1218">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-1219"><xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1219">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="c3040-1220"><xref:System.Text.Encoding.GetChars%2A> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1220">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="c3040-1221"><xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1221">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="c3040-1222">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1222">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1223">アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1223">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="c3040-1224">この場合、呼び出しの間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1224">In this case, you probably need to maintain state between calls.</span></span>

-   <span data-ttu-id="c3040-1225">アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1225">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="c3040-1226">このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1226">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="c3040-1227">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1227">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1228">この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1228">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="c3040-1229"><xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1229">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="c3040-1230">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1230">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1231">ストリームを連続してデコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1231">For continuous decoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="c3040-1232">デコードする最初のバイトへのポインター。</span><span class="sxs-lookup"><span data-stu-id="c3040-1232">A pointer to the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="c3040-1233">デコードするバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1233">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="c3040-1234">派生クラスでオーバーライドされた場合、指定したバイト ポインターから始まるバイト シーケンスをデコードすることによって生成される文字数を計算します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1234">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</span></span></summary>
        <returns><span data-ttu-id="c3040-1235">指定したバイト シーケンスをデコードすることによって生成される文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1235">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1236">結果の文字を格納するために <xref:System.Text.Encoding.GetChars%2A> が必要とする正確な配列サイズを計算するには、<xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1236">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="c3040-1237">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1237">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="c3040-1238"><xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1238">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-1239"><xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1239">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="c3040-1240"><xref:System.Text.Encoding.GetChars%2A> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1240">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="c3040-1241"><xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1241">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="c3040-1242">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1242">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1243">アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1243">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="c3040-1244">この場合、呼び出しの間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1244">In this case, you probably need to maintain state between calls.</span></span>

-   <span data-ttu-id="c3040-1245">アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1245">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="c3040-1246">このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1246">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="c3040-1247"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1247">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="c3040-1248">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1248">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-1249">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1249">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1250">この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1250">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="c3040-1251"><xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1251">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="c3040-1252">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1252">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1253">ストリームを連続してデコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1253">For continuous decoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1254"><paramref name="bytes" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1254"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1255"><paramref name="count" /> に 0 より小さい値が指定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1255"><paramref name="count" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="c3040-1256">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1256">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1257">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1257">-and-</span></span>

 <span data-ttu-id="c3040-1258"><see cref="P:System.Text.Encoding.DecoderFallback" /> は <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1258"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="c3040-1259">デコード対象のバイト シーケンスが格納されたバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1259">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="c3040-1260">デコードする最初のバイトのインデックス。</span><span class="sxs-lookup"><span data-stu-id="c3040-1260">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="c3040-1261">デコードするバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1261">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="c3040-1262">派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスをデコードすることによって生成される文字数を計算します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1262">When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</span></span></summary>
        <returns><span data-ttu-id="c3040-1263">指定したバイト シーケンスをデコードすることによって生成される文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1263">The number of characters produced by decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1264"><xref:System.Text.Encoding.GetChars%2A> が結果の文字を格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1264">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="c3040-1265">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1265">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="c3040-1266"><xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1266">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-1267"><xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1267">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="c3040-1268"><xref:System.Text.Encoding.GetChars%2A> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1268">The <xref:System.Text.Encoding.GetChars%2A> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="c3040-1269"><xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1269">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="c3040-1270">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1270">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1271">アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1271">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="c3040-1272">この場合、呼び出しの間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1272">In this case, you probably need to maintain state between calls.</span></span>

-   <span data-ttu-id="c3040-1273">アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1273">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="c3040-1274">このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1274">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="c3040-1275"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1275">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="c3040-1276">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1276">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-1277">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1277">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1278">この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1278">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="c3040-1279"><xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1279">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="c3040-1280">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1280">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1281">ストリームを連続してデコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1281">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="c3040-1282">次の例では、あるエンコードから別のエンコーディングに文字列を変換します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1282">The following example converts a string from one encoding to another.</span></span>

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 <span data-ttu-id="c3040-1283">次の例では、文字列をバイト配列にエンコードした後、バイトの範囲を文字配列にデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1283">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1284"><paramref name="bytes" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1284"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1285"><paramref name="index" /> または <paramref name="count" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1285"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="c3040-1286">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1286">-or-</span></span>

 <span data-ttu-id="c3040-1287"><paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1287"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="c3040-1288">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1288">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1289">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1289">-and-</span></span>

 <span data-ttu-id="c3040-1290"><see cref="P:System.Text.Encoding.DecoderFallback" /> は <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1290"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c3040-1291">派生クラスでオーバーライドされた場合、バイト シーケンスを文字のセットにデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1291">When overridden in a derived class, decodes a sequence of bytes into a set of characters.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="c3040-1292">デコード対象のバイト シーケンスが格納されたバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1292">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="c3040-1293">派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているすべてのバイトを文字のセットにデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1293">When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.</span></span></summary>
        <returns><span data-ttu-id="c3040-1294">指定したバイト シーケンスのデコード結果が格納された文字配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1294">A character array containing the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1295"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 入力バイトシーケンスから文字を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1295"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="c3040-1296"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> とは異なります。 <xref:System.Text.Encoding> では不連続変換が想定されており、<xref:System.Text.Decoder> は単一の入力ストリームに対して複数のパスを使用するように設計されているためです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1296"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="c3040-1297">変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1297">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-1298">**メモ**このメソッドは、バイト配列などの任意のバイナリデータではなく、Unicode 文字を操作することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1298">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="c3040-1299">任意のバイナリデータをテキストにエンコードする必要がある場合は、uuencode などのプロトコルを使用する必要があります。これは、<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>などのメソッドによって実装されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1299">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="c3040-1300"><xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1300">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="c3040-1301"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1301">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="c3040-1302"><xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1302">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="c3040-1303">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1303">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1304">アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1304">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="c3040-1305">この場合は、バッチ処理時にバイトシーケンスが中断される可能性があるため、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1305">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="c3040-1306">(たとえば、ISO-2022 シフトシーケンスの一部は、1つの <xref:System.Text.Encoding.GetChars%2A> 呼び出しを終了し、次の <xref:System.Text.Encoding.GetChars%2A> 呼び出しの先頭で続行できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1306">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="c3040-1307"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は、これらの不完全なシーケンスに対してフォールバックを呼び出しますが、<xref:System.Text.Decoder> は次の呼び出しのためにこれらのシーケンスを記憶します)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1307"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="c3040-1308">アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1308">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="c3040-1309">このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1309">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="c3040-1310"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1310">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="c3040-1311">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1311">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-1312">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1312">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1313">この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1313">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="c3040-1314"><xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1314">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="c3040-1315">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1315">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1316">ストリームを連続してデコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1316">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="c3040-1317">次の例では、文字列をバイト配列にエンコードし、バイトを文字配列にデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1317">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1318"><paramref name="bytes" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1318"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="c3040-1319">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1319">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1320">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1320">-and-</span></span>

 <span data-ttu-id="c3040-1321"><see cref="P:System.Text.Encoding.DecoderFallback" /> は <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1321"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="c3040-1322">デコード対象のバイト シーケンスが格納された読み取り専用スパン。</span><span class="sxs-lookup"><span data-stu-id="c3040-1322">A read-only span containing the sequence of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="c3040-1323">デコードされたバイトを受け取る文字スパン。</span><span class="sxs-lookup"><span data-stu-id="c3040-1323">The character span receiving the decoded bytes.</span></span></param>
        <summary><span data-ttu-id="c3040-1324">派生クラスでオーバーライドされた場合、指定した読み取り専用バイト スパンに格納されているすべてのバイトを、文字スパンにデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1324">When overridden in a derived class, decodes all the bytes in the specified read-only byte span into a character span.</span></span></summary>
        <returns><span data-ttu-id="c3040-1325">デコードされたバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1325">The number of decoded bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1326"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 入力バイト範囲から文字を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1326"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte span.</span></span> <span data-ttu-id="c3040-1327"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> とは異なります。 <xref:System.Text.Encoding> では不連続変換が想定されており、<xref:System.Text.Decoder> は単一の入力ストリームに対して複数のパスを使用するように設計されているためです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1327"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="c3040-1328">変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1328">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-1329"><xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1329">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="c3040-1330"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1330">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="c3040-1331"><xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1331">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="c3040-1332">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1332">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1333">アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1333">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="c3040-1334">この場合は、バッチ処理時にバイトシーケンスが中断される可能性があるため、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1334">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="c3040-1335">(たとえば、ISO-2022 シフトシーケンスの一部は、1つの <xref:System.Text.Encoding.GetChars%2A> 呼び出しを終了し、次の <xref:System.Text.Encoding.GetChars%2A> 呼び出しの先頭で続行できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1335">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="c3040-1336"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は、これらの不完全なシーケンスに対してフォールバックを呼び出しますが、<xref:System.Text.Decoder> は次の呼び出しのためにこれらのシーケンスを記憶します)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1336"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="c3040-1337">アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1337">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="c3040-1338">このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1338">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="c3040-1339"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1339">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="c3040-1340">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1340">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-1341">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1341">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1342">この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1342">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="c3040-1343"><xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1343">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="c3040-1344">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1344">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1345">ストリームを連続してデコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1345">For continuous decoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="c3040-1346">デコード対象のバイト シーケンスが格納されたバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1346">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="c3040-1347">デコードする最初のバイトのインデックス。</span><span class="sxs-lookup"><span data-stu-id="c3040-1347">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="c3040-1348">デコードするバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1348">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="c3040-1349">派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスを文字のセットにデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1349">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.</span></span></summary>
        <returns><span data-ttu-id="c3040-1350">指定したバイト シーケンスのデコード結果が格納された文字配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1350">A character array containing the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1351"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 入力バイトシーケンスから文字を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1351"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="c3040-1352"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> とは異なります。 <xref:System.Text.Encoding> では不連続変換が想定されており、<xref:System.Text.Decoder> は単一の入力ストリームに対して複数のパスを使用するように設計されているためです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1352"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="c3040-1353">変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1353">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-1354">**メモ**このメソッドは、バイト配列などの任意のバイナリデータではなく、Unicode 文字を操作することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1354">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="c3040-1355">任意のバイナリデータをテキストにエンコードする必要がある場合は、uuencode などのプロトコルを使用する必要があります。これは、<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>などのメソッドによって実装されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1355">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="c3040-1356"><xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1356">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="c3040-1357"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1357">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="c3040-1358"><xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1358">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="c3040-1359">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1359">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1360">アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1360">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="c3040-1361">この場合は、バッチ処理時にバイトシーケンスが中断される可能性があるため、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1361">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="c3040-1362">(たとえば、ISO-2022 シフトシーケンスの一部は、1つの <xref:System.Text.Encoding.GetChars%2A> 呼び出しを終了し、次の <xref:System.Text.Encoding.GetChars%2A> 呼び出しの先頭で続行できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1362">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="c3040-1363"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は、これらの不完全なシーケンスに対してフォールバックを呼び出しますが、<xref:System.Text.Decoder> は次の呼び出しのためにこれらのシーケンスを記憶します)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1363"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="c3040-1364">アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1364">If your app handles string outputs, it is recommended to use the <xref:System.Text.Encoding.GetString%2A> method.</span></span> <span data-ttu-id="c3040-1365">このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1365">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="c3040-1366"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1366">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="c3040-1367">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1367">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-1368">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1368">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1369">この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1369">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="c3040-1370"><xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1370">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="c3040-1371">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1371">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1372">ストリームを連続してデコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1372">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="c3040-1373">次の例では、文字列をバイト配列にエンコードした後、バイトの範囲を文字配列にデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1373">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1374"><paramref name="bytes" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1374"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1375"><paramref name="index" /> または <paramref name="count" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1375"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="c3040-1376">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1376">-or-</span></span>

 <span data-ttu-id="c3040-1377"><paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1377"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="c3040-1378">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1378">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1379">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1379">-and-</span></span>

 <span data-ttu-id="c3040-1380"><see cref="P:System.Text.Encoding.DecoderFallback" /> は <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1380"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="c3040-1381">デコードする最初のバイトへのポインター。</span><span class="sxs-lookup"><span data-stu-id="c3040-1381">A pointer to the first byte to decode.</span></span></param>
        <param name="byteCount"><span data-ttu-id="c3040-1382">デコードするバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1382">The number of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="c3040-1383">結果の文字セットの書き込みを開始する位置へのポインター。</span><span class="sxs-lookup"><span data-stu-id="c3040-1383">A pointer to the location at which to start writing the resulting set of characters.</span></span></param>
        <param name="charCount"><span data-ttu-id="c3040-1384">書き込む文字の最大数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1384">The maximum number of characters to write.</span></span></param>
        <summary><span data-ttu-id="c3040-1385">派生クラスでオーバーライドされた場合、指定したバイト ポインターで始まるバイト シーケンスを、指定した文字ポインターを開始位置として格納される文字のセットにデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1385">When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</span></span></summary>
        <returns><span data-ttu-id="c3040-1386"><paramref name="chars" /> パラメーターによって示される位置に書き込む実際の文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1386">The actual number of characters written at the location indicated by the <paramref name="chars" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1387">結果の文字を格納するために <xref:System.Text.Encoding.GetChars%2A> が必要とする正確な配列サイズを計算するには、<xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1387">To calculate the exact array size that <xref:System.Text.Encoding.GetChars%2A> requires to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="c3040-1388">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1388">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="c3040-1389"><xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1389">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-1390"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 入力バイトシーケンスから文字を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1390"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="c3040-1391"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> とは異なります。 <xref:System.Text.Encoding> では不連続変換が想定されており、<xref:System.Text.Decoder> は単一の入力ストリームに対して複数のパスを使用するように設計されているためです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1391"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="c3040-1392">変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>オブジェクト、によって提供される<xref:System.Text.Encoding.GetDecoder%2A>または<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1392">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> object provided by the <xref:System.Text.Encoding.GetDecoder%2A> or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-1393">**メモ**このメソッドは、バイト配列などの任意のバイナリデータではなく、Unicode 文字を操作することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1393">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="c3040-1394">任意のバイナリデータをテキストにエンコードする必要がある場合は、uuencode などのプロトコルを使用する必要があります。これは、<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>などのメソッドによって実装されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1394">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="c3040-1395"><xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1395">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="c3040-1396"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1396">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="c3040-1397"><xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1397">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="c3040-1398">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1398">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1399">アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1399">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="c3040-1400">この場合は、バッチ処理時にバイトシーケンスが中断される可能性があるため、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1400">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="c3040-1401">(たとえば、ISO-2022 シフトシーケンスの一部は、1つの <xref:System.Text.Encoding.GetChars%2A> 呼び出しを終了し、次の <xref:System.Text.Encoding.GetChars%2A> 呼び出しの先頭で続行できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1401">(For example, part of an ISO-2022 shift sequence may end one <xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next <xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="c3040-1402"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は、これらの不完全なシーケンスに対してフォールバックを呼び出しますが、<xref:System.Text.Decoder> は次の呼び出しのためにこれらのシーケンスを記憶します)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1402"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="c3040-1403">アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1403">If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended.</span></span> <span data-ttu-id="c3040-1404">このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1404">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="c3040-1405"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1405">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="c3040-1406">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1406">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-1407">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1407">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1408">この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1408">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="c3040-1409"><xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1409">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="c3040-1410">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1410">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1411">ストリームを連続してデコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1411">For continuous decoding of a stream, this method is often the best choice.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1412"><paramref name="bytes" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1412"><paramref name="bytes" /> is <see langword="null" />.</span></span>

<span data-ttu-id="c3040-1413">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1413">-or-</span></span>

 <span data-ttu-id="c3040-1414"><paramref name="chars" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1414"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1415"><paramref name="byteCount" /> または <paramref name="charCount" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1415"><paramref name="byteCount" /> or <paramref name="charCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c3040-1416"><paramref name="charCount" /> が結果の文字数より少なくなっています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1416"><paramref name="charCount" /> is less than the resulting number of characters.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="c3040-1417">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1417">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1418">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1418">-and-</span></span>

 <span data-ttu-id="c3040-1419"><see cref="P:System.Text.Encoding.DecoderFallback" /> は <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1419"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="c3040-1420">デコード対象のバイト シーケンスが格納されたバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1420">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="byteIndex"><span data-ttu-id="c3040-1421">デコードする最初のバイトのインデックス。</span><span class="sxs-lookup"><span data-stu-id="c3040-1421">The index of the first byte to decode.</span></span></param>
        <param name="byteCount"><span data-ttu-id="c3040-1422">デコードするバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1422">The number of bytes to decode.</span></span></param>
        <param name="chars"><span data-ttu-id="c3040-1423">結果の文字のセットを格納する文字配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1423">The character array to contain the resulting set of characters.</span></span></param>
        <param name="charIndex"><span data-ttu-id="c3040-1424">結果の文字のセットを書き込む開始位置のインデックス。</span><span class="sxs-lookup"><span data-stu-id="c3040-1424">The index at which to start writing the resulting set of characters.</span></span></param>
        <summary><span data-ttu-id="c3040-1425">派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスを、指定した文字配列にデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1425">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.</span></span></summary>
        <returns><span data-ttu-id="c3040-1426"><paramref name="chars" /> に書き込まれた実際の文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1426">The actual number of characters written into <paramref name="chars" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1427"><xref:System.Text.Encoding.GetChars%2A> が結果の文字を格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1427">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="c3040-1428">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1428">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="c3040-1429"><xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1429">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-1430">[\]、Int32、Int32、Char\<xref: GetChars% 2A? displayProperty = nameWithType > 入力バイトシーケンスから文字を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1430">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> gets characters from an input byte sequence.</span></span> <span data-ttu-id="c3040-1431">[\]、Int32、Int32、Char\<xref: GetChars% 2A? displayProperty = nameWithType > は <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> とは異なります。これは、<xref:System.Text.Encoding> が1つの入力ストリームに対して複数のパスを使用するように設計されているためです。<xref:System.Text.Decoder></span><span class="sxs-lookup"><span data-stu-id="c3040-1431">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> is different than <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> because <xref:System.Text.Encoding> expects discrete conversions, while <xref:System.Text.Decoder> is designed for multiple passes on a single input stream.</span></span>

 <span data-ttu-id="c3040-1432">変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1432">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-1433">**メモ**このメソッドは、バイト配列などの任意のバイナリデータではなく、Unicode 文字を操作することを目的としています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1433">**Note** This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays.</span></span> <span data-ttu-id="c3040-1434">任意のバイナリデータをテキストにエンコードする必要がある場合は、uuencode などのプロトコルを使用する必要があります。これは、<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>などのメソッドによって実装されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1434">If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="c3040-1435"><xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1435">The <xref:System.Text.Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.Encoding.GetChars%2A> method performs the actual decoding.</span></span> <span data-ttu-id="c3040-1436"><xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1436">The <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> method expects discrete conversions, in contrast to the <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method, which handles multiple passes on a single input stream.</span></span>

 <span data-ttu-id="c3040-1437"><xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1437">Several versions of <xref:System.Text.Encoding.GetCharCount%2A> and <xref:System.Text.Encoding.GetChars%2A> are supported.</span></span> <span data-ttu-id="c3040-1438">これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1438">The following are some programming considerations for use of these methods:</span></span>

-   <span data-ttu-id="c3040-1439">アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1439">Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls.</span></span> <span data-ttu-id="c3040-1440">この場合は、バッチ処理時にバイトシーケンスが中断される可能性があるため、呼び出し間で状態を維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1440">In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches.</span></span> <span data-ttu-id="c3040-1441">(たとえば、ISO-2022 シフトシーケンスの一部では、1つの [\], Int32, Int32, Char\<xref: GetChars% > 2A の呼び出しが終了し、次の [\], Int32, Int32, Char\<xref: GetChars% 2A > 呼び出しの先頭で続行される場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1441">(For example, part of an ISO-2022 shift sequence may end one [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> call and continue at the beginning of the next [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A> call.</span></span> <span data-ttu-id="c3040-1442">[\]、Int32、Int32、Char\<xref: GetChars% 2A? displayProperty = nameWithType > は、これらの不完全なシーケンスに対してフォールバックを呼び出しますが、<xref:System.Text.Decoder> は次の呼び出しのためにこれらのシーケンスを記憶します。)</span><span class="sxs-lookup"><span data-stu-id="c3040-1442">[\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> will call the fallback for those incomplete sequences, but <xref:System.Text.Decoder> will remember those sequences for the next call.)</span></span>

-   <span data-ttu-id="c3040-1443">アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1443">If your app handles string outputs, the <xref:System.Text.Encoding.GetString%2A> method is recommended.</span></span> <span data-ttu-id="c3040-1444">このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1444">Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref:System.String> type is to be preferred.</span></span>

-   <span data-ttu-id="c3040-1445"><xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1445">The byte version of <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> allows some fast techniques, particularly with multiple calls to large buffers.</span></span> <span data-ttu-id="c3040-1446">ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1446">Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</span></span>

-   <span data-ttu-id="c3040-1447">アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1447">If your app must convert a large amount of data, it should reuse the output buffer.</span></span> <span data-ttu-id="c3040-1448">この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1448">In this case, the [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29> version that supports output character buffers is the best choice.</span></span>

-   <span data-ttu-id="c3040-1449"><xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1449">Consider using the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method instead of <xref:System.Text.Encoding.GetCharCount%2A>.</span></span> <span data-ttu-id="c3040-1450">変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1450">The conversion method converts as much data as possible and throws an exception if the output buffer is too small.</span></span> <span data-ttu-id="c3040-1451">ストリームを連続してデコードする場合は、この方法が最適な選択肢です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1451">For continuous decoding of a stream, this method is often the best choice.</span></span>



## Examples
 <span data-ttu-id="c3040-1452">次の例では、あるエンコードから別のエンコーディングに文字列を変換します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1452">The following example converts a string from one encoding to another.</span></span>

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 <span data-ttu-id="c3040-1453">次の例では、文字列をバイト配列にエンコードした後、バイトの範囲を文字配列にデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1453">The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1454"><paramref name="bytes" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1454"><paramref name="bytes" /> is <see langword="null" />.</span></span>

<span data-ttu-id="c3040-1455">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1455">-or-</span></span>

 <span data-ttu-id="c3040-1456"><paramref name="chars" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1456"><paramref name="chars" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1457"><paramref name="byteIndex" />、<paramref name="byteCount" />、または <paramref name="charIndex" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1457"><paramref name="byteIndex" /> or <paramref name="byteCount" /> or <paramref name="charIndex" /> is less than zero.</span></span>

<span data-ttu-id="c3040-1458">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1458">-or-</span></span>

 <span data-ttu-id="c3040-1459"><paramref name="byteindex" /> および <paramref name="byteCount" /> は <paramref name="bytes" /> において有効な範囲を表していません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1459"><paramref name="byteindex" /> and <paramref name="byteCount" /> do not denote a valid range in <paramref name="bytes" />.</span></span>

<span data-ttu-id="c3040-1460">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1460">-or-</span></span>

 <span data-ttu-id="c3040-1461"><paramref name="charIndex" /> が <paramref name="chars" /> の有効なインデックスではありません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1461"><paramref name="charIndex" /> is not a valid index in <paramref name="chars" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c3040-1462"><paramref name="chars" /> には、<paramref name="charIndex" /> から配列の末尾までに十分なサイズがなく、結果の文字を格納できません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1462"><paramref name="chars" /> does not have enough capacity from <paramref name="charIndex" /> to the end of the array to accommodate the resulting characters.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="c3040-1463">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1463">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1464">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1464">-and-</span></span>

 <span data-ttu-id="c3040-1465"><see cref="P:System.Text.Encoding.DecoderFallback" /> は <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1465"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c3040-1466">派生クラスでオーバーライドされた場合、エンコード済みバイト シーケンスを文字シーケンスに変換するデコーダーを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1466">When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.</span></span></summary>
        <returns><span data-ttu-id="c3040-1467">エンコード済みバイト シーケンスを文字シーケンスに変換する <see cref="T:System.Text.Decoder" />。</span><span class="sxs-lookup"><span data-stu-id="c3040-1467">A <see cref="T:System.Text.Decoder" /> that converts an encoded sequence of bytes into a sequence of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1468"><xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドは、このクラスの <xref:System.Text.Encoding.GetChars%2A> メソッドと同様の方法で、バイトのシーケンシャルブロックを文字の連続したブロックに変換します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1468">The <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.Encoding.GetChars%2A> method of this class.</span></span> <span data-ttu-id="c3040-1469">ただし、<xref:System.Text.Decoder> は、複数のブロックにまたがるバイトシーケンスを正しくデコードするために、呼び出しの間に状態情報を保持します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1469">However, a <xref:System.Text.Decoder> maintains state information between calls so it correctly decodes byte sequences that span blocks.</span></span> <span data-ttu-id="c3040-1470">また <xref:System.Text.Decoder> は、データブロックの末尾で末尾のバイトを保持し、次のデコード操作で末尾のバイトを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1470">The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</span></span> <span data-ttu-id="c3040-1471">そのため、<xref:System.Text.Encoding.GetDecoder%2A> と <xref:System.Text.Encoding.GetEncoder%2A> は、ネットワークの転送とファイル操作に役立ちます。これらの操作は、多くの場合、データストリーム全体ではなくデータブロックを処理するためです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1471">Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="c3040-1472">既定の実装では、現在の <see cref="T:System.Text.Encoding" />の <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> および <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> メソッドを呼び出す <see cref="T:System.Text.Decoder" /> が返されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1472">The default implementation returns a <see cref="T:System.Text.Decoder" /> that calls the <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> and <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> methods of the current <see cref="T:System.Text.Encoding" />.</span></span> <span data-ttu-id="c3040-1473">呼び出し間で状態を維持する <see cref="T:System.Text.Decoder" /> を返すには、このメソッドをオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1473">You must override this method to return a <see cref="T:System.Text.Decoder" /> that maintains its state between calls.</span></span></para></block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-1474">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-1474">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c3040-1475">派生クラスでオーバーライドされた場合、Unicode 文字のシーケンスをエンコード済みバイト シーケンスに変換するエンコーダーを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1475">When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.</span></span></summary>
        <returns><span data-ttu-id="c3040-1476">Unicode 文字のシーケンスをエンコード済みバイト シーケンスに変換する <see cref="T:System.Text.Encoder" />。</span><span class="sxs-lookup"><span data-stu-id="c3040-1476">A <see cref="T:System.Text.Encoder" /> that converts a sequence of Unicode characters into an encoded sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1477"><xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドは、このクラスの <xref:System.Text.Encoding.GetBytes%2A> メソッドと同様の方法で、一連の文字を連続するバイトのブロックに変換します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1477">The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.Encoding.GetBytes%2A> method of this class.</span></span> <span data-ttu-id="c3040-1478">ただし、<xref:System.Text.Encoder> は、複数のブロックにまたがる文字シーケンスを正しくエンコードするために、呼び出しの間に状態情報を保持します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1478">However, a <xref:System.Text.Encoder> maintains state information between calls so it correctly encodes character sequences that span blocks.</span></span> <span data-ttu-id="c3040-1479">また <xref:System.Text.Encoder> は、データブロックの末尾で末尾の文字を保持し、次のエンコーディング操作で末尾の文字を使用します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1479">The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</span></span> <span data-ttu-id="c3040-1480">たとえば、データブロックの末尾が一致していない上位サロゲートで、一致する下位サロゲートが次のデータブロックに含まれている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1480">For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</span></span> <span data-ttu-id="c3040-1481">そのため、<xref:System.Text.Encoding.GetDecoder%2A> と <xref:System.Text.Encoding.GetEncoder%2A> は、ネットワークの転送とファイル操作に役立ちます。これらの操作は、多くの場合、データストリーム全体ではなくデータブロックを処理するためです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1481">Therefore, <xref:System.Text.Encoding.GetDecoder%2A> and <xref:System.Text.Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</span></span>

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="c3040-1482">既定の実装では、現在の <see cref="T:System.Text.Encoding" />の <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> および <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> メソッドを呼び出す <see cref="T:System.Text.Encoder" /> が返されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1482">The default implementation returns a <see cref="T:System.Text.Encoder" /> that calls the <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> and <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> methods of the current <see cref="T:System.Text.Encoding" />.</span></span> <span data-ttu-id="c3040-1483">呼び出し間で状態を維持する <see cref="T:System.Text.Encoder" /> を返すには、このメソッドをオーバーライドする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1483">You must override this method to return a <see cref="T:System.Text.Encoder" /> that maintains its state between calls.</span></span></para></block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-1484">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-1484">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c3040-1485">指定したコード ページのエンコーディングを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1485">Returns an encoding for the specified code page.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage"><span data-ttu-id="c3040-1486">使用するエンコーディングのコード ページ ID。</span><span class="sxs-lookup"><span data-stu-id="c3040-1486">The code page identifier of the preferred encoding.</span></span> <span data-ttu-id="c3040-1487">使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、コード ページの列にリストされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1487">Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span>

<span data-ttu-id="c3040-1488">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1488">-or-</span></span>

<span data-ttu-id="c3040-1489">既定のエンコーディングを使用する場合は 0。</span><span class="sxs-lookup"><span data-stu-id="c3040-1489">0 (zero), to use the default encoding.</span></span></param>
        <summary><span data-ttu-id="c3040-1490">指定したコード ページ ID に関連付けられたエンコーディングを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1490">Returns the encoding associated with the specified code page identifier.</span></span></summary>
        <returns><span data-ttu-id="c3040-1491">指定したコード ページに関連付けられたエンコーディング。</span><span class="sxs-lookup"><span data-stu-id="c3040-1491">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1492">フォールバックハンドラーは、`codepage`のエンコードの種類に依存します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1492">The fallback handler depends on the encoding type of `codepage`.</span></span> <span data-ttu-id="c3040-1493">`codepage` がコードページまたは2バイト文字セット (DBCS) エンコーディングの場合は、最適フォールバックハンドラーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1493">If `codepage` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</span></span> <span data-ttu-id="c3040-1494">それ以外の場合は、置換フォールバックハンドラーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1494">Otherwise, a replacement fallback handler is used.</span></span> <span data-ttu-id="c3040-1495">これらのフォールバックハンドラーは、アプリに適していない場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1495">These fallback handlers may not be appropriate for your app.</span></span> <span data-ttu-id="c3040-1496">`codepage`によって指定されたエンコーディングによって使用されるフォールバックハンドラーを指定するには、<xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> のオーバーロードを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1496">To specify the fallback handler used by the encoding specified by `codepage`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.</span></span>

 <span data-ttu-id="c3040-1497">.NET Framework では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは、ほとんどのコードページをサポートするために、基になるプラットフォームに依存しています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1497">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="c3040-1498">ただし、.NET Framework は、いくつかのエンコーディングをネイティブでサポートしています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1498">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="c3040-1499">コードページの一覧については、<xref:System.Text.Encoding> クラスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1499">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="c3040-1500">.NET Core では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドによって、.NET Core でネイティブにサポートされているエンコーディングが返されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1500">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="c3040-1501">どちらの .NET 実装でも、<xref:System.Text.Encoding.GetEncodings%2A> メソッドを呼び出して、使用可能なすべてのエンコーディングに関する情報を格納する <xref:System.Text.EncodingInfo> オブジェクトの配列を取得できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1501">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span>

 <span data-ttu-id="c3040-1502">.NET Core でネイティブに提供されている、または特定のプラットフォームバージョンの .NET Framework で本質的にサポートされているエンコーディングに加えて、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは <xref:System.Text.EncodingProvider> オブジェクトを登録することによって使用可能になる追加のエンコーディングを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1502">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="c3040-1503">同じエンコーディングが複数の <xref:System.Text.EncodingProvider> オブジェクトによって登録されている場合、このメソッドは最後に登録されたものを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1503">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>

<span data-ttu-id="c3040-1504">`codepage` 引数に値0を指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1504">You can also supply a value of 0 for the `codepage` argument.</span></span> <span data-ttu-id="c3040-1505">この正確な動作は、<xref:System.Text.EncodingProvider> オブジェクトを登録することによって、エンコードが使用可能になっているかどうかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1505">Its precise behavior depends on whether any encodings have been made available by registering an <xref:System.Text.EncodingProvider> object:</span></span>

- <span data-ttu-id="c3040-1506">1つ以上のエンコーディングプロバイダーが登録されている場合は、<xref:System.Text.Encoding.GetEncoding%2A> メソッドに0の `codepage` 引数が渡されたときに、エンコーディングを返すことを選択した最後に登録されたプロバイダーのエンコーディングを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1506">If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <xref:System.Text.Encoding.GetEncoding%2A> method is passed a `codepage` argument of 0.</span></span>

- <span data-ttu-id="c3040-1507">.NET Framework では、エンコーディングプロバイダーが登録されていない場合、<xref:System.Text.CodePagesEncodingProvider> が登録済みのエンコーディングプロバイダーである場合、または登録されているエンコーディングプロバイダーが0の `codepage` 値を処理しない場合は、オペレーティングシステムのアクティブなコードページが返されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1507">On the .NET Framework, if no encoding provider has been registered, if the <xref:System.Text.CodePagesEncodingProvider> is the registered encoding provider, or if no registered encoding provider handles a `codepage` value of 0, it returns the operating system's active code page.</span></span> <span data-ttu-id="c3040-1508">Windows システムのアクティブなコードページを確認するには、windows デスクトップの .NET Framework から Windows [Getacp](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)関数を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1508">To determine the active code page on Windows systems, call the Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the .NET Framework on the Windows desktop.</span></span>

- <span data-ttu-id="c3040-1509">.NET Core では、エンコーディングプロバイダーが登録されていない場合、または登録されているエンコーディングプロバイダーが0の `codepage` 値を処理しない場合、<xref:System.Text.UTF8Encoding>が返されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1509">On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a `codepage` value of 0, it returns the <xref:System.Text.UTF8Encoding>.</span></span>

> [!NOTE]
>  <span data-ttu-id="c3040-1510">サポートされていないコードページによっては、<xref:System.ArgumentException> がスローされ、他のコードページでは <xref:System.NotSupportedException>が発生します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1510">Some unsupported code pages cause an <xref:System.ArgumentException> to be thrown, whereas others cause a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="c3040-1511">そのため、コードでは、例外セクションに示されているすべての例外をキャッチする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1511">Therefore, your code must catch all exceptions indicated in the Exceptions section.</span></span>

> [!NOTE]
>  <span data-ttu-id="c3040-1512">ANSI コードページは、コンピューターによって異なる場合があり、1台のコンピューターで変更できるため、データが破損する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1512">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="c3040-1513">このため、アクティブなコードページが ANSI コードページである場合、`Encoding.GetEncoding(0)` によって返される既定のコードページを使用してデータをエンコードおよびデコードすることはお勧めできません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1513">For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended.</span></span> <span data-ttu-id="c3040-1514">最も一貫性のある結果を得るには、特定のコードページではなく、UTF-8 (コードページ 65001) や UTF-16 などの Unicode エンコードを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1514">For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>

 <span data-ttu-id="c3040-1515"><xref:System.Text.Encoding.GetEncoding%2A> は、既定の設定でキャッシュされたインスタンスを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1515"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="c3040-1516">異なる設定のインスタンスを取得するには、派生クラスのコンストラクターを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1516">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="c3040-1517">たとえば、<xref:System.Text.UTF32Encoding> クラスには、エラー検出を可能にするコンストラクターが用意されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1517">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>



## Examples
 <span data-ttu-id="c3040-1518">次の例では、同じエンコードの2つのインスタンスを取得します (コードページごとに、もう1つは名前別)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1518">The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</span></span>

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1519"><paramref name="codepage" /> が 0 未満か、65535 を超えています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1519"><paramref name="codepage" /> is less than zero or greater than 65535.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c3040-1520"><paramref name="codepage" /> は、基になるプラットフォームでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1520"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c3040-1521"><paramref name="codepage" /> は、基になるプラットフォームでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1521"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-1522">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-1522">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c3040-1523">使用するエンコーディングのコード ページ名。</span><span class="sxs-lookup"><span data-stu-id="c3040-1523">The code page name of the preferred encoding.</span></span> <span data-ttu-id="c3040-1524"><see cref="P:System.Text.Encoding.WebName" /> プロパティが返す値はすべて有効です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1524">Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid.</span></span> <span data-ttu-id="c3040-1525">使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、名前の列にリストされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1525">Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span></param>
        <summary><span data-ttu-id="c3040-1526">指定したコード ページ名に関連付けられたエンコーディングを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1526">Returns the encoding associated with the specified code page name.</span></span></summary>
        <returns><span data-ttu-id="c3040-1527">指定したコード ページに関連付けられたエンコード。</span><span class="sxs-lookup"><span data-stu-id="c3040-1527">The encoding  associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1528">フォールバックハンドラーは、`name`のエンコードの種類に依存します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1528">The fallback handler depends on the encoding type of `name`.</span></span> <span data-ttu-id="c3040-1529">`name` がコードページまたは2バイト文字セット (DBCS) エンコーディングの場合は、最適フォールバックハンドラーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1529">If `name` is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used.</span></span> <span data-ttu-id="c3040-1530">それ以外の場合は、置換フォールバックハンドラーが使用されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1530">Otherwise, a replacement fallback handler is used.</span></span> <span data-ttu-id="c3040-1531">これらのフォールバックハンドラーは、アプリに適していない場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1531">These fallback handlers may not be appropriate for your app.</span></span> <span data-ttu-id="c3040-1532">`name`によって指定されたエンコーディングによって使用されるフォールバックハンドラーを指定するには、<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> のオーバーロードを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1532">To specify the fallback handler used by the encoding specified by `name`, you can call the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> overload.</span></span>

<span data-ttu-id="c3040-1533">.NET Framework では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは、ほとんどのコードページをサポートするために、基になるプラットフォームに依存しています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1533">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="c3040-1534">ただし、.NET Framework は、いくつかのエンコーディングをネイティブでサポートしています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1534">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="c3040-1535">コードページの一覧については、<xref:System.Text.Encoding> クラスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1535">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="c3040-1536">.NET Core では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドによって、.NET Core でネイティブにサポートされているエンコーディングが返されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1536">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="c3040-1537">どちらの .NET 実装でも、<xref:System.Text.Encoding.GetEncodings%2A> メソッドを呼び出して、使用可能なすべてのエンコーディングに関する情報を格納する <xref:System.Text.EncodingInfo> オブジェクトの配列を取得できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1537">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span>

 <span data-ttu-id="c3040-1538">.NET Core でネイティブに提供されている、または特定のプラットフォームバージョンの .NET Framework で本質的にサポートされているエンコーディングに加えて、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは <xref:System.Text.EncodingProvider> オブジェクトを登録することによって使用可能になる追加のエンコーディングを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1538">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="c3040-1539">同じエンコーディングが複数の <xref:System.Text.EncodingProvider> オブジェクトによって登録されている場合、このメソッドは最後に登録されたものを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1539">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>

> [!NOTE]
>  <span data-ttu-id="c3040-1540">ANSI コードページは、コンピューターによって異なる場合や、1台のコンピューターで変更される場合があり、データの破損を招く可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1540">The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption.</span></span> <span data-ttu-id="c3040-1541">一貫性のある結果を得るには、特定のコードページではなく、UTF-8 (コードページ 65001) や UTF-16 などの Unicode を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1541">For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>


 <span data-ttu-id="c3040-1542"><xref:System.Text.Encoding.GetEncoding%2A> は、既定の設定でキャッシュされたインスタンスを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1542"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="c3040-1543">異なる設定のインスタンスを取得するには、派生クラスのコンストラクターを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1543">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="c3040-1544">たとえば、<xref:System.Text.UTF32Encoding> クラスには、エラー検出を可能にするコンストラクターが用意されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1544">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>

## Examples
 <span data-ttu-id="c3040-1545">次の例では、同じエンコードの2つのインスタンスを取得します (コードページごとに、もう1つは名前別)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1545">The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</span></span>

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c3040-1546"><paramref name="name" /> が有効なコード ページ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1546"><paramref name="name" /> is not a valid code page name.</span></span>

<span data-ttu-id="c3040-1547">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1547">-or-</span></span>

<span data-ttu-id="c3040-1548"><paramref name="name" /> が示すコード ページは基になるプラットフォームでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1548">The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-1549">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-1549">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage"><span data-ttu-id="c3040-1550">使用するエンコーディングのコード ページ ID。</span><span class="sxs-lookup"><span data-stu-id="c3040-1550">The code page identifier of the preferred encoding.</span></span> <span data-ttu-id="c3040-1551">使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、コード ページの列にリストされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1551">Possible values are listed in the Code Page column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span>

<span data-ttu-id="c3040-1552">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1552">-or-</span></span>

<span data-ttu-id="c3040-1553">既定のエンコーディングを使用する場合は 0。</span><span class="sxs-lookup"><span data-stu-id="c3040-1553">0 (zero), to use the default encoding.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="c3040-1554">現在のエンコーディングで文字をエンコードできない場合にエラー処理プロシージャを提供するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="c3040-1554">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="c3040-1555">現在のエンコーディングでバイト シーケンスをデコードできない場合にエラー処理プロシージャを提供するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="c3040-1555">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="c3040-1556">指定したコード ページ ID に関連付けられたエンコーディングを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1556">Returns the encoding associated with the specified code page identifier.</span></span> <span data-ttu-id="c3040-1557">パラメーターには、エンコードできない文字とデコードできないバイト シーケンスのためのエラー ハンドラーを指定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1557">Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</span></span></summary>
        <returns><span data-ttu-id="c3040-1558">指定したコード ページに関連付けられたエンコーディング。</span><span class="sxs-lookup"><span data-stu-id="c3040-1558">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  <span data-ttu-id="c3040-1559">サポートされていないコードページによっては、例外 <xref:System.ArgumentException> がスローされ、他のコードページでは <xref:System.NotSupportedException>が発生します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1559">Some unsupported code pages cause the exception <xref:System.ArgumentException> to be thrown, whereas others cause <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="c3040-1560">そのため、コードでは、例外セクションに示されているすべての例外をキャッチする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1560">Therefore, your code must catch all exceptions indicated in the Exceptions section.</span></span>

<span data-ttu-id="c3040-1561">.NET Framework では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは、ほとんどのコードページをサポートするために、基になるプラットフォームに依存しています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1561">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="c3040-1562">ただし、.NET Framework は、いくつかのエンコーディングをネイティブでサポートしています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1562">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="c3040-1563">コードページの一覧については、<xref:System.Text.Encoding> クラスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1563">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="c3040-1564">.NET Core では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドによって、.NET Core でネイティブにサポートされているエンコーディングが返されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1564">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="c3040-1565">どちらの .NET 実装でも、<xref:System.Text.Encoding.GetEncodings%2A> メソッドを呼び出して、使用可能なすべてのエンコーディングに関する情報を格納する <xref:System.Text.EncodingInfo> オブジェクトの配列を取得できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1565">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span>

 <span data-ttu-id="c3040-1566">.NET Core でネイティブに提供されている、または特定のプラットフォームバージョンの .NET Framework で本質的にサポートされているエンコーディングに加えて、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは <xref:System.Text.EncodingProvider> オブジェクトを登録することによって使用可能になる追加のエンコーディングを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1566">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="c3040-1567">同じエンコーディングが複数の <xref:System.Text.EncodingProvider> オブジェクトによって登録されている場合、このメソッドは最後に登録されたものを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1567">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>

<span data-ttu-id="c3040-1568">`codepage` 引数に値0を指定することもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1568">You can also supply a value of 0 for the `codepage` argument.</span></span> <span data-ttu-id="c3040-1569">この正確な動作は、<xref:System.Text.EncodingProvider> オブジェクトを登録することによって、エンコードが使用可能になっているかどうかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1569">Its precise behavior depends on whether any encodings have been made available by registering an <xref:System.Text.EncodingProvider> object:</span></span>

- <span data-ttu-id="c3040-1570">1つ以上のエンコーディングプロバイダーが登録されている場合は、<xref:System.Text.Encoding.GetEncoding%2A> メソッドに0の `codepage` 引数が渡されたときに、エンコーディングを返すことを選択した最後に登録されたプロバイダーのエンコーディングを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1570">If one or more encoding providers have been registered, it returns the encoding of the last registered provider that has chosen to return a encoding when the <xref:System.Text.Encoding.GetEncoding%2A> method is passed a `codepage` argument of 0.</span></span>

- <span data-ttu-id="c3040-1571">.NET Framework では、エンコーディングプロバイダーが登録されていない場合、<xref:System.Text.CodePagesEncodingProvider> が登録済みのエンコーディングプロバイダーである場合、または登録されているエンコーディングプロバイダーが0の `codepage` 値を処理しない場合は、アクティブなコードページが返されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1571">On the .NET Framework, if no encoding provider has been registered, if the <xref:System.Text.CodePagesEncodingProvider> is the registered encoding provider, or if no registered encoding provider handles a `codepage` value of 0, it returns the active code page.</span></span>

- <span data-ttu-id="c3040-1572">.NET Core では、エンコーディングプロバイダーが登録されていない場合、または `codepage` 値0を処理するエンコーディングプロバイダーが登録されていない場合、<xref:System.Text.UTF8Encoding> エンコーディングが返されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1572">On .NET Core, if no encoding provider has been registered or if no registered encoding provider handles a `codepage` value of 0, it returns the <xref:System.Text.UTF8Encoding> encoding.</span></span>

> [!NOTE]
>  <span data-ttu-id="c3040-1573">ANSI コードページは、コンピューターによって異なる場合があり、1台のコンピューターで変更できるため、データが破損する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1573">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="c3040-1574">このため、アクティブなコードページが ANSI コードページである場合、`Encoding.GetEncoding(0)` によって返される既定のコードページを使用してデータをエンコードおよびデコードすることはお勧めできません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1574">For this reason, if the active code page is an ANSI code page, encoding and decoding data using the default code page returned by `Encoding.GetEncoding(0)` is not recommended.</span></span> <span data-ttu-id="c3040-1575">一貫性のある結果を得るには、特定のコードページではなく、UTF-8 (コードページ 65001) や UTF-16 などの Unicode を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1575">For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>

 <span data-ttu-id="c3040-1576">アクティブなコードページに関連付けられているエンコードを取得するには、`codepage` 引数に値0を指定するか、Windows デスクトップの .NET Framework でコードを実行している場合は <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> プロパティの値を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1576">To get the encoding associated with the active code page, you can either supply a value of 0 for the `codepage` argument or, if your code is running on the .NET Framework on the Windows desktop, retrieve the value of the <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c3040-1577">現在アクティブなコードページを確認するには、windows デスクトップの .NET Framework から Windows [Getacp](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)関数を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1577">To determine the current active code page, call the Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) function from the .NET Framework on the Windows desktop.</span></span>

 <span data-ttu-id="c3040-1578"><xref:System.Text.Encoding.GetEncoding%2A> は、既定の設定でキャッシュされたインスタンスを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1578"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="c3040-1579">異なる設定のインスタンスを取得するには、派生クラスのコンストラクターを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1579">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="c3040-1580">たとえば、<xref:System.Text.UTF32Encoding> クラスには、エラー検出を可能にするコンストラクターが用意されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1580">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>



## Examples
 <span data-ttu-id="c3040-1581"><xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType>メソッドの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1581">The following example demonstrates the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method.</span></span>

 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1582"><paramref name="codepage" /> が 0 未満か、65535 を超えています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1582"><paramref name="codepage" /> is less than zero or greater than 65535.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c3040-1583"><paramref name="codepage" /> は、基になるプラットフォームでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1583"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c3040-1584"><paramref name="codepage" /> は、基になるプラットフォームでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1584"><paramref name="codepage" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-1585">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-1585">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c3040-1586">使用するエンコーディングのコード ページ名。</span><span class="sxs-lookup"><span data-stu-id="c3040-1586">The code page name of the preferred encoding.</span></span> <span data-ttu-id="c3040-1587"><see cref="P:System.Text.Encoding.WebName" /> プロパティが返す値はすべて有効です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1587">Any value returned by the <see cref="P:System.Text.Encoding.WebName" /> property is valid.</span></span> <span data-ttu-id="c3040-1588">使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、名前の列にリストされています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1588">Possible values are listed in the Name column of the table that appears in the <see cref="T:System.Text.Encoding" /> class topic.</span></span></param>
        <param name="encoderFallback"><span data-ttu-id="c3040-1589">現在のエンコーディングで文字をエンコードできない場合にエラー処理プロシージャを提供するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="c3040-1589">An object that provides an error-handling procedure when a character cannot be encoded with the current encoding.</span></span></param>
        <param name="decoderFallback"><span data-ttu-id="c3040-1590">現在のエンコーディングでバイト シーケンスをデコードできない場合にエラー処理プロシージャを提供するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="c3040-1590">An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding.</span></span></param>
        <summary><span data-ttu-id="c3040-1591">指定したコード ページ名に関連付けられたエンコーディングを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1591">Returns the encoding associated with the specified code page name.</span></span> <span data-ttu-id="c3040-1592">パラメーターには、エンコードできない文字とデコードできないバイト シーケンスのためのエラー ハンドラーを指定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1592">Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</span></span></summary>
        <returns><span data-ttu-id="c3040-1593">指定したコード ページに関連付けられたエンコーディング。</span><span class="sxs-lookup"><span data-stu-id="c3040-1593">The encoding that is associated with the specified code page.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="c3040-1594">.NET Framework では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは、ほとんどのコードページをサポートするために、基になるプラットフォームに依存しています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1594">In the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method relies on the underlying platform to support most code pages.</span></span> <span data-ttu-id="c3040-1595">ただし、.NET Framework は、いくつかのエンコーディングをネイティブでサポートしています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1595">However, the .NET Framework natively supports some encodings.</span></span> <span data-ttu-id="c3040-1596">コードページの一覧については、<xref:System.Text.Encoding> クラスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1596">For a list of code pages, see the <xref:System.Text.Encoding> class topic.</span></span> <span data-ttu-id="c3040-1597">.NET Core では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドによって、.NET Core でネイティブにサポートされているエンコーディングが返されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1597">In .NET Core, the <xref:System.Text.Encoding.GetEncoding%2A> method returns the encodings natively supported by .NET Core.</span></span> <span data-ttu-id="c3040-1598">どちらの .NET 実装でも、<xref:System.Text.Encoding.GetEncodings%2A> メソッドを呼び出して、使用可能なすべてのエンコーディングに関する情報を格納する <xref:System.Text.EncodingInfo> オブジェクトの配列を取得できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1598">On both .NET implementations, you can call the <xref:System.Text.Encoding.GetEncodings%2A> method to get an array of <xref:System.Text.EncodingInfo> objects that contains information about all available encodings.</span></span>

 <span data-ttu-id="c3040-1599">.NET Core でネイティブに提供されている、または特定のプラットフォームバージョンの .NET Framework で本質的にサポートされているエンコーディングに加えて、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは <xref:System.Text.EncodingProvider> オブジェクトを登録することによって使用可能になる追加のエンコーディングを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1599">In addition to the encodings that are natively available on .NET Core or that are intrinsically supported on a specific platform version of the .NET Framework, the <xref:System.Text.Encoding.GetEncoding%2A> method returns any additional encodings that are made available by registering an <xref:System.Text.EncodingProvider> object.</span></span> <span data-ttu-id="c3040-1600">同じエンコーディングが複数の <xref:System.Text.EncodingProvider> オブジェクトによって登録されている場合、このメソッドは最後に登録されたものを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1600">If the same encoding has been registered by multiple <xref:System.Text.EncodingProvider> objects, this method returns the last one registered.</span></span>

> [!NOTE]
>  <span data-ttu-id="c3040-1601">ANSI コードページは、コンピューターによって異なる場合があり、1台のコンピューターで変更できるため、データが破損する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1601">The ANSI code pages can be different on different computers and can change on a single computer, leading to data corruption.</span></span> <span data-ttu-id="c3040-1602">最も一貫性のある結果を得るには、特定のコードページではなく、UTF-8 (コードページ 65001) や UTF-16 などの Unicode エンコードを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1602">For the most consistent results, you should use a Unicode encoding, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</span></span>

 <span data-ttu-id="c3040-1603"><xref:System.Text.Encoding.GetEncoding%2A> は、既定の設定でキャッシュされたインスタンスを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1603"><xref:System.Text.Encoding.GetEncoding%2A> returns a cached instance with default settings.</span></span> <span data-ttu-id="c3040-1604">異なる設定のインスタンスを取得するには、派生クラスのコンストラクターを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1604">You should use the constructors of derived classes to get an instance with different settings.</span></span> <span data-ttu-id="c3040-1605">たとえば、<xref:System.Text.UTF32Encoding> クラスには、エラー検出を可能にするコンストラクターが用意されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1605">For example, the <xref:System.Text.UTF32Encoding> class provides a constructor that lets you enable error detection.</span></span>



## Examples
 <span data-ttu-id="c3040-1606"><xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType>メソッドの例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1606">The following example demonstrates the <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> method.</span></span>

 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c3040-1607"><paramref name="name" /> が有効なコード ページ名ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1607"><paramref name="name" /> is not a valid code page name.</span></span>

<span data-ttu-id="c3040-1608">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1608">-or-</span></span>

<span data-ttu-id="c3040-1609"><paramref name="name" /> が示すコード ページは基になるプラットフォームでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1609">The code page indicated by <paramref name="name" /> is not supported by the underlying platform.</span></span></exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-1610">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-1610">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c3040-1611">すべてのエンコーディングを格納した配列を返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1611">Returns an array that contains all encodings.</span></span></summary>
        <returns><span data-ttu-id="c3040-1612">すべてのエンコーディングを格納する配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1612">An array that contains all encodings.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1613">このメソッドは、コードページによって一意に識別される、サポートされているエンコーディングの一覧を返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1613">This method returns a list of supported encodings, uniquely distinguished by code page.</span></span> <span data-ttu-id="c3040-1614">サポートされているエンコーディングの一覧については、<xref:System.Text.Encoding> クラスに関するトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1614">For a table that lists the supported encodings, see the <xref:System.Text.Encoding> class topic.</span></span>

> [!NOTE]
>  <span data-ttu-id="c3040-1615"><xref:System.Text.Encoding.GetEncodings%2A> メソッドによって返されるサポートされているエンコーディングの一覧には、<xref:System.Text.Encoding.RegisterProvider%2A> メソッドの呼び出しによって登録された <xref:System.Text.EncodingProvider> の実装で使用できる追加のエンコーディングは含まれません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1615">The list of supported encodings returned by the <xref:System.Text.Encoding.GetEncodings%2A> method does not include any additional encodings made available by any <xref:System.Text.EncodingProvider> implementations that were registered by calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method.</span></span>

 <span data-ttu-id="c3040-1616">.NET Framework では、エンコーディング50220と50222の両方が "iso-2022-jp" という名前に関連付けられていますが、同じではありません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1616">On the .NET Framework, encodings 50220 and 50222 are both associated with the name "iso-2022-jp", but they are not identical.</span></span> <span data-ttu-id="c3040-1617">エンコード50220では、半角カタカナ文字が全角カタカナ文字に変換されますが、エンコード50222では、シフトイン/シフトアウトシーケンスを使用して半角カタカナ文字をエンコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1617">Encoding 50220 converts half-width Katakana characters to full-width Katakana characters, whereas encoding 50222 uses a shift-in/shift-out sequence to encode half-width Katakana characters.</span></span> <span data-ttu-id="c3040-1618">エンコード50222の表示名は、"日本語 (JIS-1 バイトかな-SO/SI)" のように、表示名が "日本語 (JIS)" であるエンコード50220と区別されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1618">The display name for encoding 50222 is "Japanese (JIS-Allow 1 byte Kana - SO/SI)" to distinguish it from encoding 50220, which has the display name "Japanese (JIS)".</span></span>

 <span data-ttu-id="c3040-1619">エンコード名 "iso-2022-jp" を要求した場合、.NET Framework によってエンコード50220が返されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1619">If you request the encoding name "iso-2022-jp", the .NET Framework returns encoding 50220.</span></span> <span data-ttu-id="c3040-1620">ただし、アプリに適したエンコーディングは、半角カタカナ文字の優先処理によって異なります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1620">However, the encoding that is appropriate for your app depends on the preferred treatment of the half-width Katakana characters.</span></span>

 <span data-ttu-id="c3040-1621">特定のエンコーディングを取得するには、<xref:System.Text.Encoding.GetEncoding%2A> メソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1621">To get a specific encoding, you should use the <xref:System.Text.Encoding.GetEncoding%2A> method.</span></span>

 <span data-ttu-id="c3040-1622"><xref:System.Text.Encoding.GetEncodings%2A> は、[ファイル**名を付けて保存**] ダイアログボックスで、エンコードの一覧をユーザーに表示するために使用されることがあります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1622"><xref:System.Text.Encoding.GetEncodings%2A> is sometimes used to present the user with a list of encodings in a File **Save as** dialog box.</span></span> <span data-ttu-id="c3040-1623">ただし、Unicode 以外のエンコーディングの多くは不完全で、多くの文字が "?" に変換されるか、またはプラットフォームによって動作が微妙に異なります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1623">However, many non-Unicode encodings are either incomplete and translate many characters to "?", or have subtly different behavior on different platforms.</span></span> <span data-ttu-id="c3040-1624">既定として UTF-8 または UTF-16 を使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1624">Consider using UTF-8 or UTF-16 as the default.</span></span>



## Examples
 <span data-ttu-id="c3040-1625">次の例では、各エンコーディングのブール型プロパティの値をチェックします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1625">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-1626">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-1626">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c3040-1627">現在のインスタンスのハッシュ コードを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1627">Returns the hash code for the current instance.</span></span></summary>
        <returns><span data-ttu-id="c3040-1628">現在のインスタンスのハッシュ コード。</span><span class="sxs-lookup"><span data-stu-id="c3040-1628">The hash code for the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount"><span data-ttu-id="c3040-1629">エンコードする文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1629">The number of characters to encode.</span></span></param>
        <summary><span data-ttu-id="c3040-1630">派生クラスでオーバーライドされた場合、指定した文字数をエンコードすることによって生成される最大バイト数を計算します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1630">When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.</span></span></summary>
        <returns><span data-ttu-id="c3040-1631">指定した文字数をエンコードすることによって生成される最大バイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1631">The maximum number of bytes produced by encoding the specified number of characters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1632">.NET 内部では Unicode 文字を表すために UTF-16 を使用しているため、`charCount` パラメーターでは、エンコードする Unicode 文字を表す <xref:System.Char> オブジェクトの数を指定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1632">The `charCount` parameter actually specifies the number of <xref:System.Char> objects that represent the Unicode characters to encode, because .NET internally uses UTF-16 to represent Unicode characters.</span></span> <span data-ttu-id="c3040-1633">そのため、ほとんどの Unicode 文字は1つの <xref:System.Char> オブジェクトで表すことができますが、たとえば、サロゲートペアによって表される Unicode 文字には、2つの <xref:System.Char> オブジェクトが必要です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1633">Consequently, most Unicode characters can be represented by one <xref:System.Char> object, but a Unicode character represented by a surrogate pair, for example, requires two <xref:System.Char> objects.</span></span>

 <span data-ttu-id="c3040-1634"><xref:System.Text.Encoding.GetBytes%2A> が結果のバイトを格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1634">To calculate the exact array size required by <xref:System.Text.Encoding.GetBytes%2A> to store the resulting bytes, you should use the <xref:System.Text.Encoding.GetByteCount%2A> method.</span></span> <span data-ttu-id="c3040-1635">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1635">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxByteCount%2A> method.</span></span> <span data-ttu-id="c3040-1636"><xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1636">The <xref:System.Text.Encoding.GetByteCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxByteCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-1637"><xref:System.Text.Encoding.GetMaxByteCount%2A> は、現在選択されている <xref:System.Text.EncoderFallback>の最悪のケースを含む、最悪のケース番号を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1637"><xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>.</span></span> <span data-ttu-id="c3040-1638">場合によっては、大きな文字列を使用してフォールバックを選択すると、大きな値が取得されます。特に、エンコーディングの最悪のケースでは、すべての文字のモードを切り替える必要がある場合に <xref:System.Text.Encoding.GetMaxByteCount%2A> ます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1638">If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxByteCount%2A> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character.</span></span> <span data-ttu-id="c3040-1639">たとえば、ISO-2022-JP の場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1639">For example, this can happen for ISO-2022-JP.</span></span> <span data-ttu-id="c3040-1640">詳細については、ブログ記事「[GetMaxByteCount () と GetMaxCharCount () と](https://blogs.msdn.microsoft.com/shawnste/2005/03/02/whats-with-encoding-getmaxbytecount-and-encoding-getmaxcharcount/)は」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1640">For more information, see the blog post "[What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?](https://blogs.msdn.microsoft.com/shawnste/2005/03/02/whats-with-encoding-getmaxbytecount-and-encoding-getmaxcharcount/).</span></span>

 <span data-ttu-id="c3040-1641">ほとんどの場合、このメソッドは小さい文字列に対して適切な値を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1641">In most cases, this method retrieves reasonable values for small strings.</span></span> <span data-ttu-id="c3040-1642">大きな文字列の場合は、非常に大きなバッファーを使用するか、より適切なバッファーが小さすぎる場合にまれにエラーをキャッチするかを選択することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1642">For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small.</span></span> <span data-ttu-id="c3040-1643"><xref:System.Text.Encoding.GetByteCount%2A> または <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>を使用した別の方法を検討することもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1643">You might also want to consider a different approach using <xref:System.Text.Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="c3040-1644"><xref:System.Text.Encoding.GetMaxByteCount%2A>を使用する場合は、入力バッファーの最大サイズに基づいて出力バッファーを割り当てる必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1644">When using <xref:System.Text.Encoding.GetMaxByteCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer.</span></span> <span data-ttu-id="c3040-1645">出力バッファーのサイズが制限されている場合は、<xref:System.Text.Encoding.Convert%2A> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1645">If the output buffer is constrained in size, you might use the <xref:System.Text.Encoding.Convert%2A> method.</span></span>

 <span data-ttu-id="c3040-1646"><xref:System.Text.Encoding.GetMaxByteCount%2A> は、前のデコーダー操作から残っている可能性のあるサロゲートを考慮します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1646">Note that <xref:System.Text.Encoding.GetMaxByteCount%2A> considers potential leftover surrogates from a previous decoder operation.</span></span> <span data-ttu-id="c3040-1647">デコーダーがあるため、値1をメソッドに渡すと、ASCII などの1バイトエンコードの場合は2が取得されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1647">Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII.</span></span> <span data-ttu-id="c3040-1648">この情報が必要な場合は、<xref:System.Text.ASCIIEncoding.IsSingleByte%2A> プロパティを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1648">You should use the <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> property if this information is necessary.</span></span>

> [!NOTE]
>  <span data-ttu-id="c3040-1649">`GetMaxByteCount(N)` は、必ずしも `N* GetMaxByteCount(1)`と同じ値であるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1649">`GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.</span></span>



## Examples
 <span data-ttu-id="c3040-1650">次の例では、文字配列をエンコードし、文字をエンコードし、結果のバイトを表示するために必要なバイト数を決定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1650">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1651"><paramref name="charCount" /> に 0 より小さい値が指定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1651"><paramref name="charCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.EncoderFallbackException"><span data-ttu-id="c3040-1652">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1652">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1653">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1653">-and-</span></span>

 <span data-ttu-id="c3040-1654"><see cref="P:System.Text.Encoding.EncoderFallback" /> は <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1654"><see cref="P:System.Text.Encoding.EncoderFallback" /> is set to <see cref="T:System.Text.EncoderExceptionFallback" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="c3040-1655">すべての <see cref="T:System.Text.Encoding" /> 実装では、このメソッドの計算の結果に従ってバッファーのサイズが設定されている場合に、バッファーオーバーフロー例外が発生しないことを保証する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1655">All <see cref="T:System.Text.Encoding" /> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</span></span></para></block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount"><span data-ttu-id="c3040-1656">デコードするバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1656">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="c3040-1657">派生クラスでオーバーライドされた場合、指定したバイト数をデコードすることによって生成される最大文字数を計算します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1657">When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.</span></span></summary>
        <returns><span data-ttu-id="c3040-1658">指定したバイト数をデコードすることによって生成される最大文字数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1658">The maximum number of characters produced by decoding the specified number of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1659"><xref:System.Text.Encoding.GetChars%2A> が結果の文字を格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1659">To calculate the exact array size required by <xref:System.Text.Encoding.GetChars%2A> to store the resulting characters, you should use the <xref:System.Text.Encoding.GetCharCount%2A> method.</span></span> <span data-ttu-id="c3040-1660">配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1660">To calculate the maximum array size, use the <xref:System.Text.Encoding.GetMaxCharCount%2A> method.</span></span> <span data-ttu-id="c3040-1661"><xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは一般に高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1661">The <xref:System.Text.Encoding.GetCharCount%2A> method generally allows allocation of less memory, while the <xref:System.Text.Encoding.GetMaxCharCount%2A> method generally executes faster.</span></span>

 <span data-ttu-id="c3040-1662"><xref:System.Text.Encoding.GetMaxCharCount%2A> は、現在選択されている <xref:System.Text.DecoderFallback>の最悪のケースを含む、最悪のケース番号を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1662"><xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>.</span></span> <span data-ttu-id="c3040-1663">場合によっては大きな文字列を使用してフォールバックを選択すると、<xref:System.Text.Encoding.GetMaxCharCount%2A> は大きな値を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1663">If a fallback is chosen with a potentially large string, <xref:System.Text.Encoding.GetMaxCharCount%2A> retrieves large values.</span></span>

 <span data-ttu-id="c3040-1664">ほとんどの場合、このメソッドは小さい文字列に対して適切な数値を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1664">In most cases, this method retrieves reasonable numbers for small strings.</span></span> <span data-ttu-id="c3040-1665">大きな文字列の場合は、非常に大きいバッファーを使用するか、またはより適切なバッファーが小さすぎるというまれなエラーをキャッチするかを選択する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1665">For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small.</span></span> <span data-ttu-id="c3040-1666"><xref:System.Text.Encoding.GetCharCount%2A> または <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>を使用した別の方法を検討することもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1666">You might also want to consider a different approach using <xref:System.Text.Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.</span></span>

 <span data-ttu-id="c3040-1667"><xref:System.Text.Encoding.GetMaxCharCount%2A> に <xref:System.Text.Encoding.GetBytes%2A>との関係はありません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1667"><xref:System.Text.Encoding.GetMaxCharCount%2A> has no relation to <xref:System.Text.Encoding.GetBytes%2A>.</span></span> <span data-ttu-id="c3040-1668"><xref:System.Text.Encoding.GetBytes%2A>で使用する同様の関数が必要な場合は、<xref:System.Text.Encoding.GetMaxByteCount%2A>を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1668">If you needs a similar function to use with <xref:System.Text.Encoding.GetBytes%2A>, you should use <xref:System.Text.Encoding.GetMaxByteCount%2A>.</span></span>

 <span data-ttu-id="c3040-1669"><xref:System.Text.Encoding.GetMaxCharCount%2A>を使用する場合は、入力バッファーの最大サイズに基づいて出力バッファーを割り当てる必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1669">When using <xref:System.Text.Encoding.GetMaxCharCount%2A>, you should allocate the output buffer based on the maximum size of the input buffer.</span></span> <span data-ttu-id="c3040-1670">出力バッファーのサイズが制限されている場合は、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1670">If the output buffer is constrained in size, you might use the <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> method.</span></span>

 <span data-ttu-id="c3040-1671"><xref:System.Text.Encoding.GetMaxCharCount%2A> では、前のエンコーダー操作から残されたバイトの最悪のケースが考慮されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1671">Note that <xref:System.Text.Encoding.GetMaxCharCount%2A> considers the worst case for leftover bytes from a previous encoder operation.</span></span> <span data-ttu-id="c3040-1672">ほとんどのコードページでは、値0をこのメソッドに渡すと、1以上の値が取得されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1672">For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.</span></span>

> [!NOTE]
>  <span data-ttu-id="c3040-1673">`GetMaxCharCount(N)` は、必ずしも `N* GetMaxCharCount(1)`と同じ値であるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1673">`GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.</span></span>



## Examples
 <span data-ttu-id="c3040-1674">次の例では、文字列をバイト配列にエンコードし、バイトを文字配列にデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1674">The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</span></span>

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1675"><paramref name="byteCount" /> に 0 より小さい値が指定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1675"><paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="c3040-1676">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1676">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1677">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1677">-and-</span></span>

 <span data-ttu-id="c3040-1678"><see cref="P:System.Text.Encoding.DecoderFallback" /> は <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1678"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="c3040-1679">すべての <see cref="T:System.Text.Encoding" /> 実装では、このメソッドの計算の結果に従ってバッファーのサイズが設定されている場合に、バッファーオーバーフロー例外が発生しないことを保証する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1679">All <see cref="T:System.Text.Encoding" /> implementations must guarantee that no buffer overflow exceptions occur if buffers are sized according to the results of this method's calculations.</span></span></para></block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c3040-1680">派生クラスでオーバーライドされた場合、使用するエンコーディングを指定するバイト シーケンスを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1680">When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.</span></span></summary>
        <returns><span data-ttu-id="c3040-1681">使用するエンコーディングを指定するバイト シーケンスを格納するバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1681">A byte array containing a sequence of bytes that specifies the encoding used.</span></span>

 <span data-ttu-id="c3040-1682">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1682">-or-</span></span>

 <span data-ttu-id="c3040-1683">プリアンブルが不要な場合は、長さ 0 のバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1683">A byte array of length zero, if a preamble is not required.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1684">必要に応じて、<xref:System.Text.Encoding> オブジェクトは、エンコード処理によって生成されるバイトシーケンスにプレフィックスを付けることができるバイト配列であるプリアンブルを提供します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1684">Optionally, the <xref:System.Text.Encoding> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.</span></span> <span data-ttu-id="c3040-1685">プリアンブルにバイト順マーク (Unicode、コードポイント U + FEFF) が含まれている場合は、デコーダーがバイト順と変換形式または UTF を決定するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1685">If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.</span></span>

 <span data-ttu-id="c3040-1686">Unicode バイト順マーク (BOM) は、次のようにシリアル化されます (16 進数)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1686">The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</span></span>

-   <span data-ttu-id="c3040-1687">UTF-8: EF BB BF</span><span class="sxs-lookup"><span data-stu-id="c3040-1687">UTF-8: EF BB BF</span></span>

-   <span data-ttu-id="c3040-1688">UTF-16 ビッグエンディアンバイト順: FE FF</span><span class="sxs-lookup"><span data-stu-id="c3040-1688">UTF-16 big endian byte order: FE FF</span></span>

-   <span data-ttu-id="c3040-1689">UTF-16 リトルエンディアンバイト順: FF FE</span><span class="sxs-lookup"><span data-stu-id="c3040-1689">UTF-16 little endian byte order: FF FE</span></span>

-   <span data-ttu-id="c3040-1690">32 UTF-8 ビッグエンディアンバイト順:00 00 FE FF</span><span class="sxs-lookup"><span data-stu-id="c3040-1690">UTF-32 big endian byte order: 00 00 FE FF</span></span>

-   <span data-ttu-id="c3040-1691">32 UTF-8 リトルエンディアンバイト順: FF FE 00 00</span><span class="sxs-lookup"><span data-stu-id="c3040-1691">UTF-32 little endian byte order: FF FE 00 00</span></span>

 <span data-ttu-id="c3040-1692">BOM を使用する必要があります。これは、<xref:System.Text.Encoding> オブジェクトへの参照が失われたファイル (タグなしまたは不適切なタグが付けられた web データや、ビジネスで国際的な問題や他のデータがない場合に保存されたランダムなテキストファイルなど) について、ほとんど特定のエンコードを識別できるためです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1692">You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.Encoding> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data.</span></span> <span data-ttu-id="c3040-1693">データが一貫して適切にタグ付けされている場合 (UTF-8 または UTF-16 の場合)、ユーザーの問題が回避されることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1693">Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.</span></span>

 <span data-ttu-id="c3040-1694">エンコードの種類を提供する標準の場合、BOM はやや冗長です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1694">For standards that provide an encoding type, a BOM is somewhat redundant.</span></span> <span data-ttu-id="c3040-1695">ただし、このメソッドを使用して、サーバーが正しいエンコードヘッダーを送信できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1695">However, it can be used to help a server send the correct encoding header.</span></span> <span data-ttu-id="c3040-1696">または、エンコードが失われた場合にフォールバックとして使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1696">Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</span></span>

 <span data-ttu-id="c3040-1697">BOM の使用にはいくつかの欠点があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1697">There are some disadvantages to using a BOM.</span></span> <span data-ttu-id="c3040-1698">たとえば、BOM を使用するデータベースフィールドを制限する方法を理解することは困難です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1698">For example, knowing how to limit the database fields that use a BOM can be difficult.</span></span> <span data-ttu-id="c3040-1699">ファイルの連結も問題になることがあります。たとえば、不要な文字がデータの途中で終了するような方法でファイルをマージする場合などです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1699">Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</span></span> <span data-ttu-id="c3040-1700">ただし、いくつかの欠点がありますが、BOM を使用することを強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1700">In spite of the few disadvantages, however, the use of a BOM is highly recommended.</span></span>

 <span data-ttu-id="c3040-1701">バイト順とバイト順マークの詳細については、unicode[ホームページ](https://go.microsoft.com/fwlink/?LinkId=37123)の unicode 標準を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1701">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://go.microsoft.com/fwlink/?LinkId=37123).</span></span>

> [!CAUTION]
>  <span data-ttu-id="c3040-1702">エンコードされたバイトが正しくデコードされるようにするには、エンコードされたバイトをプリアンブルでプレフィックスとして付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1702">To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble.</span></span> <span data-ttu-id="c3040-1703">ただし、ほとんどのエンコーディングではプリアンブルが提供されません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1703">However, most encodings do not provide a preamble.</span></span> <span data-ttu-id="c3040-1704">エンコードされたバイトが正しくデコードされるようにするには、Unicode エンコーディング (つまり、<xref:System.Text.UTF8Encoding>、<xref:System.Text.UnicodeEncoding>、または <xref:System.Text.UTF32Encoding>) をプリアンブルで使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1704">To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, or <xref:System.Text.UTF32Encoding>, with a preamble.</span></span>



## Examples
 <span data-ttu-id="c3040-1705">次の例では、プリアンブルに基づくエンコードのバイト順を決定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1705">The following example determines the byte order of the encoding based on the preamble.</span></span>

 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c3040-1706">派生クラスでオーバーライドされた場合、バイト シーケンスを文字列にデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1706">When overridden in a derived class, decodes a sequence of bytes into a string.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="c3040-1707">デコード対象のバイト シーケンスが格納されたバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1707">The byte array containing the sequence of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="c3040-1708">派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているすべてのバイトを文字列にデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1708">When overridden in a derived class, decodes all the bytes in the specified byte array into a string.</span></span></summary>
        <returns><span data-ttu-id="c3040-1709">指定したバイト シーケンスのデコード結果が格納されている文字列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1709">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1710">変換するデータが、連続するブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドによって返される <xref:System.Text.Decoder> オブジェクトを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1710">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>

 <span data-ttu-id="c3040-1711">デコード手法と考慮事項の説明については、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> リファレンストピックの「解説」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1711">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>

 <span data-ttu-id="c3040-1712">特定の <xref:System.Text.Encoding> 実装の <xref:System.Text.Encoding.GetString%2A> メソッドの正確な動作は、その <xref:System.Text.Encoding> オブジェクトに対して定義されているフォールバックストラテジによって異なります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1712">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="c3040-1713">詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」トピックの「フォールバックストラテジの選択」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1713">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) topic.</span></span>



## Examples
 <span data-ttu-id="c3040-1714">次の例では、<xref:System.IO.FileStream> オブジェクトによって表されるバイナリファイルから、UTF-8 でエンコードされた文字列を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1714">The following example reads a UTF-8 encoded string from a binary file represented by a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="c3040-1715">2048バイトより小さいファイルの場合、ファイル全体の内容をバイト配列に読み取り、<xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> メソッドを呼び出してデコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1715">For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> method to perform the decoding.</span></span> <span data-ttu-id="c3040-1716">サイズの大きいファイルの場合は、一度に2048バイトをバイト配列に読み取り、<xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを呼び出して配列に格納されている文字数を確認した後、<xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを呼び出してデコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1716">For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to determine how many characters are contained in the array, and then calls the <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> method to perform the decoding.</span></span>

 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]

 <span data-ttu-id="c3040-1717">この例では、次のテキストを使用します。これは、Utf8Example という名前の UTF-8 でエンコードされたファイルに保存する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1717">The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</span></span>

```

This is a UTF-8-encoded file that contains primarily Latin text, although it
does list the first twelve letters of the Russian (Cyrillic) alphabet:

А б в г д е ё ж з и й к

The goal is to save this file, then open and decode it as a binary stream.

```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c3040-1718">このバイト配列には、無効な Unicode コード ポイントが含まれています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1718">The byte array contains invalid Unicode code points.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1719"><paramref name="bytes" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1719"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="c3040-1720">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1720">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1721">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1721">-and-</span></span>

 <span data-ttu-id="c3040-1722"><see cref="P:System.Text.Encoding.DecoderFallback" /> は <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1722"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="c3040-1723">Unicode 文字列にデコードする読み取り専用バイト スパン。</span><span class="sxs-lookup"><span data-stu-id="c3040-1723">A read-only byte span to decode to a Unicode string.</span></span></param>
        <summary><span data-ttu-id="c3040-1724">派生クラスでオーバーライドされた場合、指定したバイト スパンに格納されているすべてのバイトを文字列にデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1724">When overridden in a derived class, decodes all the bytes in the specified byte span into a string.</span></span></summary>
        <returns><span data-ttu-id="c3040-1725">指定した読み取り専用スパンからデコードされたバイトを格納している文字列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1725">A string that contains the decoded bytes from the provided read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1726"><xref:System.Text.Encoding.GetString%2A> メソッドは、パフォーマンスを最適化するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1726">The <xref:System.Text.Encoding.GetString%2A> method is designed to optimize performance.</span></span> <span data-ttu-id="c3040-1727">マネージバイト配列を作成してからデコードする代わりに、このメソッドを呼び出すことができます。その際、中間オブジェクトを作成する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1727">Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.</span></span>

 <span data-ttu-id="c3040-1728">変換するデータが、連続するブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドによって返される <xref:System.Text.Decoder> オブジェクトを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1728">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>

 <span data-ttu-id="c3040-1729">デコード手法と考慮事項の説明については、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> リファレンストピックの「解説」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1729">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>

 <span data-ttu-id="c3040-1730">特定の <xref:System.Text.Encoding> 実装の <xref:System.Text.Encoding.GetString%2A> メソッドの正確な動作は、その <xref:System.Text.Encoding> オブジェクトに対して定義されているフォールバックストラテジによって異なります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1730">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="c3040-1731">詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」トピックの「フォールバックストラテジの選択」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1731">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) topic.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="c3040-1732">バイト配列へのポインター。</span><span class="sxs-lookup"><span data-stu-id="c3040-1732">A pointer to a byte array.</span></span></param>
        <param name="byteCount"><span data-ttu-id="c3040-1733">デコードするバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1733">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="c3040-1734">派生クラスでオーバーライドされた場合、指定したアドレスで始まる指定したバイト数を文字列にデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1734">When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string.</span></span></summary>
        <returns><span data-ttu-id="c3040-1735">指定したバイト シーケンスのデコード結果が格納されている文字列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1735">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1736"><xref:System.Text.Encoding.GetString%2A> メソッドは、バイト配列へのネイティブポインターがある場合にパフォーマンスを最適化するように設計されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1736">The <xref:System.Text.Encoding.GetString%2A> method is designed to optimize performance when you have a native pointer to a byte array.</span></span> <span data-ttu-id="c3040-1737">マネージバイト配列を作成してからデコードする代わりに、このメソッドを呼び出すことができます。その際、中間オブジェクトを作成する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1737">Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects.</span></span>

 <span data-ttu-id="c3040-1738">変換するデータが、連続するブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドによって返される <xref:System.Text.Decoder> オブジェクトを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1738">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> object returned by the <xref:System.Text.Encoding.GetDecoder%2A> method of a derived class.</span></span>

 <span data-ttu-id="c3040-1739">デコード手法と考慮事項の説明については、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> リファレンストピックの「解説」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1739">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>

 <span data-ttu-id="c3040-1740">特定の <xref:System.Text.Encoding> 実装の <xref:System.Text.Encoding.GetString%2A> メソッドの正確な動作は、その <xref:System.Text.Encoding> オブジェクトに対して定義されているフォールバックストラテジによって異なります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1740">Note that the precise behavior of the <xref:System.Text.Encoding.GetString%2A> method for a particular <xref:System.Text.Encoding> implementation depends on the fallback strategy defined for that <xref:System.Text.Encoding> object.</span></span> <span data-ttu-id="c3040-1741">詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」トピックの「フォールバックストラテジの選択」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1741">For more information, see the "Choosing a Fallback Strategy" section of the [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md) topic.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1742"><paramref name="bytes" /> が null ポインターです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1742"><paramref name="bytes" /> is a null pointer.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1743"><paramref name="byteCount" /> に 0 より小さい値が指定されています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1743"><paramref name="byteCount" /> is less than zero.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="c3040-1744">フォールバックが発生しました (詳細な説明については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1744">A fallback occurred (see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>) for a complete explanation)</span></span>

<span data-ttu-id="c3040-1745">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1745">-and-</span></span>

 <span data-ttu-id="c3040-1746"><see cref="P:System.Text.Encoding.DecoderFallback" /> は <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1746"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes"><span data-ttu-id="c3040-1747">デコード対象のバイト シーケンスが格納されたバイト配列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1747">The byte array containing the sequence of bytes to decode.</span></span></param>
        <param name="index"><span data-ttu-id="c3040-1748">デコードする最初のバイトのインデックス。</span><span class="sxs-lookup"><span data-stu-id="c3040-1748">The index of the first byte to decode.</span></span></param>
        <param name="count"><span data-ttu-id="c3040-1749">デコードするバイト数。</span><span class="sxs-lookup"><span data-stu-id="c3040-1749">The number of bytes to decode.</span></span></param>
        <summary><span data-ttu-id="c3040-1750">派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスを文字列にデコードします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1750">When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.</span></span></summary>
        <returns><span data-ttu-id="c3040-1751">指定したバイト シーケンスのデコード結果が格納されている文字列。</span><span class="sxs-lookup"><span data-stu-id="c3040-1751">A string that contains the results of decoding the specified sequence of bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1752">変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1752">If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.Encoding.GetDecoder%2A> method or the <xref:System.Text.Encoding.GetEncoder%2A> method, respectively, of a derived class.</span></span>

 <span data-ttu-id="c3040-1753">デコード手法と考慮事項の説明については、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> リファレンストピックの「解説」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1753">See the Remarks section of the <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> reference topic for a discussion of decoding techniques and considerations.</span></span>



## Examples
 <span data-ttu-id="c3040-1754">次の例では、<xref:System.IO.FileStream> オブジェクトによって表されるバイナリファイルから、UTF-8 でエンコードされた文字列を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1754">The following example reads a UTF-8 encoded string from a binary file that is represented by a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="c3040-1755">2048バイトより小さいファイルの場合、ファイル全体の内容をバイト配列に読み取り、<xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> メソッドを呼び出してデコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1755">For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to perform the decoding.</span></span> <span data-ttu-id="c3040-1756">サイズの大きいファイルの場合は、一度に2048バイトをバイト配列に読み取り、<xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを呼び出して配列に格納されている文字数を確認した後、<xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを呼び出してデコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1756">For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to determine how many characters are contained in the array, and then calls the <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> method to perform the decoding.</span></span>

 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]

 <span data-ttu-id="c3040-1757">この例では、次のテキストを使用します。これは、Utf8Example という名前の UTF-8 でエンコードされたファイルに保存する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1757">The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</span></span>

```

This is a UTF-8-encoded file that contains primarily Latin text, although it
does list the first twelve letters of the Russian (Cyrillic) alphabet:

А б в г д е ё ж з и й к

The goal is to save this file, then open and decode it as a binary stream.

```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c3040-1758">このバイト配列には、無効な Unicode コード ポイントが含まれています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1758">The byte array contains invalid Unicode code points.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1759"><paramref name="bytes" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1759"><paramref name="bytes" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c3040-1760"><paramref name="index" /> または <paramref name="count" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1760"><paramref name="index" /> or <paramref name="count" /> is less than zero.</span></span>

<span data-ttu-id="c3040-1761">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1761">-or-</span></span>

 <span data-ttu-id="c3040-1762"><paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1762"><paramref name="index" /> and <paramref name="count" /> do not denote a valid range in <paramref name="bytes" />.</span></span></exception>
        <exception cref="T:System.Text.DecoderFallbackException"><span data-ttu-id="c3040-1763">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)</span><span class="sxs-lookup"><span data-stu-id="c3040-1763">A fallback occurred (for more information, see <see href="~/docs/standard/base-types/character-encoding.md">Character Encoding in .NET</see>)</span></span>

<span data-ttu-id="c3040-1764">および</span><span class="sxs-lookup"><span data-stu-id="c3040-1764">-and-</span></span>

 <span data-ttu-id="c3040-1765"><see cref="P:System.Text.Encoding.DecoderFallback" /> は <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1765"><see cref="P:System.Text.Encoding.DecoderFallback" /> is set to <see cref="T:System.Text.DecoderExceptionFallback" />.</span></span></exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-1766">派生クラスでオーバーライドされた場合、メール エージェント ヘッダー タグと共に使用できる現在のエンコーディングの名前を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1766">When overridden in a derived class, gets a name for the current encoding that can be used with mail agent header tags.</span></span></summary>
        <value><span data-ttu-id="c3040-1767">メール エージェント ヘッダー タグと共に使用する、現在の <see cref="T:System.Text.Encoding" /> の名前。</span><span class="sxs-lookup"><span data-stu-id="c3040-1767">A name for the current <see cref="T:System.Text.Encoding" /> to use with mail agent header tags.</span></span>

<span data-ttu-id="c3040-1768">または</span><span class="sxs-lookup"><span data-stu-id="c3040-1768">-or-</span></span>

<span data-ttu-id="c3040-1769">現在の <see cref="T:System.Text.Encoding" /> が使用できない場合は、空の文字列 ("")。</span><span class="sxs-lookup"><span data-stu-id="c3040-1769">An empty string (""), if the current <see cref="T:System.Text.Encoding" /> cannot be used.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1770">ヘッダー名にエンコーディングが必要な場合は、<xref:System.Text.Encoding.HeaderName%2A> プロパティを使用して <xref:System.Text.Encoding.GetEncoding%2A> メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1770">If you need an encoding for a header name, you should call the <xref:System.Text.Encoding.GetEncoding%2A> method with the <xref:System.Text.Encoding.HeaderName%2A> property.</span></span> <span data-ttu-id="c3040-1771">多くの場合、メソッドは、呼び出しに含まれるテストエンコーディングから別のエンコーディングを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1771">Often the method retrieves a different encoding from the test encoding furnished in the call.</span></span> <span data-ttu-id="c3040-1772">通常、このようなエンコードを取得する必要があるのは電子メールアプリケーションのみです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1772">Generally only email applications need to retrieve such an encoding.</span></span>

 <span data-ttu-id="c3040-1773">場合によっては、<xref:System.Text.Encoding.BodyName%2A> プロパティの値は、そのエンコーディングを定義する国際標準に対応します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1773">In some cases, the value of the <xref:System.Text.Encoding.BodyName%2A> property corresponds to the international standard that defines that encoding.</span></span> <span data-ttu-id="c3040-1774">これは、実装がその標準で完全に準拠しているという意味ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1774">This doesn't mean that the implementation complies in full with that standard.</span></span>

 <span data-ttu-id="c3040-1775"><xref:System.Text.Encoding.WebName%2A> は、エンコーディングの記述に使用する名前を返すことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1775">Note that <xref:System.Text.Encoding.WebName%2A> returns the name to use to describe an encoding.</span></span> <span data-ttu-id="c3040-1776"><xref:System.Text.Encoding.HeaderName%2A> プロパティは、たとえば、電子メールアプリケーションでより適切に機能する可能性がある別のエンコードを定義します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1776">The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for an email application, for example.</span></span> <span data-ttu-id="c3040-1777">ただし、プロパティを使用してエンコードを定義することはお勧めしません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1777">However, use of the property to define the encoding is not recommended.</span></span>



## Examples
 <span data-ttu-id="c3040-1778">次の例では、各エンコードの異なる名前を取得し、<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>とは異なる1つ以上の名前のエンコーディングを表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1778">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3040-1779"><xref:System.Text.Encoding.EncodingName%2A> が表示されますが、比較は行われません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1779">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c3040-1780">現在のエンコーディングが常に正規化されるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1780">Gets a value indicating whether the current encoding is always normalized.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c3040-1781">現在のエンコーディングが、既定の正規形を使用して常に正規化されるかどうかを示す値。</span><span class="sxs-lookup"><span data-stu-id="c3040-1781">Gets a value indicating whether the current encoding is always normalized, using the default normalization form.</span></span></summary>
        <returns><span data-ttu-id="c3040-1782">現在の <see langword="true" /> が常に正規化される場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c3040-1782"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is always normalized; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c3040-1783">既定では、 <see langword="false" />です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1783">The default is <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1784">既定の正規化形式は <xref:System.Text.NormalizationForm.FormC>であり、正規の完全な分解を使用した後に、可能であれば、シーケンスをプライマリ複合に置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1784">The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="form"><span data-ttu-id="c3040-1785"><see cref="T:System.Text.NormalizationForm" /> 値のいずれか 1 つです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1785">One of the <see cref="T:System.Text.NormalizationForm" /> values.</span></span></param>
        <summary><span data-ttu-id="c3040-1786">派生クラスでオーバーライドされた場合、現在のエンコーディングが、指定した正規形を使用して常に正規化されるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1786">When overridden in a derived class, gets a value indicating whether the current encoding is always normalized, using the specified normalization form.</span></span></summary>
        <returns><span data-ttu-id="c3040-1787">現在の <see langword="true" /> オブジェクトが、指定した <see cref="T:System.Text.Encoding" /> 値を使用して常に正規化される場合は <see cref="T:System.Text.NormalizationForm" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c3040-1787"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> object is always normalized using the specified <see cref="T:System.Text.NormalizationForm" /> value; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c3040-1788">既定では、 <see langword="false" />です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1788">The default is <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1789">既定の正規化形式は <xref:System.Text.NormalizationForm.FormC>であり、正規の完全な分解を使用した後に、可能であれば、シーケンスをプライマリ複合に置き換えることができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1789">The default normalization form is <xref:System.Text.NormalizationForm.FormC>, which uses full canonical decomposition, followed by the replacement of sequences with their primary composites, if possible.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-1790">派生クラスでオーバーライドされた場合、ブラウザー クライアントが現在のエンコーディングを使用してコンテンツを表示できるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1790">When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for displaying content.</span></span></summary>
        <value><span data-ttu-id="c3040-1791">ブラウザー クライアントが現在の <see langword="true" /> を使用してコンテンツを表示できる場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c3040-1791"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by browser clients for displaying content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="c3040-1792">次の例では、各エンコーディングのブール型プロパティの値をチェックします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1792">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-1793">派生クラスでオーバーライドされた場合、ブラウザー クライアントが現在のエンコーディングを使用してコンテンツを保存できるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1793">When overridden in a derived class, gets a value indicating whether the current encoding can be used by browser clients for saving content.</span></span></summary>
        <value><span data-ttu-id="c3040-1794">ブラウザー クライアントが現在の <see langword="true" /> を使用してコンテンツを保存できる場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c3040-1794"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by browser clients for saving content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="c3040-1795">次の例では、各エンコーディングのブール型プロパティの値をチェックします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1795">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-1796">派生クラスでオーバーライドされた場合、メール クライアントおよびニュース クライアントが現在のエンコーディングを使用してコンテンツを表示できるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1796">When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for displaying content.</span></span></summary>
        <value><span data-ttu-id="c3040-1797">メール クライアントおよびニュース クライアントが現在の <see langword="true" /> を使用してコンテンツを表示できる場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c3040-1797"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by mail and news clients for displaying content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="c3040-1798">次の例では、各エンコーディングのブール型プロパティの値をチェックします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1798">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-1799">派生クラスでオーバーライドされた場合、メール クライアントおよびニュース クライアントが現在のエンコーディングを使用してコンテンツを保存できるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1799">When overridden in a derived class, gets a value indicating whether the current encoding can be used by mail and news clients for saving content.</span></span></summary>
        <value><span data-ttu-id="c3040-1800">メール クライアントおよびニュース クライアントが現在の <see langword="true" /> を使用してコンテンツを保存できる場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c3040-1800"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> can be used by mail and news clients for saving content; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 <span data-ttu-id="c3040-1801">次の例では、各エンコーディングのブール型プロパティの値をチェックします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1801">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-1802">派生クラスでオーバーライドされた場合、現在のエンコーディングが読み取り専用かどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1802">When overridden in a derived class, gets a value indicating whether the current encoding is read-only.</span></span></summary>
        <value><span data-ttu-id="c3040-1803">現在の <see langword="true" /> が読み取り専用の場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c3040-1803"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> is read-only; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="c3040-1804">既定では、 <see langword="true" />です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1804">The default is <see langword="true" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-1805">派生クラスでオーバーライドされた場合、現在のエンコーディングが 1 バイトのコード ポイントを使用するかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1805">When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.</span></span></summary>
        <value><span data-ttu-id="c3040-1806">現在の <see langword="true" /> が 1 バイトのコード ポイントを使用する場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="c3040-1806"><see langword="true" /> if the current <see cref="T:System.Text.Encoding" /> uses single-byte code points; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1807">1バイトエンコード (<xref:System.Text.ASCIIEncoding>など) の場合、このプロパティは `true`を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1807">For a single-byte encoding, for example, <xref:System.Text.ASCIIEncoding>, this property retrieves `true`.</span></span>

> [!CAUTION]
>  <span data-ttu-id="c3040-1808"><xref:System.Text.Encoding.IsSingleByte%2A>の値を使用してアプリケーションが行う処理を慎重に行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1808">You should be careful in what your application does with the value for <xref:System.Text.Encoding.IsSingleByte%2A>.</span></span> <span data-ttu-id="c3040-1809">エンコードが続行されることを前提としている場合もあります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1809">An assumption of how an Encoding will proceed may still be wrong.</span></span> <span data-ttu-id="c3040-1810">たとえば、Windows-1252 では <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>に対して `true` の値が使用されますが、GetMaxByteCount (1) は2を返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1810">For example, Windows-1252 has a value of `true` for <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, but Encoding.GetMaxByteCount(1) returns 2.</span></span> <span data-ttu-id="c3040-1811">これは、メソッドが、前のデコーダー操作から残っている可能性のあるサロゲートを考慮するためです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1811">This is because the method considers potential leftover surrogates from a previous decoder operation.</span></span>



## Examples
 <span data-ttu-id="c3040-1812">次の例では、各エンコーディングのブール型プロパティの値をチェックします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1812">The following example checks the values of the Boolean properties of each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-1813">派生クラスでオーバーライドされた場合、使用するエンコードを指定するバイト シーケンスを含むスパンが返されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1813">When overridden in a derived class, returns a span containing the sequence of bytes that specifies the encoding used.</span></span></summary>
        <value><span data-ttu-id="c3040-1814">使用するエンコードを指定するバイト シーケンスを含むバイト スパン、または長さがゼロのスパン (プリアンブルが不要な場合)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1814">A byte span containing a sequence of bytes that specifies the encoding used, or a span of length zero, if a preamble is not required.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1815">必要に応じて、<xref:System.Text.Encoding> オブジェクトは、エンコーディングプロセスによって生成されるバイトの前に付加できるバイトシーケンスであるプリアンブルを提供します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1815">Optionally, the <xref:System.Text.Encoding> object provides a preamble that is an sequence of bytes that can be prefixed to the bytes resulting from the encoding process.</span></span> <span data-ttu-id="c3040-1816">プリアンブルにバイト順マーク (Unicode、コードポイント U + FEFF) が含まれている場合は、デコーダーがバイト順と変換形式または UTF を決定するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1816">If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF.</span></span>

 <span data-ttu-id="c3040-1817">Unicode バイト順マーク (BOM) は、次のようにシリアル化されます (16 進数)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1817">The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):</span></span>

-   <span data-ttu-id="c3040-1818">UTF-8: EF BB BF</span><span class="sxs-lookup"><span data-stu-id="c3040-1818">UTF-8: EF BB BF</span></span>

-   <span data-ttu-id="c3040-1819">UTF-16 ビッグエンディアンバイト順: FE FF</span><span class="sxs-lookup"><span data-stu-id="c3040-1819">UTF-16 big endian byte order: FE FF</span></span>

-   <span data-ttu-id="c3040-1820">UTF-16 リトルエンディアンバイト順: FF FE</span><span class="sxs-lookup"><span data-stu-id="c3040-1820">UTF-16 little endian byte order: FF FE</span></span>

-   <span data-ttu-id="c3040-1821">32 UTF-8 ビッグエンディアンバイト順:00 00 FE FF</span><span class="sxs-lookup"><span data-stu-id="c3040-1821">UTF-32 big endian byte order: 00 00 FE FF</span></span>

-   <span data-ttu-id="c3040-1822">32 UTF-8 リトルエンディアンバイト順: FF FE 00 00</span><span class="sxs-lookup"><span data-stu-id="c3040-1822">UTF-32 little endian byte order: FF FE 00 00</span></span>

 <span data-ttu-id="c3040-1823">BOM を使用する必要があります。これは、<xref:System.Text.Encoding> オブジェクトへの参照が失われたファイル (タグなしまたは不適切なタグが付けられた web データや、ビジネスで国際的な問題や他のデータがない場合に保存されたランダムなテキストファイルなど) について、ほとんど特定のエンコードを識別できるためです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1823">You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.Encoding> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data.</span></span> <span data-ttu-id="c3040-1824">データが一貫して適切にタグ付けされている場合 (UTF-8 または UTF-16 の場合)、ユーザーの問題が回避されることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1824">Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.</span></span>

 <span data-ttu-id="c3040-1825">エンコードの種類を提供する標準の場合、BOM はやや冗長です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1825">For standards that provide an encoding type, a BOM is somewhat redundant.</span></span> <span data-ttu-id="c3040-1826">ただし、このメソッドを使用して、サーバーが正しいエンコードヘッダーを送信できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1826">However, it can be used to help a server send the correct encoding header.</span></span> <span data-ttu-id="c3040-1827">または、エンコードが失われた場合にフォールバックとして使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1827">Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</span></span>

 <span data-ttu-id="c3040-1828">BOM の使用にはいくつかの欠点があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1828">There are some disadvantages to using a BOM.</span></span> <span data-ttu-id="c3040-1829">たとえば、BOM を使用するデータベースフィールドを制限する方法を理解することは困難です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1829">For example, knowing how to limit the database fields that use a BOM can be difficult.</span></span> <span data-ttu-id="c3040-1830">ファイルの連結も問題になることがあります。たとえば、不要な文字がデータの途中で終了するような方法でファイルをマージする場合などです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1830">Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</span></span> <span data-ttu-id="c3040-1831">ただし、いくつかの欠点はありますが、BOM を使用することを強くお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1831">Despite the few disadvantages, however, the use of a BOM is highly recommended.</span></span>

 <span data-ttu-id="c3040-1832">バイト順とバイト順マークの詳細については、unicode[ホームページ](https://home.unicode.org/)の unicode 標準を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1832">For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](https://home.unicode.org/).</span></span>

> [!CAUTION]
>  <span data-ttu-id="c3040-1833">エンコードされたバイトが正しくデコードされるようにするには、エンコードされたバイトをプリアンブルでプレフィックスとして付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1833">To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble.</span></span> <span data-ttu-id="c3040-1834">ただし、ほとんどのエンコーディングではプリアンブルが提供されません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1834">However, most encodings do not provide a preamble.</span></span> <span data-ttu-id="c3040-1835">エンコードされたバイトが正しくデコードされるようにするには、Unicode エンコーディング (つまり、<xref:System.Text.UTF8Encoding>、<xref:System.Text.UnicodeEncoding>、または <xref:System.Text.UTF32Encoding>) をプリアンブルで使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1835">To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, or <xref:System.Text.UTF32Encoding>, with a preamble.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="c3040-1836">追加の文字エンコーディングへのアクセスを提供する <see cref="T:System.Text.EncodingProvider" /> のサブクラス。</span><span class="sxs-lookup"><span data-stu-id="c3040-1836">A subclass of <see cref="T:System.Text.EncodingProvider" /> that provides access to additional character encodings.</span></span></param>
        <summary><span data-ttu-id="c3040-1837">エンコーディング プロバイダーを登録します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1837">Registers an encoding provider.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1838"><xref:System.Text.Encoding.RegisterProvider%2A> メソッドを使用すると、他の方法ではサポートされないプラットフォームで文字エンコーディングを使用できるようにする <xref:System.Text.EncodingProvider> から派生したクラスを登録できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1838">The <xref:System.Text.Encoding.RegisterProvider%2A> method allows you to register a class derived from <xref:System.Text.EncodingProvider> that makes character encodings available on a platform that does not otherwise support them.</span></span> <span data-ttu-id="c3040-1839">エンコードプロバイダーが登録されると、サポートされているエンコーディングは、任意の <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> オーバーロードを呼び出すことによって取得できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1839">Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> overload.</span></span> <span data-ttu-id="c3040-1840">複数のエンコードプロバイダーがある場合、<xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> メソッドは、最後に登録されたもので始まる各プロバイダーから、指定されたエンコーディングを取得しようとします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1840">If there are multiple encoding providers, the <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> method attempts to retrieve a specified encoding from each provider starting with the one most recently registered.</span></span>

<span data-ttu-id="c3040-1841"><xref:System.Text.Encoding.RegisterProvider%2A> メソッドを使用してエンコーディングプロバイダーを登録すると、`0`の引数が渡されたときに、 [encoding.getencoding (int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>)メソッドと[「encodingprovider」 (int32, EncoderFallback, DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))メソッドの動作も変更されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1841">Registering an encoding provider by using the <xref:System.Text.Encoding.RegisterProvider%2A> method also modifies the behavior of the [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) and [EncodingProvider.GetEncoding(Int32, EncoderFallback, DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) methods when passed an argument of `0`:</span></span>

- <span data-ttu-id="c3040-1842">登録されているプロバイダーが <xref:System.Text.CodePagesEncodingProvider>の場合、メソッドは、Windows オペレーティングシステムで実行されている場合に、システムのアクティブなコードページと一致するエンコーディングを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1842">If the registered provider is the <xref:System.Text.CodePagesEncodingProvider>, the method returns the encoding that matches the system active code page when running on the Windows operating system.</span></span>

- <span data-ttu-id="c3040-1843">カスタムエンコーディングプロバイダーは、これらの <xref:System.Text.Encoding.GetEncoding%2A> メソッドオーバーロードのいずれかに `0`の引数が渡されたときに返すエンコーディングを選択できます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1843">A custom encoding provider can choose which encoding to return when either of these <xref:System.Text.Encoding.GetEncoding%2A> method overloads is passed an argument of `0`.</span></span> <span data-ttu-id="c3040-1844">また、<xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> メソッドが `null`を返すことによって、エンコーディングを返さないように選択することもできます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1844">The provider can also choose to not return an encoding by having the <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> method return `null`.</span></span>

<span data-ttu-id="c3040-1845">.NET Framework 4.6 以降、.NET Framework には、完全な .NET Framework に存在するがユニバーサル Windows プラットフォームでは使用できないエンコーディングを使用できるようにする1つのエンコードプロバイダー (<xref:System.Text.CodePagesEncodingProvider>) が含まれています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1845">Starting with the .NET Framework 4.6, the .NET Framework includes one encoding provider, <xref:System.Text.CodePagesEncodingProvider>, that makes the encodings available that are present in the full .NET Framework but are not available in the Universal Windows Platform.</span></span> <span data-ttu-id="c3040-1846">既定では、ユニバーサル Windows プラットフォームは Unicode エンコーディング、ASCII、およびコードページ28591のみをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1846">By default, the Universal Windows Platform only supports the Unicode encodings, ASCII, and code page 28591.</span></span>

 <span data-ttu-id="c3040-1847"><xref:System.Text.Encoding.RegisterProvider%2A> メソッドの複数の呼び出しで同じエンコーディングプロバイダーが使用されている場合、最初のメソッド呼び出しのみがプロバイダーを登録します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1847">If the same encoding provider is used in multiple calls to the <xref:System.Text.Encoding.RegisterProvider%2A> method, only the first method call registers the provider.</span></span> <span data-ttu-id="c3040-1848">後続の呼び出しは無視されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1848">Subsequent calls are ignored.</span></span>

 <span data-ttu-id="c3040-1849">同じエンコーディングを処理する複数のプロバイダーを登録するために <xref:System.Text.Encoding.RegisterProvider%2A> メソッドが呼び出されると、最後に登録されたプロバイダーが、すべてのエンコードおよびデコード操作に使用されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1849">If the <xref:System.Text.Encoding.RegisterProvider%2A> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations.</span></span> <span data-ttu-id="c3040-1850">以前に登録されたプロバイダーは無視されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1850">Any previously registered providers are ignored.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c3040-1851"><paramref name="provider" /> が <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="c3040-1851"><paramref name="provider" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-1852">リトル エンディアン バイト順を使用する UTF-16 形式のエンコーディングを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1852">Gets an encoding for the UTF-16 format using the little endian byte order.</span></span></summary>
        <value><span data-ttu-id="c3040-1853">リトル エンディアンのバイト順を使用する UTF-16 形式のエンコーディング。</span><span class="sxs-lookup"><span data-stu-id="c3040-1853">An encoding for the UTF-16 format using the little endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1854">.NET でサポートされているエンコーディングと、使用する Unicode エンコーディングの詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1854">For information about the encodings supported by the .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>

 <span data-ttu-id="c3040-1855">このプロパティによって返される <xref:System.Text.UnicodeEncoding> オブジェクトは、アプリに対して適切な動作を持つことはできません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1855">The <xref:System.Text.UnicodeEncoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="c3040-1856">この例では、置換フォールバックを使用して、エンコードできない各文字列と、デコードできない各バイトを疑問符 ("?") 文字で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1856">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark ("?") character.</span></span> <span data-ttu-id="c3040-1857">代わりに、<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> コンストラクターを呼び出して、次の例に示すように、フォールバックが <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>であるリトルエンディアン <xref:System.Text.UnicodeEncoding> オブジェクトをインスタンス化することができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1857">Instead, you can call the <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a little endian <xref:System.Text.UnicodeEncoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]



## Examples
 <span data-ttu-id="c3040-1858">次の例では、文字配列をエンコードし、文字をエンコードし、結果のバイトを表示するために必要なバイト数を決定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1858">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-1859">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-1859">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-1860">リトル エンディアン バイト順を使用する UTF-32 形式のエンコーディングを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1860">Gets an encoding for the UTF-32 format using the little endian byte order.</span></span></summary>
        <value><span data-ttu-id="c3040-1861">リトル エンディアンのバイト順を使用する UTF-32 形式のエンコーディング オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="c3040-1861">An  encoding object for the UTF-32 format using the little endian byte order.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1862">このプロパティによって返される <xref:System.Text.UTF32Encoding> オブジェクトは、アプリに対して適切な動作を持つことはできません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1862">The <xref:System.Text.UTF32Encoding> object that is returned by this property may not have the appropriate behavior for your app.</span></span> <span data-ttu-id="c3040-1863">この例では、置換フォールバックを使用して、エンコードできない文字列とデコードできない各バイトを Unicode 置換文字 (U + FFFE) で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1863">It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE).</span></span> <span data-ttu-id="c3040-1864">代わりに、次の例に示すように、<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> コンストラクターを呼び出して、フォールバックが <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>のいずれかである <xref:System.Text.UTF32Encoding> オブジェクトをインスタンス化することができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1864">Instead, you can call the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.UTF32Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]

 <span data-ttu-id="c3040-1865">リトルエンディアンのバイト順の詳細については、<xref:System.Text.Encoding> クラスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1865">For a discussion of little endian byte order, see the <xref:System.Text.Encoding> class topic.</span></span>

 <span data-ttu-id="c3040-1866">.NET でサポートされているエンコーディングと、使用する Unicode エンコーディングの詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1866">For information about the encodings supported by .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>



## Examples
 <span data-ttu-id="c3040-1867">次の例では、文字配列をエンコードし、文字をエンコードし、結果のバイトを表示するために必要なバイト数を決定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1867">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-1868">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-1868">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-1869">UTF-7 形式のエンコーディングを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1869">Gets an encoding for the UTF-7 format.</span></span></summary>
        <value><span data-ttu-id="c3040-1870">UTF-7 形式のエンコード。</span><span class="sxs-lookup"><span data-stu-id="c3040-1870">An encoding for the UTF-7 format.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1871">UTF-7 エンコードは、主に、NNTP や電子メールアプリケーションなど、7ビットに制限されている環境で使用されます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1871">UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications.</span></span> <span data-ttu-id="c3040-1872">堅牢性とセキュリティに関する問題のため、代わりに UTF-8 エンコーディングを使用できる8ビット環境では UTF7 encoding を使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1872">Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead.</span></span>



## Examples
 <span data-ttu-id="c3040-1873">次の例では、文字配列をエンコードし、文字をエンコードし、結果のバイトを表示するために必要なバイト数を決定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1873">The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</span></span>

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-1874">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-1874">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-1875">UTF-8 形式のエンコーディングを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1875">Gets an encoding for the UTF-8 format.</span></span></summary>
        <value><span data-ttu-id="c3040-1876">UTF-8 形式のエンコード。</span><span class="sxs-lookup"><span data-stu-id="c3040-1876">An encoding for the UTF-8 format.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1877">このプロパティは、Unicode (UTF-16 でエンコードされた) 文字を1文字あたり1バイトから4バイトのシーケンスにエンコードし、UTF-8 でエンコードされたバイト配列を Unicode (UTF-16 エンコード) 文字にデコードする <xref:System.Text.UTF8Encoding> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1877">This property returns a <xref:System.Text.UTF8Encoding> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters.</span></span> <span data-ttu-id="c3040-1878">.NET でサポートされている文字エンコーディングと、使用する Unicode エンコーディングの詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1878">For information about the character encodings supported by .NET and a discussion of which Unicode encoding to use, see [Character Encoding in .NET](~/docs/standard/base-types/character-encoding.md).</span></span>

 <span data-ttu-id="c3040-1879">このプロパティによって返される <xref:System.Text.UTF8Encoding> オブジェクトは、アプリに適した動作を持たない場合があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1879">The <xref:System.Text.UTF8Encoding> object that is returned by this property might not have the appropriate behavior for your app.</span></span>

-   <span data-ttu-id="c3040-1880">このメソッドは、Unicode バイト順マーク (BOM) を提供する <xref:System.Text.UTF8Encoding> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1880">It returns a <xref:System.Text.UTF8Encoding> object that provides a Unicode byte order mark (BOM).</span></span> <span data-ttu-id="c3040-1881">BOM を提供しない UTF8 エンコーディングをインスタンス化するには、<xref:System.Text.UTF8Encoding.%23ctor%2A> コンストラクターのすべてのオーバーロードを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1881">To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <xref:System.Text.UTF8Encoding.%23ctor%2A> constructor.</span></span>

-   <span data-ttu-id="c3040-1882">これは、置換フォールバックを使用してエンコードできない各文字列と、デコードできない各バイトを疑問符 ("?") 文字に置き換える、<xref:System.Text.UTF8Encoding> オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1882">It returns a <xref:System.Text.UTF8Encoding> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark ("?") character.</span></span> <span data-ttu-id="c3040-1883">代わりに、次の例に示すように、<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> コンストラクターを呼び出して、フォールバックが <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>のいずれかである <xref:System.Text.UTF8Encoding> オブジェクトをインスタンス化することができます。</span><span class="sxs-lookup"><span data-stu-id="c3040-1883">Instead, you can call the <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.UTF8Encoding> object whose fallback is either an <xref:System.Text.EncoderFallbackException> or a <xref:System.Text.DecoderFallbackException>, as the following example illustrates.</span></span>

     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]



## Examples
 <span data-ttu-id="c3040-1884">次の例では、次の文字で構成される配列を定義します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1884">The following example defines an array that consists of the following characters:</span></span>

-   <span data-ttu-id="c3040-1885">ラテン小文字 Z (U + 007A)</span><span class="sxs-lookup"><span data-stu-id="c3040-1885">LATIN SMALL LETTER Z (U+007A)</span></span>

-   <span data-ttu-id="c3040-1886">ラテン小文字 A (U + 0061)</span><span class="sxs-lookup"><span data-stu-id="c3040-1886">LATIN SMALL LETTER A (U+0061)</span></span>

-   <span data-ttu-id="c3040-1887">ブラの結合 (U + 0306)</span><span class="sxs-lookup"><span data-stu-id="c3040-1887">COMBINING BREVE (U+0306)</span></span>

-   <span data-ttu-id="c3040-1888">ラテン文字 AE (鋭) (U + 01FD)</span><span class="sxs-lookup"><span data-stu-id="c3040-1888">LATIN SMALL LETTER AE WITH ACUTE (U+01FD)</span></span>

-   <span data-ttu-id="c3040-1889">ギリシャ語の小文字ベータ (U + 03B2)</span><span class="sxs-lookup"><span data-stu-id="c3040-1889">GREEK SMALL LETTER BETA (U+03B2)</span></span>

-   <span data-ttu-id="c3040-1890">ギリシャ語 ACROPHONIC DD54 1000 STATERS (U + 10154) を形成するサロゲートペア (U + U +)。</span><span class="sxs-lookup"><span data-stu-id="c3040-1890">A surrogate pair (U+D800 U+DD54) that forms GREEK ACROPHONIC ATTIC ONE THOUSAND STATERS (U+10154).</span></span>

 <span data-ttu-id="c3040-1891">各文字の UTF-16 コード単位が表示され、UTF-8 エンコーダーが文字配列をエンコードするために必要なバイト数を決定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1891">It displays the UTF-16 code units of each character and determines the number of bytes required by a UTF-8 encoder to encode the character array.</span></span> <span data-ttu-id="c3040-1892">次に、文字をエンコードし、結果として得られる UTF-8 でエンコードされたバイトを表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1892">It then encodes the characters and displays the resulting UTF-8-encoded bytes.</span></span>

 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md"><span data-ttu-id="c3040-1893">エンコーディングについて</span><span class="sxs-lookup"><span data-stu-id="c3040-1893">Understanding Encodings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-1894">派生クラスでオーバーライドされた場合、現在のエンコーディングの IANA (Internet Assigned Numbers Authority) に登録されている名前を取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1894">When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.</span></span></summary>
        <value><span data-ttu-id="c3040-1895">現在の <see cref="T:System.Text.Encoding" /> の IANA 名。</span><span class="sxs-lookup"><span data-stu-id="c3040-1895">The IANA name for the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1896"><xref:System.Text.Encoding.WebName%2A> プロパティは、<xref:System.Text.EncodingInfo.Name%2A> プロパティと同じです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1896">The <xref:System.Text.Encoding.WebName%2A> property is the same as the <xref:System.Text.EncodingInfo.Name%2A> property.</span></span>

 <span data-ttu-id="c3040-1897"><xref:System.Text.Encoding.WebName%2A> は、IANA で登録されたエンコーディング名を返すことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1897">Note that <xref:System.Text.Encoding.WebName%2A> returns an IANA-registered name for the encoding.</span></span> <span data-ttu-id="c3040-1898">値が標準の名前である場合、エンコードの実装はその標準に完全に準拠していない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1898">When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard.</span></span> <span data-ttu-id="c3040-1899"><xref:System.Text.Encoding.HeaderName%2A> プロパティは、電子メールのヘッダーに対して適切に機能する可能性がある別のエンコードを定義します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1899">The <xref:System.Text.Encoding.HeaderName%2A> property defines a different encoding that might work better for email headers.</span></span> <span data-ttu-id="c3040-1900">ただし、ほとんどのアプリでは、代わりに <xref:System.Text.Encoding.WebName%2A> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3040-1900">However, most apps should use <xref:System.Text.Encoding.WebName%2A> instead.</span></span>

 <span data-ttu-id="c3040-1901">IANA の詳細については、 [www.iana.org](https://www.iana.org/)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1901">For more information on the IANA, go to [www.iana.org](https://www.iana.org/).</span></span>

 <span data-ttu-id="c3040-1902"><xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> は <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>によって返される <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> と同じです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1902">The <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> is the same as the <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> returned by <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3040-1903">一部の web 名は重複しています。詳細については、<xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> の解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3040-1903">Some of the web names are duplicates; see the remarks for <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> for more information.</span></span>



## Examples
 <span data-ttu-id="c3040-1904">次の例では、HTML ヘッダーに <xref:System.Text.Encoding.WebName%2A> が含まれています。</span><span class="sxs-lookup"><span data-stu-id="c3040-1904">The following example includes the <xref:System.Text.Encoding.WebName%2A> in an HTML header.</span></span>

 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]

 <span data-ttu-id="c3040-1905">次の例では、各エンコードの異なる名前を取得し、<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>とは異なる1つ以上の名前のエンコーディングを表示します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1905">The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3040-1906"><xref:System.Text.Encoding.EncodingName%2A> が表示されますが、比較は行われません。</span><span class="sxs-lookup"><span data-stu-id="c3040-1906">It displays <xref:System.Text.Encoding.EncodingName%2A> but does not compare against it.</span></span>

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c3040-1907">派生クラスでオーバーライドされた場合、現在のエンコーディングに最も厳密に対応する Windows オペレーティング システムのコード ページを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1907">When overridden in a derived class, gets the Windows operating system code page that most closely corresponds to the current encoding.</span></span></summary>
        <value><span data-ttu-id="c3040-1908">現在の <see cref="T:System.Text.Encoding" /> に最も厳密に対応する、Windows オペレーティング システムのコード ページ。</span><span class="sxs-lookup"><span data-stu-id="c3040-1908">The Windows operating system code page that most closely corresponds to the current <see cref="T:System.Text.Encoding" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="c3040-1909">このプロパティは、Windows の多言語 (MLang) Api との互換性のために用意されています。たとえば、フォントファミリを決定する場合などです。</span><span class="sxs-lookup"><span data-stu-id="c3040-1909">This property is provided for compatibility with the Windows MultiLanguage (MLang) APIs, for example, in determining font families.</span></span> <span data-ttu-id="c3040-1910">グローバリゼーションの場合は、代わりに Unicode エンコーディングのいずれかを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1910">For globalization, using one of the Unicode encodings is recommended instead.</span></span> <span data-ttu-id="c3040-1911">また、コードページを識別するために <xref:System.Text.Encoding.WindowsCodePage%2A> ではなく <xref:System.Text.Encoding.WebName%2A> を使用することもお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3040-1911">It is also recommended to use <xref:System.Text.Encoding.WebName%2A> instead of <xref:System.Text.Encoding.WindowsCodePage%2A> to identify the code page.</span></span>



## Examples
 <span data-ttu-id="c3040-1912">次の例では、各エンコーディングに最も厳密に対応する Windows コードページを特定します。</span><span class="sxs-lookup"><span data-stu-id="c3040-1912">The following example determines the Windows code page that most closely corresponds to each encoding.</span></span>

 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>
