<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="94323cba6f20c93c2f1f9bcb289b2015299cde4e" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75030812" /></Metadata><TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>文字エンコーディングを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 エンコーディングは、Unicode 文字のセットをバイト シーケンスに変換するプロセスです。 これに対して、デコードは、エンコードされたバイトシーケンスを Unicode 文字のセットに変換するプロセスです。 Unicode 変換形式 (UTFs) と、<xref:System.Text.Encoding>でサポートされているその他のエンコーディングについては、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」を参照してください。

 <xref:System.Text.Encoding> は、バイト配列などの任意のバイナリデータではなく Unicode 文字を操作することを意図しています。 任意のバイナリデータをテキストにエンコードする必要がある場合は、uuencode などのプロトコルを使用する必要があります。これは、<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>などのメソッドによって実装されます。

 .NET には、現在の Unicode エンコーディングとその他のエンコーディングをサポートするために、<xref:System.Text.Encoding> クラスの次の実装が用意されています。

-   <xref:System.Text.ASCIIEncoding> は、Unicode 文字を1つの7ビット ASCII 文字としてエンコードします。 このエンコーディングでは、U + 0000 と U + 007F の間の文字値のみがサポートされます。 コードページ20127。 <xref:System.Text.Encoding.ASCII%2A> プロパティを通じて使用することもできます。

-   <xref:System.Text.UTF7Encoding> は、UTF-8 エンコーディングを使用して Unicode 文字をエンコードします。 このエンコーディングでは、すべての Unicode 文字値がサポートされます。 コードページ65000。 <xref:System.Text.Encoding.UTF7%2A> プロパティを通じて使用することもできます。

-   <xref:System.Text.UTF8Encoding> は、UTF-8 エンコーディングを使用して Unicode 文字をエンコードします。 このエンコーディングでは、すべての Unicode 文字値がサポートされます。 コードページ65001。 <xref:System.Text.Encoding.UTF8%2A> プロパティを通じて使用することもできます。

-   <xref:System.Text.UnicodeEncoding> UTF-16 エンコーディングを使用して Unicode 文字をエンコードします。 リトルエンディアンとビッグエンディアンの両方のバイト順がサポートされています。 <xref:System.Text.Encoding.Unicode%2A> プロパティおよび <xref:System.Text.Encoding.BigEndianUnicode%2A> プロパティを通じて使用することもできます。

-   <xref:System.Text.UTF32Encoding> は、32 UTF-8 エンコーディングを使用して Unicode 文字をエンコードします。 リトルエンディアン (コードページ 12000) とビッグエンディアン (コードページ 12001) バイトの順序の両方がサポートされています。 <xref:System.Text.Encoding.UTF32%2A> プロパティを通じて使用することもできます。

 <xref:System.Text.Encoding> クラスは、主に異なるエンコーディングと Unicode の間で変換を行うことを目的としています。 多くの場合、派生 Unicode クラスの1つは、アプリに適した選択肢です。

 <xref:System.Text.Encoding.GetEncoding%2A> メソッドを使用して他のエンコーディングを取得し、<xref:System.Text.Encoding.GetEncodings%2A> メソッドを呼び出してすべてのエンコーディングの一覧を取得します。

 次の表に、.NET Framework と .NET Core でサポートされているエンコーディングを示します。 各エンコーディングのコードページ番号と、エンコードの <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> と <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> プロパティの値が一覧表示されます。 **.NET Framework サポート**と **.net Core サポート**列のチェックマークは、基になるプラットフォームに関係なく、その .net 実装によってコードページがネイティブでサポートされていることを示します。 .NET Framework の場合、表に記載されている他のエンコーディングが使用できるかどうかは、オペレーティングシステムによって異なります。 .NET Core では、<xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> クラスを使用するか、<xref:System.Text.EncodingProvider?displayProperty=nameWithType> クラスから派生させることによって、他のエンコーディングを使用できます。

> [!NOTE]
> <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> プロパティが国際標準に対応するコードページは、必ずしもその標準に準拠しているとは限りません。

|コード ページ|Name|表示名|.NET Framework サポート| .NET Core サポート |
|---------|----|------------|----------------------|-------------------|
|37|IBM037|IBM EBCDIC (米国-カナダ)|||
|437|IBM437|OEM 米国|||
|500|IBM500|IBM EBCDIC (インターナショナル)|||
|708|ASMO-708|アラビア語 (ASMO 708)|||
|720|DOS-720|アラビア語 (DOS)|||
|737|ibm737|ギリシャ語 (DOS)|||
|775|ibm775|バルト語 (DOS)|||
|850|ibm850|西ヨーロッパ言語 (DOS)|||
|852|ibm852|中央ヨーロッパ言語 (DOS)|||
|855|IBM855|OEM キリル文字|||
|857|ibm857|トルコ語 (DOS)|||
|858|IBM00858|OEM 多言語ラテン I|||
|860|IBM860|ポルトガル語 (DOS)|||
|861|ibm861|アイスランド語 (DOS)|||
|862|DOS-862|ヘブライ語 (DOS)|||
|863|IBM863|フランス語 (カナダ) (DOS)|||
|864|IBM864|アラビア語 (864)|||
|865|IBM865|北欧 (DOS)|||
|866|cp866|キリル語 (DOS)|||
|869|ibm869|ギリシャ語、モダン (DOS)|||
|870|IBM870|IBM EBCDIC (多言語ラテン-2)|||
|874|windows-874|タイ語 (Windows)|||
|875|cp875|IBM EBCDIC (ギリシャ語モダン)|||
|932|shift_jis|日本語 (Shift-JIS)|||
|936|gb2312|簡体字中国語 (GB2312)|✓||
|949|ks_c_5601-1987|韓国語|||
|950|big5|繁体字中国語 (Big5)|||
|1026|IBM1026|IBM EBCDIC (トルコ語ラテン-5)|||
|1047|IBM01047|IBM ラテン-1|||
|1140|IBM01140|IBM EBCDIC (米国-カナダ-ヨーロッパ)|||
|1141|IBM01141|IBM EBCDIC (ドイツ-ヨーロッパ)|||
|1142|IBM01142|IBM EBCDIC (デンマーク-ノルウェー-ヨーロッパ)|||
|1143|IBM01143|IBM EBCDIC (フィンランド-スウェーデン-ヨーロッパ)|||
|1144|IBM01144|IBM EBCDIC (イタリア-ヨーロッパ)|||
|1145|IBM01145|IBM EBCDIC (スペイン-ヨーロッパ)|||
|1146|IBM01146|IBM EBCDIC (UK-ヨーロッパ)|||
|1147|IBM01147|IBM EBCDIC (フランス-ヨーロッパ)|||
|1148|IBM01148|IBM EBCDIC (国際対応-ヨーロッパ)|||
|1149|IBM01149|IBM EBCDIC (アイスランド語-ヨーロッパ)|||
|1200|utf-16|Unicode|✓|✓|
|1201|unicodeFFFE|Unicode (ビッグエンディアン)|✓|✓|
|1250|windows-1250|中央ヨーロッパ言語 (Windows)|||
|1251|windows-1251|キリル語 (Windows)|||
|1252|utf-8|西ヨーロッパ言語 (Windows)|✓||
|1253|windows-1253|ギリシャ語 (Windows)|||
|1254|windows-1254|トルコ語 (Windows)|||
|1255|windows-1255|ヘブライ語 (Windows)|||
|1256|windows-1256|アラビア語 (Windows)|||
|1257|windows-1257|バルト語 (Windows)|||
|1258|windows-1258|ベトナム語 (Windows)|||
|1361|Johab|韓国語 (Johab)|||
|10000|macintosh|西ヨーロッパ言語 (Mac)|||
|10001|x-mac-日本語|日本語 (Mac)|||
|10002|x-mac-chinesetrad|繁体字中国語 (Mac)|||
|10003|x-mac-korean|韓国語 (Mac)|✓||
|10004|x-mac-arabic|アラビア語 (Mac)|||
|10005|x-mac-hebrew|ヘブライ語 (Mac)|||
|10006|x-mac-greek|ギリシャ語 (Mac)|||
|10007|x-mac-キリル文字|キリル語 (Mac)|||
|10008|x-mac-chinesesimp|簡体字中国語 (Mac)|✓||
|10010|x-mac-ルーマニア語|ルーマニア語 (Mac)|||
|10017|x-mac-ukrainian|ウクライナ語 (Mac)|||
|10021|x-mac-thai|タイ語 (Mac)|||
|10029|x-mac-ce|中央ヨーロッパ言語 (Mac)|||
|10079|x-mac-アイスランド語|アイスランド語 (Mac)|||
|10081|x-mac-turkish|トルコ語 (Mac)|||
|10082|x-mac-クロアチア語|クロアチア語 (Mac)|||
|12000|utf-32|Unicode (UTF-32)|✓|✓|
|12001|utf-32|Unicode (UTF-32 ビッグエンディアン)|✓|✓|
|20000|x-中国語-CN|繁体字中国語 (CNS)|||
|20001|x-cp20001|TCA 台湾|||
|20002|x-Eten|繁体字中国語 (Eten)|||
|20003|x-cp20003|IBM5550 台湾|||
|20004|x-cp20004|文字放送 (台湾)|||
|20005|x-cp20005|Wang 台湾|||
|20105|x-IA5|西ヨーロッパ言語 (IA5)|||
|20106|x-IA5-ドイツ語|ドイツ語 (IA5)|||
|20107|x-IA5-スウェーデン語|スウェーデン語 (IA5)|||
|20108|x-IA5-ノルウェー語|ノルウェー語 (IA5)|||
|20127|us-ascii|US-ASCII|✓|✓|
|20261|x-cp20261|T.61|||
|20269|x-cp20269|ISO-6937|||
|20273|IBM273|IBM EBCDIC (ドイツ)|||
|20277|IBM277|IBM EBCDIC (デンマーク-ノルウェー)|||
|20278|IBM278|IBM EBCDIC (フィンランド-スウェーデン)|||
|20280|IBM280|IBM EBCDIC (イタリア)|||
|20284|IBM284|IBM EBCDIC (スペイン)|||
|20285|IBM285|IBM EBCDIC (UK)|||
|20290|IBM290|IBM EBCDIC (日本語カタカナ)|||
|20297|IBM297|IBM EBCDIC (フランス)|||
|20420|IBM420|IBM EBCDIC (アラビア語)|||
|20423|IBM423|IBM EBCDIC (ギリシャ語)|||
|20424|IBM424|IBM EBCDIC (ヘブライ語)|||
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (韓国語拡張)|||
|20838|IBM-タイ語|IBM EBCDIC (タイ語)|||
|20866|koi8-r|キリル語 (KOI8-R)|||
|20871|IBM871|IBM EBCDIC (アイスランド語)|||
|20880|IBM880|IBM EBCDIC (キリル文字ロシア語)|||
|20905|IBM905|IBM EBCDIC (トルコ語)|||
|20924|IBM00924|IBM ラテン-1|||
|20932|EUC-JP|日本語 (JIS 0208-1990 および 0212-1990)|||
|20936|x-cp20936|簡体字中国語 (GB2312-80)|✓||
|20949|x-cp20949|韓国 Korean-wansung-unicode|✓||
|21025|cp1025|IBM EBCDIC (キリル語セルビア-ブルガリア)|||
|21866|koi8-u|キリル語 (KOI8-U)|||
|28591|iso-8859-1|西ヨーロッパ言語 (ISO)|✓|✓|
|28592|iso-8859-2|中央ヨーロッパ言語 (ISO)|||
|28593|iso-8859-3|ラテン 3 (ISO)|||
|28594|iso-8859-4|バルト語 (ISO)|||
|28595|iso-8859-5|キリル語 (ISO)|||
|28596|iso-8859-6|アラビア語 (ISO)|||
|28597|iso-8859-7|ギリシャ語 (ISO)|||
|28598|iso-8859-8|ヘブライ語 (ISO-Visual)|✓||
|28599|iso-8859-9|トルコ語 (ISO)|||
|28603|iso-8859-13|エストニア語 (ISO)|||
|28605|iso-8859-15|ラテン 9 (ISO)|||
|29001|x-Europa|Europa|||
|38598|iso-8859-8-i|ヘブライ語 (ISO-論理)|✓||
|50220|iso-2022-jp|日本語 (JIS)|✓||
|50221|csISO2022JP|日本語 (JIS-1 バイトカタカナを許可)|✓||
|50222|iso-2022-jp|日本語 (JIS-1 バイトカタカナを許可する-SO/SI)|✓||
|50225|iso-2022-韓国|韓国語 (ISO)|✓||
|50227|x-cp50227|簡体字中国語 (ISO-2022)|✓||
|51932|euc-jp|日本語 (EUC)|✓||
|51936|EUC-CN|簡体字中国語 (EUC)|✓||
|51949|euc-韓国|韓国語 (EUC)|✓||
|52936|hz-gb-2312|簡体字中国語 (HZ)|✓||
|54936|GB18030|簡体字中国語 (GB18030)|✓||
|57002|x-iscii-de|ISCII デバナガリ文字|✓||
|57003|x-iscii-be|ISCII ベンガル語|✓||
|57004|x-iscii-ta|ISCII タミール語|✓||
|57005|x-iscii-te|ISCII テルグ語|✓||
|57006|x-iscii-as|ISCII アッサム語|✓||
|57007|x-iscii-または|ISCII オリヤー語|✓||
|57008|x-iscii-ka|ISCII カンナダ語|✓||
|57009|x-iscii-ma|ISCII マラヤーラム語|✓||
|57010|x-iscii-gu|ISCII グジャラート語|✓||
|57011|x-iscii-pa|ISCII パンジャブ語|✓||
|65000|utf-7|Unicode (UTF-7)|✓|✓|
|65001|utf-8|Unicode (UTF-8)|✓|✓|

 次の例では、<xref:System.Text.Encoding.GetEncoding%28System.Int32%29> および <xref:System.Text.Encoding.GetEncoding%28System.String%29> メソッドを呼び出して、ギリシャ語 (Windows) のコードページエンコーディングを取得します。 メソッド呼び出しによって返された <xref:System.Text.Encoding> オブジェクトを比較して、それらが等しいことを示します。その後、マップされたオブジェクトは、ギリシャ語アルファベットの各文字について、Unicode コードポイントとそれに対応するコードページ値を表示します。

 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]

 変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。

 UTF-16 および 32 UTF-8 エンコーダーでは、ビッグエンディアンバイト順 (最初に最上位バイト) またはリトルエンディアンバイト順 (最初に最下位バイト) を使用できます。 たとえば、ラテン文字の A (U + 0041 という) は、次のようにシリアル化されます (16 進数)。

-   UTF-16 ビッグエンディアンバイト順:00 41

-   UTF-16 リトルエンディアンバイト順:41 00

-   32 UTF-8 ビッグエンディアンバイト順:00 00 00 41

-   32 UTF-8 リトルエンディアンバイト順:41 00 00 00

 一般に、ネイティブバイト順序を使用して Unicode 文字を格納する方が効率的です。 たとえば、Intel コンピューターなどのリトルエンディアンプラットフォームでは、リトルエンディアンのバイト順を使用することをお勧めします。

 <xref:System.Text.Encoding.GetPreamble%2A> メソッドは、バイトオーダーマーク (BOM) を含むバイト配列を取得します。 このバイト配列の先頭にエンコード済みストリームがある場合は、デコーダーが使用するエンコード形式を識別するのに役立ちます。

 バイト順とバイト順マークの詳細については、unicode[ホームページ](https://go.microsoft.com/fwlink/?LinkId=37123)の unicode 標準を参照してください。

 エンコーディングクラスでは、次のようなエラーが発生することに注意してください。

-   "?" 文字に自動的に変更されます。

-   "最適" の文字を使用します。

-   U + FFFD Unicode の置換文字で <xref:System.Text.EncoderFallback> クラスと <xref:System.Text.DecoderFallback> クラスを使用して、アプリケーション固有の動作に変更します。

 データストリームエラーが発生した場合は、例外をスローする必要があります。 アプリは、該当する場合に "throwonerror" フラグを使用するか、<xref:System.Text.EncoderExceptionFallback> クラスと <xref:System.Text.DecoderExceptionFallback> クラスを使用します。 ベストフィットフォールバックは、データの損失や混乱を招く可能性があり、単純な文字交換よりも低速になる可能性があるため、推奨されません。 ANSI エンコーディングの場合、最適な動作は既定値です。



## Examples
 次の例では、あるエンコードから別のエンコーディングに文字列を変換します。

> [!NOTE]
>  Byte [] 配列は、エンコードされたデータを含むこの例の唯一の型です。 .NET の Char 型と String 型はそれ自体が Unicode であるため、<xref:System.Text.Encoding.GetChars%2A> の呼び出しによってデータが Unicode にデコードされます。

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 派生クラスは、このコンストラクターをオーバーライドします。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">使用するエンコーディングのコード ページ ID。

 または

 既定のエンコーディングを使用する場合は 0。</param>
        <summary>指定したコード ページに対応する <see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 派生クラスは、このコンストラクターをオーバーライドします。

 派生クラスからこのコンストラクターを呼び出すと、エンコード操作とデコード操作の両方に最適フォールバックを使用する <xref:System.Text.Encoding> オブジェクトが作成されます。 <xref:System.Text.Encoding.DecoderFallback%2A> と <xref:System.Text.Encoding.EncoderFallback%2A> の両方のプロパティは読み取り専用であり、変更することはできません。 <xref:System.Text.Encoding>から派生したクラスのフォールバックストラテジを制御するには、<xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> コンストラクターを呼び出します。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codePage" /> が 0 未満です。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">エンコーディングのコード ページ ID。</param>
        <param name="encoderFallback">現在のエンコーディングで文字をエンコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <param name="decoderFallback">現在のエンコーディングでバイト シーケンスをデコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <summary>指定したコード ページに対応する <see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを、指定したエンコーダーとデコーダーのフォールバック方法を使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このコンストラクターは `protected`です。派生クラスはこれをオーバーライドします。

 派生クラスからこのコンストラクターを呼び出して、フォールバックエンコードおよびデコード戦略を制御します。 <xref:System.Text.Encoding> クラスのコンストラクターは、オブジェクトの作成後にエンコーダーまたはデコーダーのフォールバックを設定できない読み取り専用のエンコーディングオブジェクトを作成します。

 `encoderFallback` または `decoderFallback` のいずれかが null の場合は、対応するフォールバックストラテジとして最適フォールバックが使用されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codePage" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASCII (7 ビット) 文字セットのエンコーディングを取得します。</summary>
        <value>ASCII (7 ビット) 文字セットのエンコーディング。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASCII 文字は、U + 0000 から U + 007F までの 128 Unicode 文字に制限されています。

 アプリの ASCII エンコードを選択するときは、次の点を考慮してください。

-   Ascii エンコーディングは、通常、ASCII を必要とするプロトコルに適しています。

-   8ビットエンコード (誤って "ASCII" と呼ばれることもあります) が必要な場合は、ASCII エンコーディングより UTF-8 エンコードを使用することをお勧めします。 文字が 0-7F の場合、結果は同じですが、UTF-8 を使用すると、表現可能なすべての Unicode 文字を表現できるため、データ損失を回避できます。 ASCII エンコーディングには、悪意のある使用を許可する8ビットのあいまいさがあることに注意してください。ただし、UTF-8 エンコーディングでは、8番目のビットのあいまいさが解消されます。

-   .NET Framework バージョン2.0 より前では、8番目のビットを無視することで、.NET Framework スプーフィングを許可しています。 .NET Framework 2.0 以降では、デコード中に非 ASCII コードポイントがフォールバックします。

 このプロパティによって返される <xref:System.Text.ASCIIEncoding> オブジェクトは、アプリに適した動作を持たない場合があります。 この例では、置換フォールバックを使用して、エンコードできない各文字列と、デコードできない各バイトを疑問符 ("?") 文字で置き換えます。 代わりに、次の例に示すように、<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> メソッドを呼び出して、フォールバックが <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>のいずれかである <xref:System.Text.ASCIIEncoding> オブジェクトをインスタンス化することができます。

 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]



## Examples
 次の例は、ascii の範囲外にある文字に対する ASCII エンコーディングの効果を示しています。

 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ビッグ エンディアンのバイト順を使用する UTF-16 形式のエンコーディングを取得します。</summary>
        <value>ビッグ エンディアンのバイト順を使用する UTF-16 形式のエンコーディング オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このプロパティによって返される <xref:System.Text.UnicodeEncoding> オブジェクトは、アプリに対して適切な動作を持つことはできません。 この例では、置換フォールバックを使用して、エンコードできない各文字列と、デコードできない各バイトを疑問符 ("?") 文字で置き換えます。 代わりに、次の例に示すように、<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> コンストラクターを呼び出して、フォールバックが <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>のいずれかであるビッグエンディアン <xref:System.Text.UnicodeEncoding> オブジェクトをインスタンス化することができます。

 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]

 返される <xref:System.Text.UnicodeEncoding> オブジェクトには、<xref:System.Text.Encoding.BodyName%2A>、<xref:System.Text.Encoding.HeaderName%2A>、および <xref:System.Text.Encoding.WebName%2A> プロパティがあり、"unicodeFFFE" という名前が生成されます。 UTF-16 ビッグエンディアンバイト順マークは16進 FEFF ですが、"unicodeFFFE" という名前が選択されました。これは、バイト順マークがリトルエンディアン Windows コンピューター上の16進 FFFE として表示されるためです。



## Examples
 次の例では、ビッグエンディアンのバイト順を使用して、UTF-16 エンコードを使用してテキストファイルを読み取ります。

 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]

 次の例では、文字配列をエンコードし、文字をエンコードし、結果のバイトを表示するために必要なバイト数を決定します。

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、メール エージェントの Body タグと共に使用できる現在のエンコーディングの名前を取得します。</summary>
        <value>メール エージェントの Body タグと共に使用できる、現在の <see cref="T:System.Text.Encoding" /> の名前。

または

現在の <see cref="T:System.Text.Encoding" /> が使用できない場合は、空の文字列 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 本文名のエンコーディングが必要な場合は、<xref:System.Text.Encoding.BodyName%2A> プロパティを使用して <xref:System.Text.Encoding.GetEncoding%2A> を呼び出す必要があります。 多くの場合、メソッドは、呼び出しに含まれるテストエンコーディングから別のエンコーディングを取得します。 通常、電子メールアプリケーションのみが、このようなエンコードを取得する必要があります。エンコードを記述する必要があるその他のほとんどのアプリケーションでは、その <xref:System.Text.Encoding.WebName%2A>を使用する必要があります。

 場合によっては、<xref:System.Text.Encoding.BodyName%2A> プロパティの値は、そのエンコーディングを定義する国際標準に対応します。 これは、実装がその標準で完全に準拠しているという意味ではありません。



## Examples
 次の例では、各エンコードの異なる名前を取得し、<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>とは異なる1つ以上の名前のエンコーディングを表示します。 <xref:System.Text.Encoding.EncodingName%2A> が表示されますが、比較は行われません。

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在の <see cref="T:System.Text.Encoding" /> オブジェクトの簡易コピーを作成します。</summary>
        <returns>現在の <see cref="T:System.Text.Encoding" /> オブジェクトのコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 元の <xref:System.Text.Encoding> オブジェクトが読み取り専用の場合でも、複製は書き込み可能です。 そのため、複製のプロパティは変更できます。

 オブジェクトの簡易コピーは、オブジェクトのコピーにすぎません。 オブジェクトに他のオブジェクトへの参照が含まれている場合、シャローコピーは参照されるオブジェクトのコピーを作成しません。 代わりに、元のオブジェクトを参照します。 これに対し、オブジェクトの詳細コピーでは、オブジェクトのコピーと、そのオブジェクトによって直接または間接的に参照されるすべてのもののコピーが作成されます。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在の <see cref="T:System.Text.Encoding" /> のコード ページ ID を取得します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> のコード ページ ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次の例では、各エンコードの異なる名前を取得し、<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>とは異なる1つ以上の名前のエンコーディングを表示します。 <xref:System.Text.Encoding.EncodingName%2A> が表示されますが、比較は行われません。

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイト配列を、あるエンコーディングから別のエンコーディングに変換します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding"><paramref name="bytes" /> のエンコーディング形式。</param>
        <param name="dstEncoding">変換後のエンコーディング形式。</param>
        <param name="bytes">変換対象のバイト。</param>
        <summary>バイト配列全体を、あるエンコーディングから別のエンコーディングに変換します。</summary>
        <returns><see cref="T:System.Byte" /> を <paramref name="bytes" /> から <paramref name="srcEncoding" /> へ変換した結果を格納する <paramref name="dstEncoding" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次の例では、Unicode でエンコードされた文字列を ASCII エンコードされた文字列に変換します。 <xref:System.Text.Encoding.ASCII%2A> プロパティによって返される ASCII エンコードオブジェクトが置換フォールバックを使用し、Pi 文字が ASCII 文字セットの一部ではないため、例の出力が示すように、Pi 文字は疑問符で置き換えられます。

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" /> は <see langword="null" /> です。

または

 <paramref name="dstEncoding" /> は <see langword="null" /> です。

または

 <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 **srcEncoding です。** <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 **dstEncoding です。** <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">変換前の配列 <paramref name="bytes" /> のエンコーディング。</param>
        <param name="dstEncoding">変換後の配列のエンコーディング。</param>
        <param name="bytes">変換対象のバイト配列。</param>
        <param name="index">変換対象の <paramref name="bytes" /> の最初の要素を示すインデックス。</param>
        <param name="count">変換するバイト数。</param>
        <summary>バイト配列内のバイトの範囲を、あるエンコーディングから別のエンコーディングに変換します。</summary>
        <returns><see cref="T:System.Byte" /> に含まれる特定の範囲のバイトを <paramref name="bytes" /> から <paramref name="srcEncoding" /> へ変換した結果が格納されている <paramref name="dstEncoding" /> 型の配列。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" /> は <see langword="null" /> です。

または

 <paramref name="dstEncoding" /> は <see langword="null" /> です。

または

 <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> および <paramref name="count" /> がバイト配列内の有効範囲を指定していません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 **srcEncoding です。** <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 **dstEncoding です。** <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DecoderFallback As DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Text.DecoderFallback" /> オブジェクトの <see cref="T:System.Text.Encoding" /> オブジェクトを取得または設定します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> オブジェクトのデコーダー フォールバック オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.DecoderFallback> オブジェクトは、エンコードされたバイトシーケンスを文字にデコードできない場合に呼び出されるエラーハンドラーを表します。 次のいずれかのハンドラーの種類がサポートされています。

-   最適フォールバックハンドラー。これは、適切な置換文字でデコードできないバイトを置き換えます。

-   置換代替ハンドラー。これは、任意の置換文字でデコードできないバイトを置き換えます。 .NET には、置換フォールバックハンドラー <xref:System.Text.DecoderFallback>が1つ含まれています。このハンドラーは、既定で、疑問符 ("?") 文字でデコードできないバイトを置き換えます。

-   例外フォールバックハンドラー。バイトをデコードできない場合に例外をスローします。 .NET には、1つの例外フォールバックハンドラー <xref:System.Text.DecoderExceptionFallback>が含まれています。これは、バイトをデコードできない場合に <xref:System.Text.DecoderFallbackException> をスローします。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">設定操作の値が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">現在の <see cref="T:System.Text.Encoding" /> オブジェクトが読み取り専用であるため、値を設定操作に割り当てることができません。</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この .NET 実装の既定のエンコードを取得します。</summary>
        <value>この .NET 実装の既定のエンコーディング。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!WARNING]
>  既定では、コンピューターごとに異なるエンコードを使用できます。また、既定のエンコードは、1台のコンピューターで変更できます。 <xref:System.Text.Encoding.Default%2A> エンコーディングを使用して、コンピューター間でストリーミングされるデータをエンコードおよびデコードしたり、同じコンピューターで異なる時刻に取得したりすると、そのデータが誤って変換される可能性があります。 また、<xref:System.Text.Encoding.Default%2A> プロパティによって返されるエンコーディングは、最適フォールバックを使用して、サポートされていない文字をコードページでサポートされる文字にマップします。 このような理由から、既定のエンコードを使用することはお勧めしません。 エンコードされたバイトが正しくデコードされるようにするには、<xref:System.Text.UTF8Encoding> や <xref:System.Text.UnicodeEncoding>などの Unicode エンコーディングを使用する必要があります。 また、より高いレベルのプロトコルを使用して、エンコードとデコードに同じ形式が使用されるようにすることもできます。

### <a name="the-default-property-in-the-net-framework"></a>.NET Framework の既定のプロパティ

Windows デスクトップの .NET Framework では、<xref:System.Text.Encoding.Default%2A> プロパティは常にシステムのアクティブなコードページを取得し、それに対応する <xref:System.Text.Encoding> オブジェクトを作成します。 アクティブなコードページには、ASCII 文字セットと、コードページによって異なる追加の文字が含まれる ANSI コードページがあります。 ANSI コードページに基づくすべての <xref:System.Text.Encoding.Default%2A> エンコーディングはデータを失うため、代わりに <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> エンコーディングを使用することを検討してください。 UTF-8 は、多くの場合、U + 00 から U + 7F の範囲で同一ですが、ASCII 範囲外の文字を文字エンコードすることはできません。

## <a name="the-default-property-on-net-core"></a>.NET Core の既定のプロパティ

.NET Core では、<xref:System.Text.Encoding.Default%2A> プロパティは常に <xref:System.Text.UTF8Encoding>を返します。 UTF-8 は、.NET Core アプリケーションを実行するすべてのオペレーティングシステム (Windows、Linux、および最大 OS X) でサポートされています。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EncoderFallback As EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Text.EncoderFallback" /> オブジェクトの <see cref="T:System.Text.Encoding" /> オブジェクトを取得または設定します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> オブジェクトのエンコーダー フォールバック オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.EncoderFallback> オブジェクトは、文字をエンコード済みバイトシーケンスに変換できない場合に呼び出されるエラーハンドラーを表します。 次のいずれかのハンドラーの種類がサポートされています。

-   最適フォールバックハンドラー。適切な置換文字でエンコードできない文字を置き換えます。

-   置換代替ハンドラー。これは、任意の置換文字でエンコードできない文字を置換します。 .NET には、置換フォールバックハンドラー <xref:System.Text.EncoderFallback>が1つ含まれています。これは、既定では、疑問符 ("?") 文字でエンコードできない文字を置換します。

-   例外フォールバックハンドラー。文字をエンコードできない場合に例外をスローします。 .NET には、1つの例外フォールバックハンドラー <xref:System.Text.EncoderExceptionFallback>が含まれています。これは、文字をデコードできない場合に <xref:System.Text.EncoderFallbackException> をスローします。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">設定操作の値が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">現在の <see cref="T:System.Text.Encoding" /> オブジェクトが読み取り専用であるため、値を設定操作に割り当てることができません。</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングについての記述を、ユーザーが判読できる形式で取得します。</summary>
        <value>ユーザーが判読できる形式の、現在の <see cref="T:System.Text.Encoding" /> の記述。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.EncodingName%2A> プロパティは、表示を目的としています。 <xref:System.Text.Encoding.GetEncoding%2A> メソッドに渡すことができる名前を検索するには、<xref:System.Text.Encoding.WebName%2A> プロパティを使用します。



## Examples
 次の例では、各エンコードの異なる名前を取得し、<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>とは異なる1つ以上の名前のエンコーディングを表示します。 <xref:System.Text.Encoding.EncodingName%2A> が表示されますが、比較は行われません。

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">現在のインスタンスと比較する <see cref="T:System.Object" />。</param>
        <summary>指定した <see cref="T:System.Object" /> が、現在のインスタンスと等しいかどうかを判断します。</summary>
        <returns><see langword="true" /> が <paramref name="value" /> のインスタンスで、現在のインスタンスと等しい場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding> の2つのインスタンスが同じコードページに対応しており、その `EncoderFallback` と `DecoderFallback` オブジェクトが等しい場合は、等しいと見なされます。 特に、派生コードページのコードページはすべて0で、フォールバックは通常 `null` (Visual Basic .NET では`Nothing`) です。 そのため、これらはすべて相互に一致していると見なされます。 結果として、<xref:System.Text.Encoding.Equals%2A> を使用してハッシュテーブルを設定すると、すべての派生エンコーディングが等しいと見なされ、同じハッシュテーブルスロットに分類されます。



## Examples
 次の例では、同じエンコードの2つのインスタンス (コードページと名前によって1つ) を取得し、それらが等しいかどうかをチェックします。

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字を格納している文字配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されているすべての文字をエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字配列に格納されているすべての文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetBytes%2A> が結果のバイトを格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出します。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。 <xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。

 <xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。 この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。

-   アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A> メソッドの文字列バージョンを使用する必要があります。

-   <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。

-   <xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続エンコードする場合は、この方法が最適な選択肢です。



## Examples
 次の例では、文字配列をエンコードし、文字をエンコードし、結果のバイトを表示するために必要なバイト数を決定します。

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする文字のスパン。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字スパンに格納されている文字をエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定された文字スパンをエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 結果のバイトを格納するために <xref:System.Text.Encoding.GetBytes%2A> で必要とされる正確なスパンサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出します。 最大スパンサイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。 <xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。

 <xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。 この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。

-   アプリが文字範囲の入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A> のスパンバージョンを使用することをお勧めします。

-   <xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力スパンバッファーが小さすぎる場合は例外をスローします。 ストリームを連続エンコードする場合は、この方法が最適な選択肢です。
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">エンコード対象の文字のセットを格納している文字列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字列に含まれる文字をエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetBytes%2A> が結果のバイトを格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出します。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。 <xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。

 <xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。 この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。

-   アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A> の文字列バージョンを使用することをお勧めします。

-   <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。

-   <xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続エンコードする場合は、この方法が最適な選択肢です。



## Examples
 次の例では、文字列または文字列の範囲をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする最初の文字へのポインター。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字ポインターから始まる文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 結果のバイトを格納するために <xref:System.Text.Encoding.GetBytes%2A> が必要とする配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出す必要があります。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。 <xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。

 <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> メソッドは実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用する際の考慮事項を次に示します。

-   アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。 この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。

-   アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A> メソッドの文字列バージョンを使用する必要があります。

-   <xref:System.Text.Encoding.GetBytes%2A> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。

-   <xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続エンコードする場合は、この方法が最適な選択肢です。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="index">エンコードする最初の文字のインデックス。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されている文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetBytes%2A> が結果のバイトを格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出します。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。 <xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。

 <xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。 この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。

-   アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A> の文字列バージョンを使用することをお勧めします。

-   <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。

-   <xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続エンコードする場合は、この方法が最適な選択肢です。



## Examples
 次の例では、文字配列から3文字をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> または <paramref name="count" /> が 0 未満です。

または

 <paramref name="index" /> および <paramref name="count" /> は <paramref name="chars" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">エンコード対象の文字のセットを格納している文字列。</param>
        <param name="index">エンコードする最初の文字のインデックス。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字列の文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>文字列をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetBytes%2A> が結果のバイトを格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出します。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。 <xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。

 <xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。 この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。

-   アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A> の文字列バージョンを使用することをお勧めします。

-   <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。

-   <xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続エンコードする場合は、この方法が最適な選択肢です。


## Examples
 次の例では、文字配列から3文字をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、文字のセットをバイト シーケンスにエンコードします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字を格納している文字配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されているすべての文字をバイト シーケンスにエンコードします。</summary>
        <returns>指定した文字のセットをエンコードした結果を格納しているバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。

 <xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。 この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。 (たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。 <xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。 <xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。

-   アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A> メソッドの文字列バージョンを呼び出す必要があります。

-   <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。

-   <xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続エンコードする場合は、この方法が最適な選択肢です。



## Examples
 次の例では、文字配列をエンコードし、文字をエンコードし、結果のバイトを表示するために必要なバイト数を決定します。

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">エンコードする文字を含む文字列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字列に含まれるすべての文字をバイト シーケンスにエンコードします。</summary>
        <returns>指定した文字のセットをエンコードした結果を格納しているバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。

 <xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。 この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。 (たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。 <xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。 <xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。

-   アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A>の文字列バージョンを使用する必要があります。

-   <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。

-   <xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続エンコードする場合は、この方法が最適な選択肢です。



## Examples
 次の例では、文字列または文字列の範囲をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納しているスパン。</param>
        <param name="bytes">エンコードされたバイトを格納するバイト スパン。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した読み取り専用スパンに格納されている文字のセットをバイトのスパンにエンコードします。</summary>
        <returns>エンコードされたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。

 <xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。 この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。 (たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。 <xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。 <xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。

-   アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A>の文字列バージョンを使用する必要があります。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。

-   <xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続エンコードする場合は、この方法が最適な選択肢です。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="index">エンコードする最初の文字のインデックス。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されている文字のセットをバイト シーケンスにエンコードします。</summary>
        <returns>指定した文字のセットをエンコードした結果を格納しているバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。

 <xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。 この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。 (たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。 <xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。 <xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。

-   アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A>の文字列バージョンを使用する必要があります。

-   <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。

-   <xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続エンコードする場合は、この方法が最適な選択肢です。



## Examples
 次の例では、文字配列から3文字をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> または <paramref name="count" /> が 0 未満です。

または

 <paramref name="index" /> および <paramref name="count" /> は <paramref name="chars" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">エンコードする文字を含む文字列。</param>
        <param name="index">エンコードを開始する文字列内のインデックス。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字列内の <paramref name="count" /> で指定した数の文字を、指定した <paramref name="index" /> からバイト配列にエンコードします。</summary>
        <returns>指定した文字のセットをエンコードした結果を格納しているバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。

 <xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。 この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。 (たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。 <xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。 <xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。

-   アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A>の文字列バージョンを使用する必要があります。

-   <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。

-   <xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続エンコードする場合は、この方法が最適な選択肢です。


## Examples
 次の例では、文字列または文字列の範囲をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする最初の文字へのポインター。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスの書き込みを開始する位置へのポインター。</param>
        <param name="byteCount">書き込む最大バイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字ポインターで始まる文字のセットを、指定したバイト ポインターを開始位置として格納されるバイト シーケンスにエンコードします。</summary>
        <returns><paramref name="bytes" /> パラメーターによって示される位置に書き込む実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 結果のバイトを格納するために <xref:System.Text.Encoding.GetBytes%2A> が必要とする正確な配列サイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出します。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。 <xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。

 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>オブジェクト、によって提供される<xref:System.Text.Encoding.GetDecoder%2A>または<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。

 <xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。 この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。 (たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。 <xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。 <xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。

-   アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A>の文字列バージョンを使用する必要があります。

-   <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。

-   <xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続エンコードする場合は、この方法が最適な選択肢です。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> は <see langword="null" /> です。

または

 <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> または <paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="byteCount" /> が結果のバイト数より少なくなっています。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="charIndex">エンコードする最初の文字のインデックス。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスを格納するバイト配列。</param>
        <param name="byteIndex">結果のバイト シーケンスを書き込む開始位置のインデックス。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されている文字のセットを、指定したバイト配列にエンコードします。</summary>
        <returns><paramref name="bytes" /> に書き込まれた実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetBytes%2A> が結果のバイトを格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出す必要があります。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。 <xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。

 変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。

 <xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。 この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。 (たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。 <xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。 <xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。

-   アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A>の文字列バージョンを使用する必要があります。

-   <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。

-   <xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続エンコードする場合は、この方法が最適な選択肢です。



## Examples
 次の例では、文字配列から3文字をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。

 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> は <see langword="null" /> です。

または

 <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />、<paramref name="charCount" />、または <paramref name="byteIndex" /> が 0 未満です。

または

 <paramref name="charIndex" /> および <paramref name="charCount" /> は <paramref name="chars" /> において有効な範囲を表していません。

または

 <paramref name="byteIndex" /> が <paramref name="bytes" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" /> には、<paramref name="byteIndex" /> から配列の末尾までに十分なサイズがなく、結果のバイトを格納できません。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">エンコード対象の文字のセットを格納している文字列。</param>
        <param name="charIndex">エンコードする最初の文字のインデックス。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスを格納するバイト配列。</param>
        <param name="byteIndex">結果のバイト シーケンスを書き込む開始位置のインデックス。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字列に含まれる文字のセットを、指定したバイト配列にエンコードします。</summary>
        <returns><paramref name="bytes" /> に書き込まれた実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetBytes%2A> が結果のバイトを格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを呼び出す必要があります。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを呼び出します。 <xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。

 変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。

 <xref:System.Text.Encoding.GetByteCount%2A> メソッドは、Unicode 文字のセットをエンコードするためのバイト数を決定し、<xref:System.Text.Encoding.GetBytes%2A> メソッドは実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数の変換を処理する <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetByteCount%2A> と <xref:System.Text.Encoding.GetBytes%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、多くの入力文字をコードページにエンコードし、複数の呼び出しを使用してそれらの文字を処理することが必要になる場合があります。 この場合は、使用されている <xref:System.Text.Encoder> オブジェクトによって保持されている状態を考慮して、呼び出し間で状態を維持する必要があります。 (たとえば、サロゲートペアを含む文字シーケンスは、上位サロゲートで終了する場合があります。 <xref:System.Text.Encoder> では、上位サロゲートと結合して、次の呼び出しの開始時に下位サロゲートと組み合わせることができます。 <xref:System.Text.Encoding> は状態を保持できないため、<xref:System.Text.EncoderFallback>に文字が送信されます)。

-   アプリが文字列入力を処理する場合は、<xref:System.Text.Encoding.GetBytes%2A>の文字列バージョンを使用する必要があります。

-   <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> の Unicode 文字バッファーバージョンでは、特に <xref:System.Text.Encoder> オブジェクトを使用した複数の呼び出しや既存のバッファーへの挿入を行う、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この場合、バイト配列をサポートする <xref:System.Text.Encoding.GetBytes%2A> バージョンが最適な選択肢です。

-   <xref:System.Text.Encoding.GetByteCount%2A>ではなく、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続エンコードする場合は、この方法が最適な選択肢です。



## Examples
 次の例では、文字列または文字列の範囲をエンコードするために必要なバイト数を決定し、文字をエンコードして、結果のバイトを表示します。

 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> は <see langword="null" /> です。

または

 <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />、<paramref name="charCount" />、または <paramref name="byteIndex" /> が 0 未満です。

または

 <paramref name="charIndex" /> および <paramref name="charCount" /> は <paramref name="chars" /> において有効な範囲を表していません。

または

 <paramref name="byteIndex" /> が <paramref name="bytes" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" /> には、<paramref name="byteIndex" /> から配列の末尾までに十分なサイズがなく、結果のバイトを格納できません。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、バイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているすべてのバイトをデコードすることによって生成される文字数を計算します。</summary>
        <returns>指定したバイト シーケンスをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> が結果の文字を格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> メソッドを使用する必要があります。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> メソッドを使用する必要があります。 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは一般に高速に実行されます。

 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> メソッドは実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。 この場合、呼び出しの間で状態を維持する必要があります。

-   アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用する必要があります。 このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。

-   <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。

-   <xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続してデコードする場合は、この方法が最適な選択肢です。



## Examples
 次の例では、文字列をバイト配列にエンコードし、バイトを文字配列にデコードします。

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">デコードする読み取り専用バイト スパン。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した読み取り専用バイト スパンをデコードすることによって生成される文字数を計算します。</summary>
        <returns>バイト スパンをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 結果の文字を格納するために <xref:System.Text.Encoding.GetChars%2A> が必要とする正確な配列サイズを計算するには、<xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用する必要があります。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドを使用します。 <xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは一般に高速に実行されます。

 <xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。 この場合、呼び出しの間で状態を維持する必要があります。

-   アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。 このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。

-   <xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続してデコードする場合は、この方法が最適な選択肢です。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">デコードする最初のバイトへのポインター。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト ポインターから始まるバイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
        <returns>指定したバイト シーケンスをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 結果の文字を格納するために <xref:System.Text.Encoding.GetChars%2A> が必要とする正確な配列サイズを計算するには、<xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用する必要があります。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドを使用します。 <xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは一般に高速に実行されます。

 <xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。 この場合、呼び出しの間で状態を維持する必要があります。

-   アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。 このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。

-   <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。

-   <xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続してデコードする場合は、この方法が最適な選択肢です。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
        <returns>指定したバイト シーケンスをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetChars%2A> が結果の文字を格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用する必要があります。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドを使用します。 <xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは一般に高速に実行されます。

 <xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。 この場合、呼び出しの間で状態を維持する必要があります。

-   アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。 このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。

-   <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。

-   <xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続してデコードする場合は、この方法が最適な選択肢です。



## Examples
 次の例では、あるエンコードから別のエンコーディングに文字列を変換します。

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 次の例では、文字列をバイト配列にエンコードした後、バイトの範囲を文字配列にデコードします。

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> または <paramref name="count" /> が 0 未満です。

または

 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、バイト シーケンスを文字のセットにデコードします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているすべてのバイトを文字のセットにデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納された文字配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 入力バイトシーケンスから文字を取得します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> とは異なります。 <xref:System.Text.Encoding> では不連続変換が想定されており、<xref:System.Text.Decoder> は単一の入力ストリームに対して複数のパスを使用するように設計されているためです。

 変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。

 **メモ**このメソッドは、バイト配列などの任意のバイナリデータではなく、Unicode 文字を操作することを目的としています。 任意のバイナリデータをテキストにエンコードする必要がある場合は、uuencode などのプロトコルを使用する必要があります。これは、<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>などのメソッドによって実装されます。

 <xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。 この場合は、バッチ処理時にバイトシーケンスが中断される可能性があるため、呼び出し間で状態を維持する必要があります。 (たとえば、ISO-2022 シフトシーケンスの一部は、1つの <xref:System.Text.Encoding.GetChars%2A> 呼び出しを終了し、次の <xref:System.Text.Encoding.GetChars%2A> 呼び出しの先頭で続行できます。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は、これらの不完全なシーケンスに対してフォールバックを呼び出しますが、<xref:System.Text.Decoder> は次の呼び出しのためにこれらのシーケンスを記憶します)。

-   アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。 このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。

-   <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。

-   <xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続してデコードする場合は、この方法が最適な選択肢です。



## Examples
 次の例では、文字列をバイト配列にエンコードし、バイトを文字配列にデコードします。

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納された読み取り専用スパン。</param>
        <param name="chars">デコードされたバイトを受け取る文字スパン。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した読み取り専用バイト スパンに格納されているすべてのバイトを、文字スパンにデコードします。</summary>
        <returns>デコードされたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 入力バイト範囲から文字を取得します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> とは異なります。 <xref:System.Text.Encoding> では不連続変換が想定されており、<xref:System.Text.Decoder> は単一の入力ストリームに対して複数のパスを使用するように設計されているためです。

 変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。

 <xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。 この場合は、バッチ処理時にバイトシーケンスが中断される可能性があるため、呼び出し間で状態を維持する必要があります。 (たとえば、ISO-2022 シフトシーケンスの一部は、1つの <xref:System.Text.Encoding.GetChars%2A> 呼び出しを終了し、次の <xref:System.Text.Encoding.GetChars%2A> 呼び出しの先頭で続行できます。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は、これらの不完全なシーケンスに対してフォールバックを呼び出しますが、<xref:System.Text.Decoder> は次の呼び出しのためにこれらのシーケンスを記憶します)。

-   アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。 このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。

-   <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。

-   <xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続してデコードする場合は、この方法が最適な選択肢です。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスを文字のセットにデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納された文字配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 入力バイトシーケンスから文字を取得します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> とは異なります。 <xref:System.Text.Encoding> では不連続変換が想定されており、<xref:System.Text.Decoder> は単一の入力ストリームに対して複数のパスを使用するように設計されているためです。

 変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。

 **メモ**このメソッドは、バイト配列などの任意のバイナリデータではなく、Unicode 文字を操作することを目的としています。 任意のバイナリデータをテキストにエンコードする必要がある場合は、uuencode などのプロトコルを使用する必要があります。これは、<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>などのメソッドによって実装されます。

 <xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。 この場合は、バッチ処理時にバイトシーケンスが中断される可能性があるため、呼び出し間で状態を維持する必要があります。 (たとえば、ISO-2022 シフトシーケンスの一部は、1つの <xref:System.Text.Encoding.GetChars%2A> 呼び出しを終了し、次の <xref:System.Text.Encoding.GetChars%2A> 呼び出しの先頭で続行できます。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は、これらの不完全なシーケンスに対してフォールバックを呼び出しますが、<xref:System.Text.Decoder> は次の呼び出しのためにこれらのシーケンスを記憶します)。

-   アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。 このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。

-   <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。

-   <xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続してデコードする場合は、この方法が最適な選択肢です。



## Examples
 次の例では、文字列をバイト配列にエンコードした後、バイトの範囲を文字配列にデコードします。

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> または <paramref name="count" /> が 0 未満です。

または

 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">デコードする最初のバイトへのポインター。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <param name="chars">結果の文字セットの書き込みを開始する位置へのポインター。</param>
        <param name="charCount">書き込む文字の最大数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト ポインターで始まるバイト シーケンスを、指定した文字ポインターを開始位置として格納される文字のセットにデコードします。</summary>
        <returns><paramref name="chars" /> パラメーターによって示される位置に書き込む実際の文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 結果の文字を格納するために <xref:System.Text.Encoding.GetChars%2A> が必要とする正確な配列サイズを計算するには、<xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用する必要があります。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドを使用します。 <xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは一般に高速に実行されます。

 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 入力バイトシーケンスから文字を取得します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> とは異なります。 <xref:System.Text.Encoding> では不連続変換が想定されており、<xref:System.Text.Decoder> は単一の入力ストリームに対して複数のパスを使用するように設計されているためです。

 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>オブジェクト、によって提供される<xref:System.Text.Encoding.GetDecoder%2A>または<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。

 **メモ**このメソッドは、バイト配列などの任意のバイナリデータではなく、Unicode 文字を操作することを目的としています。 任意のバイナリデータをテキストにエンコードする必要がある場合は、uuencode などのプロトコルを使用する必要があります。これは、<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>などのメソッドによって実装されます。

 <xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。 この場合は、バッチ処理時にバイトシーケンスが中断される可能性があるため、呼び出し間で状態を維持する必要があります。 (たとえば、ISO-2022 シフトシーケンスの一部は、1つの <xref:System.Text.Encoding.GetChars%2A> 呼び出しを終了し、次の <xref:System.Text.Encoding.GetChars%2A> 呼び出しの先頭で続行できます。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> は、これらの不完全なシーケンスに対してフォールバックを呼び出しますが、<xref:System.Text.Decoder> は次の呼び出しのためにこれらのシーケンスを記憶します)。

-   アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。 このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。

-   <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。

-   <xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続してデコードする場合は、この方法が最適な選択肢です。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> は <see langword="null" /> です。

または

 <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> または <paramref name="charCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="charCount" /> が結果の文字数より少なくなっています。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に完全信頼が必要です。 このメンバーは、部分的に信頼されているコードまたは透過的なコードでは使用できません。</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="byteIndex">デコードする最初のバイトのインデックス。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <param name="chars">結果の文字のセットを格納する文字配列。</param>
        <param name="charIndex">結果の文字のセットを書き込む開始位置のインデックス。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスを、指定した文字配列にデコードします。</summary>
        <returns><paramref name="chars" /> に書き込まれた実際の文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetChars%2A> が結果の文字を格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用する必要があります。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドを使用します。 <xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは一般に高速に実行されます。

 [\]、Int32、Int32、Char\<xref: GetChars% 2A? displayProperty = nameWithType > 入力バイトシーケンスから文字を取得します。 [\]、Int32、Int32、Char\<xref: GetChars% 2A? displayProperty = nameWithType > は <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> とは異なります。これは、<xref:System.Text.Encoding> が1つの入力ストリームに対して複数のパスを使用するように設計されているためです。<xref:System.Text.Decoder>

 変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。

 **メモ**このメソッドは、バイト配列などの任意のバイナリデータではなく、Unicode 文字を操作することを目的としています。 任意のバイナリデータをテキストにエンコードする必要がある場合は、uuencode などのプロトコルを使用する必要があります。これは、<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>などのメソッドによって実装されます。

 <xref:System.Text.Encoding.GetCharCount%2A> メソッドは、バイトシーケンスをデコードする文字数を決定し、<xref:System.Text.Encoding.GetChars%2A> メソッドは実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> メソッドでは、単一の入力ストリームに対して複数のパスを処理する <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドとは対照的に、離散変換が想定されています。

 <xref:System.Text.Encoding.GetCharCount%2A> と <xref:System.Text.Encoding.GetChars%2A> のいくつかのバージョンがサポートされています。 これらのメソッドを使用するためのプログラミング上の考慮事項を次に示します。

-   アプリでは、複数の呼び出しを使用して、コードページから複数の入力バイトをデコードし、バイトを処理することが必要になる場合があります。 この場合は、バッチ処理時にバイトシーケンスが中断される可能性があるため、呼び出し間で状態を維持する必要があります。 (たとえば、ISO-2022 シフトシーケンスの一部では、1つの [\], Int32, Int32, Char\<xref: GetChars% > 2A の呼び出しが終了し、次の [\], Int32, Int32, Char\<xref: GetChars% 2A > 呼び出しの先頭で続行される場合があります。 [\]、Int32、Int32、Char\<xref: GetChars% 2A? displayProperty = nameWithType > は、これらの不完全なシーケンスに対してフォールバックを呼び出しますが、<xref:System.Text.Decoder> は次の呼び出しのためにこれらのシーケンスを記憶します。)

-   アプリが文字列出力を処理する場合は、<xref:System.Text.Encoding.GetString%2A> メソッドを使用することをお勧めします。 このメソッドは文字列の長さを確認してバッファーを割り当てる必要があるため、少し遅くなりますが、結果として得られる <xref:System.String> の種類が優先されます。

-   <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> のバイトバージョンでは、特に大きなバッファーに対する複数の呼び出しによって、いくつかの高速な手法が可能です。 ただし、ポインターが必要であるため、このメソッドのバージョンは安全でない場合があることに注意してください。

-   アプリで大量のデータを変換する必要がある場合は、出力バッファーを再利用する必要があります。 この例では、[\], Int32, Int32, Char\<xref: GetChars% 2Csystem.string% 5B% 5D% 2Csystem.string%% 2Csystem.string% 5B% > 5D; 出力文字バッファーをサポートしているバージョンが最適な選択であることが推奨されていません。

-   <xref:System.Text.Encoding.GetCharCount%2A>ではなく、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することを検討してください。 変換メソッドは、可能な限り多くのデータを変換し、出力バッファーが小さすぎる場合は例外をスローします。 ストリームを連続してデコードする場合は、この方法が最適な選択肢です。



## Examples
 次の例では、あるエンコードから別のエンコーディングに文字列を変換します。

 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]

 次の例では、文字列をバイト配列にエンコードした後、バイトの範囲を文字配列にデコードします。

 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> は <see langword="null" /> です。

または

 <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" />、<paramref name="byteCount" />、または <paramref name="charIndex" /> が 0 未満です。

または

 <paramref name="byteindex" /> および <paramref name="byteCount" /> は <paramref name="bytes" /> において有効な範囲を表していません。

または

 <paramref name="charIndex" /> が <paramref name="chars" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="chars" /> には、<paramref name="charIndex" /> から配列の末尾までに十分なサイズがなく、結果の文字を格納できません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、エンコード済みバイト シーケンスを文字シーケンスに変換するデコーダーを取得します。</summary>
        <returns>エンコード済みバイト シーケンスを文字シーケンスに変換する <see cref="T:System.Text.Decoder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> メソッドは、このクラスの <xref:System.Text.Encoding.GetChars%2A> メソッドと同様の方法で、バイトのシーケンシャルブロックを文字の連続したブロックに変換します。 ただし、<xref:System.Text.Decoder> は、複数のブロックにまたがるバイトシーケンスを正しくデコードするために、呼び出しの間に状態情報を保持します。 また <xref:System.Text.Decoder> は、データブロックの末尾で末尾のバイトを保持し、次のデコード操作で末尾のバイトを使用します。 そのため、<xref:System.Text.Encoding.GetDecoder%2A> と <xref:System.Text.Encoding.GetEncoder%2A> は、ネットワークの転送とファイル操作に役立ちます。これらの操作は、多くの場合、データストリーム全体ではなくデータブロックを処理するためです。

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>既定の実装では、現在の <see cref="T:System.Text.Encoding" />の <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> および <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> メソッドを呼び出す <see cref="T:System.Text.Decoder" /> が返されます。 呼び出し間で状態を維持する <see cref="T:System.Text.Decoder" /> を返すには、このメソッドをオーバーライドする必要があります。</para></block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、Unicode 文字のシーケンスをエンコード済みバイト シーケンスに変換するエンコーダーを取得します。</summary>
        <returns>Unicode 文字のシーケンスをエンコード済みバイト シーケンスに変換する <see cref="T:System.Text.Encoder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> メソッドは、このクラスの <xref:System.Text.Encoding.GetBytes%2A> メソッドと同様の方法で、一連の文字を連続するバイトのブロックに変換します。 ただし、<xref:System.Text.Encoder> は、複数のブロックにまたがる文字シーケンスを正しくエンコードするために、呼び出しの間に状態情報を保持します。 また <xref:System.Text.Encoder> は、データブロックの末尾で末尾の文字を保持し、次のエンコーディング操作で末尾の文字を使用します。 たとえば、データブロックの末尾が一致していない上位サロゲートで、一致する下位サロゲートが次のデータブロックに含まれている可能性があります。 そのため、<xref:System.Text.Encoding.GetDecoder%2A> と <xref:System.Text.Encoding.GetEncoder%2A> は、ネットワークの転送とファイル操作に役立ちます。これらの操作は、多くの場合、データストリーム全体ではなくデータブロックを処理するためです。

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>既定の実装では、現在の <see cref="T:System.Text.Encoding" />の <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> および <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> メソッドを呼び出す <see cref="T:System.Text.Encoder" /> が返されます。 呼び出し間で状態を維持する <see cref="T:System.Text.Encoder" /> を返すには、このメソッドをオーバーライドする必要があります。</para></block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したコード ページのエンコーディングを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">使用するエンコーディングのコード ページ ID。 使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、コード ページの列にリストされています。

または

既定のエンコーディングを使用する場合は 0。</param>
        <summary>指定したコード ページ ID に関連付けられたエンコーディングを返します。</summary>
        <returns>指定したコード ページに関連付けられたエンコーディング。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 フォールバックハンドラーは、`codepage`のエンコードの種類に依存します。 `codepage` がコードページまたは2バイト文字セット (DBCS) エンコーディングの場合は、最適フォールバックハンドラーが使用されます。 それ以外の場合は、置換フォールバックハンドラーが使用されます。 これらのフォールバックハンドラーは、アプリに適していない場合があります。 `codepage`によって指定されたエンコーディングによって使用されるフォールバックハンドラーを指定するには、<xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> のオーバーロードを呼び出すことができます。

 .NET Framework では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは、ほとんどのコードページをサポートするために、基になるプラットフォームに依存しています。 ただし、.NET Framework は、いくつかのエンコーディングをネイティブでサポートしています。 コードページの一覧については、<xref:System.Text.Encoding> クラスのトピックを参照してください。 .NET Core では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドによって、.NET Core でネイティブにサポートされているエンコーディングが返されます。 どちらの .NET 実装でも、<xref:System.Text.Encoding.GetEncodings%2A> メソッドを呼び出して、使用可能なすべてのエンコーディングに関する情報を格納する <xref:System.Text.EncodingInfo> オブジェクトの配列を取得できます。

 .NET Core でネイティブに提供されている、または特定のプラットフォームバージョンの .NET Framework で本質的にサポートされているエンコーディングに加えて、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは <xref:System.Text.EncodingProvider> オブジェクトを登録することによって使用可能になる追加のエンコーディングを返します。 同じエンコーディングが複数の <xref:System.Text.EncodingProvider> オブジェクトによって登録されている場合、このメソッドは最後に登録されたものを返します。

`codepage` 引数に値0を指定することもできます。 この正確な動作は、<xref:System.Text.EncodingProvider> オブジェクトを登録することによって、エンコードが使用可能になっているかどうかによって異なります。

- 1つ以上のエンコーディングプロバイダーが登録されている場合は、<xref:System.Text.Encoding.GetEncoding%2A> メソッドに0の `codepage` 引数が渡されたときに、エンコーディングを返すことを選択した最後に登録されたプロバイダーのエンコーディングを返します。

- .NET Framework では、エンコーディングプロバイダーが登録されていない場合、<xref:System.Text.CodePagesEncodingProvider> が登録済みのエンコーディングプロバイダーである場合、または登録されているエンコーディングプロバイダーが0の `codepage` 値を処理しない場合は、オペレーティングシステムのアクティブなコードページが返されます。 Windows システムのアクティブなコードページを確認するには、windows デスクトップの .NET Framework から Windows [Getacp](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)関数を呼び出します。

- .NET Core では、エンコーディングプロバイダーが登録されていない場合、または登録されているエンコーディングプロバイダーが0の `codepage` 値を処理しない場合、<xref:System.Text.UTF8Encoding>が返されます。

> [!NOTE]
>  サポートされていないコードページによっては、<xref:System.ArgumentException> がスローされ、他のコードページでは <xref:System.NotSupportedException>が発生します。 そのため、コードでは、例外セクションに示されているすべての例外をキャッチする必要があります。

> [!NOTE]
>  ANSI コードページは、コンピューターによって異なる場合があり、1台のコンピューターで変更できるため、データが破損する可能性があります。 このため、アクティブなコードページが ANSI コードページである場合、`Encoding.GetEncoding(0)` によって返される既定のコードページを使用してデータをエンコードおよびデコードすることはお勧めできません。 最も一貫性のある結果を得るには、特定のコードページではなく、UTF-8 (コードページ 65001) や UTF-16 などの Unicode エンコードを使用する必要があります。

 <xref:System.Text.Encoding.GetEncoding%2A> は、既定の設定でキャッシュされたインスタンスを返します。 異なる設定のインスタンスを取得するには、派生クラスのコンストラクターを使用する必要があります。 たとえば、<xref:System.Text.UTF32Encoding> クラスには、エラー検出を可能にするコンストラクターが用意されています。



## Examples
 次の例では、同じエンコードの2つのインスタンスを取得します (コードページごとに、もう1つは名前別)。

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codepage" /> が 0 未満か、65535 を超えています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" /> は、基になるプラットフォームでサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" /> は、基になるプラットフォームでサポートされていません。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">使用するエンコーディングのコード ページ名。 <see cref="P:System.Text.Encoding.WebName" /> プロパティが返す値はすべて有効です。 使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、名前の列にリストされています。</param>
        <summary>指定したコード ページ名に関連付けられたエンコーディングを返します。</summary>
        <returns>指定したコード ページに関連付けられたエンコード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 フォールバックハンドラーは、`name`のエンコードの種類に依存します。 `name` がコードページまたは2バイト文字セット (DBCS) エンコーディングの場合は、最適フォールバックハンドラーが使用されます。 それ以外の場合は、置換フォールバックハンドラーが使用されます。 これらのフォールバックハンドラーは、アプリに適していない場合があります。 `name`によって指定されたエンコーディングによって使用されるフォールバックハンドラーを指定するには、<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> のオーバーロードを呼び出すことができます。

.NET Framework では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは、ほとんどのコードページをサポートするために、基になるプラットフォームに依存しています。 ただし、.NET Framework は、いくつかのエンコーディングをネイティブでサポートしています。 コードページの一覧については、<xref:System.Text.Encoding> クラスのトピックを参照してください。 .NET Core では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドによって、.NET Core でネイティブにサポートされているエンコーディングが返されます。 どちらの .NET 実装でも、<xref:System.Text.Encoding.GetEncodings%2A> メソッドを呼び出して、使用可能なすべてのエンコーディングに関する情報を格納する <xref:System.Text.EncodingInfo> オブジェクトの配列を取得できます。

 .NET Core でネイティブに提供されている、または特定のプラットフォームバージョンの .NET Framework で本質的にサポートされているエンコーディングに加えて、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは <xref:System.Text.EncodingProvider> オブジェクトを登録することによって使用可能になる追加のエンコーディングを返します。 同じエンコーディングが複数の <xref:System.Text.EncodingProvider> オブジェクトによって登録されている場合、このメソッドは最後に登録されたものを返します。

> [!NOTE]
>  ANSI コードページは、コンピューターによって異なる場合や、1台のコンピューターで変更される場合があり、データの破損を招く可能性があります。 一貫性のある結果を得るには、特定のコードページではなく、UTF-8 (コードページ 65001) や UTF-16 などの Unicode を使用する必要があります。


 <xref:System.Text.Encoding.GetEncoding%2A> は、既定の設定でキャッシュされたインスタンスを返します。 異なる設定のインスタンスを取得するには、派生クラスのコンストラクターを使用する必要があります。 たとえば、<xref:System.Text.UTF32Encoding> クラスには、エラー検出を可能にするコンストラクターが用意されています。

## Examples
 次の例では、同じエンコードの2つのインスタンスを取得します (コードページごとに、もう1つは名前別)。

 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が有効なコード ページ名ではありません。

または

<paramref name="name" /> が示すコード ページは基になるプラットフォームでサポートされていません。</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">使用するエンコーディングのコード ページ ID。 使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、コード ページの列にリストされています。

または

既定のエンコーディングを使用する場合は 0。</param>
        <param name="encoderFallback">現在のエンコーディングで文字をエンコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <param name="decoderFallback">現在のエンコーディングでバイト シーケンスをデコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <summary>指定したコード ページ ID に関連付けられたエンコーディングを返します。 パラメーターには、エンコードできない文字とデコードできないバイト シーケンスのためのエラー ハンドラーを指定します。</summary>
        <returns>指定したコード ページに関連付けられたエンコーディング。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  サポートされていないコードページによっては、例外 <xref:System.ArgumentException> がスローされ、他のコードページでは <xref:System.NotSupportedException>が発生します。 そのため、コードでは、例外セクションに示されているすべての例外をキャッチする必要があります。

.NET Framework では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは、ほとんどのコードページをサポートするために、基になるプラットフォームに依存しています。 ただし、.NET Framework は、いくつかのエンコーディングをネイティブでサポートしています。 コードページの一覧については、<xref:System.Text.Encoding> クラスのトピックを参照してください。 .NET Core では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドによって、.NET Core でネイティブにサポートされているエンコーディングが返されます。 どちらの .NET 実装でも、<xref:System.Text.Encoding.GetEncodings%2A> メソッドを呼び出して、使用可能なすべてのエンコーディングに関する情報を格納する <xref:System.Text.EncodingInfo> オブジェクトの配列を取得できます。

 .NET Core でネイティブに提供されている、または特定のプラットフォームバージョンの .NET Framework で本質的にサポートされているエンコーディングに加えて、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは <xref:System.Text.EncodingProvider> オブジェクトを登録することによって使用可能になる追加のエンコーディングを返します。 同じエンコーディングが複数の <xref:System.Text.EncodingProvider> オブジェクトによって登録されている場合、このメソッドは最後に登録されたものを返します。

`codepage` 引数に値0を指定することもできます。 この正確な動作は、<xref:System.Text.EncodingProvider> オブジェクトを登録することによって、エンコードが使用可能になっているかどうかによって異なります。

- 1つ以上のエンコーディングプロバイダーが登録されている場合は、<xref:System.Text.Encoding.GetEncoding%2A> メソッドに0の `codepage` 引数が渡されたときに、エンコーディングを返すことを選択した最後に登録されたプロバイダーのエンコーディングを返します。

- .NET Framework では、エンコーディングプロバイダーが登録されていない場合、<xref:System.Text.CodePagesEncodingProvider> が登録済みのエンコーディングプロバイダーである場合、または登録されているエンコーディングプロバイダーが0の `codepage` 値を処理しない場合は、アクティブなコードページが返されます。

- .NET Core では、エンコーディングプロバイダーが登録されていない場合、または `codepage` 値0を処理するエンコーディングプロバイダーが登録されていない場合、<xref:System.Text.UTF8Encoding> エンコーディングが返されます。

> [!NOTE]
>  ANSI コードページは、コンピューターによって異なる場合があり、1台のコンピューターで変更できるため、データが破損する可能性があります。 このため、アクティブなコードページが ANSI コードページである場合、`Encoding.GetEncoding(0)` によって返される既定のコードページを使用してデータをエンコードおよびデコードすることはお勧めできません。 一貫性のある結果を得るには、特定のコードページではなく、UTF-8 (コードページ 65001) や UTF-16 などの Unicode を使用する必要があります。

 アクティブなコードページに関連付けられているエンコードを取得するには、`codepage` 引数に値0を指定するか、Windows デスクトップの .NET Framework でコードを実行している場合は <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> プロパティの値を取得します。 現在アクティブなコードページを確認するには、windows デスクトップの .NET Framework から Windows [Getacp](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx)関数を呼び出します。

 <xref:System.Text.Encoding.GetEncoding%2A> は、既定の設定でキャッシュされたインスタンスを返します。 異なる設定のインスタンスを取得するには、派生クラスのコンストラクターを使用する必要があります。 たとえば、<xref:System.Text.UTF32Encoding> クラスには、エラー検出を可能にするコンストラクターが用意されています。



## Examples
 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType>メソッドの例を次に示します。

 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codepage" /> が 0 未満か、65535 を超えています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" /> は、基になるプラットフォームでサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" /> は、基になるプラットフォームでサポートされていません。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">使用するエンコーディングのコード ページ名。 <see cref="P:System.Text.Encoding.WebName" /> プロパティが返す値はすべて有効です。 使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、名前の列にリストされています。</param>
        <param name="encoderFallback">現在のエンコーディングで文字をエンコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <param name="decoderFallback">現在のエンコーディングでバイト シーケンスをデコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <summary>指定したコード ページ名に関連付けられたエンコーディングを返します。 パラメーターには、エンコードできない文字とデコードできないバイト シーケンスのためのエラー ハンドラーを指定します。</summary>
        <returns>指定したコード ページに関連付けられたエンコーディング。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

.NET Framework では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは、ほとんどのコードページをサポートするために、基になるプラットフォームに依存しています。 ただし、.NET Framework は、いくつかのエンコーディングをネイティブでサポートしています。 コードページの一覧については、<xref:System.Text.Encoding> クラスのトピックを参照してください。 .NET Core では、<xref:System.Text.Encoding.GetEncoding%2A> メソッドによって、.NET Core でネイティブにサポートされているエンコーディングが返されます。 どちらの .NET 実装でも、<xref:System.Text.Encoding.GetEncodings%2A> メソッドを呼び出して、使用可能なすべてのエンコーディングに関する情報を格納する <xref:System.Text.EncodingInfo> オブジェクトの配列を取得できます。

 .NET Core でネイティブに提供されている、または特定のプラットフォームバージョンの .NET Framework で本質的にサポートされているエンコーディングに加えて、<xref:System.Text.Encoding.GetEncoding%2A> メソッドは <xref:System.Text.EncodingProvider> オブジェクトを登録することによって使用可能になる追加のエンコーディングを返します。 同じエンコーディングが複数の <xref:System.Text.EncodingProvider> オブジェクトによって登録されている場合、このメソッドは最後に登録されたものを返します。

> [!NOTE]
>  ANSI コードページは、コンピューターによって異なる場合があり、1台のコンピューターで変更できるため、データが破損する可能性があります。 最も一貫性のある結果を得るには、特定のコードページではなく、UTF-8 (コードページ 65001) や UTF-16 などの Unicode エンコードを使用する必要があります。

 <xref:System.Text.Encoding.GetEncoding%2A> は、既定の設定でキャッシュされたインスタンスを返します。 異なる設定のインスタンスを取得するには、派生クラスのコンストラクターを使用する必要があります。 たとえば、<xref:System.Text.UTF32Encoding> クラスには、エラー検出を可能にするコンストラクターが用意されています。



## Examples
 <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType>メソッドの例を次に示します。

 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が有効なコード ページ名ではありません。

または

<paramref name="name" /> が示すコード ページは基になるプラットフォームでサポートされていません。</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべてのエンコーディングを格納した配列を返します。</summary>
        <returns>すべてのエンコーディングを格納する配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、コードページによって一意に識別される、サポートされているエンコーディングの一覧を返します。 サポートされているエンコーディングの一覧については、<xref:System.Text.Encoding> クラスに関するトピックを参照してください。

> [!NOTE]
>  <xref:System.Text.Encoding.GetEncodings%2A> メソッドによって返されるサポートされているエンコーディングの一覧には、<xref:System.Text.Encoding.RegisterProvider%2A> メソッドの呼び出しによって登録された <xref:System.Text.EncodingProvider> の実装で使用できる追加のエンコーディングは含まれません。

 .NET Framework では、エンコーディング50220と50222の両方が "iso-2022-jp" という名前に関連付けられていますが、同じではありません。 エンコード50220では、半角カタカナ文字が全角カタカナ文字に変換されますが、エンコード50222では、シフトイン/シフトアウトシーケンスを使用して半角カタカナ文字をエンコードします。 エンコード50222の表示名は、"日本語 (JIS-1 バイトかな-SO/SI)" のように、表示名が "日本語 (JIS)" であるエンコード50220と区別されます。

 エンコード名 "iso-2022-jp" を要求した場合、.NET Framework によってエンコード50220が返されます。 ただし、アプリに適したエンコーディングは、半角カタカナ文字の優先処理によって異なります。

 特定のエンコーディングを取得するには、<xref:System.Text.Encoding.GetEncoding%2A> メソッドを使用する必要があります。

 <xref:System.Text.Encoding.GetEncodings%2A> は、[ファイル**名を付けて保存**] ダイアログボックスで、エンコードの一覧をユーザーに表示するために使用されることがあります。 ただし、Unicode 以外のエンコーディングの多くは不完全で、多くの文字が "?" に変換されるか、またはプラットフォームによって動作が微妙に異なります。 既定として UTF-8 または UTF-16 を使用することを検討してください。



## Examples
 次の例では、各エンコーディングのブール型プロパティの値をチェックします。

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスのハッシュ コードを返します。</summary>
        <returns>現在のインスタンスのハッシュ コード。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">エンコードする文字数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字数をエンコードすることによって生成される最大バイト数を計算します。</summary>
        <returns>指定した文字数をエンコードすることによって生成される最大バイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 .NET 内部では Unicode 文字を表すために UTF-16 を使用しているため、`charCount` パラメーターでは、エンコードする Unicode 文字を表す <xref:System.Char> オブジェクトの数を指定します。 そのため、ほとんどの Unicode 文字は1つの <xref:System.Char> オブジェクトで表すことができますが、たとえば、サロゲートペアによって表される Unicode 文字には、2つの <xref:System.Char> オブジェクトが必要です。

 <xref:System.Text.Encoding.GetBytes%2A> が結果のバイトを格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用する必要があります。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドを使用します。 <xref:System.Text.Encoding.GetByteCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxByteCount%2A> メソッドは一般に高速に実行されます。

 <xref:System.Text.Encoding.GetMaxByteCount%2A> は、現在選択されている <xref:System.Text.EncoderFallback>の最悪のケースを含む、最悪のケース番号を取得します。 場合によっては、大きな文字列を使用してフォールバックを選択すると、大きな値が取得されます。特に、エンコーディングの最悪のケースでは、すべての文字のモードを切り替える必要がある場合に <xref:System.Text.Encoding.GetMaxByteCount%2A> ます。 たとえば、ISO-2022-JP の場合に発生する可能性があります。 詳細については、ブログ記事「[GetMaxByteCount () と GetMaxCharCount () と](https://blogs.msdn.microsoft.com/shawnste/2005/03/02/whats-with-encoding-getmaxbytecount-and-encoding-getmaxcharcount/)は」を参照してください。

 ほとんどの場合、このメソッドは小さい文字列に対して適切な値を取得します。 大きな文字列の場合は、非常に大きなバッファーを使用するか、より適切なバッファーが小さすぎる場合にまれにエラーをキャッチするかを選択することが必要になる場合があります。 <xref:System.Text.Encoding.GetByteCount%2A> または <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>を使用した別の方法を検討することもできます。

 <xref:System.Text.Encoding.GetMaxByteCount%2A>を使用する場合は、入力バッファーの最大サイズに基づいて出力バッファーを割り当てる必要があります。 出力バッファーのサイズが制限されている場合は、<xref:System.Text.Encoding.Convert%2A> メソッドを使用することもできます。

 <xref:System.Text.Encoding.GetMaxByteCount%2A> は、前のデコーダー操作から残っている可能性のあるサロゲートを考慮します。 デコーダーがあるため、値1をメソッドに渡すと、ASCII などの1バイトエンコードの場合は2が取得されます。 この情報が必要な場合は、<xref:System.Text.ASCIIEncoding.IsSingleByte%2A> プロパティを使用する必要があります。

> [!NOTE]
>  `GetMaxByteCount(N)` は、必ずしも `N* GetMaxByteCount(1)`と同じ値であるとは限りません。



## Examples
 次の例では、文字配列をエンコードし、文字をエンコードし、結果のバイトを表示するために必要なバイト数を決定します。

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <block subset="none" type="overrides"><para>すべての <see cref="T:System.Text.Encoding" /> 実装では、このメソッドの計算の結果に従ってバッファーのサイズが設定されている場合に、バッファーオーバーフロー例外が発生しないことを保証する必要があります。</para></block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト数をデコードすることによって生成される最大文字数を計算します。</summary>
        <returns>指定したバイト数をデコードすることによって生成される最大文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetChars%2A> が結果の文字を格納するために必要な配列の正確なサイズを計算するには、<xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用する必要があります。 配列の最大サイズを計算するには、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドを使用します。 <xref:System.Text.Encoding.GetCharCount%2A> メソッドを使用すると、通常はより少ないメモリを割り当てることができますが、<xref:System.Text.Encoding.GetMaxCharCount%2A> メソッドは一般に高速に実行されます。

 <xref:System.Text.Encoding.GetMaxCharCount%2A> は、現在選択されている <xref:System.Text.DecoderFallback>の最悪のケースを含む、最悪のケース番号を取得します。 場合によっては大きな文字列を使用してフォールバックを選択すると、<xref:System.Text.Encoding.GetMaxCharCount%2A> は大きな値を取得します。

 ほとんどの場合、このメソッドは小さい文字列に対して適切な数値を取得します。 大きな文字列の場合は、非常に大きいバッファーを使用するか、またはより適切なバッファーが小さすぎるというまれなエラーをキャッチするかを選択する必要があります。 <xref:System.Text.Encoding.GetCharCount%2A> または <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>を使用した別の方法を検討することもできます。

 <xref:System.Text.Encoding.GetMaxCharCount%2A> に <xref:System.Text.Encoding.GetBytes%2A>との関係はありません。 <xref:System.Text.Encoding.GetBytes%2A>で使用する同様の関数が必要な場合は、<xref:System.Text.Encoding.GetMaxByteCount%2A>を使用する必要があります。

 <xref:System.Text.Encoding.GetMaxCharCount%2A>を使用する場合は、入力バッファーの最大サイズに基づいて出力バッファーを割り当てる必要があります。 出力バッファーのサイズが制限されている場合は、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> メソッドを使用することもできます。

 <xref:System.Text.Encoding.GetMaxCharCount%2A> では、前のエンコーダー操作から残されたバイトの最悪のケースが考慮されることに注意してください。 ほとんどのコードページでは、値0をこのメソッドに渡すと、1以上の値が取得されます。

> [!NOTE]
>  `GetMaxCharCount(N)` は、必ずしも `N* GetMaxCharCount(1)`と同じ値であるとは限りません。



## Examples
 次の例では、文字列をバイト配列にエンコードし、バイトを文字配列にデコードします。

 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <block subset="none" type="overrides"><para>すべての <see cref="T:System.Text.Encoding" /> 実装では、このメソッドの計算の結果に従ってバッファーのサイズが設定されている場合に、バッファーオーバーフロー例外が発生しないことを保証する必要があります。</para></block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、使用するエンコーディングを指定するバイト シーケンスを返します。</summary>
        <returns>使用するエンコーディングを指定するバイト シーケンスを格納するバイト配列。

 または

 プリアンブルが不要な場合は、長さ 0 のバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 必要に応じて、<xref:System.Text.Encoding> オブジェクトは、エンコード処理によって生成されるバイトシーケンスにプレフィックスを付けることができるバイト配列であるプリアンブルを提供します。 プリアンブルにバイト順マーク (Unicode、コードポイント U + FEFF) が含まれている場合は、デコーダーがバイト順と変換形式または UTF を決定するのに役立ちます。

 Unicode バイト順マーク (BOM) は、次のようにシリアル化されます (16 進数)。

-   UTF-8: EF BB BF

-   UTF-16 ビッグエンディアンバイト順: FE FF

-   UTF-16 リトルエンディアンバイト順: FF FE

-   32 UTF-8 ビッグエンディアンバイト順:00 00 FE FF

-   32 UTF-8 リトルエンディアンバイト順: FF FE 00 00

 BOM を使用する必要があります。これは、<xref:System.Text.Encoding> オブジェクトへの参照が失われたファイル (タグなしまたは不適切なタグが付けられた web データや、ビジネスで国際的な問題や他のデータがない場合に保存されたランダムなテキストファイルなど) について、ほとんど特定のエンコードを識別できるためです。 データが一貫して適切にタグ付けされている場合 (UTF-8 または UTF-16 の場合)、ユーザーの問題が回避されることがよくあります。

 エンコードの種類を提供する標準の場合、BOM はやや冗長です。 ただし、このメソッドを使用して、サーバーが正しいエンコードヘッダーを送信できるようにすることができます。 または、エンコードが失われた場合にフォールバックとして使用することもできます。

 BOM の使用にはいくつかの欠点があります。 たとえば、BOM を使用するデータベースフィールドを制限する方法を理解することは困難です。 ファイルの連結も問題になることがあります。たとえば、不要な文字がデータの途中で終了するような方法でファイルをマージする場合などです。 ただし、いくつかの欠点がありますが、BOM を使用することを強くお勧めします。

 バイト順とバイト順マークの詳細については、unicode[ホームページ](https://go.microsoft.com/fwlink/?LinkId=37123)の unicode 標準を参照してください。

> [!CAUTION]
>  エンコードされたバイトが正しくデコードされるようにするには、エンコードされたバイトをプリアンブルでプレフィックスとして付ける必要があります。 ただし、ほとんどのエンコーディングではプリアンブルが提供されません。 エンコードされたバイトが正しくデコードされるようにするには、Unicode エンコーディング (つまり、<xref:System.Text.UTF8Encoding>、<xref:System.Text.UnicodeEncoding>、または <xref:System.Text.UTF32Encoding>) をプリアンブルで使用する必要があります。



## Examples
 次の例では、プリアンブルに基づくエンコードのバイト順を決定します。

 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、バイト シーケンスを文字列にデコードします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているすべてのバイトを文字列にデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納されている文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 変換するデータが、連続するブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドによって返される <xref:System.Text.Decoder> オブジェクトを使用する必要があります。

 デコード手法と考慮事項の説明については、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> リファレンストピックの「解説」を参照してください。

 特定の <xref:System.Text.Encoding> 実装の <xref:System.Text.Encoding.GetString%2A> メソッドの正確な動作は、その <xref:System.Text.Encoding> オブジェクトに対して定義されているフォールバックストラテジによって異なります。 詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」トピックの「フォールバックストラテジの選択」セクションを参照してください。



## Examples
 次の例では、<xref:System.IO.FileStream> オブジェクトによって表されるバイナリファイルから、UTF-8 でエンコードされた文字列を読み取ります。 2048バイトより小さいファイルの場合、ファイル全体の内容をバイト配列に読み取り、<xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> メソッドを呼び出してデコードを実行します。 サイズの大きいファイルの場合は、一度に2048バイトをバイト配列に読み取り、<xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを呼び出して配列に格納されている文字数を確認した後、<xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを呼び出してデコードを実行します。

 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]

 この例では、次のテキストを使用します。これは、Utf8Example という名前の UTF-8 でエンコードされたファイルに保存する必要があります。

```

This is a UTF-8-encoded file that contains primarily Latin text, although it
does list the first twelve letters of the Russian (Cyrillic) alphabet:

А б в г д е ё ж з и й к

The goal is to save this file, then open and decode it as a binary stream.

```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このバイト配列には、無効な Unicode コード ポイントが含まれています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">Unicode 文字列にデコードする読み取り専用バイト スパン。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト スパンに格納されているすべてのバイトを文字列にデコードします。</summary>
        <returns>指定した読み取り専用スパンからデコードされたバイトを格納している文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetString%2A> メソッドは、パフォーマンスを最適化するように設計されています。 マネージバイト配列を作成してからデコードする代わりに、このメソッドを呼び出すことができます。その際、中間オブジェクトを作成する必要はありません。

 変換するデータが、連続するブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドによって返される <xref:System.Text.Decoder> オブジェクトを使用する必要があります。

 デコード手法と考慮事項の説明については、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> リファレンストピックの「解説」を参照してください。

 特定の <xref:System.Text.Encoding> 実装の <xref:System.Text.Encoding.GetString%2A> メソッドの正確な動作は、その <xref:System.Text.Encoding> オブジェクトに対して定義されているフォールバックストラテジによって異なります。 詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」トピックの「フォールバックストラテジの選択」セクションを参照してください。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">バイト配列へのポインター。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したアドレスで始まる指定したバイト数を文字列にデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納されている文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.GetString%2A> メソッドは、バイト配列へのネイティブポインターがある場合にパフォーマンスを最適化するように設計されています。 マネージバイト配列を作成してからデコードする代わりに、このメソッドを呼び出すことができます。その際、中間オブジェクトを作成する必要はありません。

 変換するデータが、連続するブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドによって返される <xref:System.Text.Decoder> オブジェクトを使用する必要があります。

 デコード手法と考慮事項の説明については、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> リファレンストピックの「解説」を参照してください。

 特定の <xref:System.Text.Encoding> 実装の <xref:System.Text.Encoding.GetString%2A> メソッドの正確な動作は、その <xref:System.Text.Encoding> オブジェクトに対して定義されているフォールバックストラテジによって異なります。 詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」トピックの「フォールバックストラテジの選択」セクションを参照してください。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> が null ポインターです。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください)

および

 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスを文字列にデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納されている文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 変換するデータが連続したブロック (ストリームから読み取られたデータなど) でのみ使用可能な場合、またはデータの量が大きく、小さいブロックに分割する必要がある場合は、それぞれの派生クラスの <xref:System.Text.Encoding.GetDecoder%2A> メソッドまたは <xref:System.Text.Encoding.GetEncoder%2A> メソッドによって提供される <xref:System.Text.Decoder> または <xref:System.Text.Encoder> を使用する必要があります。

 デコード手法と考慮事項の説明については、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> リファレンストピックの「解説」を参照してください。



## Examples
 次の例では、<xref:System.IO.FileStream> オブジェクトによって表されるバイナリファイルから、UTF-8 でエンコードされた文字列を読み取ります。 2048バイトより小さいファイルの場合、ファイル全体の内容をバイト配列に読み取り、<xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> メソッドを呼び出してデコードを実行します。 サイズの大きいファイルの場合は、一度に2048バイトをバイト配列に読み取り、<xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを呼び出して配列に格納されている文字数を確認した後、<xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> メソッドを呼び出してデコードを実行します。

 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]

 この例では、次のテキストを使用します。これは、Utf8Example という名前の UTF-8 でエンコードされたファイルに保存する必要があります。

```

This is a UTF-8-encoded file that contains primarily Latin text, although it
does list the first twelve letters of the Russian (Cyrillic) alphabet:

А б в г д е ё ж з и й к

The goal is to save this file, then open and decode it as a binary stream.

```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このバイト配列には、無効な Unicode コード ポイントが含まれています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> または <paramref name="count" /> が 0 未満です。

または

 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細については「<see href="~/docs/standard/base-types/character-encoding.md">.NET での文字エンコード</see>」を参照)

および

 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、メール エージェント ヘッダー タグと共に使用できる現在のエンコーディングの名前を取得します。</summary>
        <value>メール エージェント ヘッダー タグと共に使用する、現在の <see cref="T:System.Text.Encoding" /> の名前。

または

現在の <see cref="T:System.Text.Encoding" /> が使用できない場合は、空の文字列 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ヘッダー名にエンコーディングが必要な場合は、<xref:System.Text.Encoding.HeaderName%2A> プロパティを使用して <xref:System.Text.Encoding.GetEncoding%2A> メソッドを呼び出す必要があります。 多くの場合、メソッドは、呼び出しに含まれるテストエンコーディングから別のエンコーディングを取得します。 通常、このようなエンコードを取得する必要があるのは電子メールアプリケーションのみです。

 場合によっては、<xref:System.Text.Encoding.BodyName%2A> プロパティの値は、そのエンコーディングを定義する国際標準に対応します。 これは、実装がその標準で完全に準拠しているという意味ではありません。

 <xref:System.Text.Encoding.WebName%2A> は、エンコーディングの記述に使用する名前を返すことに注意してください。 <xref:System.Text.Encoding.HeaderName%2A> プロパティは、たとえば、電子メールアプリケーションでより適切に機能する可能性がある別のエンコードを定義します。 ただし、プロパティを使用してエンコードを定義することはお勧めしません。



## Examples
 次の例では、各エンコードの異なる名前を取得し、<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>とは異なる1つ以上の名前のエンコーディングを表示します。 <xref:System.Text.Encoding.EncodingName%2A> が表示されますが、比較は行われません。

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のエンコーディングが常に正規化されるかどうかを示す値を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のエンコーディングが、既定の正規形を使用して常に正規化されるかどうかを示す値。</summary>
        <returns>現在の <see langword="true" /> が常に正規化される場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 既定の正規化形式は <xref:System.Text.NormalizationForm.FormC>であり、正規の完全な分解を使用した後に、可能であれば、シーケンスをプライマリ複合に置き換えることができます。

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="form"><see cref="T:System.Text.NormalizationForm" /> 値の 1 つ。</param>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングが、指定した正規形を使用して常に正規化されるかどうかを示す値を取得します。</summary>
        <returns>現在の <see langword="true" /> オブジェクトが、指定した <see cref="T:System.Text.Encoding" /> 値を使用して常に正規化される場合は <see cref="T:System.Text.NormalizationForm" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 既定の正規化形式は <xref:System.Text.NormalizationForm.FormC>であり、正規の完全な分解を使用した後に、可能であれば、シーケンスをプライマリ複合に置き換えることができます。

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、ブラウザー クライアントが現在のエンコーディングを使用してコンテンツを表示できるかどうかを示す値を取得します。</summary>
        <value>ブラウザー クライアントが現在の <see langword="true" /> を使用してコンテンツを表示できる場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次の例では、各エンコーディングのブール型プロパティの値をチェックします。

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、ブラウザー クライアントが現在のエンコーディングを使用してコンテンツを保存できるかどうかを示す値を取得します。</summary>
        <value>ブラウザー クライアントが現在の <see langword="true" /> を使用してコンテンツを保存できる場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次の例では、各エンコーディングのブール型プロパティの値をチェックします。

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、メール クライアントおよびニュース クライアントが現在のエンコーディングを使用してコンテンツを表示できるかどうかを示す値を取得します。</summary>
        <value>メール クライアントおよびニュース クライアントが現在の <see langword="true" /> を使用してコンテンツを表示できる場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次の例では、各エンコーディングのブール型プロパティの値をチェックします。

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、メール クライアントおよびニュース クライアントが現在のエンコーディングを使用してコンテンツを保存できるかどうかを示す値を取得します。</summary>
        <value>メール クライアントおよびニュース クライアントが現在の <see langword="true" /> を使用してコンテンツを保存できる場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次の例では、各エンコーディングのブール型プロパティの値をチェックします。

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングが読み取り専用かどうかを示す値を取得します。</summary>
        <value>現在の <see langword="true" /> が読み取り専用の場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングが 1 バイトのコード ポイントを使用するかどうかを示す値を取得します。</summary>
        <value>現在の <see langword="true" /> が 1 バイトのコード ポイントを使用する場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 1バイトエンコード (<xref:System.Text.ASCIIEncoding>など) の場合、このプロパティは `true`を取得します。

> [!CAUTION]
>  <xref:System.Text.Encoding.IsSingleByte%2A>の値を使用してアプリケーションが行う処理を慎重に行う必要があります。 エンコードが続行されることを前提としている場合もあります。 たとえば、Windows-1252 では <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>に対して `true` の値が使用されますが、GetMaxByteCount (1) は2を返します。 これは、メソッドが、前のデコーダー操作から残っている可能性のあるサロゲートを考慮するためです。



## Examples
 次の例では、各エンコーディングのブール型プロパティの値をチェックします。

 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、使用するエンコードを指定するバイト シーケンスを含むスパンが返されます。</summary>
        <value>使用するエンコードを指定するバイト シーケンスを含むバイト スパン、または長さがゼロのスパン (プリアンブルが不要な場合)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 必要に応じて、<xref:System.Text.Encoding> オブジェクトは、エンコーディングプロセスによって生成されるバイトの前に付加できるバイトシーケンスであるプリアンブルを提供します。 プリアンブルにバイト順マーク (Unicode、コードポイント U + FEFF) が含まれている場合は、デコーダーがバイト順と変換形式または UTF を決定するのに役立ちます。

 Unicode バイト順マーク (BOM) は、次のようにシリアル化されます (16 進数)。

-   UTF-8: EF BB BF

-   UTF-16 ビッグエンディアンバイト順: FE FF

-   UTF-16 リトルエンディアンバイト順: FF FE

-   32 UTF-8 ビッグエンディアンバイト順:00 00 FE FF

-   32 UTF-8 リトルエンディアンバイト順: FF FE 00 00

 BOM を使用する必要があります。これは、<xref:System.Text.Encoding> オブジェクトへの参照が失われたファイル (タグなしまたは不適切なタグが付けられた web データや、ビジネスで国際的な問題や他のデータがない場合に保存されたランダムなテキストファイルなど) について、ほとんど特定のエンコードを識別できるためです。 データが一貫して適切にタグ付けされている場合 (UTF-8 または UTF-16 の場合)、ユーザーの問題が回避されることがよくあります。

 エンコードの種類を提供する標準の場合、BOM はやや冗長です。 ただし、このメソッドを使用して、サーバーが正しいエンコードヘッダーを送信できるようにすることができます。 または、エンコードが失われた場合にフォールバックとして使用することもできます。

 BOM の使用にはいくつかの欠点があります。 たとえば、BOM を使用するデータベースフィールドを制限する方法を理解することは困難です。 ファイルの連結も問題になることがあります。たとえば、不要な文字がデータの途中で終了するような方法でファイルをマージする場合などです。 ただし、いくつかの欠点はありますが、BOM を使用することを強くお勧めします。

 バイト順とバイト順マークの詳細については、unicode[ホームページ](https://home.unicode.org/)の unicode 標準を参照してください。

> [!CAUTION]
>  エンコードされたバイトが正しくデコードされるようにするには、エンコードされたバイトをプリアンブルでプレフィックスとして付ける必要があります。 ただし、ほとんどのエンコーディングではプリアンブルが提供されません。 エンコードされたバイトが正しくデコードされるようにするには、Unicode エンコーディング (つまり、<xref:System.Text.UTF8Encoding>、<xref:System.Text.UnicodeEncoding>、または <xref:System.Text.UTF32Encoding>) をプリアンブルで使用する必要があります。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">追加の文字エンコーディングへのアクセスを提供する <see cref="T:System.Text.EncodingProvider" /> のサブクラス。</param>
        <summary>エンコーディング プロバイダーを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.RegisterProvider%2A> メソッドを使用すると、他の方法ではサポートされないプラットフォームで文字エンコーディングを使用できるようにする <xref:System.Text.EncodingProvider> から派生したクラスを登録できます。 エンコードプロバイダーが登録されると、サポートされているエンコーディングは、任意の <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> オーバーロードを呼び出すことによって取得できます。 複数のエンコードプロバイダーがある場合、<xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> メソッドは、最後に登録されたもので始まる各プロバイダーから、指定されたエンコーディングを取得しようとします。

<xref:System.Text.Encoding.RegisterProvider%2A> メソッドを使用してエンコーディングプロバイダーを登録すると、`0`の引数が渡されたときに、 [encoding.getencoding (int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>)メソッドと[「encodingprovider」 (int32, EncoderFallback, DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))メソッドの動作も変更されます。

- 登録されているプロバイダーが <xref:System.Text.CodePagesEncodingProvider>の場合、メソッドは、Windows オペレーティングシステムで実行されている場合に、システムのアクティブなコードページと一致するエンコーディングを返します。

- カスタムエンコーディングプロバイダーは、これらの <xref:System.Text.Encoding.GetEncoding%2A> メソッドオーバーロードのいずれかに `0`の引数が渡されたときに返すエンコーディングを選択できます。 また、<xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> メソッドが `null`を返すことによって、エンコーディングを返さないように選択することもできます。

.NET Framework 4.6 以降、.NET Framework には、完全な .NET Framework に存在するがユニバーサル Windows プラットフォームでは使用できないエンコーディングを使用できるようにする1つのエンコードプロバイダー (<xref:System.Text.CodePagesEncodingProvider>) が含まれています。 既定では、ユニバーサル Windows プラットフォームは Unicode エンコーディング、ASCII、およびコードページ28591のみをサポートしています。

 <xref:System.Text.Encoding.RegisterProvider%2A> メソッドの複数の呼び出しで同じエンコーディングプロバイダーが使用されている場合、最初のメソッド呼び出しのみがプロバイダーを登録します。 後続の呼び出しは無視されます。

 同じエンコーディングを処理する複数のプロバイダーを登録するために <xref:System.Text.Encoding.RegisterProvider%2A> メソッドが呼び出されると、最後に登録されたプロバイダーが、すべてのエンコードおよびデコード操作に使用されます。 以前に登録されたプロバイダーは無視されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="provider" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リトル エンディアン バイト順を使用する UTF-16 形式のエンコーディングを取得します。</summary>
        <value>リトル エンディアンのバイト順を使用する UTF-16 形式のエンコーディング。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 .NET でサポートされているエンコーディングと、使用する Unicode エンコーディングの詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」を参照してください。

 このプロパティによって返される <xref:System.Text.UnicodeEncoding> オブジェクトは、アプリに対して適切な動作を持つことはできません。 この例では、置換フォールバックを使用して、エンコードできない各文字列と、デコードできない各バイトを疑問符 ("?") 文字で置き換えます。 代わりに、<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> コンストラクターを呼び出して、次の例に示すように、フォールバックが <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>であるリトルエンディアン <xref:System.Text.UnicodeEncoding> オブジェクトをインスタンス化することができます。

 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]



## Examples
 次の例では、文字配列をエンコードし、文字をエンコードし、結果のバイトを表示するために必要なバイト数を決定します。

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リトル エンディアン バイト順を使用する UTF-32 形式のエンコーディングを取得します。</summary>
        <value>リトル エンディアンのバイト順を使用する UTF-32 形式のエンコーディング オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このプロパティによって返される <xref:System.Text.UTF32Encoding> オブジェクトは、アプリに対して適切な動作を持つことはできません。 この例では、置換フォールバックを使用して、エンコードできない文字列とデコードできない各バイトを Unicode 置換文字 (U + FFFE) で置き換えます。 代わりに、次の例に示すように、<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> コンストラクターを呼び出して、フォールバックが <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>のいずれかである <xref:System.Text.UTF32Encoding> オブジェクトをインスタンス化することができます。

 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]

 リトルエンディアンのバイト順の詳細については、<xref:System.Text.Encoding> クラスのトピックを参照してください。

 .NET でサポートされているエンコーディングと、使用する Unicode エンコーディングの詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」を参照してください。



## Examples
 次の例では、文字配列をエンコードし、文字をエンコードし、結果のバイトを表示するために必要なバイト数を決定します。

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>UTF-7 形式のエンコーディングを取得します。</summary>
        <value>UTF-7 形式のエンコード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 UTF-7 エンコードは、主に、NNTP や電子メールアプリケーションなど、7ビットに制限されている環境で使用されます。 堅牢性とセキュリティに関する問題のため、代わりに UTF-8 エンコーディングを使用できる8ビット環境では UTF7 encoding を使用しないでください。



## Examples
 次の例では、文字配列をエンコードし、文字をエンコードし、結果のバイトを表示するために必要なバイト数を決定します。

 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>UTF-8 形式のエンコーディングを取得します。</summary>
        <value>UTF-8 形式のエンコード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このプロパティは、Unicode (UTF-16 でエンコードされた) 文字を1文字あたり1バイトから4バイトのシーケンスにエンコードし、UTF-8 でエンコードされたバイト配列を Unicode (UTF-16 エンコード) 文字にデコードする <xref:System.Text.UTF8Encoding> オブジェクトを返します。 .NET でサポートされている文字エンコーディングと、使用する Unicode エンコーディングの詳細については、「 [.net での文字エンコード](~/docs/standard/base-types/character-encoding.md)」を参照してください。

 このプロパティによって返される <xref:System.Text.UTF8Encoding> オブジェクトは、アプリに適した動作を持たない場合があります。

-   このメソッドは、Unicode バイト順マーク (BOM) を提供する <xref:System.Text.UTF8Encoding> オブジェクトを返します。 BOM を提供しない UTF8 エンコーディングをインスタンス化するには、<xref:System.Text.UTF8Encoding.%23ctor%2A> コンストラクターのすべてのオーバーロードを呼び出します。

-   これは、置換フォールバックを使用してエンコードできない各文字列と、デコードできない各バイトを疑問符 ("?") 文字に置き換える、<xref:System.Text.UTF8Encoding> オブジェクトを返します。 代わりに、次の例に示すように、<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> コンストラクターを呼び出して、フォールバックが <xref:System.Text.EncoderFallbackException> または <xref:System.Text.DecoderFallbackException>のいずれかである <xref:System.Text.UTF8Encoding> オブジェクトをインスタンス化することができます。

     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]



## Examples
 次の例では、次の文字で構成される配列を定義します。

-   ラテン小文字 Z (U + 007A)

-   ラテン小文字 A (U + 0061)

-   ブラの結合 (U + 0306)

-   ラテン文字 AE (鋭) (U + 01FD)

-   ギリシャ語の小文字ベータ (U + 03B2)

-   ギリシャ語 ACROPHONIC DD54 1000 STATERS (U + 10154) を形成するサロゲートペア (U + U +)。

 各文字の UTF-16 コード単位が表示され、UTF-8 エンコーダーが文字配列をエンコードするために必要なバイト数を決定します。 次に、文字をエンコードし、結果として得られる UTF-8 でエンコードされたバイトを表示します。

 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングについて</related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングの IANA (Internet Assigned Numbers Authority) に登録されている名前を取得します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> の IANA 名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Text.Encoding.WebName%2A> プロパティは、<xref:System.Text.EncodingInfo.Name%2A> プロパティと同じです。

 <xref:System.Text.Encoding.WebName%2A> は、IANA で登録されたエンコーディング名を返すことに注意してください。 値が標準の名前である場合、エンコードの実装はその標準に完全に準拠していない可能性があります。 <xref:System.Text.Encoding.HeaderName%2A> プロパティは、電子メールのヘッダーに対して適切に機能する可能性がある別のエンコードを定義します。 ただし、ほとんどのアプリでは、代わりに <xref:System.Text.Encoding.WebName%2A> を使用する必要があります。

 IANA の詳細については、 [www.iana.org](https://www.iana.org/)を参照してください。

 <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> は <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>によって返される <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> と同じです。 一部の web 名は重複しています。詳細については、<xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> の解説を参照してください。



## Examples
 次の例では、HTML ヘッダーに <xref:System.Text.Encoding.WebName%2A> が含まれています。

 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]

 次の例では、各エンコードの異なる名前を取得し、<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>とは異なる1つ以上の名前のエンコーディングを表示します。 <xref:System.Text.Encoding.EncodingName%2A> が表示されますが、比較は行われません。

 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングに最も厳密に対応する Windows オペレーティング システムのコード ページを取得します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> に最も厳密に対応する、Windows オペレーティング システムのコード ページ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このプロパティは、Windows の多言語 (MLang) Api との互換性のために用意されています。たとえば、フォントファミリを決定する場合などです。 グローバリゼーションの場合は、代わりに Unicode エンコーディングのいずれかを使用することをお勧めします。 また、コードページを識別するために <xref:System.Text.Encoding.WindowsCodePage%2A> ではなく <xref:System.Text.Encoding.WebName%2A> を使用することもお勧めします。



## Examples
 次の例では、各エンコーディングに最も厳密に対応する Windows コードページを特定します。

 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>
