<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d182624f84b2633755cb38dc10f1f03427b66e42" /><Meta Name="ms.sourcegitcommit" Value="f9576bf8c61e3d46834aeeff50f858359f2a99ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="02/09/2020" /><Meta Name="ms.locfileid" Value="77105498" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpServerUtility" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpServerUtility sealed" />
  <TypeSignature Language="F#" Value="type HttpServerUtility = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Web 要求を処理するヘルパー メソッドを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility> クラスのメソッドとプロパティは、ASP.NET によって提供される組み込みの <xref:System.Web.HttpContext.Server%2A> オブジェクトを介して公開されます。  
  
   
  
## Examples  
 このトピックでは、ソースコードが含まれている Visual Studio Web サイトプロジェクトを[ダウンロード](https://go.microsoft.com/fwlink/?LinkId=192870)できます。  
  
 次の例は、<xref:System.Web.HttpServerUtility.HtmlEncode%2A> メソッドと <xref:System.Web.HttpServerUtility> クラスの <xref:System.Web.HttpServerUtility.UrlEncode%2A> メソッドを使用する方法を示しています。 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> メソッドを使用すると、ユーザーが指定した文字列入力が、実行可能なスクリプトや HTML 要素ではなく、ブラウザーに静的なテキストとして表示されるようにすることができます。 <xref:System.Web.HttpServerUtility.UrlEncode%2A> メソッドは、HTTP ストリームで正しく送信されるように Url をエンコードします。  
  
 [!code-aspx-csharp[System.Web.HttpServerUtility1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpServerUtility1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.HttpContext" />
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpServerUtility.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>前回の例外を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、スローされた最後の例外をクリアします。  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.GetLastError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>COM オブジェクトのサーバー インスタンスを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : string -&gt; obj" Usage="httpServerUtility.CreateObject progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">インスタンスを作成するオブジェクトのクラスまたは型。</param>
        <summary>オブジェクトのプログラム ID (ProgID) で識別されている COM オブジェクトのサーバー インスタンスを作成します。</summary>
        <returns>新しいオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、オブジェクトの ProgID を使用してオブジェクトを作成します。  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">オブジェクトのインスタンスを作成できませんでした。</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.CreateObject : Type -&gt; obj" Usage="httpServerUtility.CreateObject type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">作成するオブジェクトを表す <see cref="T:System.Type" />。</param>
        <summary>オブジェクトの型で識別されている COM オブジェクトのサーバー インスタンスを作成します。</summary>
        <returns>新しいオブジェクト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectFromClsid (clsid As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObjectFromClsid(System::String ^ clsid);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectFromClsid : string -&gt; obj" Usage="httpServerUtility.CreateObjectFromClsid clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">インスタンスを作成するオブジェクトのクラス ID。</param>
        <summary>オブジェクトのクラス ID (CLSID) で識別されている COM オブジェクトのサーバー インスタンスを作成します。</summary>
        <returns>新しいオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例は、<xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A> メソッドを使用して COM オブジェクトのサーバーインスタンスを作成する方法を示しています。  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">オブジェクトのインスタンスを作成できませんでした。</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Execute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したリソースのハンドラーを現在の要求のコンテキストで実行し、そのハンドラーを起動したページに実行を戻します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Execute : string -&gt; unit" Usage="httpServerUtility.Execute path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">実行する URL パス。</param>
        <summary>指定した仮想パスのハンドラーを現在の要求のコンテキストで実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドは、新しいページの実行が完了した後も元のページの実行を継続します。 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドは無条件で別のハンドラーに実行を転送します。  
  
 ASP.NET は、現在のユーザーが <xref:System.Web.HttpServerUtility.Execute%2A> メソッドによって配信されたリソースを表示する権限を持っているかどうかを検証しません。 ASP.NET 承認と認証ロジックは、元のリソースハンドラーが呼び出される前に実行されますが、ASP.NET は、<xref:System.Web.HttpServerUtility.Execute%2A> メソッドによって示されるハンドラーを直接呼び出し、新しいリソースの認証および承認ロジックを再実行しません。 アプリケーションのセキュリティポリシーで、クライアントがリソースにアクセスするための適切な承認を要求する必要がある場合、アプリケーションは再認証を強制するか、カスタムのアクセス制御メカニズムを提供する必要があります。  
  
 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドの代わりに <xref:System.Web.HttpResponse.Redirect%2A> メソッドを使用して、強制的に再認証することができます。 <xref:System.Web.HttpResponse.Redirect%2A> は、ブラウザーが新しいリソースを要求するクライアント側のリダイレクトを実行します。 このリダイレクトはシステムへの新しい要求であるため、インターネットインフォメーションサービス (IIS) と ASP.NET の両方のセキュリティポリシーのすべての認証と承認のロジックが対象となります。  
  
 アプリケーションが <xref:System.Web.HttpServerUtility.Execute%2A> メソッドを呼び出す前に、<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> メソッドを使用するカスタム承認メソッドを組み込むことによって、ユーザーがリソースを表示するアクセス許可を持っていることを確認できます。  
  
   
  
## Examples  
 次の例では、現在のディレクトリに .aspx ページ "Updateinfo .aspx" を表示します。 Updateinfo .aspx ページが表示された後、プログラムの実行が開始ページに戻ります。  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">現在の <see cref="T:System.Web.HttpContext" /> が <see langword="null" /> です。  
  
または 
<paramref name="path" /> によって指定されているハンドラーの実行中にエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> は <see langword="null" /> です。  
  
または 
 <paramref name="path" /> は仮想パスではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * bool -&gt; unit" Usage="httpServerUtility.Execute (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">実行する URL パス。</param>
        <param name="preserveForm"><see langword="true" /> コレクションおよび <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションを保持する場合は、<see cref="P:System.Web.HttpRequest.Form" />。<see langword="false" /> コレクションおよび <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションをクリアする場合は、<see cref="P:System.Web.HttpRequest.Form" />。</param>
        <summary>指定した仮想パスのハンドラーを現在の要求のコンテキストで実行し、<see cref="P:System.Web.HttpRequest.QueryString" /> コレクションおよび <see cref="P:System.Web.HttpRequest.Form" /> コレクションをクリアするかどうかを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例は、現在の要求で `Updateinfo.aspx` .aspx ページを実行し、<xref:System.Web.HttpRequest.QueryString%2A> コレクションと <xref:System.Web.HttpRequest.Form%2A> コレクションを保持する方法を示しています。 `Updateinfo.aspx` が表示されると、プログラムの実行が開始ページに戻ります。  
  
 [!code-csharp[HttpServerUtility.Execute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">現在の <see cref="T:System.Web.HttpContext" /> が <see langword="null" /> です。  
  
または 
<paramref name="path" /> によって指定されているハンドラーの実行中にエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> は <see langword="null" /> です。  
  
または 
 <paramref name="path" /> は仮想パスではありません。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.Execute (path, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">実行する URL パス。</param>
        <param name="writer">出力を取り込む <see cref="T:System.IO.TextWriter" />。</param>
        <summary>指定した仮想パスのハンドラーを現在の要求のコンテキストで実行します。 <see cref="T:System.IO.TextWriter" /> は、実行されたハンドラーからの出力を取り込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドは、指定された仮想パスの実行が完了した後に、元の要求の実行を継続します。 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドは無条件で別のハンドラーに実行を転送します。  
  
 ASP.NET は、現在のユーザーが <xref:System.Web.HttpServerUtility.Execute%2A> メソッドによって配信されたリソースを表示する権限を持っているかどうかを検証しません。 ASP.NET 承認と認証ロジックは、元のリソースハンドラーが呼び出される前に実行されますが、ASP.NET は、<xref:System.Web.HttpServerUtility.Execute%2A> メソッドによって示されるハンドラーを直接呼び出し、新しいリソースの認証および承認ロジックを再実行しません。 アプリケーションのセキュリティポリシーで、クライアントがリソースにアクセスするための適切な承認を要求する必要がある場合、アプリケーションは再認証を強制するか、カスタムのアクセス制御メカニズムを提供する必要があります。  
  
 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドの代わりに <xref:System.Web.HttpResponse.Redirect%2A> メソッドを使用して、強制的に再認証することができます。 <xref:System.Web.HttpResponse.Redirect%2A> は、ブラウザーが新しいリソースを要求するクライアント側のリダイレクトを実行します。 このリダイレクトはシステムへの新しい要求であるため、インターネットインフォメーションサービス (IIS) と ASP.NET の両方のセキュリティポリシーのすべての認証と承認のロジックが対象となります。  
  
 アプリケーションが <xref:System.Web.HttpServerUtility.Execute%2A> メソッドを呼び出す前に、<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> メソッドを使用するカスタム承認メソッドを組み込むことによって、ユーザーがリソースを表示するアクセス許可を持っていることを確認できます。  
  
   
  
## Examples  
 次の例では、現在のディレクトリにあるサーバー上の `Login.aspx` ページを実行し、<xref:System.IO.StringWriter> オブジェクト `writer`を通じてページからの出力を受け取ります。 `writer` から受信した HTML ストリームを HTTP 出力ストリームに書き込みます。  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">現在の <see cref="T:System.Web.HttpContext" /> が <see langword="null" /> です。  
  
または 
<paramref name="path" /> によって指定されているハンドラーの実行中にエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> は <see langword="null" /> です。  
  
または 
 <paramref name="path" /> は仮想パスではありません。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : string * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (path, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">実行する URL パス。</param>
        <param name="writer">出力を取り込む <see cref="T:System.IO.TextWriter" />。</param>
        <param name="preserveForm"><see langword="true" /> コレクションおよび <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションを保持する場合は、<see cref="P:System.Web.HttpRequest.Form" />。<see langword="false" /> コレクションおよび <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションをクリアする場合は、<see cref="P:System.Web.HttpRequest.Form" />。</param>
        <summary>指定した仮想パスのハンドラーを現在の要求のコンテキストで実行します。 <see cref="T:System.IO.TextWriter" /> はページからの出力を取り込み、<see cref="P:System.Web.HttpRequest.QueryString" /> コレクションおよび <see cref="P:System.Web.HttpRequest.Form" /> コレクションをクリアするかどうかをブール型のパラメーターで指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドは、指定された仮想パスの実行が完了した後に、元の要求の実行を続行します。 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドは無条件で別のハンドラーに実行を転送します。  
  
 ASP.NET は、現在のユーザーが <xref:System.Web.HttpServerUtility.Execute%2A> メソッドによって配信されたリソースを表示する権限を持っているかどうかを検証しません。 ASP.NET 承認と認証ロジックは、元のリソースハンドラーが呼び出される前に実行されますが、ASP.NET は、<xref:System.Web.HttpServerUtility.Execute%2A> メソッドによって示されるハンドラーを直接呼び出し、新しいリソースの認証および承認ロジックを再実行しません。 アプリケーションのセキュリティポリシーで、クライアントがリソースにアクセスするための適切な承認を要求する必要がある場合、アプリケーションは再認証を強制するか、カスタムのアクセス制御メカニズムを提供する必要があります。  
  
 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドの代わりに <xref:System.Web.HttpResponse.Redirect%2A> メソッドを使用して、強制的に再認証することができます。 <xref:System.Web.HttpResponse.Redirect%2A> は、ブラウザーが新しいリソースを要求するクライアント側のリダイレクトを実行します。 このリダイレクトはシステムへの新しい要求であるため、インターネットインフォメーションサービス (IIS) と ASP.NET の両方のセキュリティポリシーのすべての認証と承認のロジックが対象となります。  
  
 アプリケーションが <xref:System.Web.HttpServerUtility.Execute%2A> メソッドを呼び出す前に、<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> メソッドを使用するカスタム承認メソッドを組み込むことによって、ユーザーがリソースを表示するアクセス許可を持っていることを確認できます。  
  
   
  
## Examples  
 次の例では、現在のディレクトリにあるサーバー上の `Login.aspx` ページを実行し、<xref:System.IO.StringWriter> オブジェクト `writer`を通じてページからの出力を受け取ります。 `writer` から受信した HTML ストリームを HTTP 出力ストリームに書き込みます。 <xref:System.Web.HttpRequest.Form%2A> コレクションと <xref:System.Web.HttpRequest.QueryString%2A> コレクションの内容は保持されます。  
  
 [!code-csharp[HttpServerUtility.Execute02#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">現在の <see cref="T:System.Web.HttpContext" /> が null 参照 (Visual Basic の場合は <see langword="Nothing" />) です。  
  
または 
 <paramref name="path" /> がピリオド (.) で終わっています。  
  
または 
<paramref name="path" /> によって指定されているハンドラーの実行中にエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> は仮想パスではありません。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (handler As IHttpHandler, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Web::IHttpHandler ^ handler, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Execute : System.Web.IHttpHandler * System.IO.TextWriter * bool -&gt; unit" Usage="httpServerUtility.Execute (handler, writer, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">現在の要求の転送先となる <see cref="T:System.Web.IHttpHandler" /> を実装する HTTP ハンドラー。</param>
        <param name="writer">出力を取り込む <see cref="T:System.IO.TextWriter" />。</param>
        <param name="preserveForm"><see langword="true" /> コレクションおよび <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションを保持する場合は、<see cref="P:System.Web.HttpRequest.Form" />。<see langword="false" /> コレクションおよび <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションをクリアする場合は、<see cref="P:System.Web.HttpRequest.Form" />。</param>
        <summary>指定した仮想パスのハンドラーを現在の要求のコンテキストで実行します。 <see cref="T:System.IO.TextWriter" /> は実行されたハンドラーからの出力を取り込み、<see cref="P:System.Web.HttpRequest.QueryString" /> コレクションおよび <see cref="P:System.Web.HttpRequest.Form" /> コレクションをクリアするかどうかをブール型のパラメーターで指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタム HTTP ハンドラーを記述して、共通言語仕様 (CLS) に準拠している任意の言語で、事前に定義された特定の種類の HTTP 要求を処理することができます。 従来の ASP (classic ASP) ページまたは ASP.NET ページではなく、HTTP ハンドラークラスで定義されている実行可能コードは、これらの特定の要求に応答します。 HTTP ハンドラーを使用すると、インターネットインフォメーションサービス (IIS) を実行している Web サーバーの下位レベルの要求および応答サービスと対話できます。また、ISAPI 拡張に似ていても、より単純なプログラミングモデルを使用する機能が提供されます。  
  
 ASP.NET は、現在のユーザーが <xref:System.Web.HttpServerUtility.Execute%2A> メソッドによって配信されたリソースを表示する権限を持っているかどうかを検証しません。 ASP.NET 承認と認証ロジックは、元のリソースハンドラーが呼び出される前に実行されますが、ASP.NET は、<xref:System.Web.HttpServerUtility.Execute%2A> メソッドによって示されるハンドラーを直接呼び出し、新しいリソースの認証および承認ロジックを再実行しません。 アプリケーションのセキュリティポリシーで、クライアントがリソースへのアクセスを取得するための適切な承認を必要とする場合、アプリケーションは再認証を強制するか、カスタムのアクセス制御メカニズムを提供する必要があります。  
  
 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドの代わりに <xref:System.Web.HttpResponse.Redirect%2A> メソッドを使用して、強制的に再認証することができます。 <xref:System.Web.HttpResponse.Redirect%2A> は、ブラウザーが新しいリソースを要求するクライアント側のリダイレクトを実行します。 このリダイレクトはシステムへの新しい要求であるため、IIS と ASP.NET の両方のセキュリティポリシーのすべての認証と承認のロジックが対象となります。  
  
 アプリケーションが <xref:System.Web.HttpServerUtility.Execute%2A> メソッドを呼び出す前に、<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> メソッドを使用するカスタム承認メソッドを組み込むことによって、ユーザーがリソースを表示するアクセス許可を持っていることを確認できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="handler" /> によって指定されているハンドラーの実行中にエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="handler" /> パラメーターが <see langword="null" /> です。</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastError () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ GetLastError();" />
      <MemberSignature Language="F#" Value="member this.GetLastError : unit -&gt; Exception" Usage="httpServerUtility.GetLastError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>前回の例外を返します。</summary>
        <returns>スローされた前回の例外。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、アプリケーションの最後のエラーの説明を HTTP 出力ストリームに出力します。 エラーが発生していない場合は、"エラーがありません" が出力されます。  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.ClearError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>エンコードされた文字列をデコードして、無効な HTML 文字を削除します。  
  
<see cref="T:System.Net.WebUtility" /> クラスを使用して、web アプリケーションの外部の値をエンコード、またはデコードします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string -&gt; string" Usage="httpServerUtility.HtmlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">デコードする HTML 文字列。</param>
        <summary>HTML エンコードされた文字列をデコードし、デコードした文字列を返します。</summary>
        <returns>デコードされたテキスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML エンコードを使用すると、ブラウザーでテキストが正しく表示され、ブラウザーでは HTML として解釈されません。 たとえば、テキスト文字列に不等号 (\<) または不等号 (>) が含まれている場合、ブラウザーはこれらの文字を HTML タグの左または右の角かっことして解釈します。 文字が HTML エンコードされている場合、これらの文字は `&lt;` および `&gt;`の文字列に変換されます。これにより、ブラウザーでは、不等号が表示され、署名が正しくなります。 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> サーバーに送信されたテキストをデコードします。  
  
 このメソッドは、ASP.NET アプリケーションから実行時に <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> メソッドにアクセスするための便利な方法です。 内部的には、このメソッドは <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> を使用して文字列をデコードします。  
  
 ASP.NET web ページの分離コードファイルで、`Server` プロパティを使用して <xref:System.Web.HttpServerUtility> クラスのインスタンスにアクセスします。 分離コードファイルにないクラスでは、`HttpContext.Current.Server` を使用して、<xref:System.Web.HttpServerUtility> クラスのインスタンスにアクセスします。  
  
 Web アプリケーションの外部では、<xref:System.Net.WebUtility> クラスを使用して値をエンコードまたはデコードします。  
  
   
  
## Examples  
 次の例には、ファイルからデータをデコードし、1つの文字列にコピーする関数 `LoadDecodedFile`が含まれています。  
  
 [!code-aspx-csharp[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-aspx-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">デコードする HTML 文字列。</param>
        <param name="output">デコードされた文字列を格納する <see cref="T:System.IO.TextWriter" /> 出力ストリーム。</param>
        <summary>HTML エンコードされた文字列をデコードし、その結果の出力を <see cref="T:System.IO.TextWriter" /> 出力ストリームに送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML エンコードを使用すると、ブラウザーでテキストが正しく表示され、ブラウザーでは HTML として解釈されません。 たとえば、テキスト文字列に不等号 (\<) または不等号 (>) が含まれている場合、ブラウザーはこれらの文字を HTML タグの左または右の角かっことして解釈します。 文字が HTML エンコードされている場合、これらの文字は `&lt;` および `&gt;`の文字列に変換されます。これにより、ブラウザーでは、不等号が表示され、署名が正しくなります。  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> サーバーに送信されたテキストをデコードします。  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> は、実行時に ASP.NET アプリケーションから <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> メソッドにアクセスするための便利な方法です。 内部的には、<xref:System.Web.HttpServerUtility.HtmlDecode%2A> は <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> を使用して文字列をデコードします。  
  
 <xref:System.Net.WebUtility> クラスを使用して、web アプリケーションの外部の値をエンコード、またはデコードします。  
  
   
  
## Examples  
 次の例では、HTTP 経由の送信用に HTML エンコードされた文字列をデコードします。 `EncodedString` という名前の指定された文字列をデコードします。この文字列には、"This is a &lt;Test String&gt;." というテキストが含まれており、これを `DecodedString` という名前の文字列にコピーします (これは \<テスト文字列 > です)。  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ブラウザーに表示される文字列をエンコードします。  
  
<see cref="T:System.Net.WebUtility" /> クラスを使用して、web アプリケーションの外部の値をエンコード、またはデコードします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string -&gt; string" Usage="httpServerUtility.HtmlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">エンコードする文字列。</param>
        <summary>文字列を HTML エンコードし、エンコードされた文字列を返します。</summary>
        <returns>HTML エンコードされたテキスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML エンコードを使用すると、ブラウザーでテキストが正しく表示され、ブラウザーでは HTML として解釈されません。 たとえば、テキスト文字列に不等号 (\<) または不等号 (>) が含まれている場合、ブラウザーはこれらの文字を HTML タグの左または右の角かっことして解釈します。 文字が HTML エンコードされている場合、これらの文字は `&lt;` および `&gt;`の文字列に変換されます。これにより、ブラウザーでは、不等号が表示され、署名が正しくなります。  
  
 このメソッドは、ASP.NET アプリケーションから実行時に <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> メソッドにアクセスするための便利な方法です。 内部的には、このメソッドは <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> を使用して文字列をエンコードします。  
  
 ASP.NET web ページの分離コードファイルで、`Server` プロパティを使用して <xref:System.Web.HttpServerUtility> クラスのインスタンスにアクセスします。 分離コードファイルにないクラスでは、`HttpContext.Current.Server` を使用して、<xref:System.Web.HttpServerUtility> クラスのインスタンスにアクセスします。  
  
 Web アプリケーションの外部では、<xref:System.Net.WebUtility> クラスを使用して値をエンコードまたはデコードします。  
  
   
  
## Examples  
 次の例は、安全でないコードをコード化する可能性がある値を HTML エンコードする方法を示しています。 このコードは、web ページの分離コードファイルに存在します。 エンコードする値は、例を簡略化し、HTML エンコードできる値の型を表示するためだけに、この例でハードコーディングされています。 通常は、ユーザーまたは要求から受け取った値を HTML エンコードします。 `Result` は `Literal` コントロールを参照します。  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 次の例は前の例と似ていますが、分離コードファイルに含まれていないクラス内から値を HTML エンコードする方法を示している点が異なります。  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.HtmlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.HtmlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">エンコードする文字列。</param>
        <param name="output">エンコードされた文字列を格納している <see cref="T:System.IO.TextWriter" /> 出力ストリーム。</param>
        <summary>文字列を HTML エンコードし、その結果の出力を <see cref="T:System.IO.TextWriter" /> 出力ストリームに送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML エンコードによって、ブラウザーではテキストが正しく表示され、HTML として解釈されません。 たとえば、テキスト文字列に不等号 (\<) または不等号 (>) が含まれている場合、ブラウザーはこれらの文字を HTML タグの左または右の角かっことして解釈します。 これら2つの文字の HTML エンコーディングは、それぞれ `&lt;` し、`&gt;`ます。これにより、ブラウザーでは、不等号が表示され、署名が正しくなります。  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> は、実行時に ASP.NET アプリケーションから <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> メソッドにアクセスするための便利な方法です。 内部的には、<xref:System.Web.HttpServerUtility.HtmlEncode%2A> は <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> を使用して文字列をエンコードします。  
  
 <xref:System.Net.WebUtility> クラスを使用して、web アプリケーションの外部の値をエンコード、またはデコードします。  
  
   
  
## Examples  
 次の例では、HTTP によって送信されるように文字列をエンコードします。 `TestString`という名前の文字列をエンコードします。これには、"This is a \<Test String >." と `EncodedString` いうテキストが含まれ、"This is a &lt;Test String&gt;." という名前の文字列にコピーされます。  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Web.HttpServerUtility.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバーのコンピューター名を取得します。</summary>
        <value>ローカル コンピューターの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、サーバーのコンピューター名を文字列変数として格納します。  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">コンピューター名が見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpServerUtility.MapPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Web アプリケーション内の仮想パス。</param>
        <summary>指定した仮想パスに対応する物理ファイル パスを返します。</summary>
        <returns><paramref name="path" /> に対応する、Web サーバー上の物理ファイル パス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `path` が `null`場合、<xref:System.Web.HttpServerUtility.MapPath%2A> メソッドは、パスの現在の要求を含むディレクトリの完全な物理パスを返します。 相対パスでは、このメソッドが値を返すための既存のファイルまたはフォルダーを指定する必要はありません。 ただし、Web アプリケーションの外部でパスを指定することはできません。  
  
> [!IMPORTANT]
>  <xref:System.Web.HttpServerUtility.MapPath%2A> 方法には、ホスティング環境に関する機密情報が含まれている可能性があります。 戻り値は、ユーザーに表示されません。  
  
 `C:\ExampleSites\TestMapPath` に存在する Web アプリケーションは、次の結果を返します。  
  
|要求元|`path`|戻り値|  
|------------------|------------|--------------------|  
|RootLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath|  
|RootLevelPage.aspx|"/DownOneLevel/DownLevelPage.aspx"|C:\ExampleSites\TestMapPath\DownOneLevel\DownLevelPage.aspx|  
|RootLevelPage.aspx|"/NotRealFolder"|C:\ExampleSites\TestMapPath\NotRealFolder|  
|RootLevelPage.aspx|"../Outsideapplication "|<xref:System.Web.HttpException>|  
|/DownOneLevel/DownLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath\DownOneLevel|  
|/DownOneLevel/DownLevelPage.aspx|"../RootLevelPage.aspx"|C:\ExampleSites\TestMapPath\RootLevelPage.aspx|  
  
   
  
## Examples  
 次の例は、相対仮想パスの物理ファイルを取得する方法を示しています。 このコードは、web ページの分離コードファイルに存在し、既定の `Server` オブジェクトを利用します。  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 次の例は前の例と似ていますが、分離コードファイルに含まれていないクラス内から物理パスを取得する方法を示している点が異なります。  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">現在の <see cref="T:System.Web.HttpContext" /> が <see langword="null" /> です。
        
または 
<paramref name="path" /> は物理パスです。仮想パスを指定してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScriptTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScriptTimeout : int with get, set" Usage="System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求タイムアウト値を秒単位で取得または設定します。</summary>
        <value>要求のタイムアウト値設定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> プロパティは、 [httpRuntime](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/e1f13641(v=vs.100))要素の `executionTimeout` 属性を設定することによって、web.config ファイルで設定できます。 <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> プロパティを使用してプログラムでタイムアウトを設定することは、web.config の設定よりも優先されます。  
  
> [!NOTE]
>  Web.config ファイルで[httpRuntime](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/e1f13641(v=vs.100))要素の `debug` 属性を `true` に設定した場合、<xref:System.Web.HttpServerUtility.ScriptTimeout%2A> の値は無視されます。  
  
   
  
## Examples  
 次の例では、要求のタイムアウト期間を60秒に設定します。  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">現在の <see cref="T:System.Web.HttpContext" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">タイムアウト時間が <see langword="null" /> です。または、それ以外の設定ができませんでした。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transfer">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のページの実行を終了し、現在の要求に対して新しいページの実行を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string -&gt; unit" Usage="httpServerUtility.Transfer path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">サーバー上にある、実行する新しいページの URL パス。</param>
        <summary>現在の要求に対して、現在のページの実行を終了し、指定された URL パスを使用して新しいページの実行を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 に転送されるページは、別の .aspx ページである必要があります。 たとえば、.asp または .asmx ページへの転送が有効ではありません。 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドは、<xref:System.Web.HttpRequest.QueryString%2A> コレクションと <xref:System.Web.HttpRequest.Form%2A> コレクションを保持します。  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> は <xref:System.Web.HttpResponse.End%2A>を呼び出します。これにより、完了時に <xref:System.Threading.ThreadAbortException> 例外がスローされます。  
  
 ASP.NET は、現在のユーザーが <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドによって配信されたリソースを表示する権限を持っているかどうかを検証しません。 ASP.NET 承認と認証ロジックは、元のリソースハンドラーが呼び出される前に実行されますが、ASP.NET は、<xref:System.Web.HttpServerUtility.Transfer%2A> メソッドによって示されるハンドラーを直接呼び出し、新しいリソースの認証および承認ロジックを再実行しません。 アプリケーションのセキュリティポリシーで、クライアントがリソースにアクセスするための適切な承認を要求する必要がある場合、アプリケーションは再認証を強制するか、カスタムのアクセス制御メカニズムを提供する必要があります。  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドの代わりに <xref:System.Web.HttpResponse.Redirect%2A> メソッドを使用して、強制的に再認証することができます。 <xref:System.Web.HttpResponse.Redirect%2A> メソッドは、ブラウザーが新しいリソースを要求するクライアント側のリダイレクトを実行します。 このリダイレクトはシステムへの新しい要求であるため、インターネットインフォメーションサービス (IIS) と ASP.NET の両方のセキュリティポリシーのすべての認証と承認のロジックが対象となります。  
  
 アプリケーションが <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドを呼び出す前に、<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> メソッドを使用するカスタム承認メソッドを組み込むことによって、ユーザーがリソースを表示するアクセス許可を持っていることを確認できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : string * bool -&gt; unit" Usage="httpServerUtility.Transfer (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">サーバー上にある、実行する新しいページの URL パス。</param>
        <param name="preserveForm"><see langword="true" /> コレクションおよび <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションを保持する場合は、<see cref="P:System.Web.HttpRequest.Form" />。<see langword="false" /> コレクションおよび <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションをクリアする場合は、<see cref="P:System.Web.HttpRequest.Form" />。</param>
        <summary>現在のページの実行を終了し、指定された URL パスを使用して新しいページの実行を開始します。 <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションと <see cref="P:System.Web.HttpRequest.Form" /> コレクションを削除するかどうかを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 に転送されるページは、別の .aspx ページである必要があります。 たとえば、.asp または .asmx ページへの転送が有効ではありません。  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> は <xref:System.Web.HttpResponse.End%2A>を呼び出します。これにより、完了時に <xref:System.Threading.ThreadAbortException> 例外がスローされます。  
  
 `preserveForm` パラメーターを `true`に設定すると、ターゲットページは <xref:System.Web.UI.Page.PreviousPage%2A> プロパティを使用して、前のページのビューステートにアクセスできるようになります。  
  
 セキュリティ上の理由から、`enableViewStateMac` 属性を `true`に設定しておく必要があります。 ASP.NET は、現在のユーザーが <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドによって配信されたリソースを表示する権限を持っているかどうかを検証しません。 ASP.NET 承認と認証ロジックは、元のリソースハンドラーが呼び出される前に実行されますが、ASP.NET は、<xref:System.Web.HttpServerUtility.Transfer%2A> メソッドによって示されるハンドラーを直接呼び出し、新しいリソースの認証および承認ロジックを再実行しません。 アプリケーションのセキュリティポリシーで、クライアントがリソースにアクセスするための適切な承認を要求する必要がある場合、アプリケーションは再認証を強制するか、カスタムのアクセス制御メカニズムを提供する必要があります。  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドの代わりに <xref:System.Web.HttpResponse.Redirect%2A> メソッドを使用して、強制的に再認証することができます。 <xref:System.Web.HttpResponse.Redirect%2A> メソッドは、ブラウザーが新しいリソースを要求するクライアント側のリダイレクトを実行します。 このリダイレクトはシステムへの新しい要求であるため、インターネットインフォメーションサービス (IIS) と ASP.NET の両方のセキュリティポリシーのすべての認証と承認のロジックが対象となります。  
  
 アプリケーションが <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドを呼び出す前に、<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> メソッドを使用するカスタム承認メソッドを組み込むことによって、ユーザーがリソースを表示するアクセス許可を持っていることを確認できます。  
  
   
  
## Examples  
 次の例では、現在のページと同じディレクトリに新しいページを実行します。  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">現在のページ要求がコールバックです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (handler As IHttpHandler, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::Web::IHttpHandler ^ handler, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.Transfer : System.Web.IHttpHandler * bool -&gt; unit" Usage="httpServerUtility.Transfer (handler, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">現在の要求の転送先となる <see cref="T:System.Web.IHttpHandler" /> を実装する HTTP ハンドラー。</param>
        <param name="preserveForm"><see langword="true" /> コレクションおよび <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションを保持する場合は、<see cref="P:System.Web.HttpRequest.Form" />。<see langword="false" /> コレクションおよび <see cref="P:System.Web.HttpRequest.QueryString" /> コレクションをクリアする場合は、<see cref="P:System.Web.HttpRequest.Form" />。</param>
        <summary>現在のページの実行を終了し、カスタム HTTP ハンドラーを使用して新しい要求の実行を開始します。このハンドラーは、<see cref="T:System.Web.IHttpHandler" /> インターフェイスを実装し、<see cref="P:System.Web.HttpRequest.QueryString" /> コレクションおよび <see cref="P:System.Web.HttpRequest.Form" /> コレクションをクリアするかどうかを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタム HTTP ハンドラーを記述して、共通言語仕様 (CLS) に準拠している任意の言語で、事前に定義された特定の種類の HTTP 要求を処理することができます。 従来の ASP (classic ASP) ページまたは ASP.NET ページではなく、HTTP ハンドラークラスで定義されている実行可能コードは、これらの特定の要求に応答します。 HTTP ハンドラーを使用すると、インターネットインフォメーションサービス (IIS) を実行している Web サーバーの下位レベルの要求および応答サービスと対話できます。また、ISAPI 拡張に似ていても、より単純なプログラミングモデルを使用する機能が提供されます。  
  
 `preserveForm` パラメーターを `true`に設定すると、ターゲットページは <xref:System.Web.UI.Page.PreviousPage%2A> プロパティを使用して、前のページのビューステートにアクセスできるようになります。  
  
 セキュリティ上の理由から、`enableViewStateMac` 属性を `true`に設定しておく必要があります。 ASP.NET は、現在のユーザーが <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドによって配信されたリソースを表示する権限を持っているかどうかを検証しません。 ASP.NET 承認と認証ロジックは、元のリソースハンドラーが呼び出される前に実行されますが、ASP.NET は、<xref:System.Web.HttpServerUtility.Transfer%2A> メソッドによって示されるハンドラーを直接呼び出し、新しいリソースの認証および承認ロジックを再実行しません。 アプリケーションのセキュリティポリシーで、リソースにアクセスするための適切な承認をクライアントに要求する場合は、アプリケーションで再認証を強制するか、カスタムのアクセス制御メカニズムを提供する必要があります。  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドの代わりに <xref:System.Web.HttpResponse.Redirect%2A> メソッドを使用して、強制的に再認証することができます。 <xref:System.Web.HttpResponse.Redirect%2A> メソッドは、ブラウザーが新しいリソースを要求するクライアント側のリダイレクトを実行します。 このリダイレクトはシステムへの新しい要求であるため、IIS と ASP.NET の両方のセキュリティポリシーのすべての認証と承認のロジックが対象となります。  
  
 アプリケーションが <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドを呼び出す前に、<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> メソッドを使用するカスタム承認メソッドを組み込むことによって、ユーザーがリソースを表示するアクセス許可を持っていることを確認できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">現在のページ要求がコールバックです。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した URL の非同期実行を行います。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> は .NET Framework バージョン3.5 で導入されました。 .NET Framework の概要については、「[バージョンと依存関係](~/docs/framework/migration-guide/versions-and-dependencies.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string -&gt; unit" Usage="httpServerUtility.TransferRequest path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">サーバー上にある、実行する新しいページの URL パス。</param>
        <summary>指定した URL の非同期実行を行います。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドオーバーロードは、`preserveForm` パラメーターが `false`に設定された <xref:System.Web.HttpServerUtility.TransferRequest%2A> オーバーロードを呼び出し、`method` パラメーターを `null`に設定し、`headers` パラメーターを `null`に設定し、`preserveUser` パラメーターを `true`に設定します。 詳細については、「<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> のオーバーロード」の「解説」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">この要求には、[!INCLUDE[iisver](~/includes/iisver-md.md)] の統合パイプライン モードが必要です。</exception>
        <exception cref="T:System.Web.HttpException">要求を処理するサーバーが使用できません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> パラメーターが正しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">サーバー上にある、実行する新しいページの URL パス。</param>
        <param name="preserveForm"><see langword="true" /> コレクションを保持する場合は <see cref="P:System.Web.HttpRequest.Form" />、<see langword="false" /> コレクションを消去する場合は <see cref="P:System.Web.HttpRequest.Form" />。</param>
        <summary>指定した URL の非同期実行を行い、クエリ文字列パラメーターを保持します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、`preserveForm` パラメーターが渡された値に設定された <xref:System.Web.HttpServerUtility.TransferRequest%2A> オーバーロードを呼び出し、`method` パラメーターが `null`に設定され、`headers` パラメーターが `null`に設定され、`preserveUser` パラメーターが `true`に設定されています。 詳細については、「<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>」の「解説」を参照してください。  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> は .NET Framework バージョン3.5 で導入されました。  詳細については、「[.NET Framework のバージョンおよび依存関係](~/docs/framework/migration-guide/versions-and-dependencies.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">この要求には、[!INCLUDE[iisver](~/includes/iisver-md.md)] の統合パイプライン モードが必要です。</exception>
        <exception cref="T:System.Web.HttpException">要求を処理するサーバーが使用できません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> パラメーターが正しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">サーバー上にある、実行する新しいページの URL パス。</param>
        <param name="preserveForm"><see langword="true" /> コレクションを保持する場合は <see cref="P:System.Web.HttpRequest.Form" />、<see langword="false" /> コレクションを消去する場合は <see cref="P:System.Web.HttpRequest.Form" />。</param>
        <param name="method">新しい要求の実行で使用する HTTP メソッド。</param>
        <param name="headers">新しい要求の要求ヘッダーの <see cref="T:System.Collections.Specialized.NameValueCollection" />。</param>
        <summary>指定した HTTP メソッドおよびヘッダーを使用して、指定した URL の非同期実行を行います。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、[!INCLUDE[iisver](~/includes/iisver-md.md)] で統合パイプラインモードを使用してを実行しているときに、正しい要求コンテキストでターゲット要求を実行している間に、要求の処理をあるリソースの種類から別の種類のリソースに転送できるようにするために使用されます。 たとえば、<xref:System.Web.HttpServerUtility.TransferRequest%2A> メソッドを使用して、ASPX ページの要求を XML ページの要求に転送できます。  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> メソッドは、指定された URL の非同期の子実行を次の条件で実行します。  
  
-   `path` パラメーターでクエリ文字列を指定した場合は、新しいクエリ文字列として使用されます。 クエリ文字列が含まれていない場合は、要求のクエリ文字列が再利用されます。  
  
-   `method` パラメーターを指定した場合は、それが使用されます。 `null`されている場合は、元の要求の HTTP メソッドが使用されます。  
  
-   `preserveForm` パラメーターが `true`場合は、要求の現在のエンティティ本体をターゲット要求で使用できるようになります。 これにより、フォームの投稿とアップロードを転送できます。  
  
-   ユーザー id が元の要求に対して現在設定されている場合、id は新しい要求に転送されます。 これにより、認証された要求は、新しい要求の認証結果を再利用できます。 ユーザーが転送されないようにするには、転送する前に、元の要求に対して `null` するようにユーザーを設定します。  
  
-   `headers` パラメーターを指定すると、指定したヘッダーを使用して新しい要求が実行されます。 これを使用して、新しい要求の要求ヘッダーとクッキーを変更したり、元の要求を受信した場所を指定する特別なヘッダーを追加したりできます。  
  
     このメソッドは、`preserveUser` パラメーターを `true`に設定して、<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29> メソッドのオーバーロードを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">この要求を実行するには、統合モードで実行している [!INCLUDE[iisver](~/includes/iisver-md.md)] が必要です。</exception>
        <exception cref="T:System.Web.HttpException">要求を処理するサーバーが使用できません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> パラメーターが正しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection, preserveUser As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers, bool preserveUser);" />
      <MemberSignature Language="F#" Value="member this.TransferRequest : string * bool * string * System.Collections.Specialized.NameValueCollection * bool -&gt; unit" Usage="httpServerUtility.TransferRequest (path, preserveForm, method, headers, preserveUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveForm" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" Index="3" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preserveUser" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">パス。</param>
        <param name="preserveForm"><see langword="true" /> コレクションを保持する場合は <see cref="P:System.Web.HttpRequest.Form" />、<see langword="false" /> コレクションを消去する場合は <see cref="P:System.Web.HttpRequest.Form" />。</param>
        <param name="method">新しい要求で使用する HTTP メソッド。</param>
        <param name="headers">新しい要求の要求ヘッダーを含む <see cref="T:System.Collections.Specialized.NameValueCollection" /> オブジェクト。</param>
        <param name="preserveUser">ユーザー id を保持する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このメソッドの他のメソッド オーバーロードは、このパラメーターが <see langword="true" /> に設定された状態でこのオーバーロードを呼び出します。</param>
        <summary>指定した HTTP メソッド、ヘッダー、およびパスを使用して、指定した URL の非同期実行を実行します。また、任意でユーザー id とフォーム値を保持します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、「<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>」の「解説」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">この要求には、[!INCLUDE[iisver](~/includes/iisver-md.md)] の統合パイプライン モードが必要です。</exception>
        <exception cref="T:System.Web.HttpException">要求を処理するサーバーが使用できません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> パラメーターが正しくありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>HTTP 伝送用にエンコードされた文字列をデコードし、URL の形でサーバーに送信します。  
  
<see cref="T:System.Net.WebUtility" /> クラスを使用して、web アプリケーションの外部の値をエンコード、またはデコードします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlDecode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string -&gt; string" Usage="httpServerUtility.UrlDecode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">デコードする文字列。</param>
        <summary>文字列を URL デコードし、デコードされた文字列を返します。</summary>
        <returns>デコードされたテキスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL エンコードによって、すべてのブラウザーが URL 文字列内のテキストを正しく転送できるようになります。 一部のブラウザーでは、疑問符 (?)、アンパサンド (&)、スラッシュ (/)、スペースなどの文字が切り捨てられたり、破損したりする可能性があります。 そのため、これらの文字は `<a>` タグまたはクエリ文字列でエンコードして、要求文字列でブラウザーが文字列を再送信できるようにする必要があります。  
  
 このメソッドは、ASP.NET アプリケーションから実行時に <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> メソッドにアクセスするための便利な方法です。 内部的には、このメソッドは <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> を使用して文字列をデコードします。  
  
 ASP.NET web ページの分離コードファイルで、`Server` プロパティを使用して <xref:System.Web.HttpServerUtility> クラスのインスタンスにアクセスします。 分離コードファイルにないクラスでは、`HttpContext.Current.Server` を使用して、<xref:System.Web.HttpServerUtility> クラスのインスタンスにアクセスします。  
  
 Web アプリケーションの外部では、<xref:System.Net.WebUtility> クラスを使用して値をエンコードまたはデコードします。  
  
   
  
## Examples  
 次の例では、クエリ文字列から取得した値を URL デコードする方法を示します。 このコードは、web ページの分離コードファイルに存在します。 `ReturnPage` は `HyperLink` コントロールを参照します。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 次の例は前の例と似ていますが、分離コードファイルに含まれていないクラス内から値を URL デコードする方法を示している点が異なります。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlDecode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlDecode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">デコードする HTML 文字列。</param>
        <param name="output">デコードされた文字列を格納する <see cref="T:System.IO.TextWriter" /> 出力ストリーム。</param>
        <summary>URL 形式で受け取った HTML 文字列をデコードし、その結果の出力を <see cref="T:System.IO.TextWriter" /> 出力ストリームへ送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL エンコードによって、すべてのブラウザーが URL 文字列内のテキストを正しく転送できるようになります。 一部のブラウザーでは、疑問符 (?)、アンパサンド (&)、スラッシュ (/)、スペースなどの文字が切り捨てられたり、破損したりする可能性があります。 そのため、これらの文字は `<a>` タグまたはクエリ文字列でエンコードして、要求文字列でブラウザーが文字列を再送信できるようにする必要があります。  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A> は、実行時に ASP.NET アプリケーションから <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> メソッドにアクセスするための便利な方法です。 内部的には、<xref:System.Web.HttpServerUtility.UrlDecode%2A> は <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> を使用して文字列をデコードします。  
  
 <xref:System.Net.WebUtility> クラスを使用して、web アプリケーションの外部の値をエンコード、またはデコードします。  
  
   
  
## Examples  
 次の例では、`EncodedString` という名前の文字列 (URL で受信) を `DecodedString`という名前の文字列にデコードします。  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>URL を使用して Web サーバーからクライアントへ信頼性のある HTTP 伝送を行うために、文字列をエンコードします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> は、実行時に ASP.NET アプリケーションから <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> メソッドにアクセスするための便利な方法です。 内部的には、<xref:System.Web.HttpServerUtility.UrlEncode%2A> は <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> を使用して文字列をエンコードします。  
  
 <xref:System.Net.WebUtility> クラスを使用して、web アプリケーションの外部の値をエンコード、またはデコードします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string -&gt; string" Usage="httpServerUtility.UrlEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">URL エンコードするテキスト。</param>
        <summary>文字列を URL エンコードし、エンコードされた文字列を返します。</summary>
        <returns>URL エンコードされたテキスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL エンコードによって、すべてのブラウザーが URL 文字列内のテキストを正しく転送できるようになります。 一部のブラウザーでは、疑問符 (?)、アンパサンド (&)、スラッシュ (/)、スペースなどの文字が切り捨てられたり、破損したりする可能性があります。 そのため、これらの文字は `<a>` タグまたはクエリ文字列でエンコードして、要求文字列でブラウザーが文字列を再送信できるようにする必要があります。  
  
 このメソッドは、ASP.NET アプリケーションから実行時に <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> メソッドにアクセスするための便利な方法です。 内部的には、このメソッドは <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> を使用して文字列をエンコードします。  
  
 ASP.NET web ページの分離コードファイルで、`Server` プロパティを使用して <xref:System.Web.HttpServerUtility> クラスのインスタンスにアクセスします。 分離コードファイルにないクラスでは、`HttpContext.Current.Server` を使用して、<xref:System.Web.HttpServerUtility> クラスのインスタンスにアクセスします。  
  
 Web アプリケーションの外部では、<xref:System.Net.WebUtility> クラスを使用して値をエンコードまたはデコードします。  
  
   
  
## Examples  
 次の例は、ハイパーリンクのクエリ文字列値として使用される値を URL エンコードする方法を示しています。 このコードは、web ページの分離コードファイルに存在します。 エンコードする値はこの例ではハードコーディングされています。この例では、例を単純化し、URL エンコードする値の型を示しています。 通常は、ユーザーまたは要求から受け取った値を URL エンコードします。 `NextPage` は `HyperLink` コントロールを参照します。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 次の例は前の例と似ていますが、分離コードファイルに含まれていないクラス内から値を URL エンコードする方法を示している点が異なります。  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="member this.UrlEncode : string * System.IO.TextWriter -&gt; unit" Usage="httpServerUtility.UrlEncode (s, output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">エンコードする文字列。</param>
        <param name="output">エンコードされた文字列を格納している <see cref="T:System.IO.TextWriter" /> 出力ストリーム。</param>
        <summary>文字列を URL エンコードし、その結果の出力を <see cref="T:System.IO.TextWriter" /> 出力ストリームに送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URL エンコードによって、すべてのブラウザーが URL 文字列内のテキストを正しく転送できるようになります。 一部のブラウザーでは、疑問符 (?)、アンパサンド (&)、スラッシュ (/)、スペースなどの文字が切り捨てられたり、破損したりする可能性があります。 そのため、これらの文字は `<a>` タグまたはクエリ文字列でエンコードして、要求文字列でブラウザーが文字列を再送信できるようにする必要があります。  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> は、実行時に ASP.NET アプリケーションから <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> メソッドにアクセスするための便利な方法です。 内部的には、<xref:System.Web.HttpServerUtility.UrlEncode%2A> は <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> を使用して文字列をエンコードします。  
  
 <xref:System.Net.WebUtility> クラスを使用して、web アプリケーションの外部の値をエンコード、またはデコードします。  
  
   
  
## Examples  
 次の例では、HTTP によって送信されるように文字列をエンコードします。 `TestString`という名前の文字列をエンコードします。これには、"This is a \<Test String >." というテキストが含まれ、"This + is + a +% 3cTest + String% 3e." として `EncodedString` という名前の文字列にコピーされます。  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlPathEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlPathEncode(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.UrlPathEncode : string -&gt; string" Usage="httpServerUtility.UrlPathEncode s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">URL エンコードするテキスト。</param>
        <summary>使用しないでください。ブラウザーの互換性のためだけのものです。 <see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />を使用します。</summary>
        <returns>URL エンコードされたテキスト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenDecode (input As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ UrlTokenDecode(System::String ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenDecode : string -&gt; byte[]" Usage="System.Web.HttpServerUtility.UrlTokenDecode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="input">デコードする URL 文字列トークン。</param>
        <summary>URL 文字列トークンをデコードし、base 64 を使用して等価なバイト配列を作成します。</summary>
        <returns>デコードされた URL 文字列トークンが格納されたバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> メソッドは、バイナリデータを base 64 の数字としてエンコードする URL 文字列トークンを、それと等価なバイト配列表現に変換します。 <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> メソッドを使用して、URL で送信され、<xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>を使用してエンコードされたトークンをデコードします。  
  
 `input` パラメーターの長さが1より小さい場合、<xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> メソッドは空のバイト配列を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> パラメーターの値が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenEncode (input As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UrlTokenEncode(cli::array &lt;System::Byte&gt; ^ input);" />
      <MemberSignature Language="F#" Value="static member UrlTokenEncode : byte[] -&gt; string" Usage="System.Web.HttpServerUtility.UrlTokenEncode input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="input">エンコードするバイト配列。</param>
        <summary>Base64 形式の文字を使用して、バイト配列を等価の文字列表現にエンコードします。この文字列表現は、URL での送信で使用できます。</summary>
        <returns>バイト配列の *length* が 2 以上の場合はエンコードされたトークンを格納している文字列。それ以外の場合は空の文字列 ("")。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> メソッドは、バイト配列を base 64 の数字でエンコードされた等価の文字列形式に変換します。 生成された文字列トークンは URL で送信できます。  
  
 `input` パラメーターの長さが1より小さい場合、<xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> は空の文字列を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> パラメーターの値が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Convert.ToBase64String(System.Byte[])" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>
