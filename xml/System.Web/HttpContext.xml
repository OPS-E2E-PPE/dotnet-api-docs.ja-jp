<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fa7e2de8a09b4fdd7f4baeff7e7542ed4e203a7d" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78757196" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContext = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>それぞれの HTTP 要求に関する HTTP 固有のすべての情報をカプセル化します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.IHttpModule> インターフェイスおよび <xref:System.Web.IHttpHandler> インターフェイスを継承するクラスには、現在の HTTP 要求に対する <xref:System.Web.HttpContext> オブジェクトへの参照が用意されています。 オブジェクトは、要求の組み込みの <xref:System.Web.HttpContext.Request%2A>、<xref:System.Web.HttpContext.Response%2A>、および <xref:System.Web.HttpContext.Server%2A> プロパティへのアクセスを提供します。

> [!IMPORTANT]
> このオブジェクトは、<xref:System.Web.HttpRequest> の完了時にガベージコレクションの準備ができています。 要求が完了した後の使用状況は、<xref:System.NullReferenceException>などの未定義の動作につながる可能性があります。
>
> このオブジェクトは、ASP.NET によって制御されるスレッドでのみ使用できます。 バックグラウンドスレッドで使用すると、未定義の動作が発生する可能性があります。

## Examples
 次の例では、<xref:System.Web.HttpContext> オブジェクトのプロパティにアクセスして表示する方法を示します。 現在の HTTP 要求のコンテキストにアクセスするには、<xref:System.Web.UI.Page> オブジェクトの <xref:System.Web.UI.Page.Context%2A> プロパティを使用します。

 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]

 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=196730">コンテキストの問題</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.HttpContext" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpWorkerRequest -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext wr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">現在の HTTP 要求に対する <see cref="T:System.Web.HttpWorkerRequest" /> オブジェクト。</param>
        <summary>指定したワーカー要求オブジェクトを使用する <see cref="T:System.Web.HttpContext" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpRequest * System.Web.HttpResponse -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext (request, response)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" /> オブジェクト。</param>
        <param name="response">現在の HTTP 要求に対する <see cref="T:System.Web.HttpResponse" /> オブジェクト。</param>
        <summary>指定した要求オブジェクトと応答オブジェクトを使用して、<see cref="T:System.Web.HttpContext" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求を受け入れます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContext.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="userFunc">ユーザー関数。</param>
        <summary>指定されたユーザー関数を使用して <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求を受け入れます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドを呼び出すことは、<xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> メソッドのオーバーロードを呼び出し、`options` パラメーターの `null` を渡すことと同じです。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="userFunc" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">この要求は <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContext.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="userFunc">ユーザー関数。</param>
        <param name="options">オプションのオブジェクト。</param>
        <summary>指定されたユーザー関数とオプション オブジェクトを使用して <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求を受け入れます。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="userFunc" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException">この要求は <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="member this.AddError : Exception -&gt; unit" Usage="httpContext.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">例外コレクションに追加する <see cref="T:System.Exception" />。</param>
        <summary>現在の HTTP 要求の例外コレクションに例外を追加します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnRequestCompleted : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContext.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">HTTP コンテキスト オブジェクト。</param>
        <summary>要求の HTTP 部分が終了するときに発生する仮想イベントを発生させます。</summary>
        <returns>サブスクリプション トークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このイベントは、<xref:System.Web.WebSockets.AspNetWebSocket> の接続が開始される前に発生します。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理中に蓄積されたエラーの配列を取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Exception" /> オブジェクトの配列。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET 要求の一部の処理中に、それが予期されていない場合、非同期操作が許可されるかどうかを示す値を取得または設定します。</summary>
        <value>予期しない時期に非同期 API が使用されると ASP.NET が例外をスローする場合は <see langword="false" />、それ以外の場合は <see langword="true" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このフラグが `true`に設定されていない場合、非同期 API を誤用しているアプリケーションを検出すると、ASP.NET は例外をスローします。 これは、非同期操作が想定されていない要求処理パイプラインの一部で非同期メソッドを呼び出そうとした場合、または非同期モジュールまたはハンドラーが完了を通知するときに未処理の非同期処理が残っている場合に発生する可能性があります。 この動作は、想定されるパターンに合わない非同期コードを記述しており、悪影響を及ぼす可能性のある非同期コードを作成している場合に、事前に知るための安全なネットワークとしてのものです。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplicationState" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplicationState" />。

現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" /> オブジェクトを取得するには、<see cref="P:System.Web.HttpContext.ApplicationInstance" /> を使用します。 (ASP.NET と従来の ASP との混同を避けるために、ASP.NET は <see langword="ApplicationInstance" /> の代わりに <see langword="Application" /> をプロパティ名として使用して、現在の <see cref="T:System.Web.HttpApplication" /> インスタンスを参照します。 従来の ASP では、<see langword="Application" /> はグローバル アプリケーション状態のディクショナリを参照します)。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" /> オブジェクトを取得または設定します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpApplication" />。

ASP.NET と従来の ASP との混同を避けるために、ASP.NET は <see langword="ApplicationInstance" /> の代わりに <see langword="Application" /> をプロパティ名として使用して、現在の <see cref="T:System.Web.HttpApplication" /> インスタンスを参照します。 従来の ASP では、<see langword="Application" /> はグローバル アプリケーション状態のディクショナリを参照します。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Web アプリケーションを IIS 7.0 の統合モードで実行しており、プロパティの値を、null 以外の値から　<see langword="null" /> に変更しようとしました。</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>非同期プリロード モードに関係するフラグを含むオブジェクトを取得または設定します。</summary>
        <value>非同期プリロード モードに関係するフラグを含むオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このプロパティに初めてアクセスするときは、非同期プリロードモードのフラグを含むオブジェクトが、構成ファイルの <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> 設定から読み込まれます。

 このプロパティはプログラムで設定できますが、プロパティ値の変更が有効なのは、ASP.NET の要求パイプラインの `ExecuteRequestHandler` の手順の前にプロパティが設定されている場合のみです。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアプリケーション ドメインに対する <see cref="T:System.Web.Caching.Cache" /> オブジェクトを取得します。</summary>
        <value>現在のアプリケーション ドメインに対する <see cref="T:System.Web.Caching.Cache" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 アプリケーションドメインごとに <xref:System.Web.Caching.Cache> クラスのインスタンスが1つあります。 その結果、<xref:System.Web.HttpContext.Cache%2A> プロパティによって返される <xref:System.Web.Caching.Cache> オブジェクトは、アプリケーションドメインのすべての要求に対する <xref:System.Web.Caching.Cache> オブジェクトになります。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpContext.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の HTTP 要求に対するすべてのエラーをクリアします。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.HttpContext with get, set" Usage="System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpContext" /> オブジェクトを取得または設定します。</summary>
        <value>現在の HTTP リクエストに対する <see cref="T:System.Web.HttpContext" /> インスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このプロパティは、<xref:System.Web.HttpContext> クラスの静的プロパティです。 プロパティは、現在の要求に適用される <xref:System.Web.HttpContext> インスタンスを格納します。 このインスタンスのプロパティは、<xref:System.Web.HttpContext> クラスの非静的プロパティです。

 また、<xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType> プロパティを使用して、現在の HTTP 要求の <xref:System.Web.HttpContext> オブジェクトにアクセスすることもできます。



## Examples
 次のコード例では、<xref:System.Web.HttpContext.Current%2A> プロパティを使用して、<xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> および <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> メソッドと <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> プロパティにアクセスします。 この例では、<xref:System.Web.HttpContext.AddError%2A> メソッドを使用して3つのカスタム例外を作成し、<xref:System.Web.HttpContext.AllErrors%2A> プロパティを使用してこれらの例外を配列に読み込みます。 次に、格納しているページに配列を書き込み、<xref:System.Web.HttpContext.ClearError%2A> メソッドを使用して、<xref:System.Web.UI.Page.Context%2A> プロパティからすべてのエラーをクリアします。

```csharp
protected void Page_Load(object sender, EventArgs e)
{
    HttpContext context = HttpContext.Current;
    Response.Write("<p>HttpContext.Current Example:</p>");

    // Add three custom exceptions.
    context.AddError(new Exception("New Exception #1"));
    context.AddError(new Exception("New Exception #2"));
    context.AddError(new Exception("New Exception #3"));

    // Capture all the new Exceptions in an array.
    Exception[] errs = context.AllErrors;

    foreach (Exception ex in errs)
    {
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");
    }

    // Clear the exceptions so ASP.NET won't handle them.
    context.ClearError();
}
```

```vb
Protected Sub Page_Load(sender As Object, e As EventArgs)
Dim context As HttpContext = HttpContext.Current
Response.Write("<p>HttpContext.Current Example:</p>")

' Add three custom exceptions.
context.AddError(New Exception("New Exception #1"))
context.AddError(New Exception("New Exception #2"))
context.AddError(New Exception("New Exception #3"))

' Capture all the new Exceptions in an array.
Dim errs As Exception() = context.AllErrors

For Each ex As Exception In errs
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")
Next

' Clear the exceptions so ASP.NET won't handle them.
context.ClearError()
End Sub

```

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行中のハンドラーを表す <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得します。</summary>
        <value>現在実行中のハンドラーを表す <see cref="T:System.Web.IHttpHandler" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.CurrentHandler%2A> プロパティによって参照されている現在実行中のハンドラーは、<xref:System.Web.HttpContext.Handler%2A> プロパティによって参照されているハンドラーとは異なる場合があります。 これは、<xref:System.Web.HttpServerUtility.Execute%2A> メソッドまたは <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドを使用して別のハンドラーが要求された場合に発生する可能性があります。 現在実行中のハンドラーが処理を終了すると、以前に決定されたハンドラーが復元されます。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb398986(v=vs.100)">HTTP ハンドラーと HTTP モジュールの概要</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>処理中の現在の <see cref="T:System.Web.HttpApplication" /> イベントを示す <see cref="T:System.Web.RequestNotification" /> 値を取得します。</summary>
        <value><see cref="T:System.Web.RequestNotification" /> 値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.CurrentNotification%2A> プロパティには、[!INCLUDE[iisver](~/includes/iisver-md.md)] の統合パイプラインモードと、少なくとも .NET Framework バージョン3.0 が必要です。 プロパティは、使用可能な場合、<xref:System.Web.RequestNotification> 値を返します。 <xref:System.Web.HttpContext.CurrentNotification%2A> プロパティの値は、<xref:System.Web.HttpApplication> インスタンス内のどのイベントが現在要求を処理しているかを示します。

 <xref:System.Web.HttpContext.CurrentNotification%2A> プロパティは、設定するためのものではありません。 代わりに、ASP.NET パイプラインでの要求の処理中に [!INCLUDE[iisver](~/includes/iisver-md.md)] によって設定されます。 <xref:System.Web.HttpContext.CurrentNotification%2A> プロパティを設定すると、コンパイルエラーが発生します。

 <xref:System.Web.HttpContext.CurrentNotification%2A> は .NET Framework バージョン3.5 で導入されました。  詳細については、「[.NET Framework のバージョンおよび依存関係](~/docs/framework/migration-guide/versions-and-dependencies.md)」を参照してください。



## Examples
 次の例では、<xref:System.Web.HttpContext.CurrentNotification%2A> プロパティを使用して、現在の要求を処理している <xref:System.Web.HttpApplication> オブジェクトのイベントを確認する方法を示します。 この例では、イベントハンドラーが <xref:System.Web.HttpApplication> オブジェクトのいくつかのイベントを処理し、<xref:System.Web.HttpContext.CurrentNotification%2A> プロパティによって、処理される各イベントに対して呼び出されるコードが決定されます。

 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">この操作を実行するには、[!INCLUDE[iisver](~/includes/iisver-md.md)] の統合パイプライン モードおよび .NET Framework Version 3.0 以降が必要です。</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="member this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContext.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="target">要求の <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続部分が完了したときに、<see cref="M:System.IDisposable.Dispose" /> メソッドを呼び出す必要のあるオブジェクト。</param>
        <summary>この要求の <see cref="M:System.IDisposable.Dispose" /> 接続部分が完了したときに、オブジェクトの <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> メソッドを呼び出すことができるようにします。</summary>
        <returns>サブスクリプション トークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ターゲットオブジェクトの <xref:System.IDisposable.Dispose%2A> メソッドは、要求の HTTP 部分と <xref:System.Web.WebSockets.AspNetWebSocket> 接続が終了した後に呼び出されます。 <xref:System.Web.HttpContext> オブジェクトを検査することはできません。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理中にエラーが蓄積された場合は、その最初のエラーを取得します。</summary>
        <value>現在の HTTP 要求または HTTP 応答の処理に対する最初の <see cref="T:System.Exception" />。ただし、HTTP 要求処理中にエラーが 1 つも蓄積されなかった場合は、<see langword="null" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetAppConfig : string -&gt; obj" Usage="System.Web.HttpContext.GetAppConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">情報が要求されたアプリケーションの構成タグ。</param>
        <summary>現在のアプリケーションに対して要求された構成情報を返します。</summary>
        <returns>構成情報を格納するオブジェクト。 返された構成セクションは、適切な構成型にキャストしてから使用してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.GetAppConfig%2A> メソッドの使用は非推奨とされました。 <xref:System.Web.Configuration.WebConfigurationManager> クラスの <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> メソッドを使用して、現在のアプリケーションの構成情報を取得します。

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetConfig : string -&gt; obj" Usage="httpContext.GetConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">情報が要求された構成タグ。</param>
        <summary>現在の HTTP 要求に対して要求された構成情報を返します。</summary>
        <returns>指定した <see cref="T:System.Configuration.ConfigurationSection" />。このセクションが存在しない場合は <see langword="null" />。このセクションに実行時にアクセスできない場合は内部オブジェクト。 返されたオブジェクトは、適切な構成型にキャストしてから使用してください。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.GetConfig%2A> メソッドの使用は非推奨とされました。 現在の HTTP 要求の構成情報を取得するには、<xref:System.Web.HttpContext.GetSection%2A> メソッドを使用します。

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アプリケーション レベル リソースを取得します。</summary>
        <related type="Article" href="~/docs/framework/resources/index.md">アプリケーション内のリソース</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET Web サイトレイアウト</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="classKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティを表す文字列。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <summary>アプリケーション レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティに基づいて取得します。</summary>
        <returns>要求されたアプリケーション レベル リソース オブジェクトを表す <see cref="T:System.Object" />。リソース オブジェクトが見つからない場合、またはリソース オブジェクトが見つかってもそれが要求されたプロパティを持っていない場合は null。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.GetGlobalResourceObject%2A> メソッドは、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A> プロパティで指定されているカルチャを使用して、グローバルリソースを返します。

> [!NOTE]
>  [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)]などの一部の編集環境では、グローバルリソースキー名にピリオド (.) を使用すると、エディターでデザイン時の <xref:System.Resources.MissingManifestResourceException> 例外がスローされる場合があります。 ただし、ファイルを編集または保存する機能には影響しません。このエラーは無視してかまいません。

 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">指定した <paramref name="classKey" /> パラメーターのリソース オブジェクトが見つかりませんでした。

- または -

メイン アセンブリにニュートラル カルチャのリソースが含まれていません。適切なサテライト アセンブリが見つからないためこれらのリソースが必要です。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="~/docs/framework/resources/index.md">アプリケーション内のリソース</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET Web サイトレイアウト</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="classKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティを表す文字列。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <param name="culture">要求されたリソースの <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを表す文字列。</param>
        <summary>アプリケーション レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティ、および <see cref="T:System.Globalization.CultureInfo" /> オブジェクトに基づいて取得します。</summary>
        <returns>要求されたアプリケーション レベル リソース オブジェクトを表す <see cref="T:System.Object" />。これは、特定のカルチャにローカライズされます。リソース オブジェクトが見つからない場合、またはリソース オブジェクトが見つかってもそれが要求されたプロパティを持っていない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Globalization.CultureInfo> オブジェクトは、リソースがローカライズされたカルチャを表します。 リソースがこのカルチャ用にローカライズされていない場合、参照はフォールバックプロセスに従って適切なリソースを検索します。 詳細については、「[リソースのパッケージ化と配置](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)」を参照してください。

> [!NOTE]
>  Visual Web Developer など、一部の編集環境では、グローバルリソースキー名にピリオド (.) を使用すると、デザイン時の <xref:System.Resources.MissingManifestResourceException> 例外がスローされる場合があります。 ただし、ファイルを編集または保存する機能には影響しません。このエラーは無視してかまいません。

 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">指定した <paramref name="classKey" /> パラメーターが見つからなかったリソース オブジェクト。

- または -

メイン アセンブリにニュートラル カルチャのリソースが含まれていません。適切なサテライト アセンブリが見つからないためこれらのリソースが必要です。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="~/docs/framework/resources/index.md">アプリケーション内のリソース</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ページ レベル リソースを取得します。</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="~/docs/framework/resources/index.md">アプリケーション内のリソース</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET Web サイトレイアウト</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">ローカル リソース オブジェクトのための <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティ。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <summary>ページ レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティに基づいて取得します。</summary>
        <returns>要求されたページ レベル リソース オブジェクトを表す <see cref="T:System.Object" />。一致するリソース オブジェクトが見つかっても <paramref name="resourceKey" /> パラメーターではない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.GetLocalResourceObject%2A> メソッドは、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A> プロパティで指定されているカルチャを使用して、ローカルリソースを返します。

 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">指定した <paramref name="virtualPath" /> パラメーターのリソース オブジェクトが見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentException">指定した <paramref name="virtualPath" /> パラメーターが、現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.InvalidOperationException">目的のページのリソース クラスが見つかりませんでした。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="~/docs/framework/resources/index.md">アプリケーション内のリソース</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET Web サイトレイアウト</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms227982(v=vs.100)">方法: プログラムによってリソース値を取得する</related>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="resourceKey" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="virtualPath">ローカル リソース オブジェクトのための <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティ。</param>
        <param name="resourceKey">要求されたリソース オブジェクトの <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティを表す文字列。</param>
        <param name="culture">要求されたリソース オブジェクトの <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを表す文字列。</param>
        <summary>ページ レベル リソース オブジェクトを、指定した <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> プロパティおよび <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> プロパティ、および <see cref="T:System.Globalization.CultureInfo" /> オブジェクトに基づいて取得します。</summary>
        <returns>要求されたローカル リソース オブジェクトを表す <see cref="T:System.Object" />。これは、特定のカルチャにローカライズされます。一致するリソース オブジェクトが見つかっても <see langword="null" /> パラメーターではない場合は <paramref name="resourceKey" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 リソースがこのカルチャ用にローカライズされていない場合、参照はフォールバックプロセスに従って適切なリソースを検索します。 詳細については、「[リソースのパッケージ化と配置](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)」を参照してください。

 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">指定した <paramref name="virtualPath" /> パラメーターのリソース オブジェクトが見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentException">指定した <paramref name="virtualPath" /> パラメーターが、現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.InvalidOperationException">目的のページのリソース クラスが見つかりませんでした。</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="~/docs/framework/resources/index.md">アプリケーション内のリソース</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ex526337(v=vs.100)">ASP.NET Web サイトレイアウト</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms227982(v=vs.100)">方法: プログラムによってリソース値を取得する</related>
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="member this.GetSection : string -&gt; obj" Usage="httpContext.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sectionName">構成セクション パス (XPath 形式) および構成要素名。</param>
        <summary>現在のアプリケーションの既定構成の、指定した構成セクションを取得します。</summary>
        <returns>指定した <see cref="T:System.Configuration.ConfigurationSection" />。このセクションが存在しない場合は <see langword="null" />。このセクションに実行時にアクセスできない場合は内部オブジェクト。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求の処理を実行する <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得または設定します。</summary>
        <value>HTTP 要求の処理を実行する <see cref="T:System.Web.IHttpHandler" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.Handler%2A> プロパティには、HTTP 要求を処理するハンドラーへの参照が含まれています。 ハンドラーは、 [httpHandlers](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bya7fh0a(v=vs.100))要素を使用して、またはユーザーコードで定義されているカスタムハンドラーを使用して指定できます。 ハンドラーの詳細については、「 [Http ハンドラーと Http モジュールの概要](https://docs.microsoft.com/previous-versions/aspnet/bb398986(v=vs.100))」を参照してください。

 <xref:System.Web.HttpContext.Handler%2A> プロパティへの参照は、現在のページがサーバー側のメソッド (<xref:System.Web.HttpServerUtility.Execute%2A> メソッドや <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドなど) によって変更された後も同じままです。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb398986(v=vs.100)">HTTP ハンドラーと HTTP モジュールの概要</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対してカスタム エラーが有効かどうかを示す値を取得します。</summary>
        <value>カスタム エラーが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求がデバッグ モードかどうかを示す値を取得します。</summary>
        <value>要求がデバッグ モードである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.HttpApplication" /> イベントが処理を終了した直後の ASP.NET パイプライン内の現在の処理ポイントである値を取得します。</summary>
        <value>カスタム エラーが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.IsPostNotification%2A> プロパティは、[!INCLUDE[iisver](~/includes/iisver-md.md)] では統合モード、少なくとも 3.0 .NET Framework でのみサポートされます。 プロパティは、使用可能な場合、<xref:System.Web.HttpApplication> オブジェクト内のイベントの処理が完了したかどうかを示すブール値を返します。

 <xref:System.Web.HttpContext.IsPostNotification%2A> プロパティは、設定するためのものではありません。 代わりに、通知ごとに ASP.NET ランタイムに [!INCLUDE[iisver](~/includes/iisver-md.md)] します。 <xref:System.Web.HttpContext.IsPostNotification%2A> プロパティを設定すると、コンパイルエラーが発生します。

 <xref:System.Web.HttpApplication> オブジェクトの複数のイベントが1つのイベントハンドラーによって処理されるシナリオでは、<xref:System.Web.HttpContext.IsPostNotification%2A> プロパティを <xref:System.Web.RequestNotification> 列挙と組み合わせて使用して、現在の要求のアプリケーションライフサイクル内の場所を正確に特定できます。

 <xref:System.Web.HttpContext.IsPostNotification%2A> は .NET Framework バージョン3.5 で導入されました。  詳細については、「[.NET Framework のバージョンおよび依存関係](~/docs/framework/migration-guide/versions-and-dependencies.md)」を参照してください。



## Examples
 次の例では、<xref:System.Web.HttpContext.IsPostNotification%2A> プロパティを使用して、<xref:System.Web.HttpApplication> オブジェクトのイベントが、関連付けられているすべてのイベントハンドラーの処理を完了したことを確認する方法を示します。 この例のカスタムイベントハンドラーは、<xref:System.Web.HttpApplication> オブジェクトのいくつかのイベントを処理し、<xref:System.Web.HttpContext.IsPostNotification%2A> プロパティは、特定のイベントが処理された後に呼び出されるコードを決定するために使用されます。

 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">この操作を実行するには、[!INCLUDE[iisver](~/includes/iisver-md.md)] の統合パイプライン モードおよび .NET Framework 3.0 以降が必要です。</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求が <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求かどうかを示す値を取得します。</summary>
        <value>要求が <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 要求である場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 要求に初期 <xref:System.Web.WebSockets.AspNetWebSocket> ハンドシェイクが含まれており、IIS の `WebSocket` モジュールがアクティブである場合、このメソッドは `true` を返します。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>接続が HTTP 接続から <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続にアップグレードされるかどうかを示す値を取得します。</summary>
        <value>接続がアップグレード中の場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP 要求時に <see cref="T:System.Web.IHttpModule" /> インターフェイスと <see cref="T:System.Web.IHttpHandler" /> インターフェイスとの間でデータを編成および共有するために使用できるキー/値のコレクションを取得します。</summary>
        <value>キーの指定によるコレクションの個々の値へのアクセスを実現する <see cref="T:System.Collections.IDictionary" /> キー/値のコレクション。</value>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/previous-versions/dotnet/articles/ms972109(v=msdn.10)">コンテキストの問題</related>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要求のページ インストルメンテーション サービス インスタンスへの参照を取得します。</summary>
        <value>この要求のページ インストルメンテーション サービス インスタンス。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親ハンドラーの <see cref="T:System.Web.IHttpHandler" /> オブジェクトを取得します。</summary>
        <value><see cref="T:System.Web.IHttpHandler" /> インスタンス。以前のハンドラーが見つからなかった場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.PreviousHandler%2A> プロパティは、現在の要求が実行される前の最後のハンドラーに対応します。

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/bb398986(v=vs.100)">HTTP ハンドラーと HTTP モジュールの概要</related>
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のユーザー プロファイルの <see cref="T:System.Web.Profile.ProfileBase" /> オブジェクトを取得します。</summary>
        <value>アプリケーションの構成ファイルにプロファイルのプロパティが定義されている場合は <see cref="T:System.Web.Profile.ProfileBase" />。それ以外の場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.Profile%2A> プロパティは、タイプセーフな API を使用して構造化データの永続的なストレージに使用します。 <xref:System.Web.HttpContext.Profile%2A> のプロパティにアクセスしても、値が存在しない場合は、空のインスタンスが返されます。`null` は返されません。

 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContext.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="handler">要求を処理するオブジェクト。</param>
        <summary>要求のハンドラーを指定できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `handler` を `null`に設定すると、既定のハンドラーが要求の処理に使用されます。 `handler` は、非同期ハンドラーまたは同期ハンドラーのいずれかに設定できます。 ハンドラーは <xref:System.Web.IHttpHandler> インターフェイスを実装する必要があります。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> メソッドが、<see cref="E:System.Web.HttpApplication.MapRequestHandler" /> イベントの発生後に呼び出されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpRequest" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.Request%2A> プロパティは、<xref:System.Web.HttpRequest> クラスのプロパティおよびメソッドにプログラムでアクセスできるようにします。 ASP.NET ページには <xref:System.Web> 名前空間 (<xref:System.Web.HttpContext> クラスを含む) への既定の参照が含まれているため、<xref:System.Web.HttpContext>への完全修飾クラス参照を使用しなくても、.aspx ページで <xref:System.Web.HttpRequest> のメンバーを参照できます。 たとえば、`Request.Browser` を使用して、クライアントブラウザーの機能を取得できます。 ただし、ASP.NET の分離コードモジュールから <xref:System.Web.HttpRequest> のメンバーを使用する場合は、モジュールの <xref:System.Web> 名前空間への参照と、現在アクティブな要求/応答コンテキストと、使用する <xref:System.Web> 内のクラスの両方への完全修飾参照を含める必要があります。 たとえば、分離コードページでは `HttpContext.Current.Request.Browser`完全修飾名を指定する必要があります。

> [!NOTE]
>  <xref:System.Web.HttpRequest> オブジェクトが使用できないときにこのプロパティを使用しようとすると、ASP.NET は例外をスローします。 たとえば、global.asax ファイルの Application_Start メソッド、または Application_Start メソッドから呼び出されたメソッドでは、これは true になります。 その時点で、HTTP 要求はまだ作成されていません。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Web アプリケーションは IIS 7 の統合モードで実行されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 応答の <see cref="T:System.Web.HttpResponse" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 応答の <see cref="T:System.Web.HttpResponse" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.Response%2A> プロパティは、<xref:System.Web.HttpResponse> クラスのプロパティおよびメソッドにプログラムでアクセスできるようにします。 ASP.NET ページには <xref:System.Web> 名前空間 (<xref:System.Web.HttpContext> クラスを含む) への既定の参照が含まれているため、<xref:System.Web.HttpContext>への完全修飾クラス参照を使用しなくても、.aspx ページで <xref:System.Web.HttpContext> のメンバーを参照できます。 たとえば、`Response.Write("some output")` を使用して、出力を HTTP 出力ストリームに書き込むことができます。 ただし、ASP.NET 分離コードモジュールから <xref:System.Web.HttpResponse> のメンバーを使用する場合は、モジュールの <xref:System.Web> 名前空間への参照と、現在アクティブな要求/応答コンテキスト、および使用する <xref:System.Web> 内のクラスへの完全修飾参照を含める必要があります。 たとえば、分離コードページでは `HttpContext.Current.Response.Write("some output")`完全修飾名を指定する必要があります。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Web アプリケーションは IIS 7 の統合モードで実行されています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リソースの要求を、要求された URL で示されているものとは別のパスにリダイレクトします。 <see cref="Overload:System.Web.HttpContext.RewritePath" /> は、Cookie を使用しないセッション状態において、URL からセッション ID を取り除くために使用されます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string -&gt; unit" Usage="httpContext.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">内部リライト パス。</param>
        <summary>指定されたパスを使用して URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.RewritePath%28System.String%29> メソッドは、リソースの要求を、要求された URL で示されているパスとは別のパスにリダイレクトします。 クライアントからのサーバーリソースへの要求が正しく解決されるように仮想パスをリセットする必要がある場合は、このメソッドのオーバーロードを使用して `rebaseClientPath` パラメーターを受け取り、パラメーターを `false`に設定します。

 URL の書き換えは、Web アプリケーション内のページを再構築するときに、古い Url をブックマークしているユーザーがページを移動した後も引き続き使用できるようにする場合に便利です。 URL リライトを使用すると、新しいページの場所に要求を透過的に転送できます。

 よりわかりやすく、検索エンジン用に最適化された Url をサイトで使用できるようにするには、ASP.NET ルーティングを使用する方法がより堅牢になります。 詳細については、「 [ASP.NET Routing](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100))」を参照してください。



## Examples
 次の例は、<xref:System.Web.HttpContext.RewritePath%2A> メソッドを使用して、web サイトが Web サイト内のファイル構造を反映していない Url に応答できるようにする方法を示しています。 最初のコードブロックは、RewritePath という名前の Web ページです。 クエリ文字列が必要です。 サイトの名前が WebSite1 の場合は、URL `http://localhost/WebSite1/RewritePath.aspx?page=1` ブラウザーに "Page 1" と表示されます。 この Web ページに続くコードブロックは、global.asax ファイルの `Application_BeginRequest` イベントハンドラーです。 このコードは、`http://localhost/WebSite1/page1` などの Url に対する要求をインターセプトし、処理する前に RewritePath .aspx に必要な形式に変換します。 そのため、URL `http://localhost/WebSite1/page1` は、ブラウザーに "Page 1" と表示されるクエリ文字列パラメーターを使用して RewritePath .aspx を呼び出します。 `http://localhost/WebSite1/page1` などの URL が受信されると、<xref:System.Web.HttpContext.RewritePath%2A> のオーバーロードが呼び出されます。これにより、クエリ文字列パラメーターに加えて、<xref:System.Web.HttpRequest.PathInfo%2A> プロパティの値を指定できるようになります。

 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]

 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="path" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET ルーティング</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd329551(v=vs.140)">チュートリアル: Web フォームアプリケーションでの ASP.NET ルーティングの使用</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * bool -&gt; unit" Usage="httpContext.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">内部リライト パス。</param>
        <param name="rebaseClientPath">仮想パスをリセットする場合は <see langword="true" />。仮想パスを変更しない場合は <see langword="false" />。</param>
        <summary>指定したパスおよびサーバー リソースの仮想パスが変更されるかどうかを指定するブール値を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> メソッドは、`rebaseClientPath` パラメーターを `true`に設定して <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType> メソッドによって呼び出されます。 リソースへのパスの作成に使用される仮想パスが変更されないようにするには、`rebaseClientPath` パラメーターを `false`に設定します。 `false` に `rebaseClientPath` を設定する一般的なシナリオは、URL を書き換える必要があり、テーマを使用して、要求されたリソースとは異なるフォルダーにあるリソースに URL をリダイレクトする場合です。

 URL の書き換えは、Web アプリケーション内のページを再構築するときに、古い Url をブックマークしているユーザーがページを移動した後も引き続き使用できるようにする場合に便利です。 URL リライトを使用すると、新しいページの場所に要求を透過的に転送できます。

 よりわかりやすく、検索エンジン用に最適化された Url をサイトで使用できるようにするには、ASP.NET ルーティングを使用する方法がより堅牢になります。 詳細については、「 [ASP.NET Routing](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100))」を参照してください。



## Examples
 コード例については、<xref:System.Web.HttpContext.RewritePath%28System.String%29> メソッドのオーバーロードに関する記述を参照してください。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="path" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET ルーティング</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd329551(v=vs.140)">チュートリアル: Web フォームアプリケーションでの ASP.NET ルーティングの使用</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">内部リライト パス。</param>
        <param name="pathInfo">リソースの追加パス情報。 詳細については、「<see cref="P:System.Web.HttpRequest.PathInfo" />」を参照してください。</param>
        <param name="queryString">要求クエリ文字列。</param>
        <summary>指定されたパス、パス情報、およびクエリ文字列情報を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.RewritePath%2A> メソッドは、URL を変更せずに、リソースの要求を別のリソースにリダイレクトします。

 `filePath` パラメーターに `pathInfo` パラメーターの内容が含まれていません。 URL `http://www.microsoft.com/virdir/page.html/tail`の場合、`filePath` パラメーターは `http://www.microsoft.com/virdir/page.html`、`pathInfo` パラメーターは tail です。

 URL の書き換えは、Web アプリケーション内のページを再構築するときに、古い Url をブックマークしているユーザーがページを移動した後も引き続き使用できるようにする場合に便利です。 URL リライトを使用すると、新しいページの場所に要求を透過的に転送できます。

 よりわかりやすく、検索エンジン用に最適化された Url をサイトで使用できるようにするには、ASP.NET ルーティングを使用する方法がより堅牢になります。 詳細については、「 [ASP.NET Routing](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100))」を参照してください。



## Examples
 このメソッドオーバーロードの例を含むコード例については、<xref:System.Web.HttpContext.RewritePath%28System.String%29> メソッドのオーバーロードに関する記述を参照してください。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="filePath" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET ルーティング</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd329551(v=vs.140)">チュートリアル: Web フォームアプリケーションでの ASP.NET ルーティングの使用</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="pathInfo" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="queryString" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="filePath">要求を処理するリソースへの仮想パス。</param>
        <param name="pathInfo">URL リダイレクトで使用する追加のパス情報。 詳細については、「<see cref="P:System.Web.HttpRequest.PathInfo" />」を参照してください。</param>
        <param name="queryString">URL リダイレクトで使用する要求クエリ文字列。</param>
        <param name="setClientFilePath">クライアント リソースで使用されるファイル パスを <paramref name="filePath" /> パラメーターの値に設定する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した仮想パス、パス情報、クエリ文字列、およびクライアント ファイル パスをリライト パスに設定するかどうかを指定するブール値を使用して、URL をリライトします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `filePath` パラメーターには、`pathInfo` パラメーターの内容は含まれません。 URL `http://www.microsoft.com/virdir/page.html/tail`の場合、`filePath` パラメーターは `http://www.microsoft.com/virdir/page.html`、`pathInfo` パラメーターは tail です。

 リソースへのパスの作成に使用される仮想パスが変更されないようにするには、`setClientFilePath` パラメーターを `false`に設定します。 `false` に `setClientFilePath` を設定する一般的なシナリオは、URL を書き換える必要があり、テーマを使用して、要求されたリソースとは異なるフォルダーにあるリソースに URL をリダイレクトする場合です。

 URL の書き換えは、Web アプリケーション内のページを再構築するときに、古い Url をブックマークしているユーザーがページを移動した後も引き続き使用できるようにする場合に便利です。 URL リライトを使用すると、新しいページの場所に要求を透過的に転送できます。

 よりわかりやすく、検索エンジン用に最適化された Url をサイトで使用できるようにするには、ASP.NET ルーティングを使用する方法がより堅牢になります。 詳細については、「 [ASP.NET Routing](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100))」を参照してください。



## Examples
 コード例については、<xref:System.Web.HttpContext.RewritePath%28System.String%29> メソッドのオーバーロードに関する記述を参照してください。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <exception cref="T:System.Web.HttpException"><paramref name="filePath" /> パラメーターが現在のアプリケーションのルート ディレクトリ内にありません。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100)">ASP.NET ルーティング</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd329551(v=vs.140)">チュートリアル: Web フォームアプリケーションでの ASP.NET ルーティングの使用</related>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web 要求の処理で使用されるメソッドを提供する <see cref="T:System.Web.HttpServerUtility" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.HttpServerUtility" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.Server%2A> プロパティは、<xref:System.Web.HttpServerUtility> クラスのプロパティおよびメソッドにプログラムでアクセスできるようにします。 ASP.NET ページには <xref:System.Web> 名前空間 (<xref:System.Web.HttpContext> クラスを含む) への既定の参照が含まれているため、<xref:System.Web.HttpContext>への完全修飾クラス参照を使用しなくても、.aspx ページで <xref:System.Web.HttpContext> のメンバーを参照できます。 たとえば、`Server.CreateObject("MyCOMComponent")` を使用して、サーバー上に COM オブジェクトのインスタンスを作成できます。 ただし、ASP.NET の分離コードモジュールから <xref:System.Web.HttpServerUtility> のメンバーを使用する場合は、モジュールの <xref:System.Web> 名前空間への参照と、現在アクティブな要求/応答コンテキストと、使用する <xref:System.Web> 内のクラスの両方への完全修飾参照を含める必要があります。 たとえば、分離コードページでは `HttpContext.Current.Server.CreateObject("MyCOMComponent")`完全修飾名を指定する必要があります。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求に対する <see cref="T:System.Web.SessionState.HttpSessionState" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 要求に対する <see cref="T:System.Web.SessionState.HttpSessionState" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.Session%2A> プロパティは、<xref:System.Web.SessionState.HttpSessionState> クラスのプロパティおよびメソッドにプログラムでアクセスできるようにします。

 セッション状態を使用するには、有効にする必要があります。 セッション状態を有効にする方法の詳細については、「 [ASP.NET セッション状態](https://docs.microsoft.com/previous-versions/aspnet/ms178581(v=vs.100))のセッション状態の**構成**の概要」を参照してください。

 セッション状態の値を保存する方法の詳細については、「[方法: セッション状態の値を保存](https://docs.microsoft.com/previous-versions/aspnet/6ad7zeeb(v=vs.100))する」を参照してください。 セッション状態から値を読み取る方法の詳細については、「[方法: セッション状態から値を読み取る](https://docs.microsoft.com/previous-versions/aspnet/03sekbw5(v=vs.100))」を参照してください。



## Examples
 次の例は、セッション状態の値を保存する方法と、セッション状態から値を読み取る方法を示しています。

 これらの例には次の項目が必要です。

-   セッション状態が有効になっている ASP.NET アプリケーション。

-   <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType> プロパティへのアクセス権を持つ Web フォームページクラス、または <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> プロパティへのアクセス権を持つ任意のクラス。

```csharp
string firstName = "Jeff";
string lastName = "Smith";
string city = "Seattle";

// Save to session state in a Web Forms page class.
Session["FirstName"] = firstName;
Session["LastName"] = lastName;
Session["City"] = city;

// Read from session state in a Web Forms page class.
firstName = (string)(Session["FirstName"]);
lastName = (string)(Session["LastName"]);
city = (string)(Session["City"]);

// Outside of Web Forms page class, use HttpContext.Current.
HttpContext context = HttpContext.Current;
context.Session["FirstName"] = firstName;
firstName = (string)(context.Session["FirstName"]);

```

```vb
Dim firstName As String = "Jeff"
Dim lastName As String = "Smith"
Dim city As String = "Seattle"

' Save to session state in a Web Forms page class.
Session("FirstName") = firstName
Session("LastName") = lastName
Session("City") = city

' Read from session state in a Web Forms page class.
firstName = DirectCast(Session("FirstName"), String)
lastName = DirectCast(Session("LastName"), String)
city = DirectCast(Session("City"), String)

' Outside of Web Forms page class, use HttpContext.Current.
Dim context As HttpContext = HttpContext.Current
context.Session("FirstName") = firstName
firstName = DirectCast(context.Session("FirstName"), String)

```

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSessionStateBehavior (sessionStateBehavior As SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="member this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContext.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">必要なセッション状態の動作の種類を指定する列挙値の 1 つ。</param>
        <summary>HTTP 要求をサポートするために必要なセッション状態の動作の種類を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET の既定の実装では、HTTP 要求ハンドラーは <xref:System.Web.SessionState.IRequiresSessionState> インターフェイスまたは <xref:System.Web.SessionState.IReadOnlySessionState> インターフェイスを実装することによって、セッション状態が必要かどうかを示します。 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> メソッドと <xref:System.Web.SessionState.SessionStateBehavior> 列挙体を使用すると、要求を処理するために必要なセッション状態のサポートの種類について、より詳細な情報を提供できます。 詳細については、<xref:System.Web.SessionState.SessionStateBehavior> 列挙型のページをご覧ください。

 <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> メソッドは、<xref:System.Web.HttpApplication.AcquireRequestState> パイプラインイベントの前に呼び出す必要があります。 このイベントの発生中または後に発生した呼び出しは、<xref:System.InvalidOperationException> 例外を発生させます。

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メソッドは、<see cref="E:System.Web.HttpApplication.AcquireRequestState" /> イベントの発生後に呼び出されました。</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Web.Security.UrlAuthorizationModule" /> オブジェクトが現在の要求に対する承認チェックをスキップするかどうかを指定する値を取得または設定します。</summary>
        <value><see cref="T:System.Web.Security.UrlAuthorizationModule" /> が承認チェックをスキップする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.SkipAuthorization%2A> プロパティは、匿名接続を許可するページにリダイレクトする必要がある認証モジュールによる高度な使用を目的としています。 フォーム認証モジュールとパスポート認証モジュールは両方とも、構成されたログオンページにリダイレクトするときに <xref:System.Web.HttpContext.SkipAuthorization%2A> 設定されます。 <xref:System.Web.HttpContext.SkipAuthorization%2A> を設定するには、`ControlPrincipal` フラグを設定する必要があります。 `ControlPrincipal` フラグの詳細については、「<xref:System.Security.Permissions.SecurityPermissionFlag>」を参照してください。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberSignature Language="F#" Value="abstract member System.IServiceProvider.GetService : Type -&gt; obj&#xA;override this.System.IServiceProvider.GetService : Type -&gt; obj" Usage="httpContext.System.IServiceProvider.GetService service" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IServiceProvider.GetService(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service"><see cref="T:System.Web.HttpContext" /> サービスの型。サービス プロバイダーをこの型に設定します。</param>
        <summary>現在のサービス型のオブジェクトを返します。</summary>
        <returns><see cref="T:System.Web.HttpContext" />。サービスが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、基になる <xref:System.Web.HttpWorkerRequest> オブジェクトにアクセスするために役立ちます。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求がタイムアウトしたときにこの要求に対処していたスレッド上で ASP.NET ランタイムが <see cref="M:System.Threading.Thread.Abort" /> を呼び出す必要があるかどうかを指定する値を取得または設定します。</summary>
        <value>スレッドのタイムアウト時に <see cref="M:System.Threading.Thread.Abort" /> が呼び出される場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> プロパティを使用して協調的な取り消しを実装するハンドラーとモジュールでは、要求がタイムアウトしたときに既定で ASP.NET が実行する <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> の動作を無効にすることができます。このプロパティを `false` に設定すると、ASP.NET によって中断されることなくキャンセルとクリーンアップルーチンが実行されるようにすることができます。

 このプロパティを `false`に設定すると、タイムアウトが発生したときに、ASP.NET は "要求がタイムアウトしました" というエラーページを自動的に表示しません。 アプリケーションは、応答の内容を適切に設定する必要があります。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求の初期タイムスタンプを取得します。</summary>
        <value>現在の HTTP 要求のタイムスタンプ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.Timestamp%2A> プロパティから返されるタイムスタンプはサーバーのローカル時刻で、<xref:System.Web.HttpContext> オブジェクトのインスタンス化中に設定されます。 現地時刻は、UTC 時刻に UTC オフセットを加えた値と等しくなります。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 応答の <see cref="T:System.Web.TraceContext" /> オブジェクトを取得します。</summary>
        <value>現在の HTTP 応答の <see cref="T:System.Web.TraceContext" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求のセキュリティ情報を取得または設定します。</summary>
        <value>現在の HTTP 要求のセキュリティ情報。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpContext.User%2A> プロパティは、<xref:System.Security.Principal.IPrincipal> インターフェイスのプロパティおよびメソッドにプログラムでアクセスできるようにします。

 ASP.NET ページには <xref:System.Web> 名前空間 (<xref:System.Web.HttpContext> クラスを含む) への既定の参照が含まれているため、<xref:System.Web.HttpContext>への完全修飾クラス参照を使用しなくても、.aspx ページで <xref:System.Web.HttpContext> のメンバーを参照できます。 たとえば、`User.Identity.Name` を使用して、現在のプロセスが実行されているユーザーの名前を取得できます。 ただし、ASP.NET の分離コードモジュールから <xref:System.Security.Principal.IPrincipal> のメンバーを使用する場合は、モジュールの <xref:System.Web> 名前空間への参照と、現在アクティブな要求/応答コンテキストと、使用する <xref:System.Web> 内のクラスの両方への完全修飾参照を含める必要があります。 たとえば、分離コードページでは `HttpContext.Current.User.Identity.Name`完全修飾名を指定する必要があります。



## Examples
 次の例では、<xref:System.Web.HttpContext.User%2A> プロパティを使用して、現在のユーザーのプロパティにアクセスする方法を示します。 これらのプロパティは、Web ページのタイトルを設定するために使用されます。

 アプリケーションで Windows 認証を使用する場合、ユーザー名にはドメインが含まれます。 たとえば、ページタイトルは "DOMAIN\username のホームページ" になります。

 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]

 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions/using-oauth-providers-with-mvc">MVC 4 で OAuth プロバイダーを使用する</related>
        <related type="ExternalDocumentation" href="/aspnet/web-forms/overview/getting-started/getting-started-with-aspnet-45-web-forms/checkout-and-payment-with-paypal">ASP.NET 4.5 Web フォームでのはじめに、および PayPal を使用した支払いと支払い</related>
        <related type="ExternalDocumentation" href="/aspnet/mvc/overview/older-versions-1/nerddinner/secure-applications-using-authentication-and-authorization">認証と承認を使用してアプリケーションをセキュリティで保護する</related>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバーからクライアントに <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> 接続のために送信されたネゴシエートされたプロトコルを取得します。</summary>
        <value>ネゴシエートされたプロトコル。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントから要求されるプロトコルの順序付きリストを取得します。</summary>
        <value>要求されたプロトコル。<see cref="T:System.Web.WebSockets.AspNetWebSocket" /> の要求でないか、リストがない場合は、<see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
