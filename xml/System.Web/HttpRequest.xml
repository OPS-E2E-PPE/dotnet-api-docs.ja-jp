<Type Name="HttpRequest" FullName="System.Web.HttpRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="44aad8811f39318c9ca616f9db2f8a9f3a467ad3" /><Meta Name="ms.sourcegitcommit" Value="f9576bf8c61e3d46834aeeff50f858359f2a99ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="02/09/2020" /><Meta Name="ms.locfileid" Value="77105563" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpRequest sealed" />
  <TypeSignature Language="F#" Value="type HttpRequest = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Web 要求中にクライアントから送信された HTTP 値を ASP.NET で読み取ることができるようにします。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest> クラスのメソッドとプロパティは、<xref:System.Web.HttpApplication>、<xref:System.Web.HttpContext>、<xref:System.Web.UI.Page>、および <xref:System.Web.UI.UserControl> クラスの `Request` プロパティを通じて公開されます。

 <xref:System.Web.HttpRequest.QueryString%2A>、<xref:System.Web.HttpRequest.Form%2A>、<xref:System.Web.HttpRequest.Cookies%2A>、または <xref:System.Web.HttpRequest.ServerVariables%2A> コレクションからのデータにアクセスするには、`Request["key"]`プロパティの例に示すように、<xref:System.Web.HttpRequest.QueryString%2A> を記述します。

> [!NOTE]
>  <xref:System.Web.HttpRequest> クラスメンバーの Unicode サポートには、IIS バージョン6.0 以降が必要です。



## Examples
 次の例では、<xref:System.Web.UI.Page> クラスの <xref:System.Web.UI.Page.Request%2A> プロパティを使用して、現在の要求の <xref:System.Web.HttpRequest> インスタンスにアクセスします。

 <xref:System.Web.HttpRequest.QueryString%2A>、<xref:System.Web.HttpRequest.Form%2A>、<xref:System.Web.HttpRequest.Cookies%2A>、または <xref:System.Web.HttpRequest.ServerVariables%2A> コレクションからのデータにアクセスするために、簡略化された構文を使用できます。 `Request["key"]`を作成できます。

 最初の例は、ページの読み込み時にクエリ文字列値を取得する方法を示しています。

```csharp
public partial class AddToCart : Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        string rawId = Request["ProductID"];
        int productId;
        if (!String.IsNullOrEmpty(rawId) && int.TryParse(rawId, out productId))
        {
            using (ShoppingCartActions usersShoppingCart = new ShoppingCartActions())
            {
                usersShoppingCart.AddToCart(productId);
            }
        }
        else
        {
            throw new Exception("Tried to call AddToCart.aspx without setting a ProductId.");
        }
        Response.Redirect("ShoppingCart.aspx");
    }
}
```

```vb
Public Class AddToCart
    Inherits Page

    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load
        Dim rawId = Request("ProductID")
        Dim productId As Integer
        If Not String.IsNullOrEmpty(rawId) And Integer.TryParse(rawId, productId) Then
            Using usersShoppingCart As New ShoppingCartActions()
                usersShoppingCart.AddToCart(productId)
            End Using

        Else
            Throw New Exception("Tried to call AddToCart.aspx without setting a ProductId.")
        End If
        Response.Redirect("ShoppingCart.aspx")
    End Sub
End Class
```

 次の例では、要求が認証されているかどうかを確認し、生の URL を取得する方法を示します。

```csharp
public partial class RestrictedPage : Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        if (!Request.IsAuthenticated)
        {
            var rawUrl = Request.RawUrl;
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl));
        }
    }
}
```

```vb
Public Class RestrictedPage
    Inherits Page

    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load
        If Not Request.IsAuthenticated Then
            Dim rawUrl = Request.RawUrl
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl))
        End If
    End Sub
End Class
```

 このトピックでは、ソースコードが含まれている Visual Studio Web サイトプロジェクトを[ダウンロード](https://go.microsoft.com/fwlink/?LinkID=191455)できます。

 この例では、<xref:System.IO.StreamWriter> クラスを使用して、いくつかの <xref:System.Web.HttpRequest> クラスのプロパティの値をファイルに書き込みます。 文字列型のプロパティの場合、値はファイルに書き込まれるときに HTML エンコードされます。 コレクションを表すプロパティはループ処理され、そこに含まれる各キーと値のペアがファイルに書き込まれます。

> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](https://docs.microsoft.com/previous-versions/aspnet/w1sw53ds(v=vs.100))」を参照してください。

 [!code-aspx-csharp[System.Web.HttpRequest_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#1)]

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpRequest (string filename, string url, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filename, string url, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filename As String, url As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpRequest(System::String ^ filename, System::String ^ url, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpRequest : string * string * string -&gt; System.Web.HttpRequest" Usage="new System.Web.HttpRequest (filename, url, queryString)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">要求に関連付けられたファイルの名前。</param>
        <param name="url">現在の要求の URL に関する情報。</param>
        <param name="queryString">要求と共に送信されるクエリ文字列全体 (<c>'?'</c> の後の部分すべて)。</param>
        <summary><see cref="T:System.Web.HttpRequest" /> オブジェクトを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest> クラスの独自のインスタンスを作成する必要はありません。 <xref:System.Web.HttpRequest> クラスのメソッドとプロパティは、<xref:System.Web.HttpApplication>、<xref:System.Web.HttpContext>、<xref:System.Web.UI.Page>、および <xref:System.Web.UI.UserControl> クラスの `Request` プロパティを通じて公開されます。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>基になっている TCP 接続を強制的に終了します。未処理の I/O は失敗します。 悪意のある HTTP クライアントによる攻撃に対してこのメソッドを使用できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドはスレッドセーフです。 どのスレッドも、いつでも呼び出すことができます。

 このメソッドは統合モードでのみ使用できます。 クラシックモードで起動すると、例外がスローされます。 パイプラインモードを決定するには、<xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>を使用します。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AcceptTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptTypes As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AcceptTypes { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AcceptTypes : string[]" Usage="System.Web.HttpRequest.AcceptTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントにサポートされている MIME で使用できる型の文字列配列を取得します。</summary>
        <value>クライアントにサポートされている MIME で使用できる型の文字列配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、<xref:System.Web.HttpRequest.AcceptTypes%2A> プロパティによって返された複数の値をオブジェクト変数にキャプチャし、それぞれの値の数と名前を HTTP 出力の個別の行に書き込みます。

 [!code-csharp[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnonymousID">
      <MemberSignature Language="C#" Value="public string AnonymousID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AnonymousID" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AnonymousID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AnonymousID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AnonymousID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AnonymousID : string" Usage="System.Web.HttpRequest.AnonymousID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>存在する場合は、ユーザーの匿名 ID を取得します。</summary>
        <value>現在の匿名ユーザーの ID を表す文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.AnonymousID%2A> プロパティは、有効期間が長い一意の識別子を認証されていないユーザーに割り当てます。これを使用すると、`Session` オブジェクトにデータを格納しなくても、ユーザーの追跡やプロファイルプロパティの割り当てを行うことができます。 既定では、<xref:System.Web.HttpRequest.AnonymousID%2A> プロパティは cookie を使用して追跡されますが、匿名 id 構成セクションの <xref:System.Web.Configuration.SessionStateSection.Cookieless%2A> 属性が <xref:System.Web.HttpCookieMode.UseUri>、<xref:System.Web.HttpCookieMode.UseDeviceProfile>、または <xref:System.Web.HttpCookieMode.AutoDetect> 値に設定されている場合は、URI を使用するように設定できます。 匿名ユーザーが認証された場合などに、cookie を使用しない場合は、明示的にクリアする必要があります。

 匿名 id は、認証されていないエンティティを識別する必要がある場合や、承認が必要な場合に使用されます。 詳細については、「 [AnonymousIdentification 要素 (ASP.NET Settings スキーマ)](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100)) 」を参照してください。



## Examples
 次の例では、global.asax ファイルで <xref:System.Web.Security.AnonymousIdentificationModule.Creating> イベントを処理することによって、<xref:System.Web.HttpRequest.AnonymousID%2A> プロパティを使用する方法を示します。 この例には、次の2つの部分があります。

-   <xref:System.Web.Security.AnonymousIdentificationModule.Creating> イベントを処理する global.asax ファイル内のメソッド。

-   Web フォームページ。

 コード例の最初の部分では、global.asax ファイルの <xref:System.Web.Security.AnonymousIdentificationModule.Creating> イベントを処理することによって <xref:System.Web.HttpRequest.AnonymousID%2A> プロパティを設定する方法を示します。 `AnonymousIdentification_Creating` という名前のメソッドは、匿名 ID が作成されるときに <xref:System.Web.HttpRequest.AnonymousID%2A> プロパティを設定します。

 [!code-csharp[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/global_asax.cs#2)]
 [!code-vb[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/global_asax.vb#2)]

 コード例の2番目の部分では、前の例で `AnonymousIdentification_Creating` イベントハンドラーによって作成された新しい <xref:System.Web.HttpRequest.AnonymousID%2A> を表示する方法を示します。

 [!code-aspx-csharp[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/anonid_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/anonid_vb.aspx#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.IsAuthenticated" />
        <altmember cref="E:System.Web.Security.AnonymousIdentificationModule.Creating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100)">anonymousIdentification 要素 (ASP.NET 設定スキーマ)</related>
      </Docs>
    </Member>
    <Member MemberName="ApplicationPath">
      <MemberSignature Language="C#" Value="public string ApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationPath : string" Usage="System.Web.HttpRequest.ApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバーの ASP.NET アプリケーションの仮想アプリケーション ルート パスを取得します。</summary>
        <value>現在のアプリケーションの仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このプロパティを使用して、ルートディレクトリにないページまたは Web ユーザーコントロールからのアプリケーションルートを基準とした URL を作成します。 これにより、ディレクトリ構造のさまざまなレベルに存在するページと共有コントロールは、同じコードを使用して、アプリケーション内の固定された場所にあるリソースにリンクできます。



## Examples
 次の例では、<xref:System.IO.StreamWriter.Write%2A> メソッドを使用して HTML エンコードを行い、<xref:System.Web.HttpRequest.ApplicationPath%2A> プロパティの値をテキストファイルに書き込みます。 このコード例は、<xref:System.Web.HttpRequest> クラス用に用意されている大規模な例の一部です。 `sw`という名前の <xref:System.IO.StreamWriter> オブジェクトが存在することを前提としています。

 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]

 次の例では、<xref:System.Web.HttpRequest.ApplicationPath%2A> プロパティを使用して、アプリケーション内の固定位置にあるリソースへのパスをプログラムで作成します。 リソースを参照するページは、リソースと同じディレクトリに配置されている必要はありません。

 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/ApplicationPath.aspx#2)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/ApplicationPath.aspx#2)]

 この例を WebSite1 という名前の Web アプリケーションで実行すると、`/WebSite1` が <xref:System.Web.HttpRequest.ApplicationPath%2A> プロパティの値として表示され、`/WebSite1/images/Image1.gif` がイメージの完全なパスとして表示されます。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeCurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string AppRelativeCurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AppRelativeCurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeCurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AppRelativeCurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ルートの仮想パスを取得し、チルダ (\~) 表記 ("\~/page.aspx" など) を使用した、アプリケーション ルートの相対パスにします。</summary>
        <value>現在の要求に対応するアプリケーション ルートの仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このプロパティを使用して、アプリケーションが場所を変更した場合でも同じままになる URL 情報を指定します。 これにより、同じ URL マッピングコードをテスト環境と最終的な配置環境で使用したり、異なるドメインの Web アプリケーションのコピーで使用したりすることができます。



## Examples
 次の例では、<xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> プロパティを使用して、<xref:System.Web.UI.WebControls.Image> コントロールの URL を、ページと同じディレクトリ内のイメージに設定します。 このページをディレクトリ構造のさまざまなレベルで実行し、結果として得られる <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> のプロパティ値を確認します。

 [!code-aspx-csharp[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/CS/AppRelativeCurrentExecutionPathCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/VB/AppRelativeCurrentExecutionPathVB.aspx#1)]

 次の例では、<xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> プロパティを使用して、ページの現在のパスに基づいて、リソースへのパスをプログラムで設定します。

 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/apprelativecurrentexecutionfilepath.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/apprelativecurrentexecutionfilepath.aspx#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BinaryRead">
      <MemberSignature Language="C#" Value="public byte[] BinaryRead (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] BinaryRead(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.BinaryRead(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinaryRead (count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ BinaryRead(int count);" />
      <MemberSignature Language="F#" Value="member this.BinaryRead : int -&gt; byte[]" Usage="httpRequest.BinaryRead count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">読み取るバイト数。</param>
        <summary>現在の入力ストリームから、指定したバイト数のバイナリ読み取りを実行します。</summary>
        <returns>バイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.BinaryRead%2A> メソッドは、ASP との互換性のために用意されています。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> は 0 です。

または

 <paramref name="count" /> は使用可能なバイト数を超えています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="public System.Web.HttpBrowserCapabilities Browser { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Browser" />
      <MemberSignature Language="VB.NET" Value="Public Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); void set(System::Web::HttpBrowserCapabilities ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities with get, set" Usage="System.Web.HttpRequest.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求を実行中のクライアントのブラウザーの性能に関する情報を取得または設定します。</summary>
        <value>クライアントのブラウザーの性能を一覧表示する <see cref="T:System.Web.HttpBrowserCapabilities" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、HTML ページでブラウザーの機能の一覧をクライアントに送り返します。

 [!code-csharp[Classic HttpRequest.Browser Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Browser Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/x3k2ssx2(v=vs.100)">ASP.NET サーバーコントロールとブラウザー機能</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificate">
      <MemberSignature Language="C#" Value="public System.Web.HttpClientCertificate ClientCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpClientCertificate ClientCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ClientCertificate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificate As HttpClientCertificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpClientCertificate ^ ClientCertificate { System::Web::HttpClientCertificate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificate : System.Web.HttpClientCertificate" Usage="System.Web.HttpRequest.ClientCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpClientCertificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在、要求しているクライアントのセキュリティ証明書を取得します。</summary>
        <value>クライアントのセキュリティ証明書の設定に関する情報を格納している <see cref="T:System.Web.HttpClientCertificate" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、クライアントの証明書設定を HTML ページでクライアントに送り返します。

 [!code-csharp[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpRequest.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>エンティティ本体の文字セットを取得または設定します。</summary>
        <value>クライアントの文字セットを表す <see cref="T:System.Text.Encoding" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 既定のコンテンツエンコードは、構成ファイルの[グローバリゼーション要素 (ASP.NET 設定スキーマ)](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/hy4kkhe0(v=vs.100))で指定できます。 コンテンツのエンコードもクライアントによって指定されている場合は、既定の構成設定が上書きされます。



## Examples
 次のコード例では、現在の HTTP エンコーディングの説明を表す値を文字列変数に代入します。

 [!code-csharp[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public int ContentLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContentLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int" Usage="System.Web.HttpRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントから送信されたコンテンツの長さをバイト単位で指定します。</summary>
        <value>クライアントから送信されたコンテンツの長さ (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、受信要求のコンテンツ長を表す値を整数変数に代入します。

 [!code-csharp[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>受信要求で使用する MIME の Content-Type を取得または設定します。</summary>
        <value>受信要求の MIME コンテンツ タイプを表す文字列 ("text/html" など)。 このほかに、一般的な MIME タイプとしては "audio.wav"、"image/gif"、"application/pdf" などがあります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、受信要求のコンテンツタイプを表す値を文字列変数に代入します。

 [!code-csharp[Classic HttpRequest.ContentType Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/VB/source.vb#1)]

 次の例は、このコードによって生成される可能性がある出力を示しています。

 `GET`

 `127.0.0.1`

 `127.0.0.1`

 `GET`

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpRequest.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントから送信されたクッキーのコレクションを取得します。</summary>
        <value>クライアントのクッキー変数を表す <see cref="T:System.Web.HttpCookieCollection" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ASP.NET には、2つの組み込みクッキーコレクションが含まれています。 <xref:System.Web.HttpRequest> の <xref:System.Web.HttpRequest.Cookies%2A> コレクションを通じてアクセスされるコレクションには、クライアントが `Cookie` ヘッダーでサーバーに送信する cookie が含まれています。 <xref:System.Web.HttpResponse> の <xref:System.Web.HttpResponse.Cookies%2A> コレクションを通じてアクセスされるコレクションには、サーバー上で作成され `Set-Cookie` ヘッダーでクライアントに送信される新しいクッキーが含まれています。

> [!NOTE]
>  <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> コレクションを使用して cookie を追加した後、応答がクライアントに送信されていない場合でも、<xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> コレクションでクッキーをすぐに使用できるようになります。



## Examples
 次のコード例では、クライアントから送信されたすべての cookie をループ処理し、各 cookie の名前、有効期限、セキュリティパラメーター、および値を HTTP 出力に送信します。

 [!code-csharp[Classic HttpRequest.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の仮想パスを取得します。</summary>
        <value>現在の要求の仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> は、現在実行中のページハンドラーへのファイルパスを返します。 <xref:System.Web.HttpServerUtility.Execute%2A> メソッドと <xref:System.Web.HttpServerUtility.Transfer%2A> メソッドを使用したリダイレクトのシナリオでは、<xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> プロパティによってリダイレクトされたページへのパスが返されます (子ページ)。 ただし、クライアントが別のページにリダイレクトされた場合、<xref:System.Web.HttpRequest.FilePath%2A> プロパティは元のページへのパスを返します。



## Examples
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A> メソッドを使用して、<xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> プロパティの値を HTML エンコードし、<xref:System.IO.TextWriter.WriteLine%2A> メソッドを使用して、エンコードされた値をファイルに書き込みます。 このコード例は、<xref:System.Web.HttpRequest> クラス用に用意されている大規模な例の一部です。

 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="M:System.Web.HttpServerUtility.Execute(System.String)" />
        <altmember cref="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePathExtension">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePathExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePathExtension" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePathExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePathExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePathExtension : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" /> プロパティで指定されているファイル名の拡張子を取得します。</summary>
        <value><see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" /> プロパティで指定されているファイル名の拡張子。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilePath">
      <MemberSignature Language="C#" Value="public string FilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.FilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FilePath : string" Usage="System.Web.HttpRequest.FilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の仮想パスを取得します。</summary>
        <value>現在の要求の仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.FilePath%2A> プロパティには、<xref:System.Web.HttpRequest.PathInfo%2A> トレーラーは含まれません。 たとえば、URL `http://www.contoso.com/virdir/page.html/tail`の場合、<xref:System.Web.HttpRequest.FilePath%2A> の値は/virdir/page.html です。



## Examples
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A> メソッドを使用して、<xref:System.Web.HttpRequest.FilePath%2A> プロパティの値を HTML エンコードし、<xref:System.IO.TextWriter.WriteLine%2A> メソッドを使用して、エンコードされた値をファイルに書き込みます。 このコード例は、<xref:System.Web.HttpRequest> クラス用に用意されている大規模な例の一部です。

 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
      </Docs>
    </Member>
    <Member MemberName="Files">
      <MemberSignature Language="C#" Value="public System.Web.HttpFileCollection Files { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpFileCollection Files" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Files" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Files As HttpFileCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpFileCollection ^ Files { System::Web::HttpFileCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Files : System.Web.HttpFileCollection" Usage="System.Web.HttpRequest.Files" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpFileCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マルチパート MIME 形式でクライアントによってアップロードされたファイルのコレクションを取得します。</summary>
        <value>クライアントによってアップロードされたファイルのコレクションを表す <see cref="T:System.Web.HttpFileCollection" /> オブジェクト。 <see cref="T:System.Web.HttpFileCollection" /> オブジェクトの項目は <see cref="T:System.Web.HttpPostedFile" /> 型です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 ファイルコレクションは、HTTP 要求 `Content-Type` 値が "マルチパート/フォーム-データ" の場合にのみ設定されます。



## Examples
 次のコード例では、<xref:System.Web.HttpRequest.Files%2A> コレクション内のすべてのファイルの名前を表示します。

 [!code-csharp[Classic HttpRequest.Files Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Files Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Files Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Files Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpRequest.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の入力ストリームを読み取るときに使用するフィルターを取得または設定します。</summary>
        <value>フィルターとして使用される <see cref="T:System.IO.Stream" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、`QQQ1` と、<xref:System.Web.HttpRequest.InputStream%2A>をフィルター処理する `QQQ2` の2つの新しいクラスを作成します。 アプリケーション内のすべての ASP.NET Web ページに対するすべての入力がフィルター処理されるように、クラスを ASP.NET アプリケーションのディレクトリにある global.asax ファイルに配置します。

 [!code-aspx-csharp[System.Web.HttpRequest.Filter#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/CS/systemwebhttprequestfilter.cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Filter#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/VB/systemwebhttprequestfilter.vb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">指定された <see cref="T:System.IO.Stream" /> が無効です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Form { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Form : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォーム変数のコレクションを取得します。</summary>
        <value>フォーム変数のコレクションを表す <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.Form%2A> プロパティは、HTTP 要求 `Content-Type` の値が "application/url エンコード" または "マルチパート/フォーム-データ" の場合に設定されます。



## Examples
 次の例は、ブラウザーからポストされたフォームコレクション内の値を読み取る方法を示しています。 コレクション内の各名前と値のペアは、フォームのコントロールとその値を表します。

 [!code-csharp[Classic HttpRequest.Form Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Form Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Form Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Form Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferedInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferedInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferedInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferedInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferedInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferedInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferedInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferedInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクトを取得します。</summary>
        <returns>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> と同じですが、<xref:System.Web.HttpRequest.Form%2A>、<xref:System.Web.HttpRequest.Files%2A>、および <xref:System.Web.HttpRequest.InputStream%2A> の各プロパティを設定するために ASP.NET によって使用される内部ストレージに読み取られるバイトもコピーされる点が異なります。 この情報が保持されるため、ASP.NET Web フォーム ページ (.aspx ファイル) などのダウンストリーム コードは正常に実行されます。 これは、<xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> メソッドには該当しません。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">要求のエンティティ本体は、既に読み込まれ、解析されています。 エンティティ本体を読み込んで解析するプロパティの例は次のとおりです。

-   <see cref="P:System.Web.HttpRequest.Form" /> プロパティ。

-   <see cref="P:System.Web.HttpRequest.Files" /> プロパティ。

-   <see cref="P:System.Web.HttpRequest.InputStream" /> プロパティ。

-   <see cref="M:System.Web.HttpRequest.GetBufferlessInputStream" /> メソッド。

この例外を回避するには、<see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> メソッドを最初に呼び出します。 この例外は、エンティティ本体の読み取り中にクライアントが切断された場合にもスローされます。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBufferlessInputStream">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクトを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクトを取得します。</summary>
        <returns>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、<xref:System.Web.HttpRequest.InputStream%2A> プロパティを使用する代わりに使用できます。 <xref:System.Web.HttpRequest.InputStream%2A> プロパティは、<xref:System.IO.Stream> オブジェクトを返す前に要求全体が受信されるまで待機します。 これに対し、<xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> メソッドは、<xref:System.IO.Stream> オブジェクトを直ちに返します。 メソッドを使用して、本文の完全な内容を受信する前に、エンティティ本体の処理を開始できます。

 エンティティ本体 (または、要求および受信されたもののほとんど) は、<xref:System.IO.Stream.Read%2A> メソッドなどのメソッドを呼び出すことによって、このメソッドによって返されたオブジェクトを使用してストリームを読み取る場合にのみ返されます。 <xref:System.IO.Stream.Read%2A> メソッドのパラメーターを使用して、読み取るエンティティ本体の量を指定します。

 このメソッドから ASP.NET によって返される <xref:System.IO.Stream> オブジェクトは、同期と非同期の両方の読み取りメソッドをサポートします。 <xref:System.IO.Stream> オブジェクトは、<xref:System.IO.Stream.BeginRead%2A> メソッドと <xref:System.IO.Stream.EndRead%2A> メソッドの両方を実装します。 非同期メソッドを使用すると、要求エンティティをチャンク単位で非同期に読み取ることができ、ASP.NET では非同期読み取りループの各反復処理の間で現在のスレッドが解放されます。

 このメソッドは、要求が大きなファイルをアップロードするときに、アップロードが完了する前にファイルの内容へのアクセスを開始する場合に便利です。 ただし、エンティティ本体のすべての処理を引き継ぐ場合にのみ、この方法を使用してください。 つまり、.aspx ページからこのメソッドを使用することはできません。これは、.aspx ページが実行されるときに、エンティティ本体が既に読み取られているためです。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">要求のエンティティ本体は、既に読み込まれ、解析されています。 エンティティ本体を読み込んで解析するプロパティの例は次のとおりです。

-   <see cref="P:System.Web.HttpRequest.Form" />

-   <see cref="P:System.Web.HttpRequest.InputStream" />

-   <see cref="P:System.Web.HttpRequest.Files" />

-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />

この例外を回避するには、<see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> メソッドを最初に呼び出します。 この例外は、エンティティ本体の読み取り中にクライアントが切断された場合にもスローされます。</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream (bool disableMaxRequestLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream(bool disableMaxRequestLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream (disableMaxRequestLength As Boolean) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream(bool disableMaxRequestLength);" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : bool -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream disableMaxRequestLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disableMaxRequestLength" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="disableMaxRequestLength">要求の期間の制限を無効にする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクトを取得し、オプションで <see cref="P:System.Web.Configuration.HttpRuntimeSection.MaxRequestLength" /> プロパティに設定した要求の期間の制限を無効にします。</summary>
        <returns>受信 HTTP エンティティ本体を読み取るために使用できる <see cref="T:System.IO.Stream" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドの詳細については、「<xref:System.Web.HttpRequest.GetBufferlessInputStream> のオーバーロード」を参照してください。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">要求のエンティティ本体は、既に読み込まれ、解析されています。 エンティティ本体を読み込んで解析するプロパティの例は次のとおりです。

-   <see cref="P:System.Web.HttpRequest.Form" /> プロパティ。

-   <see cref="P:System.Web.HttpRequest.Files" /> プロパティ。

-   <see cref="P:System.Web.HttpRequest.InputStream" /> プロパティ。

-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" /> メソッド。

この例外を回避するには、<see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" /> メソッドを最初に呼び出します。 この例外は、エンティティ本体の読み取り中にクライアントが切断された場合にもスローされます。</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP ヘッダーのコレクションを取得します。</summary>
        <value>ヘッダーの <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 使用可能なすべてのヘッダーの一覧については、W3C Web サイトの「 [Request Header Fields (要求ヘッダーフィールド](https://go.microsoft.com/fwlink/?LinkId=73147))」を参照してください。



## Examples
 次のコード例では、HTTP 要求のすべてのヘッダーの名前と値を表示します。

 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HttpChannelBinding">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpChannelBinding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpChannelBinding As ChannelBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ChannelBinding ^ HttpChannelBinding { System::Security::Authentication::ExtendedProtection::ChannelBinding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpChannelBinding : System.Security.Authentication.ExtendedProtection.ChannelBinding" Usage="System.Web.HttpRequest.HttpChannelBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ChannelBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> インスタンスの <see cref="T:System.Web.HttpWorkerRequest" /> オブジェクトを取得します。</summary>
        <value>現在の <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> インスタンスの <see cref="T:System.Web.HttpWorkerRequest" /> オブジェクト。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">現在の <see cref="T:System.Web.HttpWorkerRequest" /> オブジェクトが、<see langword="System.Web.Hosting.IIS7WorkerRequest" /> オブジェクトまたは <see langword="System.Web.Hosting.ISAPIWorkerRequestInProc" /> オブジェクトではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpMethod As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HttpMethod { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpMethod : string" Usage="System.Web.HttpRequest.HttpMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントによって使用される HTTP データ転送メソッド (<see langword="GET" />、<see langword="POST" />、<see langword="HEAD" /> など) を取得します。</summary>
        <value>クライアントによって使用される HTTP データの転送方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A> メソッドを使用して、<xref:System.Web.HttpRequest.HttpMethod%2A> プロパティの値を HTML エンコードし、<xref:System.IO.TextWriter.WriteLine%2A> メソッドを使用して、エンコードされた値をファイルに書き込みます。 このコード例は、<xref:System.Web.HttpRequest> クラス用に用意されている大規模な例の一部です。

 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]

 次の例は、このコードによって生成される出力を示しています。

 `GET`

 `127.0.0.1`

 `127.0.0.1`

 `GET`

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.InputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ InputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputStream : System.IO.Stream" Usage="System.Web.HttpRequest.InputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>受信 HTTP エンティティ本体の内容を取得します。</summary>
        <value>受信 HTTP コンテンツ本体の内容を表す <see cref="T:System.IO.Stream" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、<xref:System.Web.HttpRequest.InputStream%2A> の内容を文字列にコピーします。

 [!code-csharp[Classic HttpRequest.InputStream Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/cs/source.aspx#1)]
 [!code-vb[Classic HttpRequest.InputStream Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertEntityBody">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>HTTP 要求エンティティ本体をメモリに挿入する IIS のメソッドのマネージド ラッパーを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.InsertEntityBody%2A> メソッドのオーバーロードは、IIS 7 `IHttpRequest::InsertEntityBody` メソッドへのマネージアクセスを提供します。 IIS メソッドは、HTTP 要求エンティティ本体 (クライアントからポストされたデータ) をメモリに挿入します。 これは、IIS が読み取り後に要求エンティティのコピーを保持しないため便利です。 <xref:System.Web.HttpRequest.InsertEntityBody%2A> メソッドは、HTTP 要求エンティティデータのコピーを作成し、追加のカスタム処理のために IIS で使用できるようにします。

> [!NOTE]
>  <xref:System.Web.HttpRequest.InsertEntityBody%2A> メソッドのオーバーロードは、iis 7.0 で `IHttpRequest::InsertEntityBody` メソッドが追加されたため、IIS 7.0 以降でのみ動作します。

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody();" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : unit -&gt; unit" Usage="httpRequest.InsertEntityBody " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>HTTP 要求エンティティ本体のコピーを IIS に提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 IIS は、読み取り後の要求のコピーを保持しません。 そのため、HTTP 要求のハンドラーだけが要求エンティティを読み取るようにすることをお勧めします。

 <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> メソッドのオーバーロードは、以前に ASP.NET によって読み取られた場合に、要求エンティティのコピーを IIS に提供します。 このメソッドオーバーロードは、ASP.NET がエンティティ要求を読み取り、既存の要求データを再利用する場合に便利です。

 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">IIS 7.0 より前バージョンの IIS で、メソッドが呼び出されました。</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">ホストされた環境での運用に使用します。 セキュリティアクション: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 関連付けられた列挙型: <see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : byte[] * int * int -&gt; unit" Usage="httpRequest.InsertEntityBody (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="buffer">要求エンティティ データが格納されている配列。</param>
        <param name="offset">要求エンティティ データの格納を開始する、<paramref name="buffer" /> 内の、インデックス番号が 0 から始まる位置。</param>
        <param name="count"><paramref name="buffer" /> 配列に読み取るバイト数。</param>
        <summary>HTTP 要求エンティティ本体のコピーおよび要求エンティティ オブジェクトについての情報を IIS に提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 IIS は、読み取り後の要求のコピーを保持しません。 そのため、HTTP 要求のハンドラーだけが要求エンティティを読み取るようにすることをお勧めします。

 <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> メソッドのオーバーロードは、別のエンティティ本体をメモリに挿入するなど、カスタム処理を実行する場合に便利です。

 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">IIS 7.0 より前バージョンの IIS で、メソッドが呼び出されました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> または <paramref name="count" /> が負の値です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="count" /> 値を仮定すると、<paramref name="buffer" /> の項目数が <paramref name="offset" /> 内の使用可能な領域を超えています。</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">ホストされた環境で使用します。 セキュリティアクション: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。 関連付けられた列挙型: <see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Web.HttpRequest.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求が認証されているかどうかを示す値を取得します。</summary>
        <value>要求が認証されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、<xref:System.Web.HttpRequest.IsAuthenticated%2A> プロパティを使用して、現在の要求が認証されているかどうかを判断します。 認証されていない場合、要求は別のページにリダイレクトされ、ユーザーは Web アプリケーションに資格情報を入力できます。 これは、アプリケーションの既定のページで使用される一般的な方法です。

 [!code-csharp[System.Web.HttpRequest_Sample3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/CS/isauthenticatedcs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/VB/isauthenticatedvb.aspx#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocal : bool" Usage="System.Web.HttpRequest.IsLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求がローカル コンピューターから送信されたかどうかを示す値を取得します。</summary>
        <value>要求がローカル コンピューターから送信された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.IsLocal%2A> プロパティは、要求の発信元の IP アドレスが127.0.0.1 の場合、または要求の IP アドレスがサーバーの IP アドレスと同じである場合に `true` を返します。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecureConnection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecureConnection : bool" Usage="System.Web.HttpRequest.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>セキュリティ設定されたソケットを HTTP 接続で使用しているかどうか (つまり、HTTPS かどうか) を示す値を取得します。</summary>
        <value>接続に SSL を使用する場合は<see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、<xref:System.Web.HttpRequest.IsSecureConnection%2A> プロパティが false に設定されているかどうかを判断します。 値がの場合、<xref:System.Web.HttpResponse.SuppressContent%2A> プロパティは true に設定され、応答の送信を停止します。

 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public string this[string key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ key); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Web.HttpRequest.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">取得するコレクション メンバーの名前。</param>
        <summary><see cref="P:System.Web.HttpRequest.QueryString" />、<see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" />、または <see cref="P:System.Web.HttpRequest.ServerVariables" /> の各コレクションから指定したオブジェクトを取得します。</summary>
        <value><see cref="P:System.Web.HttpRequest.QueryString" /> パラメーターで指定された <see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" />、<see cref="P:System.Web.HttpRequest.ServerVariables" />、または <paramref name="key" /> コレクションのメンバー。 指定した <paramref name="key" /> が見つからない場合は <see langword="null" /> が返されます。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogonUserIdentity">
      <MemberSignature Language="C#" Value="public System.Security.Principal.WindowsIdentity LogonUserIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.WindowsIdentity LogonUserIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.LogonUserIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogonUserIdentity As WindowsIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::WindowsIdentity ^ LogonUserIdentity { System::Security::Principal::WindowsIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogonUserIdentity : System.Security.Principal.WindowsIdentity" Usage="System.Web.HttpRequest.LogonUserIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のユーザーに対する <see cref="T:System.Security.Principal.WindowsIdentity" /> の種類を取得します。</summary>
        <value>現在の Microsoft Internet Information Services (IIS) の認証設定に対応する <see cref="T:System.Security.Principal.WindowsIdentity" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.LogonUserIdentity%2A> プロパティは、現在接続しているユーザーの <xref:System.Security.Principal.WindowsIdentity> オブジェクトのプロパティとメソッドを Microsoft インターネットインフォメーションサービス (IIS) に公開します。 <xref:System.Web.HttpRequest.LogonUserIdentity%2A> によって公開される <xref:System.Security.Principal.WindowsIdentity> クラスのインスタンスは、IIS 要求トークンを追跡し、ASP.NET 内で処理されている現在の HTTP 要求に対してこのトークンに簡単にアクセスできるようにします。 <xref:System.Security.Principal.WindowsIdentity> クラスのインスタンスは自動的に作成されるので、メソッドとプロパティにアクセスするために構築する必要はありません。



## Examples
 次のコード例は、現在のユーザーの <xref:System.Web.HttpRequest.LogonUserIdentity%2A> プロパティを取得し、各項目の値をテキストファイルに書き出す方法を示しています。 このコードは、フォームの `ACTION` 属性で参照される ASP.NET ページに配置します。

 [!code-aspx-csharp[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/CS/logonuseridentity_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/VB/logonuseridentity_vb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Web アプリケーションは IIS 7 統合モードで実行されていて、<see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" /> イベントはまだ発生していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapImageCoordinates">
      <MemberSignature Language="C#" Value="public int[] MapImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] MapImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapImageCoordinates (imageFieldName As String) As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ MapImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapImageCoordinates : string -&gt; int[]" Usage="httpRequest.MapImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">フォーム イメージ マップの名前。</param>
        <summary>インカミング イメージ フィールド フォーム パラメーターを、該当する x 座標値および y 座標値に割り当てます。</summary>
        <returns>整数の 2 次元配列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>要求された URL の仮想パスを、現在の要求に対するサーバー上の物理パスに割り当てます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpRequest.MapPath virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">現在の要求の仮想パス (絶対パスまたは相対パス)。</param>
        <summary>指定された仮想パスを物理パスに割り当てます。</summary>
        <returns><paramref name="virtualPath" /> で指定されたサーバー上の物理パス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A> プロパティには、ホスティング環境に関する機密情報が含まれている可能性があります。 戻り値は、ユーザーに表示されません。



## Examples
 次のコード例では、<xref:System.Web.HttpRequest.MapPath%2A> メソッドを使用して、仮想パスをサーバー上の完全に修飾された物理パスに変換します。 この例には、次の2つの部分があります。

-   .Aspx ページにより、パスがマップされ、ファイルが読み取られ、読み取り操作の結果が表示されます。

-   `UpperCaseFilterStream`クラス。このクラスは、このクラスを通じて渡されるすべての文字を大文字に変更します。

 この例の最初の部分では、<xref:System.Web.HttpRequest.MapPath%2A> メソッドを使用して、仮想パスを完全に修飾された物理パスに変換する方法を示します。 この物理パスは、ファイルの内容を取得する <xref:System.IO.StreamReader> オブジェクトに渡されます。 次に、<xref:System.Web.HttpResponse.Write%2A> メソッドを呼び出して、ページ上のファイルの内容を表示します。 <xref:System.Web.HttpResponse.Filter%2A> プロパティは、ページに表示されるテキストをすべて大文字にするフィルターを応答ストリームにアタッチするために使用されます。

 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]

 この例の2番目の部分は、<xref:System.IO.Stream> から継承し、ストリーム内のすべての文字を大文字に変換するクラスを示しています。 このコードをアプリケーションの `App_Code` フォルダーに配置します。

 [!code-csharp[System.Web.HttpRequest_Samples2#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/responsefilter.cs#2)]
 [!code-vb[System.Web.HttpRequest_Samples2#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/responsefilter.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">要求に対して <see cref="T:System.Web.HttpContext" /> オブジェクトが定義されていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath, string baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath, string baseVirtualDir, bool allowCrossAppMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String, baseVirtualDir As String, allowCrossAppMapping As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath, System::String ^ baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string * string * bool -&gt; string" Usage="httpRequest.MapPath (virtualPath, baseVirtualDir, allowCrossAppMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="baseVirtualDir" Type="System.String" />
        <Parameter Name="allowCrossAppMapping" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">現在の要求の仮想パス (絶対パスまたは相対パス)。</param>
        <param name="baseVirtualDir">相対解決に使用される仮想ベース ディレクトリ パス。</param>
        <param name="allowCrossAppMapping"><see langword="true" /> が別のアプリケーションに所属できることを示す場合は <paramref name="virtualPath" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定された仮想パスを物理パスに割り当てます。</summary>
        <returns>サーバー上の物理パス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!CAUTION]
>  <xref:System.Web.HttpRequest.MapPath%2A> プロパティには、ホスティング環境に関する機密情報が含まれている可能性があります。 戻り値は、ユーザーに表示されません。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="allowCrossMapping" /> は <see langword="false" />。<paramref name="virtualPath" /> は別のアプリケーションに属します。

または

要求に対して <see cref="T:System.Web.HttpContext" /> オブジェクトが定義されていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="MapRawImageCoordinates">
      <MemberSignature Language="C#" Value="public double[] MapRawImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64[] MapRawImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapRawImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapRawImageCoordinates (imageFieldName As String) As Double()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;double&gt; ^ MapRawImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapRawImageCoordinates : string -&gt; double[]" Usage="httpRequest.MapRawImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">イメージ フィールドの名前。</param>
        <summary>着信イメージ フィールド フォーム パラメーターを、適切な x 座標値および y 座標値にマップします。</summary>
        <returns>x および y 座標値。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Params">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Params { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Params" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Params" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Params As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Params { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Params : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Params" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Web.HttpRequest.QueryString" />、<see cref="P:System.Web.HttpRequest.Form" />、<see cref="P:System.Web.HttpRequest.Cookies" />、および <see cref="P:System.Web.HttpRequest.ServerVariables" /> の各項目が組み合わされたコレクションを取得します。</summary>
        <value><see cref="T:System.Collections.Specialized.NameValueCollection" /> オブジェクトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 名前と値のペアは、次の順序でコレクションに追加されます。

1.  クエリ文字列パラメーター。

2.  フォームフィールド。

3.  Cookie.

4.  サーバー変数。



## Examples
 次のコード例は、ページの <xref:System.Web.HttpRequest.Params%2A> プロパティをループ処理する方法と、各キーと値のペアを表示する方法を示しています。

 [!code-aspx-csharp[System.Web.HttpRequest.Params#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Params/CS/requestparamscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Params#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Params/VB/requestparamsvb.aspx#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Path" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Path : string" Usage="System.Web.HttpRequest.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の仮想パスを取得します。</summary>
        <value>現在の要求の仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest.Path%2A> は、<xref:System.Web.HttpRequest.FilePath%2A> と <xref:System.Web.HttpRequest.PathInfo%2A> トレーラーを連結したものです。 たとえば、URL `http://www.contoso.com/virdir/page.html/tail`の場合、<xref:System.Web.HttpRequest.Path%2A> は/virdir/page.html/tail. になります。



## Examples
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A> メソッドを使用して、<xref:System.Web.HttpRequest.Path%2A> プロパティの値を HTML エンコードし、<xref:System.IO.TextWriter.WriteLine%2A> メソッドを使用して、エンコードされた値をファイルに書き込みます。 このコード例は、<xref:System.Web.HttpRequest> クラス用に用意されている大規模な例の一部です。

 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
      </Docs>
    </Member>
    <Member MemberName="PathInfo">
      <MemberSignature Language="C#" Value="public string PathInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PathInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathInfo : string" Usage="System.Web.HttpRequest.PathInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>URL 拡張子付きリソースの追加パス情報を取得します。</summary>
        <value>リソースの追加パス情報。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 URL `http://www.contoso.com/virdir/page.html/tail`の場合、<xref:System.Web.HttpRequest.PathInfo%2A> 値は/tail です。です。



## Examples
 次のコード例では、<xref:System.Web.HttpRequest.PathInfo%2A> プロパティに空の文字列が含まれているかどうかを判断します。 存在する場合、<xref:System.IO.StreamWriter.Write%2A> メソッドはこれを示す文字列をファイルに書き込みます。 そうでない場合は、<xref:System.Web.HttpUtility.HtmlEncode%2A> メソッドによって <xref:System.Web.HttpRequest.PathInfo%2A> プロパティの値が HTML エンコードされ、<xref:System.IO.TextWriter.WriteLine%2A> メソッドによって、エンコードされた値がファイルに書き込まれます。 このコード例は、<xref:System.Web.HttpRequest> クラス用に用意されている大規模な例の一部です。

 [!code-csharp[System.Web.HttpRequest_Sample1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#4)]
 [!code-vb[System.Web.HttpRequest_Sample1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#4)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
      </Docs>
    </Member>
    <Member MemberName="PhysicalApplicationPath">
      <MemberSignature Language="C#" Value="public string PhysicalApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalApplicationPath : string" Usage="System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行しているサーバー アプリケーションのルート ディレクトリの物理ファイル システム パスを取得します。</summary>
        <value>現在のアプリケーションのルート ディレクトリのファイル システム パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A> メソッドを使用して、<xref:System.Web.HttpRequest.PhysicalApplicationPath%2A> プロパティの値を HTML エンコードし、<xref:System.IO.TextWriter.WriteLine%2A> メソッドを使用して、エンコードされた値をファイルに書き込みます。 このコード例は、<xref:System.Web.HttpRequest> クラス用に用意されている大規模な例の一部です。

 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalPath">
      <MemberSignature Language="C#" Value="public string PhysicalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalPath : string" Usage="System.Web.HttpRequest.PhysicalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求された URL に一致する物理ファイル システム パスを取得します。</summary>
        <value>現在の要求のファイル システム パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpServerUtility.Execute%2A> と <xref:System.Web.HttpServerUtility.Transfer%2A>を使用したリダイレクトのシナリオでは、<xref:System.Web.HttpRequest.PhysicalPath%2A> プロパティによって元のページへのパスが返されます。 現在実行中のページの物理パスを検索するには、<xref:System.Web.HttpRequest.MapPath%2A> メソッドを <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> プロパティとして設定された入力引数と共に使用します。



## Examples
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A> メソッドを使用して、<xref:System.Web.HttpRequest.PhysicalPath%2A> プロパティの値を HTML エンコードし、<xref:System.IO.TextWriter.WriteLine%2A> メソッドを使用して、エンコードされた値をファイルに書き込みます。 このコード例は、<xref:System.Web.HttpRequest> クラス用に用意されている大規模な例の一部です。

 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.MapPath(System.String)" />
        <altmember cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.QueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryString As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ QueryString { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryString : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.QueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>HTTP クエリ文字列変数のコレクションを取得します。</summary>
        <value>クライアントから送信されたクエリ文字列変数。 URL デコードされたキーと値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、"fullname" という名前のクエリ文字列変数の値を取得する2つの方法を示しています。 どちらの場合も、URL が `http://www.contoso.com/default.aspx?fullname=Fadi%20Fakhouri`場合、返される値は "Fadi Fakhouri" です。これは、`%20` が空白文字に URL でデコードされるためです。 URL に `fullname` クエリ文字列 ID がない場合、返される値は `null`になります。

 コードの1行目では、クエリ文字列内でのみキー "fullname" が検索されます。2行目では、すべての HTTP 要求コレクションで "fullname" というキーが検索されます。 2行目の詳細については、「<xref:System.Web.HttpRequest.Item%2A>」を参照してください。

```csharp
string fullname1 = Request.QueryString["fullname"];
string fullname2 = Request["fullname"];

```

```vb
Dim fullname1 As String = Request.QueryString("fullname")
Dim fullname2 As String = Request("fullname")
```

 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RawUrl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawUrl { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawUrl : string" Usage="System.Web.HttpRequest.RawUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の生の URL を取得します。</summary>
        <value>現在の要求の生の URL。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 未加工の URL は、ドメイン情報の後の URL の一部として定義されます。 URL 文字列 `http://www.contoso.com/articles/recent.aspx`では、生の URL は/articles/recent.aspx. です。 未加工の URL にクエリ文字列が含まれている場合は、その文字列が含まれます。



## Examples
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A> メソッドを使用して、<xref:System.Web.HttpRequest.RawUrl%2A> プロパティの値を HTML エンコードし、<xref:System.IO.TextWriter.WriteLine%2A> メソッドを使用して、エンコードされた値をファイルに書き込みます。 このコード例は、<xref:System.Web.HttpRequest> クラス用に用意されている大規模な例の一部です。

 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEntityBodyMode">
      <MemberSignature Language="C#" Value="public System.Web.ReadEntityBodyMode ReadEntityBodyMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.ReadEntityBodyMode ReadEntityBodyMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadEntityBodyMode As ReadEntityBodyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ReadEntityBodyMode ReadEntityBodyMode { System::Web::ReadEntityBodyMode get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadEntityBodyMode : System.Web.ReadEntityBodyMode" Usage="System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ReadEntityBodyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求エンティティ本体が読み取られたかどうかおよび読み取った方法 (読み取られた場合) を示す値を取得します。</summary>
        <value>要求エンティティ本体がどのように読み取られたか、または読み取られていないことを示す値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このメソッドは、エンティティ本体が既に読み取られていて、互換性のないメソッドを使用して読み取りを試行した場合にスローされる例外を回避するために使用されます。 エンティティ本体を読み取るメソッドとプロパティには、次のものがあります。

-   <xref:System.Web.HttpRequest.Form%2A> プロパティ。

-   <xref:System.Web.HttpRequest.Files%2A> プロパティ。

-   <xref:System.Web.HttpRequest.InputStream%2A> プロパティ。

-   <xref:System.Web.HttpRequest.GetBufferedInputStream%2A> メソッド。

-   <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> メソッド。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestContext">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RequestContext RequestContext { get; }" FrameworkAlternate="netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RequestContext RequestContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RequestContext As RequestContext" FrameworkAlternate="netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RequestContext ^ RequestContext { System::Web::Routing::RequestContext ^ get(); };" FrameworkAlternate="netframework-4.0" />
      <MemberSignature Language="F#" Value="member this.RequestContext : System.Web.Routing.RequestContext" Usage="System.Web.HttpRequest.RequestContext" FrameworkAlternate="netframework-4.0" />
      <MemberSignature Language="C#" Value="public System.Web.Routing.RequestContext RequestContext { get; set; }" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestContext As RequestContext" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RequestContext ^ RequestContext { System::Web::Routing::RequestContext ^ get(); void set(System::Web::Routing::RequestContext ^ value); };" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.RequestContext : System.Web.Routing.RequestContext with get, set" Usage="System.Web.HttpRequest.RequestContext" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RequestContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の <see cref="T:System.Web.Routing.RequestContext" /> インスタンスを取得します。</summary>
        <value>現在の要求の <see cref="T:System.Web.Routing.RequestContext" /> インスタンス。 非ルーティング要求の場合、返される <see cref="T:System.Web.Routing.RequestContext" /> オブジェクトは空です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このプロパティは、現在の要求に対する <xref:System.Web.Routing.RouteData> オブジェクトへのアクセスを提供します。 ASP.NET ルーティングの詳細については、「」を参照してください。[ASP.NET ルーティング](https://docs.microsoft.com/previous-versions/aspnet/cc668201(v=vs.100))。

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd329551(v=vs.140)">チュートリアル: Web フォームアプリケーションでの ASP.NET ルーティングの使用</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dd535620(v=vs.140)">方法: ルーティングページの URL パラメーターにアクセスする</related>
      </Docs>
    </Member>
    <Member MemberName="RequestType">
      <MemberSignature Language="C#" Value="public string RequestType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RequestType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestType" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RequestType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestType : string with get, set" Usage="System.Web.HttpRequest.RequestType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントによって使用される HTTP データ転送メソッド (<see langword="GET" /> または <see langword="POST" />) を取得または設定します。</summary>
        <value>クライアントから送信される HTTP 呼び出し型を表す文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A> メソッドを使用して、<xref:System.Web.HttpRequest.RequestType%2A> プロパティの値を HTML エンコードし、<xref:System.IO.TextWriter.WriteLine%2A> メソッドを使用して、エンコードされた値をファイルに書き込みます。 このコード例は、<xref:System.Web.HttpRequest> クラス用に用意されている大規模な例の一部です。

 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAs">
      <MemberSignature Language="C#" Value="public void SaveAs (string filename, bool includeHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveAs(string filename, bool includeHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.SaveAs(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveAs (filename As String, includeHeaders As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveAs(System::String ^ filename, bool includeHeaders);" />
      <MemberSignature Language="F#" Value="member this.SaveAs : string * bool -&gt; unit" Usage="httpRequest.SaveAs (filename, includeHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="includeHeaders" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">物理ドライブ パス。</param>
        <param name="includeHeaders">HTTP ヘッダーをディスクに保存するかどうかを指定するブール値。</param>
        <summary>HTTP 要求をディスクに保存します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 要求コンテキストをディスクに保存すると、デバッグに役立ちます。



## Examples
 次のコード例では、ページが読み込まれるときに <xref:System.Web.HttpRequest.SaveAs%2A> メソッドを呼び出します。 この呼び出しは、ASP.NET process id に書き込みアクセス許可が付与されているディレクトリにテキストファイルとして要求を保存すること、および要求に含まれるすべてのヘッダー情報がファイルに含まれることを指定します。

 [!code-csharp[System.Web.HttpRequest_Sample6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/cs/requestsample6cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/vb/requestsample6vb.aspx#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><see cref="P:System.Web.Configuration.HttpRuntimeSection.RequireRootedSaveAsPath" /> の <see cref="T:System.Web.Configuration.HttpRuntimeSection" /> プロパティが <see langword="true" /> に設定されていますが、<paramref name="filename" /> が絶対パスではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection ServerVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection ServerVariables" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ServerVariables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServerVariables As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ ServerVariables { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServerVariables : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.ServerVariables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Web サーバー変数のコレクションを取得します。</summary>
        <value>サーバー変数の <see cref="T:System.Collections.Specialized.NameValueCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 IIS でサポートされているサーバー変数の一覧については、「 [Iis サーバー変数](https://go.microsoft.com/fwlink/?LinkId=52471)」を参照してください。



## Examples
 次のコード例では、すべての名前付きサーバー変数の名前と値を表示します。

 [!code-csharp[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimedOutToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken TimedOutToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken TimedOutToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TimedOutToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimedOutToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken TimedOutToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.TimedOutToken : System.Threading.CancellationToken" Usage="System.Web.HttpRequest.TimedOutToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求がタイムアウトするとトリップされる <see cref="T:System.Threading.CancellationToken" /> オブジェクトを取得します。</summary>
        <value>キャンセル トークン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 タイムアウト期間は、web.config ファイルで指定することも (<xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A?displayProperty=nameWithType>を参照)、プログラムによって指定することもできます (<xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType>を参照してください)。 タイムアウト期間は、要求が届いた時点から計測されます。 既定のタイムアウトである110秒が有効な場合、キャンセルトークンは、要求の処理が開始されてから110秒以内にトリップされます。 <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType> プロパティの値を変更できます。このトークンがまだトリップしていない限り、新しいタイムアウト値が尊重されます。

 現在、トークンには15秒の粒度しか指定できません。つまり、タイムアウト値が110秒の場合、要求の処理が開始された後、110 ~ 125 秒の間にトークンがトリップします。 粒度は将来変更される可能性があります。

 このプロパティはスレッドセーフですが、使用に関する制限があります。 詳細については、<xref:System.Web.HttpResponse.ClientDisconnectedToken%2A?displayProperty=nameWithType> を参照してください。

 Websocket 要求の処理が開始されている場合、このプロパティは意味がありません。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TlsTokenBindingInfo">
      <MemberSignature Language="C#" Value="public System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TlsTokenBindingInfo As ITlsTokenBindingInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ITlsTokenBindingInfo ^ TlsTokenBindingInfo { System::Web::ITlsTokenBindingInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TlsTokenBindingInfo : System.Web.ITlsTokenBindingInfo" Usage="System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ITlsTokenBindingInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>TLS トークンのバインド情報を取得します。 このプロパティによりアプリケーションは、強化された認証のために受信 HTTP 要求からトークンの情報を取得できます。</summary>
        <value>現在の接続のバインド トークンです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 このプロパティは、非 windows10 プラットフォームで `null` を返します。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TotalBytes">
      <MemberSignature Language="C#" Value="public int TotalBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TotalBytes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TotalBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalBytes As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TotalBytes { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalBytes : int" Usage="System.Web.HttpRequest.TotalBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の入力ストリームのバイト数を取得します。</summary>
        <value>入力ストリームのバイト数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、<xref:System.Web.HttpRequest.TotalBytes%2A> プロパティの値が1000バイトを超えているかどうかを判断し、その情報をファイルに書き込みます。

 [!code-csharp[System.Web.HttpRequest_Sample1#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#6)]
 [!code-vb[System.Web.HttpRequest_Sample1#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#6)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unvalidated">
      <MemberSignature Language="C#" Value="public System.Web.UnvalidatedRequestValues Unvalidated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UnvalidatedRequestValues Unvalidated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Unvalidated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Unvalidated As UnvalidatedRequestValues" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UnvalidatedRequestValues ^ Unvalidated { System::Web::UnvalidatedRequestValues ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unvalidated : System.Web.UnvalidatedRequestValues" Usage="System.Web.HttpRequest.Unvalidated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UnvalidatedRequestValues</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求の検証をトリガーせずに HTTP 要求値を取得します。</summary>
        <value>要求の検証を使用してチェックされていない HTTP 要求値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 要求の検証では、クロスサイトスクリプティング攻撃の可能性を示す可能性がある HTML マークアップとスクリプトを確認します。 既定では、すべての値は、要求の検証を使用してチェックされます。また、マークアップまたはスクリプトが含まれている値がある場合、ASP.NET は <xref:System.Web.HttpRequestValidationException> 例外をスローします。 要求にマークアップが含まれていることが予想される場合 (たとえば、ユーザーがマークアップを含むコンテンツを投稿することを許可している場合)、要求の生の値を取得する必要がある場合は、このメソッドを使用します。

> [!IMPORTANT]
>  このプロパティを使用する場合は、クロスサイトスクリプティング攻撃を受ける可能性があるかどうか、手動でデータを確認する必要があります。

 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Web.HttpRequest.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の要求の URL に関する情報を取得します。</summary>
        <value>現在の要求の URL を格納している <see cref="T:System.Uri" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、現在の要求の <xref:System.Uri> オブジェクトをオブジェクト変数に割り当て、URL オブジェクトの2つのプロパティの値を HTTP 出力に表示します。

 [!code-csharp[Classic HttpRequest.Url Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Url Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Url Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Url Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Uri" />
        <altmember cref="P:System.Web.HttpRequest.RawUrl" />
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UrlReferrer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UrlReferrer As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UrlReferrer { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UrlReferrer : Uri" Usage="System.Web.HttpRequest.UrlReferrer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の URL にリンクされている、クライアントが前回要求した URL に関する情報を取得します。</summary>
        <value><see cref="T:System.Uri" /> オブジェクトです。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、クライアントを現在のアプリケーションに対して参照している URL の2つのプロパティの値を表示します。

 [!code-csharp[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">HTTP <see langword="Referer" /> 要求ヘッダーの形式が正しくなく、<see cref="T:System.Uri" /> オブジェクトに変換することはできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string" Usage="System.Web.HttpRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されているクライアント ブラウザーの生のユーザー エージェント文字列を取得します。 null も指定できる点にご注意ください。</summary>
        <value>クライアント ブラウザーの生のユーザー エージェント文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、要求元のブラウザーの型識別を文字列変数に割り当てます。

 [!code-csharp[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/x3k2ssx2(v=vs.100)">ASP.NET サーバーコントロールとブラウザー機能</related>
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostAddress { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostAddress : string" Usage="System.Web.HttpRequest.UserHostAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リモート クライアントの IP ホスト アドレスを取得します。</summary>
        <value>リモート クライアントの IP アドレス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A> メソッドを使用して、<xref:System.Web.HttpRequest.UserHostAddress%2A> プロパティの値を HTML エンコードし、<xref:System.IO.TextWriter.WriteLine%2A> メソッドを使用して、エンコードされた値をファイルに書き込みます。 このコード例は、<xref:System.Web.HttpRequest> クラス用に用意されている大規模な例の一部です。

 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostName : string" Usage="System.Web.HttpRequest.UserHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リモート クライアントの DNS 名を取得します。</summary>
        <value>リモート クライアントの DNS 名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、<xref:System.Web.HttpUtility.HtmlEncode%2A> メソッドを使用して、<xref:System.Web.HttpRequest.UserHostName%2A> プロパティの値を HTML エンコードし、<xref:System.IO.TextWriter.WriteLine%2A> メソッドを使用して、エンコードされた値をファイルに書き込みます。 このコード例は、<xref:System.Web.HttpRequest> クラス用に用意されている大規模な例の一部です。

 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserLanguages" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserLanguages As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ UserLanguages { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserLanguages : string[]" Usage="System.Web.HttpRequest.UserLanguages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアントの言語設定の並べ替えられた文字列配列を取得します。</summary>
        <value>クライアント言語設定の並べ替えられた文字列配列。空の場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例では、<xref:System.Web.HttpRequest.UserLanguages%2A> プロパティによって返された複数の値を文字列配列にキャプチャし、各言語名を HTTP 出力の個別の行に書き込みます。

 言語名はブラウザーによって提供され、すべての使用可能なコードを明確に一覧表示することはできません。  通常、これらは、言語の2文字のコード、ハイフン、およびカルチャの2文字のコードで構成されます。たとえば、米国英語の場合は "en-us"、カナダフランス語の場合は "fr-fr" になります。

 [!code-csharp[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/VB/source.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateInput">
      <MemberSignature Language="C#" Value="public void ValidateInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.ValidateInput" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateInput ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateInput();" />
      <MemberSignature Language="F#" Value="member this.ValidateInput : unit -&gt; unit" Usage="httpRequest.ValidateInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Web.HttpRequest.Cookies" />、<see cref="P:System.Web.HttpRequest.Form" />、および <see cref="P:System.Web.HttpRequest.QueryString" /> の各プロパティを通じてアクセスするコレクションに対して検証を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Web.HttpRequest> クラスは、入力検証フラグを使用して、<xref:System.Web.HttpRequest.Cookies%2A>、<xref:System.Web.HttpRequest.Form%2A>、および <xref:System.Web.HttpRequest.QueryString%2A> プロパティを通じてアクセスされる要求コレクションに対して検証を実行するかどうかを追跡します。 <xref:System.Web.HttpRequest.ValidateInput%2A> メソッドは、<xref:System.Web.HttpRequest.Cookies%2A>、<xref:System.Web.HttpRequest.Form%2A>、または <xref:System.Web.HttpRequest.QueryString%2A> プロパティの get アクセサーが呼び出されると、入力の検証が実行されるように、これらのフラグを設定します。 検証は、すべての入力データをハードコーディングされた危険なデータのリストと比較することによって機能します。

 ページディレクティブまたは構成によって検証機能が有効になっている場合、このメソッドはページの `ProcessRequest` 処理フェーズ中に呼び出されます。 検証機能が有効になっていない場合は、コードから <xref:System.Web.HttpRequest.ValidateInput%2A> メソッドを呼び出すことができます。

 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpRequestValidationException">危険性の高いデータがクライアントから受信されました。</exception>
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
  </Members>
</Type>
