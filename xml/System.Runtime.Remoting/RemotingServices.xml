<Type Name="RemotingServices" FullName="System.Runtime.Remoting.RemotingServices">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1cee83084cbf8704c196a2c43d3edf0ef6e2a574" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78829905" /></Metadata><TypeSignature Language="C#" Value="public sealed class RemotingServices" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed RemotingServices extends System.Object" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingServices" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RemotingServices" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingServices sealed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
  <TypeSignature Language="F#" Value="type RemotingServices = class" />
  <TypeSignature Language="C#" Value="public static class RemotingServices" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed RemotingServices extends System.Object" FrameworkAlternate="netframework-4.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingServices" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingServices abstract sealed" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RemotingServices extends System.Object" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>リモート オブジェクトとプロキシを使用および公開するための複数のメソッドを提供します。 このクラスは継承できません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 アクティブ化、有効期間管理、トランザクションなどの問題を処理するサービスプロバイダーでない限り、プロキシ参照とオブジェクト参照を区別する必要はありません。 リモート処理インフラストラクチャは、リモートオブジェクトがクライアントの領域に存在するという印象を与える透過プロキシを使用します。 プロキシは、リモートの場所で実際のオブジェクトに対して行われた呼び出しを転送することによってこれを実現します。

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既知のオブジェクトのプロキシを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classToProxy">サーバー エンドにある接続する既知のオブジェクトの <see cref="T:System.Type" />。</param>
        <param name="url">サーバー クラスの URL。</param>
        <summary><see cref="T:System.Type" /> および URL を指定して、既知のオブジェクトのプロキシを作成します。</summary>
        <returns>指定した既知のオブジェクトによって提供されたエンドポイントを指す、リモート オブジェクトへのプロキシ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 返されたプロキシオブジェクトは、指定された既知のオブジェクトによって提供されるエンドポイントを指します。 プロキシでメソッドが呼び出されるまで、ネットワーク経由でメッセージが送信されることはありません。



## Examples
 次のコード例は、<xref:System.Runtime.Remoting.RemotingServices.Connect%2A> メソッドを使用して、既知のオブジェクトへのプロキシを作成する方法を示しています。

 [!code-cpp[RemotingServices.BasicSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/basicclient.cpp#1)]
 [!code-csharp[RemotingServices.BasicSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/basicclient.cs#1)]
 [!code-vb[RemotingServices.BasicSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/basicclient.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元に、リモート処理の型とチャネルを構成するためのアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public static object Connect (Type classToProxy, string url, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Connect(class System.Type classToProxy, string url, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Connect (classToProxy As Type, url As String, data As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Connect(Type ^ classToProxy, System::String ^ url, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member Connect : Type * string * obj -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Connect (classToProxy, url, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classToProxy" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="classToProxy">接続する既知のオブジェクトの <see cref="T:System.Type" />。</param>
        <param name="url">既知のオブジェクトの URL。</param>
        <param name="data">チャネル固有のデータ。 <see langword="null" /> を指定できます。</param>
        <summary><see cref="T:System.Type" />、URL、およびチャネル固有のデータを指定して、既知のオブジェクトのプロキシを作成します。</summary>
        <returns>要求した既知のオブジェクトによって提供されたエンドポイントを指すプロキシ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 返されたプロキシオブジェクトは、指定された既知のオブジェクトによって提供されるエンドポイントを指します。 プロキシでメソッドが呼び出されるまで、ネットワーク経由でメッセージが送信されることはありません。

 `data` オブジェクトは、情報をチャネルに伝達するために使用され、<xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> メソッドに渡されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元に、リモート処理の型とチャネルを構成するためのアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public static bool Disconnect (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Disconnect(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Disconnect (obj As MarshalByRefObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Disconnect(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member Disconnect : MarshalByRefObject -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.Disconnect obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">チャネルから切断するオブジェクト。</param>
        <summary>オブジェクトが登録したリモート処理チャネルを経由してそれ以上のメッセージを受信するのを停止します。</summary>
        <returns>オブジェクトが登録されたリモート処理チャネルから正常に切断された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 次のコード例は、<xref:System.Runtime.Remoting.RemotingServices.Disconnect%2A> メソッドを使用して、リモート処理チャネルからオブジェクトを切断する方法を示しています。

 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="obj" /> パラメーターがプロキシです。</exception>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元に、リモート処理の型とチャネルを構成するためのアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteMessage">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage(class System.MarshalByRefObject target, class System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExecuteMessage (target As MarshalByRefObject, reqMsg As IMethodCallMessage) As IMethodReturnMessage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMethodReturnMessage ^ ExecuteMessage(MarshalByRefObject ^ target, System::Runtime::Remoting::Messaging::IMethodCallMessage ^ reqMsg);" />
      <MemberSignature Language="F#" Value="static member ExecuteMessage : MarshalByRefObject * System.Runtime.Remoting.Messaging.IMethodCallMessage -&gt; System.Runtime.Remoting.Messaging.IMethodReturnMessage" Usage="System.Runtime.Remoting.RemotingServices.ExecuteMessage (target, reqMsg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMethodReturnMessage</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.MarshalByRefObject" />
        <Parameter Name="reqMsg" Type="System.Runtime.Remoting.Messaging.IMethodCallMessage" />
      </Parameters>
      <Docs>
        <param name="target">メソッドを呼び出す対象のリモート オブジェクト。</param>
        <param name="reqMsg">指定したリモート オブジェクトのメソッドへのメソッド呼び出しメッセージ。</param>
        <summary>指定したリモート オブジェクトに接続し、そのオブジェクトで提供された <see cref="T:System.Runtime.Remoting.Messaging.IMethodCallMessage" /> を実行します。</summary>
        <returns>リモート メソッドの応答。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 現在のメソッドは、指定されたメソッド呼び出しを別のリモートオブジェクトに転送するために、サーバーによって特殊なケースで使用されます。 このメソッドは、呼び出し元が適切なコンテキスト内にある場合にのみ呼び出すことができます。



## Examples
 次のコード例は、<xref:System.Runtime.Remoting.RemotingServices.ExecuteMessage%2A> メソッドを使用して、メソッド呼び出しをリモートオブジェクトに転送する方法を示しています。

 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元に、インフラストラクチャ アクセス許可がありません。</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">メソッドがオブジェクトのネイティブ コンテキスト以外のコンテキストから呼び出されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnvoyChainForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvoyChainForProxy (obj As MarshalByRefObject) As IMessageSink" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Messaging::IMessageSink ^ GetEnvoyChainForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetEnvoyChainForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.Messaging.IMessageSink" Usage="System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Messaging.IMessageSink</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">要求したエンボイ シンクが関連付けられているリモート オブジェクトのプロキシ。</param>
        <summary>指定したプロキシによって表されるリモート オブジェクトに、メッセージを送信するときに使用するエンボイ シンクのチェインを返します。</summary>
        <returns>指定したプロキシに関連付けられているエンボイ シンクのチェイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 エンボイシンクは、オブジェクトにメッセージを返すときに使用されるオブジェクトの <xref:System.Runtime.Remoting.ObjRef> と共に送信されるシンクです。 現在のメソッドは、オブジェクトのプロキシとオブジェクト自体の間の通信中に使用されるエンボイシンクを返します。

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元に、インフラストラクチャ アクセス許可がありません。</exception>
        <altmember cref="T:System.Runtime.Remoting.IEnvoyInfo" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public static object GetLifetimeService (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLifetimeService(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLifetimeService (obj As MarshalByRefObject) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLifetimeService(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetLifetimeService : MarshalByRefObject -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.GetLifetimeService obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">有効期間サービスを取得する対象となるオブジェクト。</param>
        <summary>指定したオブジェクトの有効期間ポリシーを制御する、有効期間サービス オブジェクトを返します。</summary>
        <returns><paramref name="obj" /> の有効期間を制御するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 既定の有効期間サービスの場合、返されるオブジェクトは <xref:System.Runtime.Remoting.Lifetime.ILease>型のオブジェクトになります。 `obj` パラメーターが `null`の場合、メソッドは `null`を返します。



## Examples
 次のコード例は、<xref:System.Runtime.Remoting.RemotingServices.GetLifetimeService%2A> メソッドを使用して、指定されたオブジェクトの有効期間リースを取得する方法を示しています。

 [!code-cpp[RemotingServices.TimerSample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.TimerSample/CPP/timerclient.cpp#1)]
 [!code-csharp[RemotingServices.TimerSample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerclient.cs#1)]
 [!code-vb[RemotingServices.TimerSample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerclient.vb#1)]

 この例をコンパイルして実行するには、サーバーをコンパイルして実行し、共有ライブラリの timerserver .dll をコンパイルする必要があります。

 次のように、timerserver のソースを次に示します。

 [!code-csharp[RemotingServices.TimerSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerserver.cs#2)]
 [!code-vb[RemotingServices.TimerSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerserver.vb#2)]

 Timerservice .dll のソースは次のようになります。

 [!code-csharp[RemotingServices.TimerSample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.TimerSample/CS/timerservice.cs#3)]
 [!code-vb[RemotingServices.TimerSample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.TimerSample/VB/timerservice.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元に、インフラストラクチャ アクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBaseFromMethodMessage">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodBaseFromMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodBaseFromMethodMessage (msg As IMethodMessage) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodBaseFromMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetMethodBaseFromMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; System.Reflection.MethodBase" Usage="System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">メソッド ベースの抽出元となるメソッド メッセージ。</param>
        <summary>特定の <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" /> からメソッド ベースを返します。</summary>
        <returns><paramref name="msg" /> パラメーターから抽出されたメソッド ベース。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 これにより、<xref:System.Runtime.Remoting.Messaging.IMethodMessage> の <xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>、<xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>、および <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> プロパティからのメソッドベースが決定され、<xref:System.Runtime.Remoting.Messaging.IMethodMessage> インターフェイスを実装するクラスによって使用されます。 <xref:System.Runtime.Remoting.Messaging.IMethodMessage> クラスのコンシューマーは、<xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=nameWithType> プロパティを参照する必要があります。

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元にインフラストラクチャ アクセス許可がありません。または、コールスタックの上位にある 1 つ以上の呼び出し元に非パブリック メンバーの型情報を取得するためのアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetObjectData(object obj, class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetObjectData (obj As Object, info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetObjectData(System::Object ^ obj, System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="static member GetObjectData : obj * System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.GetObjectData (obj, info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="obj">シリアル化するオブジェクト。</param>
        <param name="info">シリアル化するオブジェクトの <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="context">シリアル化元とシリアル化先。</param>
        <summary>参照オブジェクトによって指定されたマーシャルを提供される <see cref="T:System.Runtime.Serialization.SerializationInfo" /> にシリアル化します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターまたは <paramref name="info" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元に、インフラストラクチャ アクセス許可がありません。</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectUri">
      <MemberSignature Language="C#" Value="public static string GetObjectUri (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetObjectUri(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectUri (obj As MarshalByRefObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetObjectUri(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectUri : MarshalByRefObject -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetObjectUri obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj">URI が要求される対象の <see cref="T:System.MarshalByRefObject" />。</param>
        <summary>指定したオブジェクトの URI を取得します。</summary>
        <returns>指定したオブジェクトの URI が 1 つの場合はその URI。オブジェクトがマーシャリングされていない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#18)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#18)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#18)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元に、インフラストラクチャ アクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjRefForProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef GetObjRefForProxy(class System.MarshalByRefObject obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjRefForProxy (obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ GetObjRefForProxy(MarshalByRefObject ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjRefForProxy : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.GetObjRefForProxy obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Runtime.Remoting.ObjRef" /> を作成する対象となるオブジェクトに接続されたプロキシ。</param>
        <summary>指定したプロキシから、リモート オブジェクトを表す <see cref="T:System.Runtime.Remoting.ObjRef" /> を返します。</summary>
        <returns>指定したプロキシが接続されているリモート オブジェクトを表す <see cref="T:System.Runtime.Remoting.ObjRef" />。オブジェクトまたはプロキシがマーシャリングされていない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Runtime.Remoting.ObjRef> は、アプリケーションドメインの境界を越えてオブジェクト参照を転送するために使用されるオブジェクトのシリアル化可能な表現です。 オブジェクトの <xref:System.Runtime.Remoting.ObjRef> の作成は、マーシャリングと呼ばれます。 <xref:System.Runtime.Remoting.ObjRef> は、チャネルを通じて別のアプリケーションドメイン (別のプロセスまたはコンピューターなど) に転送できます。 もう一方のアプリケーションドメインでは、オブジェクトのプロキシを作成するために <xref:System.Runtime.Remoting.ObjRef> を解析する必要があります。通常、実際のオブジェクトに接続します。 この操作は、マーシャリング解除と呼ばれます。 マーシャリング解除中に、<xref:System.Runtime.Remoting.ObjRef> が解析され、リモートオブジェクトのメソッド情報が抽出され、透過プロキシと <xref:System.Runtime.Remoting.Proxies.RealProxy> オブジェクトの両方が作成されます。

 <xref:System.Runtime.Remoting.ObjRef> には、マーシャリングするオブジェクトの <xref:System.Type> とクラス、特定のオブジェクトインスタンスを一意に識別する URI、およびオブジェクトが配置されているリモートアプリケーションへの接続方法に関する通信関連情報が含まれています。



## Examples
 次のコード例は、指定されたオブジェクトの <xref:System.Runtime.Remoting.ObjRef> インスタンスを取得する方法を示しています。

 [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CPP/client.cpp#1)]
 [!code-csharp[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/CS/client.cs#1)]
 [!code-vb[RemotingServices.GetObjRefForProxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.GetObjRefForProxy/VB/client.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元に、インフラストラクチャ アクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRealProxy">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRealProxy (proxy As Object) As RealProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::Proxies::RealProxy ^ GetRealProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member GetRealProxy : obj -&gt; System.Runtime.Remoting.Proxies.RealProxy" Usage="System.Runtime.Remoting.RemotingServices.GetRealProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Proxies.RealProxy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">透過プロキシ。</param>
        <summary>指定した透過プロキシを実現するための実際のプロキシを返します。</summary>
        <returns>透過プロキシを実現するための実際のプロキシ インスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 任意の種類のリモート処理境界でオブジェクトを使用するクライアントは、実際にはオブジェクトに対して透過的なプロキシを使用します。 透過プロキシは、実際のオブジェクトがクライアントの領域に存在するという印象を与えます。 これを実現するには、リモート処理インフラストラクチャを使用して、それに対して行われた呼び出しを実際のオブジェクトに転送します。

 透過プロキシは、<xref:System.Runtime.Remoting.Proxies.RealProxy>型のマネージランタイムクラスのインスタンスによってサポートされます。 <xref:System.Runtime.Remoting.Proxies.RealProxy> は、透過プロキシから操作を転送するために必要な機能の一部を実装します。

 プロキシオブジェクトは、ガベージコレクションなどのマネージオブジェクトの関連付けられたセマンティクス、メンバーとメソッドのサポート、および新しいクラスを作成するために拡張できます。 プロキシは、リモートオブジェクト (透過プロキシ) と同じクラスのオブジェクトとして機能し、マネージオブジェクトでもあります。

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元に、インフラストラクチャ アクセス許可がありません。</exception>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="GetServerTypeForUri">
      <MemberSignature Language="C#" Value="public static Type GetServerTypeForUri (string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetServerTypeForUri(string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetServerTypeForUri (URI As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetServerTypeForUri(System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member GetServerTypeForUri : string -&gt; Type" Usage="System.Runtime.Remoting.RemotingServices.GetServerTypeForUri URI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="URI"><see cref="T:System.Type" /> が要求されるオブジェクトの URI。</param>
        <summary>指定した URI を持つオブジェクトの <see cref="T:System.Type" /> を返します。</summary>
        <returns>指定した URI を持つオブジェクトの <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 リモート処理は Uri を使用してエンドポイントを識別するため、<xref:System.Runtime.Remoting.RemotingServices.GetServerTypeForUri%2A> メソッドは、<xref:System.Runtime.Remoting.Messaging.IMessage> オブジェクトを使用するリモート処理インフラストラクチャのプラグ可能な部分 (チャネルシンク、動的シンク、コンテキストシンクなど) で非常に便利です。これは、現在のメソッドが、関連付けられている型オブジェクトを URI から返すためです。



## Examples
 [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#7)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#7)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#7)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元にインフラストラクチャ アクセス許可がありません。または、コールスタックの上位にある 1 つ以上の呼び出し元に非パブリック メンバーの型情報を取得するためのアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSessionIdForMethodMessage">
      <MemberSignature Language="C#" Value="public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetSessionIdForMethodMessage(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSessionIdForMethodMessage (msg As IMethodMessage) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetSessionIdForMethodMessage(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member GetSessionIdForMethodMessage : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; string" Usage="System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">セッション ID が要求される対象の <see cref="T:System.Runtime.Remoting.Messaging.IMethodMessage" />。</param>
        <summary>メッセージのセッション ID を取得します。</summary>
        <returns>現在のセッションを一意に識別するセッション ID 文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 同じアプリケーション内のオブジェクトに対して同じセッション ID が返される場合がありますが、この方法では、異なるリモートアプリケーションの2つのオブジェクトに対して同じセッション ID は返されません。

 セッションとセッション Id の識別の詳細については、「ASP.Net [ASP.NET Session State の概要](https://docs.microsoft.com/previous-versions/aspnet/ms178581(v=vs.100))」を参照してください。



## Examples
 次のコード例は、現在のセッションのセッション ID 文字列を取得する方法を示しています。

 [!code-cpp[RemotingServices.ExecuteMessage#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CPP/serviceclass.cpp#1)]
 [!code-csharp[RemotingServices.ExecuteMessage#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/CS/serviceclass.cs#1)]
 [!code-vb[RemotingServices.ExecuteMessage#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.ExecuteMessage/VB/serviceclass.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元に、インフラストラクチャ アクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMethodOverloaded">
      <MemberSignature Language="C#" Value="public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMethodOverloaded(class System.Runtime.Remoting.Messaging.IMethodMessage msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMethodOverloaded (msg As IMethodMessage) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMethodOverloaded(System::Runtime::Remoting::Messaging::IMethodMessage ^ msg);" />
      <MemberSignature Language="F#" Value="static member IsMethodOverloaded : System.Runtime.Remoting.Messaging.IMethodMessage -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsMethodOverloaded msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Runtime.Remoting.Messaging.IMethodMessage" />
      </Parameters>
      <Docs>
        <param name="msg">該当するメソッドへの呼び出しを格納しているメッセージ。</param>
        <summary>特定のメッセージ内のメソッドがオーバーロードされているかどうかを示す Boolean 値を返します。</summary>
        <returns><see langword="true" /> で呼び出されたメソッドがオーバーロードされている場合は <paramref name="msg" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元に、インフラストラクチャ アクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfAppDomain">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfAppDomain (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfAppDomain(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfAppDomain (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfAppDomain(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfAppDomain : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">確認する対象のオブジェクト。</param>
        <summary>特定の透過プロキシで指定したオブジェクトが、現在のメソッドを呼び出したオブジェクトとは異なるアプリケーション ドメインに格納されているかどうかを示す Boolean 値を返します。</summary>
        <returns>オブジェクトが現在のアプリケーション ドメイン外にある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 アプリケーションドメインの詳細については、「[アプリケーションドメイン](https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90))」を参照してください。



## Examples
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]

 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">アプリケーション ドメイン</related>
      </Docs>
    </Member>
    <Member MemberName="IsObjectOutOfContext">
      <MemberSignature Language="C#" Value="public static bool IsObjectOutOfContext (object tp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsObjectOutOfContext(object tp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsObjectOutOfContext (tp As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsObjectOutOfContext(System::Object ^ tp);" />
      <MemberSignature Language="F#" Value="static member IsObjectOutOfContext : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext tp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tp" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tp">確認する対象のオブジェクト。</param>
        <summary>特定のプロキシによって表されたオブジェクトが、現在のメソッドを呼び出したオブジェクトとは異なるコンテキスト内に格納されているかどうかを示す Boolean 値を返します。</summary>
        <returns>オブジェクトが現在のコンテキスト外にある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 コンテキストとは、その内部に存在するオブジェクトの環境を定義する、順序付けられた一連のプロパティです。 コンテキストは、同期、トランザクション、ジャストインタイムアクティベーション、セキュリティなど、特定の自動サービスを必要とするように構成されているオブジェクトのアクティブ化プロセス中に作成されます。 1 つのコンテキスト内に複数のオブジェクトを常駐させることができます。



## Examples
 [!code-cpp[RemotingServices IsObject Snippets#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CPP/class1.cpp#1)]
 [!code-csharp[RemotingServices IsObject Snippets#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices IsObject Snippets/CS/class1.cs#1)]
 [!code-vb[RemotingServices IsObject Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices IsObject Snippets/VB/class1.vb#1)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Contexts.Context" />
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public static bool IsOneWay (System.Reflection.MethodBase method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOneWay(class System.Reflection.MethodBase method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOneWay (method As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOneWay(System::Reflection::MethodBase ^ method);" />
      <MemberSignature Language="F#" Value="static member IsOneWay : System.Reflection.MethodBase -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsOneWay method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="method">該当するメソッド。</param>
        <summary>特定のメッセージ内で指定したメソッドを呼び出したクライアントが、実行を継続する前に、このメソッドの処理をサーバーが完了するまで待機するかどうかを示す Boolean 値を返します。</summary>
        <returns>メソッドが一方向の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 一方向のメソッドが呼び出されると、クライアントは、サーバーがメッセージの処理を終了するまで待機しません。 クライアントメソッドは、サーバーがメッセージを正常に処理するかどうかを知らずにアプリケーションに戻ります。 メソッドは、<xref:System.Runtime.Remoting.Messaging.OneWayAttribute>を使用して1つの方法としてマークされます。

 一方向のメソッドに戻り値または出力パラメーターを指定することはできません。



## Examples
 [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CPP/remotingservicessample.cpp#2)]
 [!code-csharp[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/CS/remotingservicessample.cs#2)]
 [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Runtime.Remoting.RemotingServices/VB/remotingservicessample.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直前の呼び出し元に、インフラストラクチャ アクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsTransparentProxy">
      <MemberSignature Language="C#" Value="public static bool IsTransparentProxy (object proxy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTransparentProxy(object proxy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsTransparentProxy (proxy As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsTransparentProxy(System::Object ^ proxy);" />
      <MemberSignature Language="F#" Value="static member IsTransparentProxy : obj -&gt; bool" Usage="System.Runtime.Remoting.RemotingServices.IsTransparentProxy proxy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proxy" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="proxy">確認する対象のオブジェクトへの参照。</param>
        <summary>特定のオブジェクトが、透過プロキシまたは実際のオブジェクトのどちらであるかを示す Boolean 値を返します。</summary>
        <returns><paramref name="proxy" /> パラメーターで指定したオブジェクトが、透過プロキシまたは実際のオブジェクトのどちらであるかを示す Boolean 値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 任意の種類のリモート処理境界でオブジェクトを使用するクライアントは、実際にはオブジェクトに対して透過的なプロキシを使用します。 透過プロキシは、実際のオブジェクトがクライアントの領域に存在するという印象を与えます。 これを実現するには、リモート処理インフラストラクチャを使用して、それに対して行われた呼び出しを実際のオブジェクトに転送します。

 透過プロキシ自体は、<xref:System.Runtime.Remoting.Proxies.RealProxy>型のマネージランタイムクラスのインスタンスによって格納されます。 <xref:System.Runtime.Remoting.Proxies.RealProxy> は、透過プロキシから操作を転送するために必要な機能の一部を実装します。 プロキシオブジェクトは、ガベージコレクションなどのマネージオブジェクトの関連付けられたセマンティクス、メンバーとメソッドのサポート、および新しいクラスを作成するために拡張できます。 このため、プロキシには二重の性質があります。一方では、リモートオブジェクト (透過プロキシ) と同じクラスのオブジェクトとして動作する必要があり、もう1つはマネージオブジェクト自体です。

 プロキシオブジェクトは、<xref:System.AppDomain>内のリモート処理の区分に関係なく使用できます。 アプリケーションでは、プロキシ参照とオブジェクト参照を区別する必要がありません。 ただし、アクティブ化、有効期間管理、トランザクションなどの問題を処理するサービスプロバイダーは、このような区別を行う必要があります。



## Examples
 次のコード例は、<xref:System.Runtime.Remoting.RemotingServices.IsTransparentProxy%2A> メソッドを使用して、オブジェクトがプロキシまたは実際のオブジェクトであるかどうかを確認する方法を示しています。 コード例全体については、<xref:System.Runtime.Remoting.Messaging.AsyncResult> クラスの例を参照してください。

 [!code-cpp[AsyncResult.NewExamples#6](~/samples/snippets/cpp/VS_Snippets_CLR/AsyncResult.NewExamples/CPP/ad.cpp#6)]
 [!code-csharp[AsyncResult.NewExamples#6](~/samples/snippets/csharp/VS_Snippets_CLR/AsyncResult.NewExamples/CS/ad.cs#6)]
 [!code-vb[AsyncResult.NewExamples#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/AsyncResult.NewExamples/VB/ad.vb#6)]

 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="LogRemotingStage">
      <MemberSignature Language="C#" Value="public static void LogRemotingStage (int stage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogRemotingStage(int32 stage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogRemotingStage (stage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LogRemotingStage(int stage);" />
      <MemberSignature Language="F#" Value="static member LogRemotingStage : int -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.LogRemotingStage stage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.Conditional("REMOTING_PERF")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("It existed for only internal use in .NET and unimplemented in mono")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use of this method is not recommended. The LogRemotingStage existed for internal diagnostic purposes only.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stage">リモート処理エクスチェンジの段階を示す、内部的に定義されている定数。</param>
        <summary>リモート処理エクスチェンジの段階のログを外部デバッガーに記録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `"REMOTING_PERF"` 前処理シンボルは、<xref:System.Diagnostics.ConditionalAttribute> 属性を使用してメソッドに適用されます。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Marshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>特定の <see cref="T:System.MarshalByRefObject" /> を <see cref="T:System.Runtime.Remoting.ObjRef" /> クラスのインスタンスに変換して、このインスタンスをアプリケーション ドメイン間およびネットワーク上の伝送のためにシリアル化できます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal Obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
      </Parameters>
      <Docs>
        <param name="Obj">変換するオブジェクト。</param>
        <summary><see cref="T:System.MarshalByRefObject" /> を取り、これをリモート処理インフラストラクチャで登録して、<see cref="T:System.Runtime.Remoting.ObjRef" /> クラスのインスタンスに変換します。</summary>
        <returns><see cref="T:System.Runtime.Remoting.ObjRef" /> パラメーターで指定されたオブジェクトを表す <paramref name="Obj" /> クラスのインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Runtime.Remoting.ObjRef> は、アプリケーションドメインの境界を越えてオブジェクト参照を転送するために使用されるオブジェクトのシリアル化可能な表現です。 オブジェクトの <xref:System.Runtime.Remoting.ObjRef> の作成は、マーシャリングと呼ばれます。 <xref:System.Runtime.Remoting.ObjRef> は、チャネルを通じて別のアプリケーションドメイン (別のプロセスまたはコンピューターなど) に転送できます。 もう一方のアプリケーションドメインでは、オブジェクトのプロキシを作成するために <xref:System.Runtime.Remoting.ObjRef> を解析する必要があります。通常、実際のオブジェクトに接続します。 この操作は、マーシャリング解除と呼ばれます。

 <xref:System.Runtime.Remoting.ObjRef> には、マーシャリングされるオブジェクトの <xref:System.Type> とクラス、特定のオブジェクトインスタンスを一意に識別する URI、およびオブジェクトが配置されているリモート処理の部分に対する通信に関する情報が含まれています。

 マーシャリング中に、オブジェクトが作成されたときにアクティブだったコンテキストではなく、現在のスレッドからのコンテキストが使用されます。 URI が <xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A> メソッドによって明示的に設定されていない場合は、リモート処理 id インフラストラクチャによって自動的に生成されます。

 Uri をプロキシに関連付けることはできません。次の2つの理由があります。つまり、uri がサーバー側で生成されたか、オブジェクトが既知である場合、URI は既知です。 このため、`Obj` パラメーターがプロキシの場合、例外がスローされます。 カスタムプロキシの場合、透過プロキシはサーバーオブジェクトとして扱われるため、この制限は緩和されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="Obj" /> パラメーターがオブジェクトのプロキシです。</exception>
        <exception cref="T:System.Security.SecurityException">コールスタックの上位にある 1 つ以上の呼び出し元に、リモート処理の型とチャネルを構成するためのアクセス許可がありません。</exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">アプリケーション ドメイン</related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string URI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, URI As String) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ URI);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, URI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="URI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Obj">変換するオブジェクト。</param>
        <param name="URI">新しい <see cref="T:System.Runtime.Remoting.ObjRef" /> を初期化するために使用する指定した URI。 <see langword="null" /> を指定できます。</param>
        <summary>特定の <see cref="T:System.MarshalByRefObject" /> を、指定した URI を持つ <see cref="T:System.Runtime.Remoting.ObjRef" /> クラスのインスタンスに変換します。</summary>
        <returns><see cref="T:System.Runtime.Remoting.ObjRef" /> パラメーターで指定されたオブジェクトを表す <paramref name="Obj" /> クラスのインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Runtime.Remoting.ObjRef> は、アプリケーションドメインの境界を越えてオブジェクト参照を転送するために使用されるオブジェクトのシリアル化可能な表現です。 オブジェクトの <xref:System.Runtime.Remoting.ObjRef> の作成は、マーシャリングと呼ばれます。 <xref:System.Runtime.Remoting.ObjRef> は、チャネルを通じて別のアプリケーションドメイン (別のプロセスまたはコンピューターなど) に転送できます。 もう一方のアプリケーションドメインでは、オブジェクトのプロキシを作成するために <xref:System.Runtime.Remoting.ObjRef> を解析する必要があります。通常、実際のオブジェクトに接続します。 この操作は、マーシャリング解除と呼ばれます。

 <xref:System.Runtime.Remoting.ObjRef> には、マーシャリングされるオブジェクトの <xref:System.Type> とクラス、特定のオブジェクトインスタンスを一意に識別する URI、およびオブジェクトが配置されているリモート処理の部分に対する通信に関する情報が含まれています。

 マーシャリング中に、オブジェクトが作成されたときにアクティブだったコンテキストではなく、現在のスレッドからのコンテキストが使用されます。

 Uri をプロキシに関連付けることはできません。次の2つの理由があります。つまり、uri がサーバー側で生成されたか、オブジェクトが既知である場合、URI は既知です。 このため、`Obj` パラメーターがプロキシの場合、例外がスローされます。 カスタムプロキシの場合、透過プロキシはサーバーオブジェクトとして扱われるため、この制限は緩和されます。



## Examples
 次のコード例は、現在の <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> メソッドを使用して、指定されたオブジェクトをマーシャリングする方法を示しています。

 [!code-cpp[RemotingServices.BasicSample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.BasicSample/CPP/manualserver.cpp#2)]
 [!code-csharp[RemotingServices.BasicSample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.BasicSample/CS/manualserver.cs#2)]
 [!code-vb[RemotingServices.BasicSample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.BasicSample/VB/manualserver.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="Obj" /> がオブジェクト プロキシであり、<paramref name="URI" /> パラメーターが <see langword="null" /> ではありません。</exception>
        <exception cref="T:System.Security.SecurityException">コールスタックの上位にある 1 つ以上の呼び出し元に、リモート処理の型とチャネルを構成するためのアクセス許可がありません。</exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">アプリケーション ドメイン</related>
      </Docs>
    </Member>
    <Member MemberName="Marshal">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjRef Marshal(class System.MarshalByRefObject Obj, string ObjURI, class System.Type RequestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Marshal (Obj As MarshalByRefObject, ObjURI As String, RequestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjRef ^ Marshal(MarshalByRefObject ^ Obj, System::String ^ ObjURI, Type ^ RequestedType);" />
      <MemberSignature Language="F#" Value="static member Marshal : MarshalByRefObject * string * Type -&gt; System.Runtime.Remoting.ObjRef" Usage="System.Runtime.Remoting.RemotingServices.Marshal (Obj, ObjURI, RequestedType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Obj" Type="System.MarshalByRefObject" />
        <Parameter Name="ObjURI" Type="System.String" />
        <Parameter Name="RequestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="Obj"><see cref="T:System.Runtime.Remoting.ObjRef" /> に変換するオブジェクト。</param>
        <param name="ObjURI"><paramref name="Obj" /> パラメーターで指定したオブジェクトがマーシャリングされるときに使用する URI。 <see langword="null" /> を指定できます。</param>
        <param name="RequestedType"><see cref="T:System.Type" /> がマーシャリングされるときの <paramref name="Obj" />。 <see langword="null" /> を指定できます。</param>
        <summary><see cref="T:System.MarshalByRefObject" /> を取り、これを指定した URI と提供された <see cref="T:System.Runtime.Remoting.ObjRef" /> を持つ、<see cref="T:System.Type" /> クラスのインスタンスに変換します。</summary>
        <returns><see cref="T:System.Runtime.Remoting.ObjRef" /> パラメーターで指定されたオブジェクトを表す <paramref name="Obj" /> クラスのインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Runtime.Remoting.ObjRef> は、アプリケーションドメインの境界を越えてオブジェクト参照を転送するために使用されるオブジェクトのシリアル化可能な表現です。 オブジェクトの <xref:System.Runtime.Remoting.ObjRef> の作成は、マーシャリングと呼ばれます。 <xref:System.Runtime.Remoting.ObjRef> は、チャネルを通じて別のアプリケーションドメイン (別のプロセスまたはコンピューターなど) に転送できます。 もう一方のアプリケーションドメインでは、オブジェクトのプロキシを作成するために <xref:System.Runtime.Remoting.ObjRef> を解析する必要があります。通常、実際のオブジェクトに接続します。 この操作は、マーシャリング解除と呼ばれます。

 <xref:System.Runtime.Remoting.ObjRef> には、マーシャリングされるオブジェクトの <xref:System.Type> とクラス、特定のオブジェクトインスタンスを一意に識別する URI、およびオブジェクトが配置されているリモート処理の部分に対する通信に関する情報が含まれています。

 指定された <xref:System.Type> は、公開される型階層のスコープを制限するために、リモート処理インフラストラクチャによって使用されます。 たとえば、オブジェクト A がオブジェクト C から派生したオブジェクト B から派生し、<xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> が呼び出された場合、クライアントは C と B の間にプロキシをキャストできますが、にはキャストできません。

 マーシャリング中に、オブジェクトが作成されたときにアクティブだったコンテキストではなく、現在のスレッドからのコンテキストが使用されます。

 Uri をプロキシに関連付けることはできません。次の2つの理由があります。つまり、uri がサーバー側で生成されたか、オブジェクトが既知である場合、URI は既知です。 このため、`Obj` パラメーターがプロキシの場合、例外がスローされます。 カスタムプロキシの場合、透過プロキシはサーバーオブジェクトとして扱われるため、この制限は緩和されます。

 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="Obj" /> がリモート オブジェクトのプロキシであり、<paramref name="ObjUri" /> パラメーターが <see langword="null" /> ではありません。</exception>
        <exception cref="T:System.Security.SecurityException">コールスタックの上位にある 1 つ以上の呼び出し元に、リモート処理の型とチャネルを構成するためのアクセス許可がありません。</exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/visualstudio/visual-studio-2008/cxk374d9(v=vs.90)">アプリケーション ドメイン</related>
      </Docs>
    </Member>
    <Member MemberName="SetObjectUriForMarshal">
      <MemberSignature Language="C#" Value="public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetObjectUriForMarshal(class System.MarshalByRefObject obj, string uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetObjectUriForMarshal (obj As MarshalByRefObject, uri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetObjectUriForMarshal(MarshalByRefObject ^ obj, System::String ^ uri);" />
      <MemberSignature Language="F#" Value="static member SetObjectUriForMarshal : MarshalByRefObject * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal (obj, uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.MarshalByRefObject" />
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">URI を設定する対象となるオブジェクト。</param>
        <param name="uri">指定したオブジェクトに割り当てる URI。</param>
        <summary><see cref="M:System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)" /> メソッドへの後続の呼び出しに対して URI を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 現在のメソッドによって設定された URI は、指定されたオブジェクトをマーシャリングするときに使用されます。

 マーシャリング後、指定したオブジェクトの URI は、現在の <xref:System.AppDomain>の <xref:System.Guid> に追加された `uri` パラメーターの文字列に設定されます。

 現在のアプリケーションが HTTP ポートでリッスンしている場合は、`uri` パラメーターに指定された文字列と、指定されたオブジェクトへの現在の <xref:System.AppDomain> ルートの <xref:System.Guid> に `uri` 文字列が追加されます。 たとえば、アプリケーションが HTTP ポート9000でリッスンしている場合、`http://localhost:9000/objectUri`、`http://localhost:9000/<appdomainguid>/objectUri`、`obj` パラメーターで指定されたオブジェクトにルーティングされます。



## Examples
 次のコード例は、指定されたオブジェクトをマーシャリングするときに、<xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> メソッドによって使用される URI を設定する方法を示しています。

 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException"><paramref name="obj" /> がローカル オブジェクトではありません。既にマーシャリングされています。または、現在のメソッドが既に呼び出されています。</exception>
        <exception cref="T:System.Security.SecurityException">コールスタックの上位にある 1 つ以上の呼び出し元に、リモート処理の型とチャネルを構成するためのアクセス許可がありません。</exception>
        <altmember cref="T:System.Uri" />
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unmarshal">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>特定の <see cref="T:System.Runtime.Remoting.ObjRef" /> をプロキシ オブジェクトに変換します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal objectRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
      </Parameters>
      <Docs>
        <param name="objectRef">プロキシが作成される対象のリモート オブジェクトを表す <see cref="T:System.Runtime.Remoting.ObjRef" />。</param>
        <summary><see cref="T:System.Runtime.Remoting.ObjRef" /> を取得し、これからプロキシ オブジェクトを作成します。</summary>
        <returns>特定の <see cref="T:System.Runtime.Remoting.ObjRef" /> が表すオブジェクトへのプロキシ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Runtime.Remoting.ObjRef> は、アプリケーションドメインの境界を越えてオブジェクト参照を転送するために使用されるオブジェクトのシリアル化可能な表現です。 オブジェクトの <xref:System.Runtime.Remoting.ObjRef> の作成は、マーシャリングと呼ばれます。 <xref:System.Runtime.Remoting.ObjRef> は、チャネルを通じて別のアプリケーションドメイン (別のプロセスまたはコンピューターなど) に転送できます。 もう一方のアプリケーションドメインでは、オブジェクトのプロキシを作成するために <xref:System.Runtime.Remoting.ObjRef> を解析する必要があります。通常、実際のオブジェクトに接続します。 この操作は、マーシャリング解除と呼ばれます。 マーシャリング解除中に、<xref:System.Runtime.Remoting.ObjRef> が解析され、リモートオブジェクトのメソッド情報が抽出され、透過プロキシと <xref:System.Runtime.Remoting.Proxies.RealProxy> オブジェクトの両方が作成されます。 透過プロキシが共通言語ランタイムに登録される前に、解析された <xref:System.Runtime.Remoting.ObjRef> の内容が透過プロキシに追加されます。

 <xref:System.Runtime.Remoting.ObjRef> には、マーシャリングされるオブジェクトの <xref:System.Type> とクラス、特定のオブジェクトインスタンスを一意に識別する URI、およびオブジェクトが配置されているリモート処理の部分に対する通信に関する情報が含まれています。



## Examples
 次のコード例は、オブジェクトのマーシャリングを解除する方法を示しています。

 [!code-cpp[RemotingServices.Unmarshal#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CPP/client.cpp#2)]
 [!code-csharp[RemotingServices.Unmarshal#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingServices.Unmarshal/CS/client.cs#2)]
 [!code-vb[RemotingServices.Unmarshal#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingServices.Unmarshal/VB/client.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Runtime.Remoting.ObjRef" /> パラメーターで指定した <paramref name="objectRef" /> インスタンスが適切に構成されていません。</exception>
        <exception cref="T:System.Security.SecurityException">コールスタックの上位にある 1 つ以上の呼び出し元に、リモート処理の型とチャネルを構成するためのアクセス許可がありません。</exception>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
    <Member MemberName="Unmarshal">
      <MemberSignature Language="C#" Value="public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Unmarshal(class System.Runtime.Remoting.ObjRef objectRef, bool fRefine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unmarshal (objectRef As ObjRef, fRefine As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Unmarshal(System::Runtime::Remoting::ObjRef ^ objectRef, bool fRefine);" />
      <MemberSignature Language="F#" Value="static member Unmarshal : System.Runtime.Remoting.ObjRef * bool -&gt; obj" Usage="System.Runtime.Remoting.RemotingServices.Unmarshal (objectRef, fRefine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectRef" Type="System.Runtime.Remoting.ObjRef" />
        <Parameter Name="fRefine" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="objectRef">プロキシが作成される対象のリモート オブジェクトを表す <see cref="T:System.Runtime.Remoting.ObjRef" />。</param>
        <param name="fRefine">サーバーにある型に対してプロキシを詳細に指定する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Runtime.Remoting.ObjRef" /> を取得し、これからプロキシ オブジェクトを作成し、サーバーにある型に対してこのプロキシ オブジェクトを詳細に指定します。</summary>
        <returns>特定の <see cref="T:System.Runtime.Remoting.ObjRef" /> が表すオブジェクトへのプロキシ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Runtime.Remoting.ObjRef> は、アプリケーションドメインの境界を越えてオブジェクト参照を転送するために使用されるオブジェクトのシリアル化可能な表現です。 オブジェクトの <xref:System.Runtime.Remoting.ObjRef> の作成は、マーシャリングと呼ばれます。 <xref:System.Runtime.Remoting.ObjRef> は、チャネルを通じて別のアプリケーションドメイン (別のプロセスまたはコンピューターなど) に転送できます。 もう一方のアプリケーションドメインでは、オブジェクトのプロキシを作成するために <xref:System.Runtime.Remoting.ObjRef> を解析する必要があります。通常、実際のオブジェクトに接続します。 この操作は、マーシャリング解除と呼ばれます。 マーシャリング解除中に、<xref:System.Runtime.Remoting.ObjRef> が解析され、リモートオブジェクトのメソッド情報が抽出され、透過プロキシと <xref:System.Runtime.Remoting.Proxies.RealProxy> オブジェクトの両方が作成されます。 透過プロキシが共通言語ランタイムに登録される前に、解析された <xref:System.Runtime.Remoting.ObjRef> の内容が透過プロキシに追加されます。

 <xref:System.Runtime.Remoting.ObjRef> には、マーシャリングされるオブジェクトの <xref:System.Type> とクラス、特定のオブジェクトインスタンスを一意に識別する URI、およびオブジェクトが配置されているリモート処理の部分に対する通信に関する情報が含まれています。

 プロキシは、最初に作成されたときに <xref:System.MarshalByRefObject>型になります。 この型を別の型にキャストすると、リモート処理インフラストラクチャは、型が不必要に読み込まれないように、最も使用されている型を追跡します。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Runtime.Remoting.ObjRef" /> パラメーターで指定した <paramref name="objectRef" /> インスタンスが適切に構成されていません。</exception>
        <exception cref="T:System.Security.SecurityException">コールスタックの上位にある 1 つ以上の呼び出し元に、リモート処理の型とチャネルを構成するためのアクセス許可がありません。</exception>
        <altmember cref="T:System.Runtime.Remoting.Proxies.RealProxy" />
        <altmember cref="T:System.Runtime.Remoting.ObjRef" />
      </Docs>
    </Member>
  </Members>
</Type>
