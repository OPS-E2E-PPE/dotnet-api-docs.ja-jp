<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5060134ecbdeaec5293e426623e57eb461ac9ad6" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83945732" /></Metadata><TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Threading.Tasks" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="5.0.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.0.0" To="System.Runtime" ToVersion="4.2.0.0" FrameworkAlternate="netcore-2.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.1.0" To="System.Runtime" ToVersion="4.2.1.0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
    <TypeForwarding From="System.Threading.Tasks" FromVersion="4.1.2.0" To="System.Runtime" ToVersion="4.2.2.0" FrameworkAlternate="netcore-3.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="25428-101">スレッドのキューにタスクを置くという下位の作業を処理するオブジェクトを表します。</span><span class="sxs-lookup"><span data-stu-id="25428-101">Represents an object that handles the low-level work of queuing tasks onto threads.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25428-102"><xref:System.Threading.Tasks.TaskScheduler> クラスのインスタンスは、タスクスケジューラを表します。</span><span class="sxs-lookup"><span data-stu-id="25428-102">An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler.</span></span> <span data-ttu-id="25428-103">タスク スケジューラは、タスクの作業が最終的に実行されるようにします。</span><span class="sxs-lookup"><span data-stu-id="25428-103">A task scheduler ensures that the work of a task is eventually executed.</span></span>  
  
 <span data-ttu-id="25428-104">既定のタスク スケジューラは、負荷分散、スループット最大化のためのスレッドのインジェクション/リタイヤ、および全体のパフォーマンスの向上のためのワーク スティーリングを提供する .NET Framework 4 スレッド プールに基づいています。</span><span class="sxs-lookup"><span data-stu-id="25428-104">The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</span></span> <span data-ttu-id="25428-105">ほとんどのシナリオでは、既定のタスク スケジューラで十分です。</span><span class="sxs-lookup"><span data-stu-id="25428-105">It should be sufficient for most scenarios.</span></span>  
  
 <span data-ttu-id="25428-106"><xref:System.Threading.Tasks.TaskScheduler> クラスは、カスタマイズ可能なすべてのスケジューリングロジックの拡張ポイントとしても機能します。</span><span class="sxs-lookup"><span data-stu-id="25428-106">The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.</span></span>  <span data-ttu-id="25428-107">これには、実行するタスクをスケジュールする方法や、スケジュールされたタスクをデバッガーに公開する方法などのメカニズムが含まれます。</span><span class="sxs-lookup"><span data-stu-id="25428-107">This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</span></span> <span data-ttu-id="25428-108">特別な機能が必要な場合は、カスタムスケジューラを作成し、特定のタスクまたはクエリに対して有効にすることができます。</span><span class="sxs-lookup"><span data-stu-id="25428-108">If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</span></span>  
  
 <span data-ttu-id="25428-109">このトピックの内容:</span><span class="sxs-lookup"><span data-stu-id="25428-109">In this topic:</span></span>  
[<span data-ttu-id="25428-110">既定のタスクスケジューラとスレッドプール</span><span class="sxs-lookup"><span data-stu-id="25428-110">The default task scheduler and the thread pool</span></span>](#Default)  
 [<span data-ttu-id="25428-111">グローバルキューとローカルキュー</span><span class="sxs-lookup"><span data-stu-id="25428-111">The global queue vs. local queues</span></span>](#Queues)  
 [<span data-ttu-id="25428-112">作業の盗難</span><span class="sxs-lookup"><span data-stu-id="25428-112">Work stealing</span></span>](#Stealing)  
 [<span data-ttu-id="25428-113">長時間実行されるタスク</span><span class="sxs-lookup"><span data-stu-id="25428-113">Long-running tasks</span></span>](#LongRunning)  
 [<span data-ttu-id="25428-114">タスクのインライン展開</span><span class="sxs-lookup"><span data-stu-id="25428-114">Task inlining</span></span>](#Inlining)  
[<span data-ttu-id="25428-115">同期コンテキストの指定</span><span class="sxs-lookup"><span data-stu-id="25428-115">Specifying a synchronization context</span></span>](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a><span data-ttu-id="25428-116">既定のタスクスケジューラとスレッドプール</span><span class="sxs-lookup"><span data-stu-id="25428-116">The default task scheduler and the thread pool</span></span>  
 <span data-ttu-id="25428-117">タスク並列ライブラリと PLINQ の既定のスケジューラは、<xref:System.Threading.ThreadPool> クラスによって表される .NET Framework スレッドプールを使用して、作業をキューに置いて実行します。</span><span class="sxs-lookup"><span data-stu-id="25428-117">The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work.</span></span> <span data-ttu-id="25428-118">スレッドプールは、<xref:System.Threading.Tasks.Task> 型によって提供される情報を使用して、並列タスクとクエリが表すことのできる粒度の細かい並列処理 (短時間の作業単位) を効率的にサポートします。</span><span class="sxs-lookup"><span data-stu-id="25428-118">The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</span></span>  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a><span data-ttu-id="25428-119">グローバルキューとローカルキュー</span><span class="sxs-lookup"><span data-stu-id="25428-119">The global queue vs. local queues</span></span>  
 <span data-ttu-id="25428-120">スレッドプールは、各アプリケーションドメインのスレッドに対して、グローバル FIFO (先入れ先出し) 作業キューを保持します。</span><span class="sxs-lookup"><span data-stu-id="25428-120">The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</span></span> <span data-ttu-id="25428-121">プログラムが <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (または <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) メソッドを呼び出すたびに、作業はこの共有キューに配置され、最終的には使用可能になった次のスレッドにキューから解除されます。</span><span class="sxs-lookup"><span data-stu-id="25428-121">Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</span></span> <span data-ttu-id="25428-122">.NET Framework 4 以降では、このキューが改善され、<xref:System.Collections.Concurrent.ConcurrentQueue%601> クラスに似たロック解放アルゴリズムが使用されるようになりました。</span><span class="sxs-lookup"><span data-stu-id="25428-122">Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class.</span></span> <span data-ttu-id="25428-123">このロックフリーの実装を使用することにより、スレッドプールは作業項目をキューに置いたり、キューから除外したりする時間を短縮します。</span><span class="sxs-lookup"><span data-stu-id="25428-123">By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</span></span> <span data-ttu-id="25428-124">このパフォーマンス上の利点は、スレッドプールを使用するすべてのプログラムで利用できます。</span><span class="sxs-lookup"><span data-stu-id="25428-124">This performance benefit is available to all programs that use the thread pool.</span></span>  
  
 <span data-ttu-id="25428-125">トップレベル タスクは、別のタスクのコンテキストで作成されないタスクのことで、他の作業項目と同様にグローバル キューに配置されます。</span><span class="sxs-lookup"><span data-stu-id="25428-125">Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</span></span> <span data-ttu-id="25428-126">ただし、別のタスクのコンテキストで作成される入れ子のタスクまたは子タスクは、まったく異なる方法で処理されます。</span><span class="sxs-lookup"><span data-stu-id="25428-126">However, nested or child tasks, which are created in the context of another task, are handled quite differently.</span></span> <span data-ttu-id="25428-127">子タスクまたは入れ子のタスクは、親タスクが実行されているスレッドに固有のローカル キューに配置されます。</span><span class="sxs-lookup"><span data-stu-id="25428-127">A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</span></span> <span data-ttu-id="25428-128">親タスクはトップレベルのタスクである場合もあれば、別のタスクの子である場合もあります。</span><span class="sxs-lookup"><span data-stu-id="25428-128">The parent task may be a top-level task or it also may be the child of another task.</span></span> <span data-ttu-id="25428-129">このスレッドは、追加の作業を処理する準備が整ったら、最初にローカル キューを検索します。</span><span class="sxs-lookup"><span data-stu-id="25428-129">When this thread is ready for more work, it first looks in the local queue.</span></span> <span data-ttu-id="25428-130">作業項目がローカル キューで待機している場合は、それらにすばやくアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="25428-130">If work items are waiting there, they can be accessed quickly.</span></span> <span data-ttu-id="25428-131">キャッシュの局所性を維持し、競合を減らすために、ローカルキューには後入れ先出し (LIFO) でアクセスします。</span><span class="sxs-lookup"><span data-stu-id="25428-131">The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</span></span> <span data-ttu-id="25428-132">子タスクと入れ子になったタスクの詳細については、「[アタッチおよびデタッチされた子タスク](/dotnet/standard/parallel-programming/attached-and-detached-child-tasks)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="25428-132">For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](/dotnet/standard/parallel-programming/attached-and-detached-child-tasks).</span></span>  
  
 <span data-ttu-id="25428-133">ローカルキューを使用すると、グローバルキューの負荷が軽減されるだけでなく、データの局所性も利用できます。</span><span class="sxs-lookup"><span data-stu-id="25428-133">The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</span></span> <span data-ttu-id="25428-134">ローカルキュー内の作業項目は、多くの場合、メモリ内に物理的に近いデータ構造を参照します。</span><span class="sxs-lookup"><span data-stu-id="25428-134">Work items in the local queue frequently reference data structures that are physically near one another in memory.</span></span> <span data-ttu-id="25428-135">このような場合は、最初のタスクが実行された後にデータがキャッシュに既に存在し、すぐにアクセスできるようになります。</span><span class="sxs-lookup"><span data-stu-id="25428-135">In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</span></span> <span data-ttu-id="25428-136">[並列 LINQ (PLINQ)](/dotnet/standard/parallel-programming/parallel-linq-plinq)と <xref:System.Threading.Tasks.Parallel> クラスは、入れ子になったタスクと子タスクを広範囲に使用し、ローカルの作業キューを使用して重要な高速化を実現します。</span><span class="sxs-lookup"><span data-stu-id="25428-136">Both [Parallel LINQ (PLINQ)](/dotnet/standard/parallel-programming/parallel-linq-plinq) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</span></span>  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a><span data-ttu-id="25428-137">作業の盗難</span><span class="sxs-lookup"><span data-stu-id="25428-137">Work stealing</span></span>  
 <span data-ttu-id="25428-138">.NET Framework 4 以降では、スレッドプールにもワークスティーリングアルゴリズムが用意されており、他のスレッドがキューで動作している間は、スレッドがアイドル状態にならないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="25428-138">Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</span></span> <span data-ttu-id="25428-139">スレッド プールのスレッドは、追加の作業を処理する準備が整ったら、最初にローカル キューの先頭を探します。次にグローバル キューを探し、最後に他のスレッドのローカル キューを探します。</span><span class="sxs-lookup"><span data-stu-id="25428-139">When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</span></span> <span data-ttu-id="25428-140">別のスレッドのローカル キューで作業項目が見つかった場合、作業を効率的に実行できるように、最初にヒューリスティックを適用します。</span><span class="sxs-lookup"><span data-stu-id="25428-140">If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</span></span> <span data-ttu-id="25428-141">可能な場合は、(FIFO の順序で) 末尾から作業項目のキューを解除します。</span><span class="sxs-lookup"><span data-stu-id="25428-141">If it can, it de-queues the work item from the tail (in FIFO order).</span></span> <span data-ttu-id="25428-142">これにより、各ローカル キューでの競合が減り、データの局所性が保持されます。</span><span class="sxs-lookup"><span data-stu-id="25428-142">This reduces contention on each local queue and preserves data locality.</span></span> <span data-ttu-id="25428-143">このアーキテクチャでは、スレッドプールの負荷分散を、過去のバージョンよりも効率的に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="25428-143">This architecture helps the thread pool load-balance work more efficiently than past versions did.</span></span>  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a><span data-ttu-id="25428-144">長時間実行されるタスク</span><span class="sxs-lookup"><span data-stu-id="25428-144">Long-running tasks</span></span>  
 <span data-ttu-id="25428-145">タスクがローカル キューに配置されるのを明示的に防止したい場合があります。</span><span class="sxs-lookup"><span data-stu-id="25428-145">You may want to explicitly prevent a task from being put on a local queue.</span></span> <span data-ttu-id="25428-146">たとえば、特定の作業項目がかなり長い時間実行され、ローカル キューの他の作業項目をすべてブロックする可能性があることがわかっている場合などです。</span><span class="sxs-lookup"><span data-stu-id="25428-146">For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</span></span> <span data-ttu-id="25428-147">このような場合は、<xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> オプションを指定できます。このオプションは、タスクの処理に追加のスレッドが必要になる可能性があるというヒントをスケジューラに提供し、他のスレッドまたはローカル キューの作業項目の進行をスケジューラがブロックするのを防ぎます。</span><span class="sxs-lookup"><span data-stu-id="25428-147">In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</span></span> <span data-ttu-id="25428-148">このオプションを使用すると、グローバルキューとローカルキューを含め、スレッドプールを完全に回避できます。</span><span class="sxs-lookup"><span data-stu-id="25428-148">By using this option you avoid the thread pool completely, including the global and local queues.</span></span>  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a><span data-ttu-id="25428-149">タスクのインライン展開</span><span class="sxs-lookup"><span data-stu-id="25428-149">Task inlining</span></span>  
 <span data-ttu-id="25428-150"><xref:System.Threading.Tasks.Task> が待機している場合、待機操作を実行しているスレッド上で同期的に実行されることがあります。</span><span class="sxs-lookup"><span data-stu-id="25428-150">In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</span></span> <span data-ttu-id="25428-151">これにより、追加のスレッドが不要になり、既存のスレッドを使用するのではなく、他のスレッドがブロックされてしまうため、パフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="25428-151">This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</span></span> <span data-ttu-id="25428-152">再入によるエラーを回避するために、タスクのインライン展開は、関連するスレッドのローカルキューで待機対象が見つかった場合にのみ発生します。</span><span class="sxs-lookup"><span data-stu-id="25428-152">To prevent errors due to reentrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</span></span>  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a><span data-ttu-id="25428-153">同期コンテキストの指定</span><span class="sxs-lookup"><span data-stu-id="25428-153">Specifying a synchronization context</span></span>  
 <span data-ttu-id="25428-154"><xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> メソッドを使用すると、タスクが特定のスレッドで実行されるようにスケジュールできます。</span><span class="sxs-lookup"><span data-stu-id="25428-154">You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method to specify that a task should be scheduled to run on a particular thread.</span></span> <span data-ttu-id="25428-155">これは、Windows フォームや Windows Presentation Foundation などのフレームワークで役立ちます。これらのフレームワークでは、多くの場合、ユーザー インターフェイス オブジェクトへのアクセスが、その UI オブジェクトが作成されたスレッドで実行されているコードに制限されるからです。</span><span class="sxs-lookup"><span data-stu-id="25428-155">This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</span></span>  
  
 <span data-ttu-id="25428-156">次の例では、Windows Presentation Foundation (WPF) アプリの <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> メソッドを使用して、ユーザーインターフェイス (UI) コントロールが作成されたのと同じスレッド上でタスクをスケジュールします。</span><span class="sxs-lookup"><span data-stu-id="25428-156">The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</span></span>   <span data-ttu-id="25428-157">この例では、指定されたディレクトリからランダムに選択されたイメージのモザイクを作成します。</span><span class="sxs-lookup"><span data-stu-id="25428-157">The example creates a mosaic of images that are randomly selected from a specified directory.</span></span> <span data-ttu-id="25428-158">WPF オブジェクトは、イメージの読み込みとサイズ変更に使用されます。</span><span class="sxs-lookup"><span data-stu-id="25428-158">The WPF objects are used to load and resize the images.</span></span> <span data-ttu-id="25428-159">その後、生のピクセルは、<xref:System.Threading.Tasks.Parallel.For%2A> ループを使用して、ピクセルデータを大きな1バイト配列に書き込むタスクに渡されます。</span><span class="sxs-lookup"><span data-stu-id="25428-159">The raw pixels are then passed to a task that uses a <xref:System.Threading.Tasks.Parallel.For%2A> loop to write the pixel data into a large single-byte array.</span></span> <span data-ttu-id="25428-160">2つのタイルで同じ配列要素が占有されていないため、同期は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="25428-160">No synchronization is required because no two tiles occupy the same array elements.</span></span> <span data-ttu-id="25428-161">また、タイルは他のタイルとは別に計算されるため、任意の順序で書き込むこともできます。</span><span class="sxs-lookup"><span data-stu-id="25428-161">The tiles can also be written in any order because their position is calculated independently of any other tile.</span></span> <span data-ttu-id="25428-162">その後、大きな配列が UI スレッドで実行されるタスクに渡され、そこでピクセルデータがイメージコントロールに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="25428-162">The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</span></span>  
  
 <span data-ttu-id="25428-163">この例では、データを UI スレッドから移動し、並列ループと <xref:System.Threading.Tasks.Task> オブジェクトを使用して変更してから、UI スレッドで実行されるタスクに渡します。</span><span class="sxs-lookup"><span data-stu-id="25428-163">The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread.</span></span> <span data-ttu-id="25428-164">この方法は、タスク並列ライブラリを使用して、WPF API でサポートされていない操作や、十分に高速ではない操作を実行する必要がある場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="25428-164">This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</span></span> <span data-ttu-id="25428-165">WPF でイメージのモザイクを作成する別の方法として、<xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> コントロールを使用してイメージを追加する方法があります。</span><span class="sxs-lookup"><span data-stu-id="25428-165">Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> control and add images to it.</span></span> <span data-ttu-id="25428-166"><xref:System.Windows.Controls.WrapPanel> は、タイルを配置する作業を処理します。</span><span class="sxs-lookup"><span data-stu-id="25428-166">The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles.</span></span> <span data-ttu-id="25428-167">ただし、この作業は UI スレッドでのみ実行できます。</span><span class="sxs-lookup"><span data-stu-id="25428-167">However, this work can only be performed on the UI thread.</span></span>  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 <span data-ttu-id="25428-168">この例を作成するには、Visual Studio で WPF アプリケーションプロジェクトを作成し、WPF_CS1 ( C# wpf プロジェクトの場合) または WPF_VB1 (VISUAL BASIC wpf プロジェクトの場合) という名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="25428-168">To create the example, create a WPF application project in Visual Studio and name it WPF_CS1 (for a C# WPF project) or WPF_VB1 (for a Visual Basic WPF project).</span></span> <span data-ttu-id="25428-169">次に、次を実行します。</span><span class="sxs-lookup"><span data-stu-id="25428-169">Then do the following:</span></span>  
  
1. <span data-ttu-id="25428-170">デザインビューで、**[ツールボックス]** からデザインサーフェイスの左上隅に <xref:System.Windows.Controls.Image> コントロールをドラッグします。</span><span class="sxs-lookup"><span data-stu-id="25428-170">In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** onto the upper left corner of the design surface.</span></span> <span data-ttu-id="25428-171">**[プロパティ]** ウィンドウの **[名前]** ボックスに、コントロールに "image" という名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="25428-171">In the **Name** textbox of the **Properties** window, name the control "image".</span></span>    
  
2. <span data-ttu-id="25428-172"><xref:System.Windows.Controls.Button> コントロールを **[ツールボックス]** からアプリケーションウィンドウの左下の部分にドラッグします。</span><span class="sxs-lookup"><span data-stu-id="25428-172">Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window.</span></span> <span data-ttu-id="25428-173">XAML ビューで、ボタンの <xref:System.Windows.Controls.ContentControl.Content%2A> プロパティを "モザイクを作成する" として指定し、その <xref:System.Windows.FrameworkElement.Width> プロパティを "100" として指定します。</span><span class="sxs-lookup"><span data-stu-id="25428-173">In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as "Make a mosaic", and specify its <xref:System.Windows.FrameworkElement.Width> property as "100".</span></span> <span data-ttu-id="25428-174">`<Button>` 要素に `Click="button_Click"` を追加して、<xref:System.Windows.Controls.Primitives.ButtonBase.Click> イベントを例のコードで定義されている `button_Click` イベントハンドラーと接続します。</span><span class="sxs-lookup"><span data-stu-id="25428-174">Connect the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with the `button_Click` event handler defined in the example's code by adding `Click="button_Click"` to the `<Button>` element.</span></span> <span data-ttu-id="25428-175">**[プロパティ]** ウィンドウの **[名前]** ボックスに、コントロールに "button" という名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="25428-175">In the **Name** textbox of the **Properties** window, name the control "button".</span></span>  
  
3. <span data-ttu-id="25428-176">MainWindow.xaml.cs または Mainwindow.xaml ファイルの内容全体を、この例のコードに置き換えます。</span><span class="sxs-lookup"><span data-stu-id="25428-176">Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</span></span> <span data-ttu-id="25428-177">C# WPF プロジェクトの場合は、ワークスペースの名前がプロジェクト名と一致していることを確認します。</span><span class="sxs-lookup"><span data-stu-id="25428-177">For a C# WPF project, make sure that the name of the workspace matches the project name.</span></span> 
  
4. <span data-ttu-id="25428-178">この例では、C:\Users\Public\Pictures\Sample Pictures\\という名前のディレクトリから JPEG イメージを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="25428-178">The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures\\.</span></span> <span data-ttu-id="25428-179">ディレクトリを作成し、その中にイメージを配置するか、またはイメージを含む他のディレクトリを参照するようにパスを変更します。</span><span class="sxs-lookup"><span data-stu-id="25428-179">Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</span></span> 
  
<span data-ttu-id="25428-180">この例にはいくつかの制限があります。</span><span class="sxs-lookup"><span data-stu-id="25428-180">This example has some limitations.</span></span> <span data-ttu-id="25428-181">たとえば、32ビット/ピクセルのイメージのみがサポートされています。サイズ変更操作中に、<xref:System.Windows.Media.Imaging.BitmapImage> オブジェクトによって、他の形式の画像が破損しています。</span><span class="sxs-lookup"><span data-stu-id="25428-181">For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation.</span></span> <span data-ttu-id="25428-182">また、ソースイメージはすべて、タイルのサイズよりも大きくする必要があります。</span><span class="sxs-lookup"><span data-stu-id="25428-182">Also, the source images must all be larger than the tile size.</span></span> <span data-ttu-id="25428-183">さらに演習として、複数のピクセル形式とファイルサイズを処理する機能を追加することもできます。</span><span class="sxs-lookup"><span data-stu-id="25428-183">As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</span></span>  
  
## Examples  
 <span data-ttu-id="25428-184">次の例は、MSDN コードギャラリー Web サイトの[.NET Framework 4 を使用した並列プログラミングのサンプル](https://go.microsoft.com/fwlink/?LinkID=165717)から抜粋したものです。</span><span class="sxs-lookup"><span data-stu-id="25428-184">The following example is taken from the [Samples for Parallel Programming with the .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) on the MSDN Code Gallery Web site.</span></span>  <span data-ttu-id="25428-185">アプリによって使用されるスレッドの数を制限するカスタムタスクスケジューラが作成されます。</span><span class="sxs-lookup"><span data-stu-id="25428-185">It creates a custom task scheduler that limits the number of threads used by the app.</span></span> <span data-ttu-id="25428-186">次に、2つのタスクセットを起動し、タスクおよびタスクが実行されているスレッドに関する情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="25428-186">It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</span></span>  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 <span data-ttu-id="25428-187">さらに、コードギャラリーのサンプルタスクスケジューラがいくつか用意されています。 [.NET Framework 4 を使用した並列プログラミングのサンプル](https://go.microsoft.com/fwlink/?LinkID=165717)です。</span><span class="sxs-lookup"><span data-stu-id="25428-187">In addition, several sample task schedulers are available on Code Gallery: [Samples for Parallel Programming with the .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="25428-188">抽象 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 型のすべてのメンバーはスレッドセーフであり、複数のスレッドから同時に使用することができます。</span><span class="sxs-lookup"><span data-stu-id="25428-188">All members of the abstract <see cref="T:System.Threading.Tasks.TaskScheduler" /> type are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="25428-189">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="25428-189">Task Parallel Library (TPL)</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25428-190"><see cref="T:System.Threading.Tasks.TaskScheduler" /> を初期化します。</span><span class="sxs-lookup"><span data-stu-id="25428-190">Initializes the <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="25428-191">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="25428-191">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="25428-192">現在実行中のタスクに関連付けられている <see cref="T:System.Threading.Tasks.TaskScheduler" /> を取得します。</span><span class="sxs-lookup"><span data-stu-id="25428-192">Gets the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span></span></summary>
        <value><span data-ttu-id="25428-193">現在実行中のタスクに関連付けられている <see cref="T:System.Threading.Tasks.TaskScheduler" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="25428-193">Returns the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25428-194">タスク内から呼び出されない場合、<xref:System.Threading.Tasks.TaskScheduler.Current%2A> は <xref:System.Threading.Tasks.TaskScheduler.Default%2A> スケジューラを返します。</span><span class="sxs-lookup"><span data-stu-id="25428-194">When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler.</span></span>  
  
 <span data-ttu-id="25428-195">詳細については、<xref:System.Threading.Tasks.TaskScheduler> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="25428-195">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="25428-196">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="25428-196">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="25428-197">.NET Framework によって提供される既定の <see cref="T:System.Threading.Tasks.TaskScheduler" /> インスタンスを取得します。</span><span class="sxs-lookup"><span data-stu-id="25428-197">Gets the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance that is provided by the .NET Framework.</span></span></summary>
        <value><span data-ttu-id="25428-198">既定の <see cref="T:System.Threading.Tasks.TaskScheduler" /> インスタンスを返します。</span><span class="sxs-lookup"><span data-stu-id="25428-198">Returns the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25428-199">詳細については、<xref:System.Threading.Tasks.TaskScheduler> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="25428-199">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="25428-200">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="25428-200">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25428-201">このスケジューラに関連付けられているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="25428-201">Frees all resources associated with this scheduler.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25428-202">現在の <see cref="T:System.Threading.SynchronizationContext" /> に関連付けられている <see cref="T:System.Threading.Tasks.TaskScheduler" /> を作成します。</span><span class="sxs-lookup"><span data-stu-id="25428-202">Creates a <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />.</span></span></summary>
        <returns><span data-ttu-id="25428-203"><see cref="P:System.Threading.SynchronizationContext.Current" />による判断として、現在の <see cref="T:System.Threading.SynchronizationContext" /> に関連付けられている <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="25428-203">A <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />, as determined by <see cref="P:System.Threading.SynchronizationContext.Current" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25428-204">返されたスケジューラにキューに置かれているすべての <xref:System.Threading.Tasks.Task> インスタンスは、そのコンテキストの <xref:System.Threading.SynchronizationContext.Post%2A> メソッドの呼び出しを通じて実行されます。</span><span class="sxs-lookup"><span data-stu-id="25428-204">All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context.</span></span>  
  
 <span data-ttu-id="25428-205">詳細については、<xref:System.Threading.Tasks.TaskScheduler> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="25428-205">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="25428-206">現在の SynchronizationContext を TaskScheduler として使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="25428-206">The current SynchronizationContext may not be used as a TaskScheduler.</span></span></exception>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="25428-207">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="25428-207">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="25428-208">デバッガー サポートの目的でのみ、現在実行待機中のスケジューラのキューに含まれている <see cref="T:System.Threading.Tasks.Task" /> インスタンスの列挙可能なコレクションを生成します。</span><span class="sxs-lookup"><span data-stu-id="25428-208">For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" /> instances currently queued to the scheduler waiting to be executed.</span></span></summary>
        <returns><span data-ttu-id="25428-209">デバッガーがこのスケジューラのキューに現在含まれているタスクを走査できるようにする列挙可能なコレクション。</span><span class="sxs-lookup"><span data-stu-id="25428-209">An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25428-210"><xref:System.Threading.Tasks.TaskScheduler> から派生したクラスは、デバッガーとの統合をサポートするために、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="25428-210">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers.</span></span> <span data-ttu-id="25428-211">このメソッドは、デバッガーがデータへのアクセスを要求した場合にのみ .NET Framework によって呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="25428-211">This method will only be invoked by the .NET Framework when the debugger requests access to the data.</span></span> <span data-ttu-id="25428-212">返される列挙型は、このスケジューラに現在キューに置かれているタスクにアクセスするためにデバッグユーティリティによってスキャンされます。これにより、デバッガーはこの情報をユーザーインターフェイスに表示できます。</span><span class="sxs-lookup"><span data-stu-id="25428-212">The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</span></span>  
  
 <span data-ttu-id="25428-213">このメソッドが呼び出されると、プロセス内の他のすべてのスレッドが固定されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="25428-213">It is important to note that, when this method is called, all other threads in the process will be frozen.</span></span> <span data-ttu-id="25428-214">そのため、ブロックの原因となる可能性がある他のスレッドとの同期を避けることが重要です。</span><span class="sxs-lookup"><span data-stu-id="25428-214">Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</span></span> <span data-ttu-id="25428-215">同期が必要で、このメソッドでロックを取得できない場合は、デバッガーがブロックしないように例外をスローする必要があります。</span><span class="sxs-lookup"><span data-stu-id="25428-215">If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not block.</span></span> <span data-ttu-id="25428-216">次の例は、で使用できるC#1 つの方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="25428-216">The following example shows one possible approach in C#:</span></span>
  
```csharp
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 <span data-ttu-id="25428-217">さらに、このメソッドと返される列挙体は、グローバルに表示される状態を変更することはできません。</span><span class="sxs-lookup"><span data-stu-id="25428-217">Additionally, this method and the enumerable returned must not modify any globally visible state.</span></span>  
  
 <span data-ttu-id="25428-218">返される列挙型は null にしないでください。</span><span class="sxs-lookup"><span data-stu-id="25428-218">The returned enumerable should never be null.</span></span> <span data-ttu-id="25428-219">現在キューに登録されているタスクがない場合は、代わりに空の列挙型を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="25428-219">If there are currently no queued tasks, an empty enumerable should be returned instead.</span></span>  
  
 <span data-ttu-id="25428-220">カスタムデバッガーを実装している開発者は、このメソッドを直接呼び出す必要はありませんが、代わりに内部ラッパーメソッドを使用する必要があります: `internal Task[] GetScheduledTasksForDebugger()``GetScheduledTasksForDebugger`。</span><span class="sxs-lookup"><span data-stu-id="25428-220">Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`.</span></span> <span data-ttu-id="25428-221">このラッパーメソッドは、列挙可能なではなくタスクの配列を返します。</span><span class="sxs-lookup"><span data-stu-id="25428-221">This wrapper method returns an array of tasks instead of an enumerable.</span></span> <span data-ttu-id="25428-222">アクティブなスケジューラの一覧を取得するには、内部メソッド `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`を使用します。</span><span class="sxs-lookup"><span data-stu-id="25428-222">To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span></span> <span data-ttu-id="25428-223">この静的メソッドは、アクティブなすべての <xref:System.Threading.Tasks.TaskScheduler> インスタンスの配列を返します。</span><span class="sxs-lookup"><span data-stu-id="25428-223">This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances.</span></span> <span data-ttu-id="25428-224">その後、各スケジューラインスタンスで `GetScheduledTasksForDebugger` を使用して、スケジュールされたタスクの一覧を取得できます。</span><span class="sxs-lookup"><span data-stu-id="25428-224">You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="25428-225">このスケジューラは、この時点でキューにあるタスクの一覧を生成できません。</span><span class="sxs-lookup"><span data-stu-id="25428-225">This scheduler is unable to generate a list of queued tasks at this time.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="25428-226">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="25428-226">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="25428-227">この <see cref="T:System.Threading.Tasks.TaskScheduler" /> の一意の ID を取得します。</span><span class="sxs-lookup"><span data-stu-id="25428-227">Gets the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <value><span data-ttu-id="25428-228">この <see cref="T:System.Threading.Tasks.TaskScheduler" /> の一意の ID を返します。</span><span class="sxs-lookup"><span data-stu-id="25428-228">Returns the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25428-229">詳細については、<xref:System.Threading.Tasks.TaskScheduler> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="25428-229">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="25428-230">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="25428-230">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="25428-231">この <see cref="T:System.Threading.Tasks.TaskScheduler" /> がサポートできるコンカレンシー レベルの上限を示します。</span><span class="sxs-lookup"><span data-stu-id="25428-231">Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler" /> is able to support.</span></span></summary>
        <value><span data-ttu-id="25428-232">コンカレンシー レベルの上限を表す整数を返します。</span><span class="sxs-lookup"><span data-stu-id="25428-232">Returns an integer that represents the maximum concurrency level.</span></span> <span data-ttu-id="25428-233">既定のスケジューラは、<see cref="F:System.Int32.MaxValue" /> を返します。</span><span class="sxs-lookup"><span data-stu-id="25428-233">The default scheduler returns <see cref="F:System.Int32.MaxValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25428-234">詳細については、<xref:System.Threading.Tasks.TaskScheduler> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="25428-234">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="25428-235">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="25428-235">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub QueueTask (task As Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="25428-236">キューに追加する <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="25428-236">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</span></span></param>
        <summary><span data-ttu-id="25428-237">スケジューラのキューに <see cref="T:System.Threading.Tasks.Task" /> を追加します。</span><span class="sxs-lookup"><span data-stu-id="25428-237">Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25428-238"><xref:System.Threading.Tasks.TaskScheduler> から派生したクラスは、スケジューラでスケジュールされているタスクを受け入れるために、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="25428-238">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler.</span></span>  
  
 <span data-ttu-id="25428-239">一般的な実装では、タスクを内部データ構造に格納します。これは、今後、これらのタスクを実行するスレッドによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="25428-239">A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</span></span>  
  
 <span data-ttu-id="25428-240">このメソッドは、.NET Framework によって呼び出されるだけであり、派生クラスによって直接呼び出すことはできません。</span><span class="sxs-lookup"><span data-stu-id="25428-240">This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</span></span> <span data-ttu-id="25428-241">これは、システムの整合性を維持するために必要です。</span><span class="sxs-lookup"><span data-stu-id="25428-241">This is necessary for maintaining the consistency of the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="25428-242"><paramref name="task" /> 引数が null です。</span><span class="sxs-lookup"><span data-stu-id="25428-242">The <paramref name="task" /> argument is null.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="25428-243">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="25428-243">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function TryDequeue (task As Task) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="25428-244">キューから取り出す <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="25428-244">The <see cref="T:System.Threading.Tasks.Task" /> to be dequeued.</span></span></param>
        <summary><span data-ttu-id="25428-245">このスケジューラのキューに以前含まれていた <see cref="T:System.Threading.Tasks.Task" /> のデキューを試みます。</span><span class="sxs-lookup"><span data-stu-id="25428-245">Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task" /> that was previously queued to this scheduler.</span></span></summary>
        <returns><span data-ttu-id="25428-246"><paramref name="task" /> 引数が正常にデキューされたかどうかを示すブール値。</span><span class="sxs-lookup"><span data-stu-id="25428-246">A Boolean denoting whether the <paramref name="task" /> argument was successfully dequeued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25428-247">詳細については、<xref:System.Threading.Tasks.TaskScheduler> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="25428-247">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 <span data-ttu-id="25428-248">このメソッドは、finally ブロックで実行できます。したがって、<xref:System.Threading.CancellationTokenRegistration> オブジェクトなどのリソースを適時に破棄できるように、できるだけ迅速にを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="25428-248">This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="25428-249"><paramref name="task" /> 引数が null です。</span><span class="sxs-lookup"><span data-stu-id="25428-249">The <paramref name="task" /> argument is null.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="25428-250">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="25428-250">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="VB.NET" Value="Protected Function TryExecuteTask (task As Task) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="25428-251">実行対象の <see cref="T:System.Threading.Tasks.Task" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="25428-251">A <see cref="T:System.Threading.Tasks.Task" /> object to be executed.</span></span></param>
        <summary><span data-ttu-id="25428-252">このスケジューラ上の指定された <see cref="T:System.Threading.Tasks.Task" /> の実行を試みます。</span><span class="sxs-lookup"><span data-stu-id="25428-252">Attempts to execute the provided <see cref="T:System.Threading.Tasks.Task" /> on this scheduler.</span></span></summary>
        <returns><span data-ttu-id="25428-253"><paramref name="task" /> が正常に実行された場合は true、正常に実行されなかった場合は false。</span><span class="sxs-lookup"><span data-stu-id="25428-253">A Boolean that is true if <paramref name="task" /> was successfully executed, false if it was not.</span></span> <span data-ttu-id="25428-254">タスクが正常に実行されない原因としては、タスクが既に実行されていた場合や、他のスレッドによって実行中である場合などが挙げられます。</span><span class="sxs-lookup"><span data-stu-id="25428-254">A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25428-255">スケジューラ実装は、<xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> メソッドまたは <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> メソッドを使用して実行される <xref:System.Threading.Tasks.Task> インスタンスと共に提供されます。</span><span class="sxs-lookup"><span data-stu-id="25428-255">Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method.</span></span> <span data-ttu-id="25428-256">スケジューラが、指定されたタスクの実行に適切な判断をした場合、そのためには <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="25428-256">When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so.</span></span> <span data-ttu-id="25428-257">TryExecuteTask は、アクションの呼び出し、例外処理、状態管理、ライフサイクル制御など、タスクの実行に関するあらゆる側面を処理します。</span><span class="sxs-lookup"><span data-stu-id="25428-257">TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</span></span>  
  
 <span data-ttu-id="25428-258"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> は、.NET Framework インフラストラクチャによってこのスケジューラに提供されるタスクにのみ使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="25428-258"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</span></span> <span data-ttu-id="25428-259">カスタムメカニズムによって取得された任意のタスクを実行するために使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="25428-259">It should not be used to execute arbitrary tasks obtained through custom mechanisms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="25428-260"><paramref name="task" /> はこのスケジューラに関連付けられていません。</span><span class="sxs-lookup"><span data-stu-id="25428-260">The <paramref name="task" /> is not associated with this scheduler.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="25428-261">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="25428-261">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function TryExecuteTaskInline (task As Task, taskWasPreviouslyQueued As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="25428-262">実行対象の <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="25428-262">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</span></span></param>
        <param name="taskWasPreviouslyQueued"><span data-ttu-id="25428-263">タスクが以前キューに追加されていたかどうかを示すブール値。</span><span class="sxs-lookup"><span data-stu-id="25428-263">A Boolean denoting whether or not task has previously been queued.</span></span> <span data-ttu-id="25428-264">このパラメーターを True に設定すると、タスクが以前キューに追加されていた (スケジュールされていた) 可能性があることを示します。False に設定すると、タスクがキューに追加されていないことを示し、この呼び出しによって、タスクがキューに追加されずにインラインで実行されます。</span><span class="sxs-lookup"><span data-stu-id="25428-264">If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</span></span></param>
        <summary><span data-ttu-id="25428-265">指定された <see cref="T:System.Threading.Tasks.Task" /> をこの呼び出しで同期的に実行できるかどうかを判断し、できる場合は実行します。</span><span class="sxs-lookup"><span data-stu-id="25428-265">Determines whether the provided <see cref="T:System.Threading.Tasks.Task" /> can be executed synchronously in this call, and if it can, executes it.</span></span></summary>
        <returns><span data-ttu-id="25428-266">タスクがインラインで実行されたかどうかを示すブール値。</span><span class="sxs-lookup"><span data-stu-id="25428-266">A Boolean value indicating whether the task was executed inline.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25428-267"><xref:System.Threading.Tasks.TaskScheduler> から派生したクラスは、この関数を実装して、そのタスクオブジェクトで待機を開始するスレッド上でのタスクのインライン実行をサポートします。</span><span class="sxs-lookup"><span data-stu-id="25428-267">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</span></span> <span data-ttu-id="25428-268">インライン実行は省略可能であり、false を返すことによって要求が拒否される場合があります。</span><span class="sxs-lookup"><span data-stu-id="25428-268">Inline execution is optional, and the request may be rejected by returning false.</span></span> <span data-ttu-id="25428-269">ただし、インライン化できるタスクが多いほど、スケジューラがより適切に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="25428-269">However, the more tasks that can be inlined, the better the scheduler will scale.</span></span> <span data-ttu-id="25428-270">実際、スケジューラが少なすぎると、デッドロックが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="25428-270">In fact, a scheduler that inlines too little may be prone to deadlocks.</span></span> <span data-ttu-id="25428-271">適切な実装では、スケジューラによって保証されるポリシーで実行されている要求が正常にインラインで実行できることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="25428-271">A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</span></span> <span data-ttu-id="25428-272">たとえば、スケジューラが専用のスレッドを使用してタスクを実行する場合、そのスレッドからのインライン展開要求は成功します。</span><span class="sxs-lookup"><span data-stu-id="25428-272">For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</span></span>  
  
 <span data-ttu-id="25428-273">スケジューラがインライン実行を決定した場合は、指定されたタスクオブジェクトを使用して base TaskScheduler の <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> メソッドを呼び出し、戻り値を反映することによって、この処理を実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="25428-273">If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value.</span></span> <span data-ttu-id="25428-274">また、インライン展開要求を受け入れる場合に、スケジューラが内部データ構造からインラインタスクを削除することが適切な場合もあります。</span><span class="sxs-lookup"><span data-stu-id="25428-274">It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</span></span> <span data-ttu-id="25428-275">ただし、状況によっては、スケジューラが <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> メソッドを使用して以前に提供されていなかったタスクをインライン化するように求められることがあります。</span><span class="sxs-lookup"><span data-stu-id="25428-275">Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.</span></span>  
  
 <span data-ttu-id="25428-276">派生スケジューラは、呼び出し元のスレッドが、特定のタスクの実行に適しているかどうかを確認する役割を担います。これは、独自のスケジュール設定と実行ポリシーに関係します。</span><span class="sxs-lookup"><span data-stu-id="25428-276">The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</span></span>  
  
 <span data-ttu-id="25428-277">詳細については、<xref:System.Threading.Tasks.TaskScheduler> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="25428-277">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="25428-278"><paramref name="task" /> 引数が null です。</span><span class="sxs-lookup"><span data-stu-id="25428-278">The <paramref name="task" /> argument is null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="25428-279"><paramref name="task" /> は既に実行されました。</span><span class="sxs-lookup"><span data-stu-id="25428-279">The <paramref name="task" /> was already executed.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="25428-280">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="25428-280">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="25428-281">エラーが発生したタスクの無視された例外が例外エスカレーション ポリシーをトリガーしようとする場合に発生します。既定では、プロセスを終了します。</span><span class="sxs-lookup"><span data-stu-id="25428-281">Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="25428-282">このアプリケーションドメイン全体のイベントは、例外エスカレーションポリシー (既定ではプロセスの終了) がトリガーされないようにするためのメカニズムを提供します。</span><span class="sxs-lookup"><span data-stu-id="25428-282">This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</span></span>  
  
 <span data-ttu-id="25428-283">開発者がタスクに基づいて非同期コードを簡単に記述できるように、[!INCLUDE[net_v45](~/includes/net-v45-md.md)] によって、監視され例外の既定の例外動作が変更されます。</span><span class="sxs-lookup"><span data-stu-id="25428-283">To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions.</span></span> <span data-ttu-id="25428-284">監視され例外は依然として <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> 例外を生成しますが、プロセスは既定では終了しません。</span><span class="sxs-lookup"><span data-stu-id="25428-284">Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default.</span></span> <span data-ttu-id="25428-285">代わりに、イベントハンドラーが例外を監視しているかどうかに関係なく、イベントが発生した後にランタイムによって例外が処理されます。</span><span class="sxs-lookup"><span data-stu-id="25428-285">Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</span></span> <span data-ttu-id="25428-286">この動作は構成できます。</span><span class="sxs-lookup"><span data-stu-id="25428-286">This behavior can be configured.</span></span> <span data-ttu-id="25428-287">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]以降では、 [`<ThrowUnobservedTaskExceptions>`](/dotnet/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element)構成要素を使用して [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] の動作に戻し、プロセスを終了することができます。</span><span class="sxs-lookup"><span data-stu-id="25428-287">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the [`<ThrowUnobservedTaskExceptions>`](/dotnet/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element) configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:</span></span>  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/parallel-programming/task-parallel-library-tpl"><span data-ttu-id="25428-288">タスク並列ライブラリ (TPL)</span><span class="sxs-lookup"><span data-stu-id="25428-288">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element"><span data-ttu-id="25428-289">&lt;ThrowUnobservedTaskExceptions&gt; 要素</span><span class="sxs-lookup"><span data-stu-id="25428-289">&lt;ThrowUnobservedTaskExceptions&gt; Element</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
