<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="19ac66eb23c469305f0eeb17e80258e07135ea15" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75117490" /></Metadata><TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>並列ループおよび並列領域のサポートを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Parallel> クラスは、for ループ、for each ループ、ステートメントセットの実行などの一般的な操作に対して、ライブラリベースのデータの並列置換を提供します。  
  
   
  
## Examples  
 この例では、複数の言語構成要素を使用して並列ループを実装するいくつかの方法を示します。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="T:System.Threading.Tasks.Parallel" /> のパブリックメンバーとプロテクトメンバーはすべてスレッドセーフであり、複数のスレッドから同時に使用することができます。</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md">データの並列化 (タスク並列ライブラリ)</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">.NET Framework を使用した並列プログラミングのサンプル</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>反復処理が並列で実行される可能性のある <see langword="for" /> ループを実行します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">開始インデックス。ここで指定したインデックスから処理が開始されます。</param>
        <param name="toExclusive">終了インデックス。ここで指定したインデックスの前のインデックスまで処理が行われます。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary>反復処理が並列で実行される可能性があり、ループの状態を監視および操作できる <see langword="for" /> ループを実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、イテレーション範囲 (`fromInclusive`、`toExclusive`) の各値に対して1回ずつ呼び出されます。 2つの引数を使用して提供されます。  
  
-   反復回数を表す <xref:System.Int32> 値。  
  
-   ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンス。 <xref:System.Threading.Tasks.ParallelLoopState> オブジェクトはコンパイラによって作成されます。ユーザーコードでインスタンス化することはできません。  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドを呼び出すと、現在のの後のイテレーションが実行する必要がないことを `for` 操作に通知します。 ただし、現在のイテレーションより前のイテレーションは、まだ実行していない場合でも実行する必要があります。  
  
 したがって、<xref:System.Threading.Tasks.ParallelLoopState.Break%2A> の呼び出しはC#、などの言語で従来の `for` ループ内で中断操作を使用するのと似ていますが、これは完全な代替手段ではありません。たとえば、現在のイテレーションの後のイテレーションが確実に実行されないという保証はありません。  
  
 現在のイテレーションより前にすべてのイテレーションを実行する必要がない場合は、<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>を使用するのではなく、<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> メソッドを使用します。 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> を呼び出すと、必要なすべての作業が既に完了しているため、現在のイテレーションの前後であるかどうかに関係なく、残りのすべてのイテレーションを破棄できることが `for` ループに通知されます。 ただし、<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>の場合と同様に、他のイテレーションが実行されないことについての保証はありません。  
  
 ループが途中で終了した場合、返される <xref:System.Threading.Tasks.ParallelLoopResult> 構造には、ループの完了に関する関連情報が含まれます。  
  
 `fromInclusive` が `toExclusive`以上の場合、メソッドは、繰り返しを実行せずにすぐに制御を戻します。  
  
   
  
## Examples  
 次の例では、ループの最大100の反復処理を並列実行します。 各イテレーションは、1 ~ 1000 ミリ秒のランダムな間隔で一時停止します。 ランダムに生成された値によって、<xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> メソッドが呼び出されるループの反復処理が決定されます。 この例の出力に示すように、インデックスが <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> プロパティ値よりも大きいイテレーションは、<xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> メソッドの呼び出しの後に開始されます。  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> メソッドが呼び出されたときにループの反復処理が実行される可能性があるため、各反復処理は <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> プロパティを呼び出して、別のイテレーションが <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> メソッドを呼び出したかどうかを確認します。 プロパティ値が `true`場合、反復処理は <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> プロパティの値をチェックし、現在のイテレーションのインデックス値より大きい場合は、直ちにを返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">開始インデックス。ここで指定したインデックスから処理が開始されます。</param>
        <param name="toExclusive">終了インデックス。ここで指定したインデックスの前のインデックスまで処理が行われます。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary>反復処理が並列で実行される可能性のある <see langword="for" /> ループを実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、イテレーション範囲 (`fromInclusive`、`toExclusive`) の各値に対して1回ずつ呼び出されます。 これは、パラメーターとして反復回数 (<xref:System.Int32>) を使用して提供されます。  
  
 `fromInclusive` が `toExclusive`以上の場合、メソッドは、繰り返しを実行せずにすぐに制御を戻します。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Tasks.Parallel.For%2A> メソッドを使用して、ランダムバイト値を生成し、その合計を計算するデリゲートの100呼び出しを行います。  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">開始インデックス。ここで指定したインデックスから処理が開始されます。</param>
        <param name="toExclusive">終了インデックス。ここで指定したインデックスの前のインデックスまで処理が行われます。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary>反復処理が並列で実行される可能性があり、ループの状態を監視および操作できる、64 ビットのインデックスを持つ <see langword="for" /> ループを実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> 構造体。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、イテレーション範囲 (`fromInclusive`、`toExclusive`) の各値に対して1回ずつ呼び出されます。 これには、次のパラメーターがあります。反復回数 (<xref:System.Int64>) と、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンスです。  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> メソッドを呼び出すと、現在のの後のイテレーションを実行する必要がないことを `for` 操作に通知しますが、現在のイテレーションはすべて実行されます。  
  
 したがって、Break の呼び出しはC#、などの言語の従来の `for` ループ内で break 操作を使用するのと似ていますが、これは完全な代替手段ではありません。たとえば、現在のイテレーションの後のイテレーションが確実に実行されないという保証はありません。  
  
 現在のイテレーションより前にすべてのイテレーションを実行する必要がない場合は、<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>を使用するのではなく、<xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> メソッドを使用します。 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> を呼び出すと、必要なすべての作業が既に完了しているため、現在のイテレーションの前後であるかどうかに関係なく、残りのすべてのイテレーションを破棄できることが `for` ループに通知されます。 ただし、<xref:System.Threading.Tasks.ParallelLoopState.Break%2A>の場合と同様に、他のイテレーションが実行されないことについての保証はありません。  
  
 ループが途中で終了した場合、返される <xref:System.Threading.Tasks.ParallelLoopResult> 構造には、ループの完了に関する関連情報が含まれます。  
  
 `fromInclusive` が `toExclusive`以上の場合、メソッドは、繰り返しを実行せずにすぐに制御を戻します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">開始インデックス。ここで指定したインデックスから処理が開始されます。</param>
        <param name="toExclusive">終了インデックス。ここで指定したインデックスの前のインデックスまで処理が行われます。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary>反復処理が並列で実行される可能性のある、64 ビットのインデックスを持つ <see langword="for" /> ループを実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、イテレーション範囲 (`fromInclusive`、`toExclusive`) の各値に対して1回ずつ呼び出されます。 これは、パラメーターとして反復回数 (<xref:System.Int64>) を使用して提供されます。  
  
 `fromInclusive` が `toExclusive`以上の場合、メソッドは、繰り返しを実行せずにすぐに制御を戻します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">開始インデックス。ここで指定したインデックスから処理が開始されます。</param>
        <param name="toExclusive">終了インデックス。ここで指定したインデックスの前のインデックスまで処理が行われます。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary>反復処理が並列で実行される可能性があり、ループ オプションを構成でき、ループの状態を監視および操作できる <see langword="for" /> ループを実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、イテレーション範囲 (`fromInclusive`、`toExclusive`) の各値に対して1回ずつ呼び出されます。 これには、次のパラメーターがあります。反復回数 (<xref:System.Int32>) と、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンスです。  
  
 `fromInclusive` が `toExclusive`以上の場合、メソッドは、繰り返しを実行せずにすぐに制御を戻します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">開始インデックス。ここで指定したインデックスから処理が開始されます。</param>
        <param name="toExclusive">終了インデックス。ここで指定したインデックスの前のインデックスまで処理が行われます。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary>反復処理が並列で実行される可能性があり、ループ オプションを構成できる <see langword="for" /> ループを実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、イテレーション範囲 (`fromInclusive`、`toExclusive`) の各値に対して1回ずつ呼び出されます。 これは、パラメーターとして反復回数 (<xref:System.Int32>) を使用して提供されます。  
  
 `fromInclusive` が `toExclusive`以上の場合、メソッドは、繰り返しを実行せずにすぐに制御を戻します。  
  
   
  
## Examples  
 次の例は、並列ループを取り消す方法を示しています。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">開始インデックス。ここで指定したインデックスから処理が開始されます。</param>
        <param name="toExclusive">終了インデックス。ここで指定したインデックスの前のインデックスまで処理が行われます。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary>反復処理が並列で実行される可能性があり、ループ オプションを構成でき、ループの状態を監視および操作できる、64 ビットのインデックスを持つ <see langword="for" /> ループを実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、イテレーション範囲 (`fromInclusive`、`toExclusive`) の各値に対して1回ずつ呼び出されます。 これには、次のパラメーターがあります。反復回数 (<xref:System.Int64>) と、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンスです。  
  
 `fromInclusive` が `toExclusive`以上の場合、メソッドは、繰り返しを実行せずにすぐに制御を戻します。  
  
   
  
## Examples  
 次の例は、<xref:System.Threading.Tasks.ParallelOptions> オブジェクトで <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> メソッドを使用する方法を示しています。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">開始インデックス。ここで指定したインデックスから処理が開始されます。</param>
        <param name="toExclusive">終了インデックス。ここで指定したインデックスの前のインデックスまで処理が行われます。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary>イテレーションが並列で実行される可能性があり、ループ オプションを構成できる、64 ビットのインデックスを持つ <see langword="for" /> ループを実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 では、64ビットのインデックスをサポートしています。 `body` デリゲートは、イテレーション範囲 (`fromInclusive`、`toExclusive`) の各値に対して1回ずつ呼び出されます。 これは、パラメーターとして反復回数 (<xref:System.Int64>) を使用して提供されます。  
  
 `fromInclusive` が `toExclusive`以上の場合、メソッドは、繰り返しを実行せずにすぐに制御を戻します。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Tasks.ParallelOptions> を使用してカスタムタスクスケジューラを指定する方法を示します。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">スレッド ローカル データの型。</typeparam>
        <param name="fromInclusive">開始インデックス。ここで指定したインデックスから処理が開始されます。</param>
        <param name="toExclusive">終了インデックス。ここで指定したインデックスの前のインデックスまで処理が行われます。</param>
        <param name="localInit">各タスクのローカル データの初期状態を返す関数デリゲート。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <param name="localFinally">各タスクのローカル状態に対して最後の操作を行うデリゲート。</param>
        <summary>反復処理が並列で実行される可能性があり、ループの状態を監視および操作できる、スレッド ローカル データを持つ <see langword="for" /> ループを実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、イテレーション範囲 (`fromInclusive`、`toExclusive`) の各値に対して1回ずつ呼び出されます。 これには、次のパラメーターが用意されています。反復回数 (<xref:System.Int32>)、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンス、および同じスレッドで実行される繰り返し間で共有される可能性のあるローカル状態。  
  
 `localInit` デリゲートは、ループの実行に参加するタスクごとに1回呼び出され、各タスクの最初のローカル状態を返します。 これらの初期状態は、各タスクの最初の `body` 呼び出しに渡されます。 次に、後続のすべての本文呼び出しで、次の本文呼び出しに渡される、変更可能な状態値が返されます。 最後に、各タスクの最後の本文呼び出しによって、`localFinally` デリゲートに渡される状態値が返されます。 `localFinally` デリゲートは、各タスクのローカル状態に対して最後のアクションを実行するために、タスクごとに1回呼び出されます。 このデリゲートは、複数のタスクで同時に呼び出される場合があります。そのため、共有変数へのアクセスを同期する必要があります。  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> メソッドは、既存のタスクが完了し、新しいタスクに置き換えられるため、実行の有効期間中にスレッドよりも多くのタスクを使用する場合があります。 これにより、基になる <xref:System.Threading.Tasks.TaskScheduler> オブジェクトは、ループを処理するスレッドを追加、変更、または削除できるようになります。  
  
 `fromInclusive` が `toExclusive`以上の場合、メソッドは、繰り返しを実行せずにすぐに制御を戻します。  
  
 このメソッドを使用する例については、「[方法: スレッドローカル変数を使用して Parallel ループを記述](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)する」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localInit" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localFinally" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">スレッド ローカル データの型。</typeparam>
        <param name="fromInclusive">開始インデックス。ここで指定したインデックスから処理が開始されます。</param>
        <param name="toExclusive">終了インデックス。ここで指定したインデックスの前のインデックスまで処理が行われます。</param>
        <param name="localInit">各タスクのローカル データの初期状態を返す関数デリゲート。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <param name="localFinally">各タスクのローカル状態に対して最後の操作を行うデリゲート。</param>
        <summary>反復処理が並列で実行される可能性があり、ループの状態を監視および操作できる、64 ビットのインデックスとスレッド ローカル データを持つ <see langword="for" /> ループを実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、イテレーション範囲 (`fromInclusive`、`toExclusive`) の各値に対して1回ずつ呼び出されます。 これには、次のパラメーターが用意されています。反復回数 (<xref:System.Int64>)、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンス、および同じタスクで実行されるイテレーション間で共有される可能性のあるローカル状態。  
  
 `localInit` デリゲートは、ループの実行に参加するタスクごとに1回呼び出され、各タスクの最初のローカル状態を返します。 これらの初期状態は、各タスクの最初の `body` 呼び出しに渡されます。 次に、後続のすべての本文呼び出しで、次の本文呼び出しに渡される、変更可能な状態値が返されます。 最後に、各タスクの最後の本文呼び出しによって、`localFinally` デリゲートに渡される状態値が返されます。 `localFinally` デリゲートは、各タスクのローカル状態に対して最後のアクションを実行するために、タスクごとに1回呼び出されます。 このデリゲートは、複数のタスクで同時に呼び出される場合があります。そのため、共有変数へのアクセスを同期する必要があります。  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> メソッドは、既存のタスクが完了し、新しいタスクに置き換えられるため、実行の有効期間中にスレッドよりも多くのタスクを使用する場合があります。 これにより、基になる <xref:System.Threading.Tasks.TaskScheduler> オブジェクトは、ループを処理するスレッドを追加、変更、または削除できるようになります。  
  
 `fromInclusive` が `toExclusive`以上の場合、メソッドは、繰り返しを実行せずにすぐに制御を戻します。  
  
 このメソッドを使用する例については、「[方法: スレッドローカル変数を使用して Parallel ループを記述](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)する」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localInit" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localFinally" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">スレッド ローカル データの型。</typeparam>
        <param name="fromInclusive">開始インデックス。ここで指定したインデックスから処理が開始されます。</param>
        <param name="toExclusive">終了インデックス。ここで指定したインデックスの前のインデックスまで処理が行われます。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="localInit">各タスクのローカル データの初期状態を返す関数デリゲート。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <param name="localFinally">各タスクのローカル状態に対して最後の操作を行うデリゲート。</param>
        <summary>反復処理が並列で実行される可能性があり、ループ オプションを構成でき、ループの状態を監視および操作できる、スレッド ローカル データを持つ <see langword="for" /> ループを実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、イテレーション範囲 (`fromInclusive`、`toExclusive`) の各値に対して1回ずつ呼び出されます。 これには、次のパラメーターが用意されています。反復回数 (<xref:System.Int32>)、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンス、および同じタスクで実行されるイテレーション間で共有される可能性のあるローカル状態。  
  
 `localInit` デリゲートは、ループの実行に参加するタスクごとに1回呼び出され、各タスクの最初のローカル状態を返します。 これらの初期状態は、各タスクの最初の `body` 呼び出しに渡されます。 次に、後続のすべての本文呼び出しで、次の本文呼び出しに渡される、変更可能な状態値が返されます。 最後に、各タスクの最後の本文呼び出しによって、`localFinally` デリゲートに渡される状態値が返されます。 `localFinally` デリゲートは、各タスクのローカル状態に対して最後のアクションを実行するために、タスクごとに1回呼び出されます。 このデリゲートは、複数のスレッドで同時に呼び出される場合があります。そのため、共有変数へのアクセスを同期する必要があります。  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> メソッドは、既存のタスクが完了し、新しいタスクに置き換えられるため、実行の有効期間中にスレッドよりも多くのタスクを使用する場合があります。 これにより、基になる <xref:System.Threading.Tasks.TaskScheduler> オブジェクトは、ループを処理するスレッドを追加、変更、または削除できるようになります。  
  
 `fromInclusive` が `toExclusive`以上の場合、メソッドは、繰り返しを実行せずにすぐに制御を戻します。  
  
   
  
## Examples  
 次の例では、スレッドローカル変数を使用して、多くの長い操作の結果の合計を計算します。 この例では、並列処理の次数を4に制限しています。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localInit" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localFinally" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">スレッド ローカル データの型。</typeparam>
        <param name="fromInclusive">開始インデックス。ここで指定したインデックスから処理が開始されます。</param>
        <param name="toExclusive">終了インデックス。ここで指定したインデックスの前のインデックスまで処理が行われます。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="localInit">各スレッドのローカル データの初期状態を返す関数デリゲート。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <param name="localFinally">各スレッドのローカル状態に対して最後の操作を行うデリゲート。</param>
        <summary>反復処理が並列で実行される可能性があり、ループ オプションを構成でき、ループの状態を監視および操作できる、64 ビットのインデックスとスレッド ローカル データを持つ <see langword="for" /> ループを実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、イテレーション範囲 (`fromInclusive`、`toExclusive`) の各値に対して1回ずつ呼び出されます。 これには、次のパラメーターが用意されています。反復回数 (<xref:System.Int64>)、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンス、および同じスレッドで実行される繰り返し間で共有される可能性のあるローカル状態。  
  
 `localInit` デリゲートは、ループの実行に参加するスレッドごとに1回呼び出され、各スレッドの最初のローカル状態を返します。 これらの初期状態は、各スレッドの最初の `body` 呼び出しに渡されます。 次に、後続のすべての本文呼び出しで、次の本文呼び出しに渡される、変更可能な状態値が返されます。 最後に、各スレッドの最後の本文呼び出しによって、`localFinally` デリゲートに渡される状態値が返されます。 `localFinally` デリゲートは、各スレッドのローカル状態に対して最後のアクションを実行するために、スレッドごとに1回呼び出されます。 このデリゲートは、複数のスレッドで同時に呼び出される場合があります。そのため、共有変数へのアクセスを同期する必要があります。  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> メソッドは、既存のタスクが完了し、新しいタスクに置き換えられるため、実行の有効期間中にスレッドよりも多くのタスクを使用する場合があります。 これにより、基になる <xref:System.Threading.Tasks.TaskScheduler> オブジェクトは、ループを処理するスレッドを追加、変更、または削除できるようになります。  
  
 `fromInclusive` が `toExclusive`以上の場合、メソッドは、繰り返しを実行せずにすぐに制御を戻します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localInit" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localFinally" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>イテレーションが並列で実行される可能性のある <see langword="foreach" /> (Visual Basic の場合は <see langword="For Each " />) 操作を実行します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> の要素の型。</typeparam>
        <param name="source">元のデータ ソースを格納している順序付け可能なパーティショナー。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループの状態を監視および操作できる <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、既定のパーティション構成をオーバーライドする場合に提供されます。 たとえば、小さなループ本体では、範囲をパーティション分割することによってメリットが得られる場合があります。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドでは、動的パーティション分割をサポートするためにカスタムパーティショナーが想定されています。 詳細については、「 [PLINQ および TPL のカスタムパーティショナー](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 」および「[方法: 動的パーティションを実装する](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">順序付け可能のパーティショナー、<see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> の <paramref name="source" /> プロパティは <see langword="false" /> を返します。  
  
または 
順序付け可能のパーティショナー、ソースの <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> プロパティは <see langword="false" /> を返します。  
  
または 
ソースの順序付け可能なパーティショナーのすべてのメソッドは、<see langword="null" /> を返します。</exception>
        <exception cref="T:System.AggregateException">指定したデリゲートのいずれかからスローされた例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> の要素の型。</typeparam>
        <param name="source">元のデータ ソースを格納しているパーティショナー。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループの状態を監視および操作できる <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.Concurrent.Partitioner" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、既定のパーティション構成をオーバーライドする場合に提供されます。 たとえば、小さなループ本体では、範囲をパーティション分割することによってメリットが得られる場合があります。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドでは、動的パーティション分割をサポートするためにカスタムパーティショナーが想定されています。 詳細については、「 [PLINQ および TPL のカスタムパーティショナー](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 」および「[方法: 動的パーティションを実装する](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> パーティショナーの <paramref name="source" /> プロパティは <see langword="false" /> を返します。  
  
または 
<paramref name="source" /> パーティショナーのメソッドは <see langword="null" /> を返します。  
  
または 
<see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> パーティショナーの <paramref name="source" /> メソッドが正しいパーティション数を返しません。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
        <exception cref="T:System.AggregateException">指定のデリゲートの 1 つからスローされる例外を含める目的でスローされる例外。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> の要素の型。</typeparam>
        <param name="source">元のデータ ソースを格納しているパーティショナー。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性のある <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.Concurrent.Partitioner" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、既定のパーティション構成をオーバーライドする場合に提供されます。 たとえば、小さなループ本体では、範囲をパーティション分割することによってメリットが得られる場合があります。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドでは、動的パーティション分割をサポートするためにカスタムパーティショナーが想定されています。 詳細については、「 [PLINQ および TPL のカスタムパーティショナー](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 」および「[方法: 動的パーティションを実装する](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)」を参照してください。  
  
   
  
## Examples  
 次の例は、<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>で使用する範囲パーティショナーを実装する方法を示しています。  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> パーティショナーの <paramref name="source" /> プロパティは <see langword="false" /> を返します。  
  
または 
<paramref name="source" /> パーティショナー内のメソッドが <see langword="null" /> を返したときにスローされる例外。  
  
または 
<see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> パーティショナーの <paramref name="source" /> メソッドが正しいパーティション数を返しません。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
        <exception cref="T:System.AggregateException">指定のデリゲートの 1 つからスローされる例外を含める目的でスローされる例外。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">ソース内のデータの型。</typeparam>
        <param name="source">列挙可能なデータ ソース。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループの状態を監視および操作できる、64 ビットのインデックスを持つ <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.IEnumerable" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、`source` 列挙可能なの各要素に対して1回ずつ呼び出されます。 このパラメーターには、現在の要素、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンス、および現在の要素のインデックス (<xref:System.Int64>) が含まれています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">ソース内のデータの型。</typeparam>
        <param name="source">列挙可能なデータ ソース。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループの状態を監視および操作できる <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.IEnumerable" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、`source` 列挙可能なの各要素に対して1回ずつ呼び出されます。 これには、現在の要素と、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンスのパラメーターがあります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">ソース内のデータの型。</typeparam>
        <param name="source">列挙可能なデータ ソース。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性のある <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.IEnumerable" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、`source` 列挙可能なの各要素に対して1回ずつ呼び出されます。 現在の要素がパラメーターとして提供されます。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> メソッドを使用して、テキストファイル内の母音と空白以外の文字の数をカウントします。 この場合、メソッドによって返される <xref:System.Threading.Tasks.ParallelLoopResult> の値は無視されます。 操作は並列で実行できるため、カウンター変数のインクリメントがアトミック操作であること、および複数のスレッドがカウンター変数に同時にアクセスしようとしないことを確認する必要があることに注意してください。 このため、この例では、`lock` ステートメント (でC#は) と `SyncLock` ステートメント (Visual Basic) を使用します。  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> の要素の型。</typeparam>
        <param name="source">元のデータ ソースを格納している順序付け可能なパーティショナー。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループ オプションを構成でき、ループの状態を監視および操作できる <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、既定のパーティション構成をオーバーライドする場合に提供されます。 たとえば、小さなループ本体では、範囲をパーティション分割することによってメリットが得られる場合があります。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドでは、動的パーティション分割をサポートするためにカスタムパーティショナーが想定されています。 詳細については、「 [PLINQ および TPL のカスタムパーティショナー](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 」および「[方法: 動的パーティションを実装する](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <exception cref="T:System.InvalidOperationException">順序付け可能のパーティショナー、<see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> の <paramref name="source" /> プロパティは <see langword="false" /> を返します。  
  
または 
順序付け可能のパーティショナー、<see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> の <paramref name="source" /> プロパティは <see langword="false" /> を返します。  
  
または 
順序付け可能なパーティショナー、<paramref name="source" /> 内のメソッドが <see langword="null" /> を返したときにスローされる例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
        <exception cref="T:System.AggregateException">指定のデリゲートの 1 つからスローされる例外を含める目的でスローされる例外。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> の要素の型。</typeparam>
        <param name="source">元のデータ ソースを格納しているパーティショナー。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループ オプションを構成でき、ループの状態を監視および操作できる <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.Concurrent.Partitioner" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、既定のパーティション構成をオーバーライドする場合に提供されます。 たとえば、小さなループ本体では、範囲をパーティション分割することによってメリットが得られる場合があります。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドでは、動的パーティション分割をサポートするためにカスタムパーティショナーが想定されています。 詳細については、「 [PLINQ および TPL のカスタムパーティショナー](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 」および「[方法: 動的パーティションを実装する](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> パーティショナーの <paramref name="source" /> プロパティは <see langword="false" /> を返します。  
  
または 
<paramref name="source" /> パーティショナー内のメソッドが <see langword="null" /> を返したときにスローされる例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
        <exception cref="T:System.AggregateException">指定のデリゲートの 1 つからスローされる例外を含める目的でスローされる例外。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> の要素の型。</typeparam>
        <param name="source">元のデータ ソースを格納しているパーティショナー。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループ オプションを構成できる <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.Concurrent.Partitioner" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、既定のパーティション構成をオーバーライドする場合に提供されます。 たとえば、小さなループ本体では、範囲をパーティション分割することによってメリットが得られる場合があります。 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドでは、動的パーティション分割をサポートするためにカスタムパーティショナーが想定されています。 詳細については、「 [PLINQ および TPL のカスタムパーティショナー](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 」および「[方法: 動的パーティションを実装する](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> パーティショナーの <paramref name="source" /> プロパティは <see langword="false" /> を返します。  
  
または 
<paramref name="source" /> パーティショナー内のメソッドが <see langword="null" /> を返したときにスローされる例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
        <exception cref="T:System.AggregateException">指定のデリゲートの 1 つからスローされる例外を含める目的でスローされる例外。</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">ソース内のデータの型。</typeparam>
        <param name="source">列挙可能なデータ ソース。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループ オプションを構成でき、ループの状態を監視および操作できる、64 ビットのインデックスを持つ <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.IEnumerable" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、`source` 列挙可能なの各要素に対して1回ずつ呼び出されます。 このパラメーターには、現在の要素、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンス、および現在の要素のインデックス (<xref:System.Int64>) が含まれています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">ソース内のデータの型。</typeparam>
        <param name="source">列挙可能なデータ ソース。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループ オプションを構成でき、ループの状態を監視および操作できる <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.IEnumerable" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、`source` 列挙可能なの各要素に対して1回ずつ呼び出されます。 これには、現在の要素と、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンスのパラメーターがあります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">ソース内のデータの型。</typeparam>
        <param name="source">列挙可能なデータ ソース。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループ オプションを構成できる <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.IEnumerable" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、`source` 列挙可能なの各要素に対して1回ずつ呼び出されます。 現在の要素がパラメーターとして提供されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> の要素の型。</typeparam>
        <typeparam name="TLocal">スレッド ローカル データの型。</typeparam>
        <param name="source">元のデータ ソースを格納している順序付け可能なパーティショナー。</param>
        <param name="localInit">各タスクのローカル データの初期状態を返す関数デリゲート。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <param name="localFinally">各タスクのローカル状態に対して最後の操作を行うデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループ オプションを構成でき、ループの状態を監視および操作できる、スレッド ローカル データを持つ <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、既定のパーティション構成をオーバーライドする場合に提供されます。 たとえば、小さなループ本体では、範囲をパーティション分割することによってメリットが得られる場合があります。 <xref:System.Threading.Tasks.Parallel.ForEach%2A> メソッドでは、動的パーティション分割をサポートするためにカスタムパーティショナーが想定されています。 詳細については、「 [PLINQ および TPL のカスタムパーティショナー](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 」および「[方法: 動的パーティションを実装する](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)」を参照してください。  
  
 `localInit` デリゲートは、ループの実行に参加するタスクごとに1回呼び出され、各タスクの最初のローカル状態を返します。 これらの初期状態は、各タスクの最初の `body` 呼び出しに渡されます。 次に、後続のすべての本文呼び出しで、次の本文呼び出しに渡される、変更可能な状態値が返されます。 最後に、各タスクの最後の本文呼び出しによって、`localFinally` デリゲートに渡される状態値が返されます。 `localFinally` デリゲートは、各タスクのローカル状態に対して最後のアクションを実行するために、タスクごとに1回呼び出されます。 このデリゲートは、複数のタスクで同時に呼び出される場合があります。そのため、共有変数へのアクセスを同期する必要があります。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドは、既存のタスクが完了し、新しいタスクに置き換えられるため、実行の有効期間中にスレッドよりも多くのタスクを使用する場合があります。 これにより、基になる <xref:System.Threading.Tasks.TaskScheduler> オブジェクトは、ループを処理するスレッドを追加、変更、または削除できるようになります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localInit" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localFinally" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /><paramref name="source" /> の <see cref="T:System.Collections.Concurrent.Partitioner" /> プロパティは <see langword="false" /> を返します。またはパーティショナーは <see langword="null" /> パーティションを返します。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> の要素の型。</typeparam>
        <typeparam name="TLocal">スレッド ローカル データの型。</typeparam>
        <param name="source">元のデータ ソースを格納しているパーティショナー。</param>
        <param name="localInit">各タスクのローカル データの初期状態を返す関数デリゲート。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <param name="localFinally">各タスクのローカル状態に対して最後の操作を行うデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループの状態を監視および操作できる、スレッド ローカル データを持つ <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.Concurrent.Partitioner" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、既定のパーティション構成をオーバーライドする場合に提供されます。 たとえば、小さなループ本体では、範囲をパーティション分割することによってメリットが得られる場合があります。 <xref:System.Threading.Tasks.Parallel.ForEach%2A> メソッドでは、動的パーティション分割をサポートするためにカスタムパーティショナーが想定されています。 詳細については、「 [PLINQ および TPL のカスタムパーティショナー](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 」および「[方法: 動的パーティションを実装する](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)」を参照してください。  
  
 `localInit` デリゲートは、ループの実行に参加するスレッドごとに1回呼び出され、各タスクの最初のローカル状態を返します。 これらの初期状態は、各タスクの最初の `body` 呼び出しに渡されます。 次に、後続のすべての本文呼び出しで、次の本文呼び出しに渡される、変更可能な状態値が返されます。 最後に、各タスクの最後の本文呼び出しによって、`localFinally` デリゲートに渡される状態値が返されます。 `localFinally` デリゲートは、各タスクのローカル状態に対して最後のアクションを実行するために、タスクごとに1回呼び出されます。 このデリゲートは、複数のタスクで同時に呼び出される場合があります。そのため、共有変数へのアクセスを同期する必要があります。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドは、既存のタスクが完了し、新しいタスクに置き換えられるため、実行の有効期間中にスレッドよりも多くのタスクを使用する場合があります。 これにより、基になる <xref:System.Threading.Tasks.TaskScheduler> オブジェクトは、ループを処理するスレッドを追加、変更、または削除できるようになります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localInit" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localFinally" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /><paramref name="source" /> の <see cref="T:System.Collections.Concurrent.Partitioner" /> プロパティは <see langword="false" /> を返します。またはパーティショナーは <see langword="null" /> パーティションを返します。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">ソース内のデータの型。</typeparam>
        <typeparam name="TLocal">スレッド ローカル データの型。</typeparam>
        <param name="source">列挙可能なデータ ソース。</param>
        <param name="localInit">各タスクのローカル データの初期状態を返す関数デリゲート。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <param name="localFinally">各タスクのローカル状態に対して最後の操作を行うデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループの状態を監視および操作できる、スレッド ローカル データを持つ <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.IEnumerable" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、`source` 列挙可能なの各要素に対して1回ずつ呼び出されます。 このパラメーターには、現在の要素、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンス、現在の要素のインデックス (<xref:System.Int64>)、および同じスレッドで実行される繰り返し間で共有される可能性があるローカルの状態があります。  
  
 `localInit` デリゲートは、ループの実行に参加するタスクごとに1回呼び出され、各タスクの最初のローカル状態を返します。 これらの初期状態は、各タスクの最初の `body` 呼び出しに渡されます。 次に、後続のすべての本文呼び出しで、次の本文呼び出しに渡される、変更可能な状態値が返されます。 最後に、各タスクの最後の本文呼び出しによって、`localFinally` デリゲートに渡される状態値が返されます。 `localFinally` デリゲートは、各タスクのローカル状態に対して最後のアクションを実行するために、タスクごとに1回呼び出されます。 このデリゲートは、複数のタスクで同時に呼び出される場合があります。そのため、共有変数へのアクセスを同期する必要があります。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドは、既存のタスクが完了し、新しいタスクに置き換えられるため、実行の有効期間中にスレッドよりも多くのタスクを使用する場合があります。 これにより、基になる <xref:System.Threading.Tasks.TaskScheduler> オブジェクトは、ループを処理するスレッドを追加、変更、または削除できるようになります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localInit" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localFinally" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">ソース内のデータの型。</typeparam>
        <typeparam name="TLocal">スレッド ローカル データの型。</typeparam>
        <param name="source">列挙可能なデータ ソース。</param>
        <param name="localInit">各タスクのローカル データの初期状態を返す関数デリゲート。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <param name="localFinally">各タスクのローカル状態に対して最後の操作を行うデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループの状態を監視および操作できる、スレッド ローカル データを持つ <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.IEnumerable" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、`source` 列挙可能なの各要素に対して1回ずつ呼び出されます。 これには、現在の要素、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンス、および同じスレッドで実行される繰り返し間で共有される可能性があるローカル状態のパラメーターが含まれます。  
  
 `localInit` デリゲートは、ループの実行に参加するタスクごとに1回呼び出され、各タスクの最初のローカル状態を返します。 これらの初期状態は、各タスクの最初の `body` 呼び出しに渡されます。 次に、後続のすべての本文呼び出しで、次の本文呼び出しに渡される、変更可能な状態値が返されます。 最後に、各タスクの最後の本文呼び出しによって、`localFinally` デリゲートに渡される状態値が返されます。 `localFinally` デリゲートは、各タスクのローカル状態に対して最後のアクションを実行するために、スレッドごとに1回呼び出されます。 このデリゲートは、複数のタスクで同時に呼び出される場合があります。そのため、共有変数へのアクセスを同期する必要があります。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドは、既存のタスクが完了し、新しいタスクに置き換えられるため、実行の有効期間中にスレッドよりも多くのタスクを使用する場合があります。 これにより、基になる <xref:System.Threading.Tasks.TaskScheduler> オブジェクトは、ループを処理するスレッドを追加、変更、または削除できるようになります。  
  
   
  
## Examples  
 次の例は、ローカル状態で <xref:System.Threading.Tasks.Parallel.ForEach%2A> メソッドを使用する方法を示しています。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localInit" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localFinally" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> の要素の型。</typeparam>
        <typeparam name="TLocal">スレッド ローカル データの型。</typeparam>
        <param name="source">元のデータ ソースを格納している順序付け可能なパーティショナー。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="localInit">各タスクのローカル データの初期状態を返す関数デリゲート。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <param name="localFinally">各タスクのローカル状態に対して最後の操作を行うデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループ オプションを構成でき、ループの状態を監視および操作できる、64 ビットのインデックスとスレッド ローカル データを持つ <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、既定のパーティション構成をオーバーライドする場合に提供されます。 たとえば、小さなループ本体では、範囲をパーティション分割することによってメリットが得られる場合があります。 <xref:System.Threading.Tasks.Parallel.ForEach%2A> メソッドでは、動的パーティション分割をサポートするためにカスタムパーティショナーが想定されています。 詳細については、「 [PLINQ および TPL のカスタムパーティショナー](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 」および「[方法: 動的パーティションを実装する](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)」を参照してください。  
  
 `localInit` デリゲートは、ループの実行に参加するタスクごとに1回呼び出され、各タスクの最初のローカル状態を返します。 これらの初期状態は、各タスクの最初の `body` 呼び出しに渡されます。 次に、後続のすべての本文呼び出しで、次の本文呼び出しに渡される、変更可能な状態値が返されます。 最後に、各スレッドの最後の本文呼び出しによって、`localFinally` デリゲートに渡される状態値が返されます。 `localFinally` デリゲートは、各タスクのローカル状態に対して最後のアクションを実行するために、タスクごとに1回呼び出されます。 このデリゲートは、複数のタスクで同時に呼び出される場合があります。そのため、共有変数へのアクセスを同期する必要があります。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドは、既存のタスクが完了し、新しいタスクに置き換えられるため、実行の有効期間中にスレッドよりも多くのタスクを使用する場合があります。 これにより、基になる <xref:System.Threading.Tasks.TaskScheduler> オブジェクトは、ループを処理するスレッドを追加、変更、または削除できるようになります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localInit" /> または <paramref name="localFinally" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /><paramref name="source" /> の <see cref="T:System.Collections.Concurrent.Partitioner" /> プロパティは <see langword="false" /> を返します。またはパーティショナーは <see langword="null" /> パーティションを返します。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><paramref name="source" /> の要素の型。</typeparam>
        <typeparam name="TLocal">スレッド ローカル データの型。</typeparam>
        <param name="source">元のデータ ソースを格納しているパーティショナー。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="localInit">各タスクのローカル データの初期状態を返す関数デリゲート。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <param name="localFinally">各タスクのローカル状態に対して最後の操作を行うデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループ オプションを構成でき、ループの状態を監視および操作できる、スレッド ローカル データを持つ <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.Concurrent.Partitioner" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードは、既定のパーティション構成をオーバーライドする場合に提供されます。 たとえば、小さなループ本体では、範囲をパーティション分割することによってメリットが得られる場合があります。 <xref:System.Threading.Tasks.Parallel.ForEach%2A> メソッドでは、動的パーティション分割をサポートするためにカスタムパーティショナーが想定されています。 このオーバーロードは、静的な範囲のパーティション分割の恩恵を受ける可能性がある小さなループ本体を使用するシナリオに対して用意されています。 パーティショナーは、動的パーティションをサポートする必要があります。  詳細については、「 [PLINQ および TPL のカスタムパーティショナー](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) 」および「[方法: 動的パーティションを実装する](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)」を参照してください。  
  
 `localInit` デリゲートは、ループの実行に参加するタスクごとに1回呼び出され、各タスクの最初のローカル状態を返します。 これらの初期状態は、各タスクの最初の `body` 呼び出しに渡されます。 次に、後続のすべての本文呼び出しで、次の本文呼び出しに渡される、変更可能な状態値が返されます。 最後に、各タスクの最後の本文呼び出しによって、`localFinally` デリゲートに渡される状態値が返されます。 `localFinally` デリゲートは、各タスクのローカル状態に対して最後のアクションを実行するために、タスクごとに1回呼び出されます。 このデリゲートは、複数のタスクで同時に呼び出される場合があります。そのため、共有変数へのアクセスを同期する必要があります。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドは、既存のタスクが完了し、新しいタスクに置き換えられるため、実行の有効期間中にスレッドよりも多くのタスクを使用する場合があります。 これにより、基になる <xref:System.Threading.Tasks.TaskScheduler> オブジェクトは、ループを処理するスレッドを追加、変更、または削除できるようになります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localInit" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localFinally" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /><paramref name="source" /> の <see cref="T:System.Collections.Concurrent.Partitioner" /> プロパティは <see langword="false" /> を返します。またはパーティショナーは <see langword="null" /> パーティションを返します。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">ソース内のデータの型。</typeparam>
        <typeparam name="TLocal">スレッド ローカル データの型。</typeparam>
        <param name="source">列挙可能なデータ ソース。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="localInit">各タスクのローカル データの初期状態を返す関数デリゲート。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <param name="localFinally">各タスクのローカル状態に対して最後の操作を行うデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループ オプションを構成でき、ループの状態を監視および操作できる、スレッド ローカル データと 64 ビットのインデックスを持つ <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.IEnumerable" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、`source` 列挙可能なの各要素に対して1回ずつ呼び出されます。 このパラメーターには、現在の要素、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンス、現在の要素のインデックス (<xref:System.Int64>)、および同じスレッドで実行される繰り返し間で共有される可能性があるローカルの状態があります。  
  
 `localInit` デリゲートは、ループの実行に参加するタスクごとに1回呼び出され、各タスクの最初のローカル状態を返します。 これらの初期状態は、各タスクの最初の `body` 呼び出しに渡されます。 次に、後続のすべての本文呼び出しで、次の本文呼び出しに渡される、変更可能な状態値が返されます。 最後に、各タスクの最後の本文呼び出しによって、`localFinally` デリゲートに渡される状態値が返されます。 `localFinally` デリゲートは、各タスクのローカル状態に対して最後のアクションを実行するために、スレッドごとに1回呼び出されます。 このデリゲートは、複数のタスクで同時に呼び出される場合があります。そのため、共有変数へのアクセスを同期する必要があります。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドは、既存のタスクが完了し、新しいタスクに置き換えられるため、実行の有効期間中にスレッドよりも多くのタスクを使用する場合があります。 これにより、基になる <xref:System.Threading.Tasks.TaskScheduler> オブジェクトは、ループを処理するスレッドを追加、変更、または削除できるようになります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localInit" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localFinally" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">ソース内のデータの型。</typeparam>
        <typeparam name="TLocal">スレッド ローカル データの型。</typeparam>
        <param name="source">列挙可能なデータ ソース。</param>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="localInit">各タスクのローカル データの初期状態を返す関数デリゲート。</param>
        <param name="body">1 回のイテレーションにつき 1 回呼び出されるデリゲート。</param>
        <param name="localFinally">各タスクのローカル状態に対して最後の操作を行うデリゲート。</param>
        <summary><see langword="foreach" /> に対して、イテレーションが並列で実行される可能性があり、ループ オプションを構成でき、ループの状態を監視および操作できる、スレッド ローカル データを持つ <see langword="For Each" /> (Visual Basic の場合は <see cref="T:System.Collections.IEnumerable" />) 操作を実行します。</summary>
        <returns>完了したループの部分に関する情報を格納している構造。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` デリゲートは、`source` 列挙可能なの各要素に対して1回ずつ呼び出されます。 これには、現在の要素、ループを途中で中断するために使用できる <xref:System.Threading.Tasks.ParallelLoopState> インスタンス、および同じスレッドで実行される繰り返し間で共有される可能性があるローカル状態のパラメーターが含まれます。  
  
 `localInit` デリゲートは、ループの実行に参加するタスクごとに1回呼び出され、各タスクの最初のローカル状態を返します。 これらの初期状態は、各タスクの最初の `body` 呼び出しに渡されます。 次に、後続のすべての本文呼び出しで、次の本文呼び出しに渡される、変更可能な状態値が返されます。 最後に、各タスクの最後の本文呼び出しによって、`localFinally` デリゲートに渡される状態値が返されます。 `localFinally` デリゲートは、各タスクのローカル状態に対して最後のアクションを実行するために、スレッドごとに1回呼び出されます。 このデリゲートは、複数のタスクで同時に呼び出される場合があります。そのため、共有変数へのアクセスを同期する必要があります。  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> メソッドは、既存のタスクが完了し、新しいタスクに置き換えられるため、実行の有効期間中にスレッドよりも多くのタスクを使用する場合があります。 これにより、基になる <xref:System.Threading.Tasks.TaskScheduler> オブジェクトは、ループを処理するスレッドを追加、変更、または削除できるようになります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="body" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localInit" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="localFinally" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 引数の <paramref name="parallelOptions" /> が取り消されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
        <exception cref="T:System.AggregateException">すべてのスレッドでスローされたすべての個別の例外を含む例外。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">並列ループ</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された一連のアクションの各アクションを実行します (場合によっては並列で)。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">実行対象の <see cref="T:System.Action" /> の配列。</param>
        <summary>指定された一連のアクションの各アクションを実行します (場合によっては並列で)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、一連の操作を並列で実行するために使用できます。  
  
 操作が実行される順序や、並列で実行するかどうかは保証されません。 このメソッドは、指定された各操作が完了するまでは戻りません。通常または例外的な終了によって完了が発生したかどうかは関係ありません。  
  
 詳細については、「[How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)」を参照してください。  
  
   
  
## Examples  
 この例では、<xref:System.Threading.Tasks.Parallel.Invoke%2A> メソッドを他のメソッド、匿名デリゲート、およびラムダ式と共に使用する方法を示します。  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="actions" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException"><paramref name="actions" /> 配列内のアクションが例外をスローしたときにスローされる例外。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="actions" /> 配列に <see langword="null" /> 要素が含まれています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">この操作の動作を構成するオブジェクト。</param>
        <param name="actions">実行対象のアクションの配列。</param>
        <summary>操作がユーザーによって取り消されていない限り、指定された各アクションを実行します。アクションは並列で実行される可能性があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、一連の操作を並列で実行するために使用できます。 <xref:System.Threading.Tasks.ParallelOptions> 構造体を使用して渡されたキャンセルトークンを使用すると、呼び出し元は操作全体を取り消すことができます。 詳細については、「[マネージド スレッドのキャンセル](~/docs/standard/threading/cancellation-in-managed-threads.md)」を参照してください。  
  
 操作が実行される順序や、並列で実行するかどうかは保証されません。 このメソッドは、指定された各操作が完了するまでは戻りません。通常または例外的な終了によって完了が発生したかどうかは関係ありません。  
  
 詳細については、「[How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> 内の <paramref name="parallelOptions" /> が設定されます。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="actions" /> 引数が <see langword="null" /> です。  
  
または 
<paramref name="parallelOptions" /> 引数が <see langword="null" /> です。</exception>
        <exception cref="T:System.AggregateException"><paramref name="actions" /> 配列内のアクションが例外をスローしたときにスローされる例外。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="actions" /> 配列に <see langword="null" /> 要素が含まれています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> 内の <see cref="T:System.Threading.CancellationToken" /> に関連付けられている <paramref name="parallelOptions" /> は破棄されました。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
